# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from __future__ import annotations

from alibabacloud_das20200116 import models as main_models
from darabonba.model import DaraModel

class GetDasProServiceUsageResponseBody(DaraModel):
    def __init__(
        self,
        code: int = None,
        data: main_models.GetDasProServiceUsageResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned.
        self.code = code
        # The data returned.
        self.data = data
        # The returned message.
        # 
        # >  If the request was successful, **Successful** is returned. If the request failed, an error message such as an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**
        # *   **false**
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.code is not None:
            result['Code'] = self.code

        if self.data is not None:
            result['Data'] = self.data.to_map()

        if self.message is not None:
            result['Message'] = self.message

        if self.request_id is not None:
            result['RequestId'] = self.request_id

        if self.success is not None:
            result['Success'] = self.success

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')

        if m.get('Data') is not None:
            temp_model = main_models.GetDasProServiceUsageResponseBodyData()
            self.data = temp_model.from_map(m.get('Data'))

        if m.get('Message') is not None:
            self.message = m.get('Message')

        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')

        if m.get('Success') is not None:
            self.success = m.get('Success')

        return self

class GetDasProServiceUsageResponseBodyData(DaraModel):
    def __init__(
        self,
        commodity_instance_id: str = None,
        engine: str = None,
        expire_time: int = None,
        instance_alias: str = None,
        instance_id: str = None,
        ip: str = None,
        is_spare: bool = None,
        migration_predict_remaining_time: int = None,
        port: int = None,
        region: str = None,
        service_unit_id: str = None,
        sql_retention: str = None,
        start_time: int = None,
        storage_free_quota_in_mb: float = None,
        storage_used: int = None,
        user_id: str = None,
        vpc_id: str = None,
    ):
        # The ID of the DAS Enterprise Edition instance.
        self.commodity_instance_id = commodity_instance_id
        # The type of the database engine.
        self.engine = engine
        # The point of time when DAS Enterprise Edition for the database instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.expire_time = expire_time
        # The name of the database instance.
        self.instance_alias = instance_alias
        # The database instance ID.
        self.instance_id = instance_id
        # The endpoint of the database instance.
        self.ip = ip
        # Indicates whether DAS Enterprise Edition for the database instance has expired. Valid values:
        # 
        # *   **true**
        # *   **false**
        self.is_spare = is_spare
        # The estimated remaining time for migrating the data generated by the SQL Explorer and Audit feature from the previous version to the new version. Unit: milliseconds.
        # 
        # >  This parameter is returned only when the SQL Explorer and Audit feature is migrated from the previous version to the new version.
        self.migration_predict_remaining_time = migration_predict_remaining_time
        # The port number that is used to connect to the database instance.
        self.port = port
        # The region in which the database instance resides.
        self.region = region
        # The service unit ID.
        self.service_unit_id = service_unit_id
        # The storage duration of SQL Explorer data. Unit: days.
        self.sql_retention = sql_retention
        # The time when DAS Enterprise Edition was enabled for the database instance. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time
        # The SQL Explorer storage space that is offered free-of-charge. Unit: MB.
        self.storage_free_quota_in_mb = storage_free_quota_in_mb
        # The storage usage of SQL Explorer of the database instance. Unit: bytes.
        self.storage_used = storage_used
        # The ID of the Alibaba Cloud account that is used to create the database instance.
        self.user_id = user_id
        # The virtual private cloud (VPC) ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.commodity_instance_id is not None:
            result['commodityInstanceId'] = self.commodity_instance_id

        if self.engine is not None:
            result['engine'] = self.engine

        if self.expire_time is not None:
            result['expireTime'] = self.expire_time

        if self.instance_alias is not None:
            result['instanceAlias'] = self.instance_alias

        if self.instance_id is not None:
            result['instanceId'] = self.instance_id

        if self.ip is not None:
            result['ip'] = self.ip

        if self.is_spare is not None:
            result['isSpare'] = self.is_spare

        if self.migration_predict_remaining_time is not None:
            result['migrationPredictRemainingTime'] = self.migration_predict_remaining_time

        if self.port is not None:
            result['port'] = self.port

        if self.region is not None:
            result['region'] = self.region

        if self.service_unit_id is not None:
            result['serviceUnitId'] = self.service_unit_id

        if self.sql_retention is not None:
            result['sqlRetention'] = self.sql_retention

        if self.start_time is not None:
            result['startTime'] = self.start_time

        if self.storage_free_quota_in_mb is not None:
            result['storageFreeQuotaInMB'] = self.storage_free_quota_in_mb

        if self.storage_used is not None:
            result['storageUsed'] = self.storage_used

        if self.user_id is not None:
            result['userId'] = self.user_id

        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commodityInstanceId') is not None:
            self.commodity_instance_id = m.get('commodityInstanceId')

        if m.get('engine') is not None:
            self.engine = m.get('engine')

        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')

        if m.get('instanceAlias') is not None:
            self.instance_alias = m.get('instanceAlias')

        if m.get('instanceId') is not None:
            self.instance_id = m.get('instanceId')

        if m.get('ip') is not None:
            self.ip = m.get('ip')

        if m.get('isSpare') is not None:
            self.is_spare = m.get('isSpare')

        if m.get('migrationPredictRemainingTime') is not None:
            self.migration_predict_remaining_time = m.get('migrationPredictRemainingTime')

        if m.get('port') is not None:
            self.port = m.get('port')

        if m.get('region') is not None:
            self.region = m.get('region')

        if m.get('serviceUnitId') is not None:
            self.service_unit_id = m.get('serviceUnitId')

        if m.get('sqlRetention') is not None:
            self.sql_retention = m.get('sqlRetention')

        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')

        if m.get('storageFreeQuotaInMB') is not None:
            self.storage_free_quota_in_mb = m.get('storageFreeQuotaInMB')

        if m.get('storageUsed') is not None:
            self.storage_used = m.get('storageUsed')

        if m.get('userId') is not None:
            self.user_id = m.get('userId')

        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')

        return self

