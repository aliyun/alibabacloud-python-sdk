# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Any, Dict


class AIAgentConfigAsrConfig(TeaModel):
    def __init__(
        self,
        asr_hot_words: List[str] = None,
        asr_language_id: str = None,
        asr_max_silence: int = None,
        vad_level: int = None,
    ):
        self.asr_hot_words = asr_hot_words
        self.asr_language_id = asr_language_id
        self.asr_max_silence = asr_max_silence
        self.vad_level = vad_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_hot_words is not None:
            result['AsrHotWords'] = self.asr_hot_words
        if self.asr_language_id is not None:
            result['AsrLanguageId'] = self.asr_language_id
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.vad_level is not None:
            result['VadLevel'] = self.vad_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrHotWords') is not None:
            self.asr_hot_words = m.get('AsrHotWords')
        if m.get('AsrLanguageId') is not None:
            self.asr_language_id = m.get('AsrLanguageId')
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('VadLevel') is not None:
            self.vad_level = m.get('VadLevel')
        return self


class AIAgentConfigAvatarConfig(TeaModel):
    def __init__(
        self,
        avatar_id: str = None,
    ):
        self.avatar_id = avatar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        return self


class AIAgentConfigInterruptConfig(TeaModel):
    def __init__(
        self,
        enable_voice_interrupt: bool = None,
        interrupt_words: List[str] = None,
    ):
        self.enable_voice_interrupt = enable_voice_interrupt
        self.interrupt_words = interrupt_words

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.interrupt_words is not None:
            result['InterruptWords'] = self.interrupt_words
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('InterruptWords') is not None:
            self.interrupt_words = m.get('InterruptWords')
        return self


class AIAgentConfigLlmConfigLlmHistory(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class AIAgentConfigLlmConfig(TeaModel):
    def __init__(
        self,
        bailian_app_params: str = None,
        llm_history: List[AIAgentConfigLlmConfigLlmHistory] = None,
        llm_history_limit: int = None,
        llm_system_prompt: str = None,
    ):
        self.bailian_app_params = bailian_app_params
        self.llm_history = llm_history
        self.llm_history_limit = llm_history_limit
        self.llm_system_prompt = llm_system_prompt

    def validate(self):
        if self.llm_history:
            for k in self.llm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bailian_app_params is not None:
            result['BailianAppParams'] = self.bailian_app_params
        result['LlmHistory'] = []
        if self.llm_history is not None:
            for k in self.llm_history:
                result['LlmHistory'].append(k.to_map() if k else None)
        if self.llm_history_limit is not None:
            result['LlmHistoryLimit'] = self.llm_history_limit
        if self.llm_system_prompt is not None:
            result['LlmSystemPrompt'] = self.llm_system_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BailianAppParams') is not None:
            self.bailian_app_params = m.get('BailianAppParams')
        self.llm_history = []
        if m.get('LlmHistory') is not None:
            for k in m.get('LlmHistory'):
                temp_model = AIAgentConfigLlmConfigLlmHistory()
                self.llm_history.append(temp_model.from_map(k))
        if m.get('LlmHistoryLimit') is not None:
            self.llm_history_limit = m.get('LlmHistoryLimit')
        if m.get('LlmSystemPrompt') is not None:
            self.llm_system_prompt = m.get('LlmSystemPrompt')
        return self


class AIAgentConfigTtsConfig(TeaModel):
    def __init__(
        self,
        voice_id: str = None,
        voice_id_list: List[str] = None,
    ):
        self.voice_id = voice_id
        self.voice_id_list = voice_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_id_list is not None:
            result['VoiceIdList'] = self.voice_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceIdList') is not None:
            self.voice_id_list = m.get('VoiceIdList')
        return self


class AIAgentConfigTurnDetectionConfig(TeaModel):
    def __init__(
        self,
        turn_end_words: List[str] = None,
    ):
        self.turn_end_words = turn_end_words

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.turn_end_words is not None:
            result['TurnEndWords'] = self.turn_end_words
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TurnEndWords') is not None:
            self.turn_end_words = m.get('TurnEndWords')
        return self


class AIAgentConfigVoiceprintConfig(TeaModel):
    def __init__(
        self,
        use_voiceprint: bool = None,
        voiceprint_id: str = None,
    ):
        self.use_voiceprint = use_voiceprint
        self.voiceprint_id = voiceprint_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.use_voiceprint is not None:
            result['UseVoiceprint'] = self.use_voiceprint
        if self.voiceprint_id is not None:
            result['VoiceprintId'] = self.voiceprint_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UseVoiceprint') is not None:
            self.use_voiceprint = m.get('UseVoiceprint')
        if m.get('VoiceprintId') is not None:
            self.voiceprint_id = m.get('VoiceprintId')
        return self


class AIAgentConfig(TeaModel):
    def __init__(
        self,
        asr_config: AIAgentConfigAsrConfig = None,
        avatar_config: AIAgentConfigAvatarConfig = None,
        avatar_url: str = None,
        avatar_url_type: str = None,
        enable_intelligent_segment: bool = None,
        enable_push_to_talk: bool = None,
        experimental_config: str = None,
        graceful_shutdown: bool = None,
        greeting: str = None,
        interrupt_config: AIAgentConfigInterruptConfig = None,
        llm_config: AIAgentConfigLlmConfig = None,
        max_idle_time: int = None,
        tts_config: AIAgentConfigTtsConfig = None,
        turn_detection_config: AIAgentConfigTurnDetectionConfig = None,
        user_offline_timeout: int = None,
        user_online_timeout: int = None,
        voiceprint_config: AIAgentConfigVoiceprintConfig = None,
        volume: int = None,
        wake_up_query: str = None,
        workflow_override_params: str = None,
    ):
        self.asr_config = asr_config
        self.avatar_config = avatar_config
        self.avatar_url = avatar_url
        self.avatar_url_type = avatar_url_type
        self.enable_intelligent_segment = enable_intelligent_segment
        self.enable_push_to_talk = enable_push_to_talk
        self.experimental_config = experimental_config
        self.graceful_shutdown = graceful_shutdown
        self.greeting = greeting
        self.interrupt_config = interrupt_config
        self.llm_config = llm_config
        self.max_idle_time = max_idle_time
        self.tts_config = tts_config
        self.turn_detection_config = turn_detection_config
        self.user_offline_timeout = user_offline_timeout
        self.user_online_timeout = user_online_timeout
        self.voiceprint_config = voiceprint_config
        self.volume = volume
        self.wake_up_query = wake_up_query
        self.workflow_override_params = workflow_override_params

    def validate(self):
        if self.asr_config:
            self.asr_config.validate()
        if self.avatar_config:
            self.avatar_config.validate()
        if self.interrupt_config:
            self.interrupt_config.validate()
        if self.llm_config:
            self.llm_config.validate()
        if self.tts_config:
            self.tts_config.validate()
        if self.turn_detection_config:
            self.turn_detection_config.validate()
        if self.voiceprint_config:
            self.voiceprint_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.avatar_config is not None:
            result['AvatarConfig'] = self.avatar_config.to_map()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.avatar_url_type is not None:
            result['AvatarUrlType'] = self.avatar_url_type
        if self.enable_intelligent_segment is not None:
            result['EnableIntelligentSegment'] = self.enable_intelligent_segment
        if self.enable_push_to_talk is not None:
            result['EnablePushToTalk'] = self.enable_push_to_talk
        if self.experimental_config is not None:
            result['ExperimentalConfig'] = self.experimental_config
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_config is not None:
            result['InterruptConfig'] = self.interrupt_config.to_map()
        if self.llm_config is not None:
            result['LlmConfig'] = self.llm_config.to_map()
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.tts_config is not None:
            result['TtsConfig'] = self.tts_config.to_map()
        if self.turn_detection_config is not None:
            result['TurnDetectionConfig'] = self.turn_detection_config.to_map()
        if self.user_offline_timeout is not None:
            result['UserOfflineTimeout'] = self.user_offline_timeout
        if self.user_online_timeout is not None:
            result['UserOnlineTimeout'] = self.user_online_timeout
        if self.voiceprint_config is not None:
            result['VoiceprintConfig'] = self.voiceprint_config.to_map()
        if self.volume is not None:
            result['Volume'] = self.volume
        if self.wake_up_query is not None:
            result['WakeUpQuery'] = self.wake_up_query
        if self.workflow_override_params is not None:
            result['WorkflowOverrideParams'] = self.workflow_override_params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrConfig') is not None:
            temp_model = AIAgentConfigAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('AvatarConfig') is not None:
            temp_model = AIAgentConfigAvatarConfig()
            self.avatar_config = temp_model.from_map(m['AvatarConfig'])
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('AvatarUrlType') is not None:
            self.avatar_url_type = m.get('AvatarUrlType')
        if m.get('EnableIntelligentSegment') is not None:
            self.enable_intelligent_segment = m.get('EnableIntelligentSegment')
        if m.get('EnablePushToTalk') is not None:
            self.enable_push_to_talk = m.get('EnablePushToTalk')
        if m.get('ExperimentalConfig') is not None:
            self.experimental_config = m.get('ExperimentalConfig')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptConfig') is not None:
            temp_model = AIAgentConfigInterruptConfig()
            self.interrupt_config = temp_model.from_map(m['InterruptConfig'])
        if m.get('LlmConfig') is not None:
            temp_model = AIAgentConfigLlmConfig()
            self.llm_config = temp_model.from_map(m['LlmConfig'])
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('TtsConfig') is not None:
            temp_model = AIAgentConfigTtsConfig()
            self.tts_config = temp_model.from_map(m['TtsConfig'])
        if m.get('TurnDetectionConfig') is not None:
            temp_model = AIAgentConfigTurnDetectionConfig()
            self.turn_detection_config = temp_model.from_map(m['TurnDetectionConfig'])
        if m.get('UserOfflineTimeout') is not None:
            self.user_offline_timeout = m.get('UserOfflineTimeout')
        if m.get('UserOnlineTimeout') is not None:
            self.user_online_timeout = m.get('UserOnlineTimeout')
        if m.get('VoiceprintConfig') is not None:
            temp_model = AIAgentConfigVoiceprintConfig()
            self.voiceprint_config = temp_model.from_map(m['VoiceprintConfig'])
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        if m.get('WakeUpQuery') is not None:
            self.wake_up_query = m.get('WakeUpQuery')
        if m.get('WorkflowOverrideParams') is not None:
            self.workflow_override_params = m.get('WorkflowOverrideParams')
        return self


class AIAgentOutboundCallConfigAsrConfig(TeaModel):
    def __init__(
        self,
        asr_hot_words: List[str] = None,
        asr_language_id: str = None,
        asr_max_silence: int = None,
        vad_level: int = None,
    ):
        self.asr_hot_words = asr_hot_words
        self.asr_language_id = asr_language_id
        self.asr_max_silence = asr_max_silence
        self.vad_level = vad_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_hot_words is not None:
            result['AsrHotWords'] = self.asr_hot_words
        if self.asr_language_id is not None:
            result['AsrLanguageId'] = self.asr_language_id
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.vad_level is not None:
            result['VadLevel'] = self.vad_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrHotWords') is not None:
            self.asr_hot_words = m.get('AsrHotWords')
        if m.get('AsrLanguageId') is not None:
            self.asr_language_id = m.get('AsrLanguageId')
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('VadLevel') is not None:
            self.vad_level = m.get('VadLevel')
        return self


class AIAgentOutboundCallConfigInterruptConfig(TeaModel):
    def __init__(
        self,
        enable_voice_interrupt: bool = None,
        interrupt_words: List[str] = None,
    ):
        self.enable_voice_interrupt = enable_voice_interrupt
        self.interrupt_words = interrupt_words

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.interrupt_words is not None:
            result['InterruptWords'] = self.interrupt_words
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('InterruptWords') is not None:
            self.interrupt_words = m.get('InterruptWords')
        return self


class AIAgentOutboundCallConfigLlmConfigLlmHistory(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class AIAgentOutboundCallConfigLlmConfig(TeaModel):
    def __init__(
        self,
        bailian_app_params: str = None,
        llm_history: List[AIAgentOutboundCallConfigLlmConfigLlmHistory] = None,
        llm_history_limit: int = None,
        llm_system_prompt: str = None,
    ):
        self.bailian_app_params = bailian_app_params
        self.llm_history = llm_history
        self.llm_history_limit = llm_history_limit
        self.llm_system_prompt = llm_system_prompt

    def validate(self):
        if self.llm_history:
            for k in self.llm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bailian_app_params is not None:
            result['BailianAppParams'] = self.bailian_app_params
        result['LlmHistory'] = []
        if self.llm_history is not None:
            for k in self.llm_history:
                result['LlmHistory'].append(k.to_map() if k else None)
        if self.llm_history_limit is not None:
            result['LlmHistoryLimit'] = self.llm_history_limit
        if self.llm_system_prompt is not None:
            result['LlmSystemPrompt'] = self.llm_system_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BailianAppParams') is not None:
            self.bailian_app_params = m.get('BailianAppParams')
        self.llm_history = []
        if m.get('LlmHistory') is not None:
            for k in m.get('LlmHistory'):
                temp_model = AIAgentOutboundCallConfigLlmConfigLlmHistory()
                self.llm_history.append(temp_model.from_map(k))
        if m.get('LlmHistoryLimit') is not None:
            self.llm_history_limit = m.get('LlmHistoryLimit')
        if m.get('LlmSystemPrompt') is not None:
            self.llm_system_prompt = m.get('LlmSystemPrompt')
        return self


class AIAgentOutboundCallConfigTtsConfig(TeaModel):
    def __init__(
        self,
        voice_id: str = None,
        voice_id_list: List[str] = None,
    ):
        self.voice_id = voice_id
        self.voice_id_list = voice_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_id_list is not None:
            result['VoiceIdList'] = self.voice_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceIdList') is not None:
            self.voice_id_list = m.get('VoiceIdList')
        return self


class AIAgentOutboundCallConfigTurnDetectionConfig(TeaModel):
    def __init__(
        self,
        turn_end_words: List[str] = None,
    ):
        self.turn_end_words = turn_end_words

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.turn_end_words is not None:
            result['TurnEndWords'] = self.turn_end_words
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TurnEndWords') is not None:
            self.turn_end_words = m.get('TurnEndWords')
        return self


class AIAgentOutboundCallConfig(TeaModel):
    def __init__(
        self,
        asr_config: AIAgentOutboundCallConfigAsrConfig = None,
        enable_intelligent_segment: bool = None,
        greeting: str = None,
        interrupt_config: AIAgentOutboundCallConfigInterruptConfig = None,
        llm_config: AIAgentOutboundCallConfigLlmConfig = None,
        tts_config: AIAgentOutboundCallConfigTtsConfig = None,
        turn_detection_config: AIAgentOutboundCallConfigTurnDetectionConfig = None,
    ):
        self.asr_config = asr_config
        self.enable_intelligent_segment = enable_intelligent_segment
        self.greeting = greeting
        self.interrupt_config = interrupt_config
        self.llm_config = llm_config
        self.tts_config = tts_config
        self.turn_detection_config = turn_detection_config

    def validate(self):
        if self.asr_config:
            self.asr_config.validate()
        if self.interrupt_config:
            self.interrupt_config.validate()
        if self.llm_config:
            self.llm_config.validate()
        if self.tts_config:
            self.tts_config.validate()
        if self.turn_detection_config:
            self.turn_detection_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.enable_intelligent_segment is not None:
            result['EnableIntelligentSegment'] = self.enable_intelligent_segment
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_config is not None:
            result['InterruptConfig'] = self.interrupt_config.to_map()
        if self.llm_config is not None:
            result['LlmConfig'] = self.llm_config.to_map()
        if self.tts_config is not None:
            result['TtsConfig'] = self.tts_config.to_map()
        if self.turn_detection_config is not None:
            result['TurnDetectionConfig'] = self.turn_detection_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrConfig') is not None:
            temp_model = AIAgentOutboundCallConfigAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('EnableIntelligentSegment') is not None:
            self.enable_intelligent_segment = m.get('EnableIntelligentSegment')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptConfig') is not None:
            temp_model = AIAgentOutboundCallConfigInterruptConfig()
            self.interrupt_config = temp_model.from_map(m['InterruptConfig'])
        if m.get('LlmConfig') is not None:
            temp_model = AIAgentOutboundCallConfigLlmConfig()
            self.llm_config = temp_model.from_map(m['LlmConfig'])
        if m.get('TtsConfig') is not None:
            temp_model = AIAgentOutboundCallConfigTtsConfig()
            self.tts_config = temp_model.from_map(m['TtsConfig'])
        if m.get('TurnDetectionConfig') is not None:
            temp_model = AIAgentOutboundCallConfigTurnDetectionConfig()
            self.turn_detection_config = temp_model.from_map(m['TurnDetectionConfig'])
        return self


class AIAgentRuntimeConfigAvatarChat3D(TeaModel):
    def __init__(
        self,
        agent_user_id: str = None,
        auth_token: str = None,
        channel_id: str = None,
    ):
        self.agent_user_id = agent_user_id
        self.auth_token = auth_token
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_user_id is not None:
            result['AgentUserId'] = self.agent_user_id
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentUserId') is not None:
            self.agent_user_id = m.get('AgentUserId')
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class AIAgentRuntimeConfigVisionChat(TeaModel):
    def __init__(
        self,
        agent_user_id: str = None,
        auth_token: str = None,
        channel_id: str = None,
    ):
        self.agent_user_id = agent_user_id
        self.auth_token = auth_token
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_user_id is not None:
            result['AgentUserId'] = self.agent_user_id
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentUserId') is not None:
            self.agent_user_id = m.get('AgentUserId')
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class AIAgentRuntimeConfigVoiceChat(TeaModel):
    def __init__(
        self,
        agent_user_id: str = None,
        auth_token: str = None,
        channel_id: str = None,
    ):
        self.agent_user_id = agent_user_id
        self.auth_token = auth_token
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_user_id is not None:
            result['AgentUserId'] = self.agent_user_id
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentUserId') is not None:
            self.agent_user_id = m.get('AgentUserId')
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class AIAgentRuntimeConfig(TeaModel):
    def __init__(
        self,
        agent_user_id: str = None,
        auth_token: str = None,
        avatar_chat_3d: AIAgentRuntimeConfigAvatarChat3D = None,
        channel_id: str = None,
        vision_chat: AIAgentRuntimeConfigVisionChat = None,
        voice_chat: AIAgentRuntimeConfigVoiceChat = None,
    ):
        self.agent_user_id = agent_user_id
        self.auth_token = auth_token
        self.avatar_chat_3d = avatar_chat_3d
        self.channel_id = channel_id
        self.vision_chat = vision_chat
        self.voice_chat = voice_chat

    def validate(self):
        if self.avatar_chat_3d:
            self.avatar_chat_3d.validate()
        if self.vision_chat:
            self.vision_chat.validate()
        if self.voice_chat:
            self.voice_chat.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_user_id is not None:
            result['AgentUserId'] = self.agent_user_id
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.avatar_chat_3d is not None:
            result['AvatarChat3D'] = self.avatar_chat_3d.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.vision_chat is not None:
            result['VisionChat'] = self.vision_chat.to_map()
        if self.voice_chat is not None:
            result['VoiceChat'] = self.voice_chat.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentUserId') is not None:
            self.agent_user_id = m.get('AgentUserId')
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('AvatarChat3D') is not None:
            temp_model = AIAgentRuntimeConfigAvatarChat3D()
            self.avatar_chat_3d = temp_model.from_map(m['AvatarChat3D'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('VisionChat') is not None:
            temp_model = AIAgentRuntimeConfigVisionChat()
            self.vision_chat = temp_model.from_map(m['VisionChat'])
        if m.get('VoiceChat') is not None:
            temp_model = AIAgentRuntimeConfigVoiceChat()
            self.voice_chat = temp_model.from_map(m['VoiceChat'])
        return self


class AIAgentTemplateConfigAvatarChat3DLlmHistory(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class AIAgentTemplateConfigAvatarChat3D(TeaModel):
    def __init__(
        self,
        asr_hot_words: List[str] = None,
        asr_language_id: str = None,
        asr_max_silence: int = None,
        avatar_id: str = None,
        bailian_app_params: str = None,
        char_break: bool = None,
        enable_intelligent_segment: bool = None,
        enable_push_to_talk: bool = None,
        enable_voice_interrupt: bool = None,
        graceful_shutdown: bool = None,
        greeting: str = None,
        interrupt_words: List[str] = None,
        llm_history: List[AIAgentTemplateConfigAvatarChat3DLlmHistory] = None,
        llm_history_limit: int = None,
        llm_system_prompt: str = None,
        max_idle_time: int = None,
        use_voiceprint: bool = None,
        user_offline_timeout: int = None,
        user_online_timeout: int = None,
        vad_level: int = None,
        voice_id: str = None,
        voice_id_list: List[str] = None,
        voiceprint_id: str = None,
        volume: int = None,
        wake_up_query: str = None,
        workflow_override_params: str = None,
    ):
        self.asr_hot_words = asr_hot_words
        self.asr_language_id = asr_language_id
        self.asr_max_silence = asr_max_silence
        self.avatar_id = avatar_id
        self.bailian_app_params = bailian_app_params
        self.char_break = char_break
        self.enable_intelligent_segment = enable_intelligent_segment
        self.enable_push_to_talk = enable_push_to_talk
        self.enable_voice_interrupt = enable_voice_interrupt
        self.graceful_shutdown = graceful_shutdown
        self.greeting = greeting
        self.interrupt_words = interrupt_words
        self.llm_history = llm_history
        self.llm_history_limit = llm_history_limit
        self.llm_system_prompt = llm_system_prompt
        self.max_idle_time = max_idle_time
        self.use_voiceprint = use_voiceprint
        self.user_offline_timeout = user_offline_timeout
        self.user_online_timeout = user_online_timeout
        self.vad_level = vad_level
        self.voice_id = voice_id
        self.voice_id_list = voice_id_list
        self.voiceprint_id = voiceprint_id
        self.volume = volume
        self.wake_up_query = wake_up_query
        self.workflow_override_params = workflow_override_params

    def validate(self):
        if self.llm_history:
            for k in self.llm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_hot_words is not None:
            result['AsrHotWords'] = self.asr_hot_words
        if self.asr_language_id is not None:
            result['AsrLanguageId'] = self.asr_language_id
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.bailian_app_params is not None:
            result['BailianAppParams'] = self.bailian_app_params
        if self.char_break is not None:
            result['CharBreak'] = self.char_break
        if self.enable_intelligent_segment is not None:
            result['EnableIntelligentSegment'] = self.enable_intelligent_segment
        if self.enable_push_to_talk is not None:
            result['EnablePushToTalk'] = self.enable_push_to_talk
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_words is not None:
            result['InterruptWords'] = self.interrupt_words
        result['LlmHistory'] = []
        if self.llm_history is not None:
            for k in self.llm_history:
                result['LlmHistory'].append(k.to_map() if k else None)
        if self.llm_history_limit is not None:
            result['LlmHistoryLimit'] = self.llm_history_limit
        if self.llm_system_prompt is not None:
            result['LlmSystemPrompt'] = self.llm_system_prompt
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.use_voiceprint is not None:
            result['UseVoiceprint'] = self.use_voiceprint
        if self.user_offline_timeout is not None:
            result['UserOfflineTimeout'] = self.user_offline_timeout
        if self.user_online_timeout is not None:
            result['UserOnlineTimeout'] = self.user_online_timeout
        if self.vad_level is not None:
            result['VadLevel'] = self.vad_level
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_id_list is not None:
            result['VoiceIdList'] = self.voice_id_list
        if self.voiceprint_id is not None:
            result['VoiceprintId'] = self.voiceprint_id
        if self.volume is not None:
            result['Volume'] = self.volume
        if self.wake_up_query is not None:
            result['WakeUpQuery'] = self.wake_up_query
        if self.workflow_override_params is not None:
            result['WorkflowOverrideParams'] = self.workflow_override_params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrHotWords') is not None:
            self.asr_hot_words = m.get('AsrHotWords')
        if m.get('AsrLanguageId') is not None:
            self.asr_language_id = m.get('AsrLanguageId')
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('BailianAppParams') is not None:
            self.bailian_app_params = m.get('BailianAppParams')
        if m.get('CharBreak') is not None:
            self.char_break = m.get('CharBreak')
        if m.get('EnableIntelligentSegment') is not None:
            self.enable_intelligent_segment = m.get('EnableIntelligentSegment')
        if m.get('EnablePushToTalk') is not None:
            self.enable_push_to_talk = m.get('EnablePushToTalk')
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptWords') is not None:
            self.interrupt_words = m.get('InterruptWords')
        self.llm_history = []
        if m.get('LlmHistory') is not None:
            for k in m.get('LlmHistory'):
                temp_model = AIAgentTemplateConfigAvatarChat3DLlmHistory()
                self.llm_history.append(temp_model.from_map(k))
        if m.get('LlmHistoryLimit') is not None:
            self.llm_history_limit = m.get('LlmHistoryLimit')
        if m.get('LlmSystemPrompt') is not None:
            self.llm_system_prompt = m.get('LlmSystemPrompt')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('UseVoiceprint') is not None:
            self.use_voiceprint = m.get('UseVoiceprint')
        if m.get('UserOfflineTimeout') is not None:
            self.user_offline_timeout = m.get('UserOfflineTimeout')
        if m.get('UserOnlineTimeout') is not None:
            self.user_online_timeout = m.get('UserOnlineTimeout')
        if m.get('VadLevel') is not None:
            self.vad_level = m.get('VadLevel')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceIdList') is not None:
            self.voice_id_list = m.get('VoiceIdList')
        if m.get('VoiceprintId') is not None:
            self.voiceprint_id = m.get('VoiceprintId')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        if m.get('WakeUpQuery') is not None:
            self.wake_up_query = m.get('WakeUpQuery')
        if m.get('WorkflowOverrideParams') is not None:
            self.workflow_override_params = m.get('WorkflowOverrideParams')
        return self


class AIAgentTemplateConfigVisionChatLlmHistory(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class AIAgentTemplateConfigVisionChat(TeaModel):
    def __init__(
        self,
        asr_hot_words: List[str] = None,
        asr_language_id: str = None,
        asr_max_silence: int = None,
        bailian_app_params: str = None,
        char_break: bool = None,
        enable_intelligent_segment: bool = None,
        enable_push_to_talk: bool = None,
        enable_voice_interrupt: bool = None,
        graceful_shutdown: bool = None,
        greeting: str = None,
        interrupt_words: List[str] = None,
        llm_history: List[AIAgentTemplateConfigVisionChatLlmHistory] = None,
        llm_history_limit: int = None,
        llm_system_prompt: str = None,
        max_idle_time: int = None,
        use_voiceprint: bool = None,
        user_offline_timeout: int = None,
        user_online_timeout: int = None,
        vad_level: int = None,
        voice_id: str = None,
        voice_id_list: List[str] = None,
        voiceprint_id: str = None,
        volume: int = None,
        wake_up_query: str = None,
        workflow_override_params: str = None,
    ):
        self.asr_hot_words = asr_hot_words
        self.asr_language_id = asr_language_id
        self.asr_max_silence = asr_max_silence
        self.bailian_app_params = bailian_app_params
        self.char_break = char_break
        self.enable_intelligent_segment = enable_intelligent_segment
        self.enable_push_to_talk = enable_push_to_talk
        self.enable_voice_interrupt = enable_voice_interrupt
        self.graceful_shutdown = graceful_shutdown
        self.greeting = greeting
        self.interrupt_words = interrupt_words
        self.llm_history = llm_history
        self.llm_history_limit = llm_history_limit
        self.llm_system_prompt = llm_system_prompt
        self.max_idle_time = max_idle_time
        self.use_voiceprint = use_voiceprint
        self.user_offline_timeout = user_offline_timeout
        self.user_online_timeout = user_online_timeout
        self.vad_level = vad_level
        self.voice_id = voice_id
        self.voice_id_list = voice_id_list
        self.voiceprint_id = voiceprint_id
        self.volume = volume
        self.wake_up_query = wake_up_query
        self.workflow_override_params = workflow_override_params

    def validate(self):
        if self.llm_history:
            for k in self.llm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_hot_words is not None:
            result['AsrHotWords'] = self.asr_hot_words
        if self.asr_language_id is not None:
            result['AsrLanguageId'] = self.asr_language_id
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.bailian_app_params is not None:
            result['BailianAppParams'] = self.bailian_app_params
        if self.char_break is not None:
            result['CharBreak'] = self.char_break
        if self.enable_intelligent_segment is not None:
            result['EnableIntelligentSegment'] = self.enable_intelligent_segment
        if self.enable_push_to_talk is not None:
            result['EnablePushToTalk'] = self.enable_push_to_talk
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_words is not None:
            result['InterruptWords'] = self.interrupt_words
        result['LlmHistory'] = []
        if self.llm_history is not None:
            for k in self.llm_history:
                result['LlmHistory'].append(k.to_map() if k else None)
        if self.llm_history_limit is not None:
            result['LlmHistoryLimit'] = self.llm_history_limit
        if self.llm_system_prompt is not None:
            result['LlmSystemPrompt'] = self.llm_system_prompt
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.use_voiceprint is not None:
            result['UseVoiceprint'] = self.use_voiceprint
        if self.user_offline_timeout is not None:
            result['UserOfflineTimeout'] = self.user_offline_timeout
        if self.user_online_timeout is not None:
            result['UserOnlineTimeout'] = self.user_online_timeout
        if self.vad_level is not None:
            result['VadLevel'] = self.vad_level
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_id_list is not None:
            result['VoiceIdList'] = self.voice_id_list
        if self.voiceprint_id is not None:
            result['VoiceprintId'] = self.voiceprint_id
        if self.volume is not None:
            result['Volume'] = self.volume
        if self.wake_up_query is not None:
            result['WakeUpQuery'] = self.wake_up_query
        if self.workflow_override_params is not None:
            result['WorkflowOverrideParams'] = self.workflow_override_params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrHotWords') is not None:
            self.asr_hot_words = m.get('AsrHotWords')
        if m.get('AsrLanguageId') is not None:
            self.asr_language_id = m.get('AsrLanguageId')
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('BailianAppParams') is not None:
            self.bailian_app_params = m.get('BailianAppParams')
        if m.get('CharBreak') is not None:
            self.char_break = m.get('CharBreak')
        if m.get('EnableIntelligentSegment') is not None:
            self.enable_intelligent_segment = m.get('EnableIntelligentSegment')
        if m.get('EnablePushToTalk') is not None:
            self.enable_push_to_talk = m.get('EnablePushToTalk')
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptWords') is not None:
            self.interrupt_words = m.get('InterruptWords')
        self.llm_history = []
        if m.get('LlmHistory') is not None:
            for k in m.get('LlmHistory'):
                temp_model = AIAgentTemplateConfigVisionChatLlmHistory()
                self.llm_history.append(temp_model.from_map(k))
        if m.get('LlmHistoryLimit') is not None:
            self.llm_history_limit = m.get('LlmHistoryLimit')
        if m.get('LlmSystemPrompt') is not None:
            self.llm_system_prompt = m.get('LlmSystemPrompt')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('UseVoiceprint') is not None:
            self.use_voiceprint = m.get('UseVoiceprint')
        if m.get('UserOfflineTimeout') is not None:
            self.user_offline_timeout = m.get('UserOfflineTimeout')
        if m.get('UserOnlineTimeout') is not None:
            self.user_online_timeout = m.get('UserOnlineTimeout')
        if m.get('VadLevel') is not None:
            self.vad_level = m.get('VadLevel')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceIdList') is not None:
            self.voice_id_list = m.get('VoiceIdList')
        if m.get('VoiceprintId') is not None:
            self.voiceprint_id = m.get('VoiceprintId')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        if m.get('WakeUpQuery') is not None:
            self.wake_up_query = m.get('WakeUpQuery')
        if m.get('WorkflowOverrideParams') is not None:
            self.workflow_override_params = m.get('WorkflowOverrideParams')
        return self


class AIAgentTemplateConfigVoiceChatLlmHistory(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class AIAgentTemplateConfigVoiceChat(TeaModel):
    def __init__(
        self,
        asr_hot_words: List[str] = None,
        asr_language_id: str = None,
        asr_max_silence: int = None,
        avatar_url: str = None,
        avatar_url_type: str = None,
        bailian_app_params: str = None,
        char_break: bool = None,
        enable_intelligent_segment: bool = None,
        enable_push_to_talk: bool = None,
        enable_voice_interrupt: bool = None,
        graceful_shutdown: bool = None,
        greeting: str = None,
        interrupt_words: List[str] = None,
        llm_history: List[AIAgentTemplateConfigVoiceChatLlmHistory] = None,
        llm_history_limit: int = None,
        llm_system_prompt: str = None,
        max_idle_time: int = None,
        use_voiceprint: bool = None,
        user_offline_timeout: int = None,
        user_online_timeout: int = None,
        vad_level: int = None,
        voice_id: str = None,
        voice_id_list: List[str] = None,
        voiceprint_id: str = None,
        volume: int = None,
        wake_up_query: str = None,
        workflow_override_params: str = None,
    ):
        self.asr_hot_words = asr_hot_words
        self.asr_language_id = asr_language_id
        self.asr_max_silence = asr_max_silence
        self.avatar_url = avatar_url
        self.avatar_url_type = avatar_url_type
        self.bailian_app_params = bailian_app_params
        self.char_break = char_break
        self.enable_intelligent_segment = enable_intelligent_segment
        self.enable_push_to_talk = enable_push_to_talk
        self.enable_voice_interrupt = enable_voice_interrupt
        self.graceful_shutdown = graceful_shutdown
        self.greeting = greeting
        self.interrupt_words = interrupt_words
        self.llm_history = llm_history
        self.llm_history_limit = llm_history_limit
        self.llm_system_prompt = llm_system_prompt
        self.max_idle_time = max_idle_time
        self.use_voiceprint = use_voiceprint
        self.user_offline_timeout = user_offline_timeout
        self.user_online_timeout = user_online_timeout
        self.vad_level = vad_level
        self.voice_id = voice_id
        self.voice_id_list = voice_id_list
        self.voiceprint_id = voiceprint_id
        self.volume = volume
        self.wake_up_query = wake_up_query
        self.workflow_override_params = workflow_override_params

    def validate(self):
        if self.llm_history:
            for k in self.llm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_hot_words is not None:
            result['AsrHotWords'] = self.asr_hot_words
        if self.asr_language_id is not None:
            result['AsrLanguageId'] = self.asr_language_id
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.avatar_url_type is not None:
            result['AvatarUrlType'] = self.avatar_url_type
        if self.bailian_app_params is not None:
            result['BailianAppParams'] = self.bailian_app_params
        if self.char_break is not None:
            result['CharBreak'] = self.char_break
        if self.enable_intelligent_segment is not None:
            result['EnableIntelligentSegment'] = self.enable_intelligent_segment
        if self.enable_push_to_talk is not None:
            result['EnablePushToTalk'] = self.enable_push_to_talk
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_words is not None:
            result['InterruptWords'] = self.interrupt_words
        result['LlmHistory'] = []
        if self.llm_history is not None:
            for k in self.llm_history:
                result['LlmHistory'].append(k.to_map() if k else None)
        if self.llm_history_limit is not None:
            result['LlmHistoryLimit'] = self.llm_history_limit
        if self.llm_system_prompt is not None:
            result['LlmSystemPrompt'] = self.llm_system_prompt
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.use_voiceprint is not None:
            result['UseVoiceprint'] = self.use_voiceprint
        if self.user_offline_timeout is not None:
            result['UserOfflineTimeout'] = self.user_offline_timeout
        if self.user_online_timeout is not None:
            result['UserOnlineTimeout'] = self.user_online_timeout
        if self.vad_level is not None:
            result['VadLevel'] = self.vad_level
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_id_list is not None:
            result['VoiceIdList'] = self.voice_id_list
        if self.voiceprint_id is not None:
            result['VoiceprintId'] = self.voiceprint_id
        if self.volume is not None:
            result['Volume'] = self.volume
        if self.wake_up_query is not None:
            result['WakeUpQuery'] = self.wake_up_query
        if self.workflow_override_params is not None:
            result['WorkflowOverrideParams'] = self.workflow_override_params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrHotWords') is not None:
            self.asr_hot_words = m.get('AsrHotWords')
        if m.get('AsrLanguageId') is not None:
            self.asr_language_id = m.get('AsrLanguageId')
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('AvatarUrlType') is not None:
            self.avatar_url_type = m.get('AvatarUrlType')
        if m.get('BailianAppParams') is not None:
            self.bailian_app_params = m.get('BailianAppParams')
        if m.get('CharBreak') is not None:
            self.char_break = m.get('CharBreak')
        if m.get('EnableIntelligentSegment') is not None:
            self.enable_intelligent_segment = m.get('EnableIntelligentSegment')
        if m.get('EnablePushToTalk') is not None:
            self.enable_push_to_talk = m.get('EnablePushToTalk')
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptWords') is not None:
            self.interrupt_words = m.get('InterruptWords')
        self.llm_history = []
        if m.get('LlmHistory') is not None:
            for k in m.get('LlmHistory'):
                temp_model = AIAgentTemplateConfigVoiceChatLlmHistory()
                self.llm_history.append(temp_model.from_map(k))
        if m.get('LlmHistoryLimit') is not None:
            self.llm_history_limit = m.get('LlmHistoryLimit')
        if m.get('LlmSystemPrompt') is not None:
            self.llm_system_prompt = m.get('LlmSystemPrompt')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('UseVoiceprint') is not None:
            self.use_voiceprint = m.get('UseVoiceprint')
        if m.get('UserOfflineTimeout') is not None:
            self.user_offline_timeout = m.get('UserOfflineTimeout')
        if m.get('UserOnlineTimeout') is not None:
            self.user_online_timeout = m.get('UserOnlineTimeout')
        if m.get('VadLevel') is not None:
            self.vad_level = m.get('VadLevel')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceIdList') is not None:
            self.voice_id_list = m.get('VoiceIdList')
        if m.get('VoiceprintId') is not None:
            self.voiceprint_id = m.get('VoiceprintId')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        if m.get('WakeUpQuery') is not None:
            self.wake_up_query = m.get('WakeUpQuery')
        if m.get('WorkflowOverrideParams') is not None:
            self.workflow_override_params = m.get('WorkflowOverrideParams')
        return self


class AIAgentTemplateConfig(TeaModel):
    def __init__(
        self,
        avatar_chat_3d: AIAgentTemplateConfigAvatarChat3D = None,
        vision_chat: AIAgentTemplateConfigVisionChat = None,
        voice_chat: AIAgentTemplateConfigVoiceChat = None,
    ):
        self.avatar_chat_3d = avatar_chat_3d
        self.vision_chat = vision_chat
        self.voice_chat = voice_chat

    def validate(self):
        if self.avatar_chat_3d:
            self.avatar_chat_3d.validate()
        if self.vision_chat:
            self.vision_chat.validate()
        if self.voice_chat:
            self.voice_chat.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_chat_3d is not None:
            result['AvatarChat3D'] = self.avatar_chat_3d.to_map()
        if self.vision_chat is not None:
            result['VisionChat'] = self.vision_chat.to_map()
        if self.voice_chat is not None:
            result['VoiceChat'] = self.voice_chat.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarChat3D') is not None:
            temp_model = AIAgentTemplateConfigAvatarChat3D()
            self.avatar_chat_3d = temp_model.from_map(m['AvatarChat3D'])
        if m.get('VisionChat') is not None:
            temp_model = AIAgentTemplateConfigVisionChat()
            self.vision_chat = temp_model.from_map(m['VisionChat'])
        if m.get('VoiceChat') is not None:
            temp_model = AIAgentTemplateConfigVoiceChat()
            self.voice_chat = temp_model.from_map(m['VoiceChat'])
        return self


class AppInfoDTOPlatforms(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        license_item_ids: List[str] = None,
        pkg_name: str = None,
        pkg_signature: str = None,
        platform_type: int = None,
        type: int = None,
    ):
        self.item_id = item_id
        self.license_item_ids = license_item_ids
        self.pkg_name = pkg_name
        self.pkg_signature = pkg_signature
        self.platform_type = platform_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.license_item_ids is not None:
            result['LicenseItemIds'] = self.license_item_ids
        if self.pkg_name is not None:
            result['PkgName'] = self.pkg_name
        if self.pkg_signature is not None:
            result['PkgSignature'] = self.pkg_signature
        if self.platform_type is not None:
            result['PlatformType'] = self.platform_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('LicenseItemIds') is not None:
            self.license_item_ids = m.get('LicenseItemIds')
        if m.get('PkgName') is not None:
            self.pkg_name = m.get('PkgName')
        if m.get('PkgSignature') is not None:
            self.pkg_signature = m.get('PkgSignature')
        if m.get('PlatformType') is not None:
            self.platform_type = m.get('PlatformType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AppInfoDTO(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        app_type: int = None,
        gmt_create: str = None,
        item_id: str = None,
        platforms: List[AppInfoDTOPlatforms] = None,
        user_id: int = None,
    ):
        self.app_name = app_name
        self.app_type = app_type
        self.gmt_create = gmt_create
        self.item_id = item_id
        self.platforms = platforms
        self.user_id = user_id

    def validate(self):
        if self.platforms:
            for k in self.platforms:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        result['Platforms'] = []
        if self.platforms is not None:
            for k in self.platforms:
                result['Platforms'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        self.platforms = []
        if m.get('Platforms') is not None:
            for k in m.get('Platforms'):
                temp_model = AppInfoDTOPlatforms()
                self.platforms.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ChannelOutPutConfigList(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        format: str = None,
        manifest_name: str = None,
        manifest_settings: str = None,
        playback_url: str = None,
        source_group_name: str = None,
    ):
        self.channel_name = channel_name
        self.format = format
        self.manifest_name = manifest_name
        self.manifest_settings = manifest_settings
        self.playback_url = playback_url
        self.source_group_name = source_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.format is not None:
            result['Format'] = self.format
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.manifest_settings is not None:
            result['ManifestSettings'] = self.manifest_settings
        if self.playback_url is not None:
            result['PlaybackUrl'] = self.playback_url
        if self.source_group_name is not None:
            result['SourceGroupName'] = self.source_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('ManifestSettings') is not None:
            self.manifest_settings = m.get('ManifestSettings')
        if m.get('PlaybackUrl') is not None:
            self.playback_url = m.get('PlaybackUrl')
        if m.get('SourceGroupName') is not None:
            self.source_group_name = m.get('SourceGroupName')
        return self


class Channel(TeaModel):
    def __init__(
        self,
        access_policy: bool = None,
        access_token: str = None,
        arn: str = None,
        channel_name: str = None,
        channel_tier: str = None,
        filler_source_location_name: str = None,
        filler_source_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        out_put_config_list: List[ChannelOutPutConfigList] = None,
        playback_mode: str = None,
        state: int = None,
    ):
        self.access_policy = access_policy
        self.access_token = access_token
        self.arn = arn
        self.channel_name = channel_name
        self.channel_tier = channel_tier
        self.filler_source_location_name = filler_source_location_name
        self.filler_source_name = filler_source_name
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.out_put_config_list = out_put_config_list
        self.playback_mode = playback_mode
        self.state = state

    def validate(self):
        if self.out_put_config_list:
            for k in self.out_put_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_policy is not None:
            result['AccessPolicy'] = self.access_policy
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.channel_tier is not None:
            result['ChannelTier'] = self.channel_tier
        if self.filler_source_location_name is not None:
            result['FillerSourceLocationName'] = self.filler_source_location_name
        if self.filler_source_name is not None:
            result['FillerSourceName'] = self.filler_source_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        result['OutPutConfigList'] = []
        if self.out_put_config_list is not None:
            for k in self.out_put_config_list:
                result['OutPutConfigList'].append(k.to_map() if k else None)
        if self.playback_mode is not None:
            result['PlaybackMode'] = self.playback_mode
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessPolicy') is not None:
            self.access_policy = m.get('AccessPolicy')
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ChannelTier') is not None:
            self.channel_tier = m.get('ChannelTier')
        if m.get('FillerSourceLocationName') is not None:
            self.filler_source_location_name = m.get('FillerSourceLocationName')
        if m.get('FillerSourceName') is not None:
            self.filler_source_name = m.get('FillerSourceName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        self.out_put_config_list = []
        if m.get('OutPutConfigList') is not None:
            for k in m.get('OutPutConfigList'):
                temp_model = ChannelOutPutConfigList()
                self.out_put_config_list.append(temp_model.from_map(k))
        if m.get('PlaybackMode') is not None:
            self.playback_mode = m.get('PlaybackMode')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ChannelAssemblyChannelOutPutConfigList(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        format: str = None,
        manifest_name: str = None,
        manifest_settings: str = None,
        playback_url: str = None,
        source_group_name: str = None,
    ):
        self.channel_name = channel_name
        self.format = format
        self.manifest_name = manifest_name
        self.manifest_settings = manifest_settings
        self.playback_url = playback_url
        self.source_group_name = source_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.format is not None:
            result['Format'] = self.format
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.manifest_settings is not None:
            result['ManifestSettings'] = self.manifest_settings
        if self.playback_url is not None:
            result['PlaybackUrl'] = self.playback_url
        if self.source_group_name is not None:
            result['SourceGroupName'] = self.source_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('ManifestSettings') is not None:
            self.manifest_settings = m.get('ManifestSettings')
        if m.get('PlaybackUrl') is not None:
            self.playback_url = m.get('PlaybackUrl')
        if m.get('SourceGroupName') is not None:
            self.source_group_name = m.get('SourceGroupName')
        return self


class ChannelAssemblyChannel(TeaModel):
    def __init__(
        self,
        access_policy: bool = None,
        access_token: str = None,
        arn: str = None,
        channel_name: str = None,
        channel_tier: str = None,
        filler_source_location_name: str = None,
        filler_source_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        out_put_config_list: List[ChannelAssemblyChannelOutPutConfigList] = None,
        playback_mode: str = None,
        state: int = None,
    ):
        self.access_policy = access_policy
        self.access_token = access_token
        self.arn = arn
        self.channel_name = channel_name
        self.channel_tier = channel_tier
        self.filler_source_location_name = filler_source_location_name
        self.filler_source_name = filler_source_name
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.out_put_config_list = out_put_config_list
        self.playback_mode = playback_mode
        self.state = state

    def validate(self):
        if self.out_put_config_list:
            for k in self.out_put_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_policy is not None:
            result['AccessPolicy'] = self.access_policy
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.channel_tier is not None:
            result['ChannelTier'] = self.channel_tier
        if self.filler_source_location_name is not None:
            result['FillerSourceLocationName'] = self.filler_source_location_name
        if self.filler_source_name is not None:
            result['FillerSourceName'] = self.filler_source_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        result['OutPutConfigList'] = []
        if self.out_put_config_list is not None:
            for k in self.out_put_config_list:
                result['OutPutConfigList'].append(k.to_map() if k else None)
        if self.playback_mode is not None:
            result['PlaybackMode'] = self.playback_mode
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessPolicy') is not None:
            self.access_policy = m.get('AccessPolicy')
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ChannelTier') is not None:
            self.channel_tier = m.get('ChannelTier')
        if m.get('FillerSourceLocationName') is not None:
            self.filler_source_location_name = m.get('FillerSourceLocationName')
        if m.get('FillerSourceName') is not None:
            self.filler_source_name = m.get('FillerSourceName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        self.out_put_config_list = []
        if m.get('OutPutConfigList') is not None:
            for k in m.get('OutPutConfigList'):
                temp_model = ChannelAssemblyChannelOutPutConfigList()
                self.out_put_config_list.append(temp_model.from_map(k))
        if m.get('PlaybackMode') is not None:
            self.playback_mode = m.get('PlaybackMode')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ChannelAssemblyProgramAdBreaks(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        message_type: str = None,
        offset_millis: int = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        splice_insert_settings: str = None,
        time_signal_settings: str = None,
    ):
        self.channel_name = channel_name
        self.message_type = message_type
        self.offset_millis = offset_millis
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.splice_insert_settings = splice_insert_settings
        self.time_signal_settings = time_signal_settings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.message_type is not None:
            result['MessageType'] = self.message_type
        if self.offset_millis is not None:
            result['OffsetMillis'] = self.offset_millis
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.splice_insert_settings is not None:
            result['SpliceInsertSettings'] = self.splice_insert_settings
        if self.time_signal_settings is not None:
            result['TimeSignalSettings'] = self.time_signal_settings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('MessageType') is not None:
            self.message_type = m.get('MessageType')
        if m.get('OffsetMillis') is not None:
            self.offset_millis = m.get('OffsetMillis')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SpliceInsertSettings') is not None:
            self.splice_insert_settings = m.get('SpliceInsertSettings')
        if m.get('TimeSignalSettings') is not None:
            self.time_signal_settings = m.get('TimeSignalSettings')
        return self


class ChannelAssemblyProgram(TeaModel):
    def __init__(
        self,
        ad_breaks: List[ChannelAssemblyProgramAdBreaks] = None,
        arn: str = None,
        channel_name: str = None,
        clip_range: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        transition: str = None,
    ):
        self.ad_breaks = ad_breaks
        self.arn = arn
        self.channel_name = channel_name
        self.clip_range = clip_range
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type
        self.transition = transition

    def validate(self):
        if self.ad_breaks:
            for k in self.ad_breaks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdBreaks'] = []
        if self.ad_breaks is not None:
            for k in self.ad_breaks:
                result['AdBreaks'].append(k.to_map() if k else None)
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.clip_range is not None:
            result['ClipRange'] = self.clip_range
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.transition is not None:
            result['Transition'] = self.transition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ad_breaks = []
        if m.get('AdBreaks') is not None:
            for k in m.get('AdBreaks'):
                temp_model = ChannelAssemblyProgramAdBreaks()
                self.ad_breaks.append(temp_model.from_map(k))
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClipRange') is not None:
            self.clip_range = m.get('ClipRange')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Transition') is not None:
            self.transition = m.get('Transition')
        return self


class ChannelAssemblyScheduleDataAdBreaks(TeaModel):
    def __init__(
        self,
        message_type: str = None,
        offset_millis: str = None,
        source_location_name: str = None,
        source_name: str = None,
        splice_insert_settings: str = None,
        time_signal_settings: str = None,
    ):
        self.message_type = message_type
        self.offset_millis = offset_millis
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.splice_insert_settings = splice_insert_settings
        self.time_signal_settings = time_signal_settings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_type is not None:
            result['MessageType'] = self.message_type
        if self.offset_millis is not None:
            result['OffsetMillis'] = self.offset_millis
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.splice_insert_settings is not None:
            result['SpliceInsertSettings'] = self.splice_insert_settings
        if self.time_signal_settings is not None:
            result['TimeSignalSettings'] = self.time_signal_settings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageType') is not None:
            self.message_type = m.get('MessageType')
        if m.get('OffsetMillis') is not None:
            self.offset_millis = m.get('OffsetMillis')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SpliceInsertSettings') is not None:
            self.splice_insert_settings = m.get('SpliceInsertSettings')
        if m.get('TimeSignalSettings') is not None:
            self.time_signal_settings = m.get('TimeSignalSettings')
        return self


class ChannelAssemblyScheduleData(TeaModel):
    def __init__(
        self,
        ad_breaks: List[ChannelAssemblyScheduleDataAdBreaks] = None,
        approximate_duration_seconds: int = None,
        approximate_start_time: str = None,
        entry_type: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        self.ad_breaks = ad_breaks
        self.approximate_duration_seconds = approximate_duration_seconds
        self.approximate_start_time = approximate_start_time
        self.entry_type = entry_type
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type

    def validate(self):
        if self.ad_breaks:
            for k in self.ad_breaks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdBreaks'] = []
        if self.ad_breaks is not None:
            for k in self.ad_breaks:
                result['AdBreaks'].append(k.to_map() if k else None)
        if self.approximate_duration_seconds is not None:
            result['ApproximateDurationSeconds'] = self.approximate_duration_seconds
        if self.approximate_start_time is not None:
            result['ApproximateStartTime'] = self.approximate_start_time
        if self.entry_type is not None:
            result['EntryType'] = self.entry_type
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ad_breaks = []
        if m.get('AdBreaks') is not None:
            for k in m.get('AdBreaks'):
                temp_model = ChannelAssemblyScheduleDataAdBreaks()
                self.ad_breaks.append(temp_model.from_map(k))
        if m.get('ApproximateDurationSeconds') is not None:
            self.approximate_duration_seconds = m.get('ApproximateDurationSeconds')
        if m.get('ApproximateStartTime') is not None:
            self.approximate_start_time = m.get('ApproximateStartTime')
        if m.get('EntryType') is not None:
            self.entry_type = m.get('EntryType')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class ChannelAssemblySource(TeaModel):
    def __init__(
        self,
        arn: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        http_package_configurations: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        state: int = None,
    ):
        self.arn = arn
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.http_package_configurations = http_package_configurations
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.http_package_configurations is not None:
            result['HttpPackageConfigurations'] = self.http_package_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HttpPackageConfigurations') is not None:
            self.http_package_configurations = m.get('HttpPackageConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ChannelAssemblySourceLocation(TeaModel):
    def __init__(
        self,
        arn: str = None,
        base_url: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        segment_delivery_configurations: str = None,
        source_location_name: str = None,
        state: int = None,
    ):
        self.arn = arn
        self.base_url = base_url
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.segment_delivery_configurations = segment_delivery_configurations
        self.source_location_name = source_location_name
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.base_url is not None:
            result['BaseUrl'] = self.base_url
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.segment_delivery_configurations is not None:
            result['SegmentDeliveryConfigurations'] = self.segment_delivery_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('BaseUrl') is not None:
            self.base_url = m.get('BaseUrl')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('SegmentDeliveryConfigurations') is not None:
            self.segment_delivery_configurations = m.get('SegmentDeliveryConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class TranspositionResult(TeaModel):
    def __init__(
        self,
        target_language: str = None,
        translated_text: str = None,
    ):
        self.target_language = target_language
        self.translated_text = translated_text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_language is not None:
            result['TargetLanguage'] = self.target_language
        if self.translated_text is not None:
            result['TranslatedText'] = self.translated_text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetLanguage') is not None:
            self.target_language = m.get('TargetLanguage')
        if m.get('TranslatedText') is not None:
            self.translated_text = m.get('TranslatedText')
        return self


class Hotword(TeaModel):
    def __init__(
        self,
        language: str = None,
        text: str = None,
        transposition_result_list: List[TranspositionResult] = None,
        weight: int = None,
    ):
        self.language = language
        self.text = text
        self.transposition_result_list = transposition_result_list
        self.weight = weight

    def validate(self):
        if self.transposition_result_list:
            for k in self.transposition_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language is not None:
            result['Language'] = self.language
        if self.text is not None:
            result['Text'] = self.text
        result['TranspositionResultList'] = []
        if self.transposition_result_list is not None:
            for k in self.transposition_result_list:
                result['TranspositionResultList'].append(k.to_map() if k else None)
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        self.transposition_result_list = []
        if m.get('TranspositionResultList') is not None:
            for k in m.get('TranspositionResultList'):
                temp_model = TranspositionResult()
                self.transposition_result_list.append(temp_model.from_map(k))
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class LicenseInstanceAppDTOLicenseConfigs(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        feature_ids: str = None,
        is_trial: bool = None,
        sdk_id: int = None,
        sdk_name: str = None,
        subscription: str = None,
        subscription_imp: str = None,
        subscription_pkg: str = None,
    ):
        self.business_type = business_type
        self.feature_ids = feature_ids
        self.is_trial = is_trial
        self.sdk_id = sdk_id
        self.sdk_name = sdk_name
        self.subscription = subscription
        self.subscription_imp = subscription_imp
        self.subscription_pkg = subscription_pkg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.feature_ids is not None:
            result['FeatureIds'] = self.feature_ids
        if self.is_trial is not None:
            result['IsTrial'] = self.is_trial
        if self.sdk_id is not None:
            result['SdkId'] = self.sdk_id
        if self.sdk_name is not None:
            result['SdkName'] = self.sdk_name
        if self.subscription is not None:
            result['Subscription'] = self.subscription
        if self.subscription_imp is not None:
            result['SubscriptionImp'] = self.subscription_imp
        if self.subscription_pkg is not None:
            result['SubscriptionPkg'] = self.subscription_pkg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('FeatureIds') is not None:
            self.feature_ids = m.get('FeatureIds')
        if m.get('IsTrial') is not None:
            self.is_trial = m.get('IsTrial')
        if m.get('SdkId') is not None:
            self.sdk_id = m.get('SdkId')
        if m.get('SdkName') is not None:
            self.sdk_name = m.get('SdkName')
        if m.get('Subscription') is not None:
            self.subscription = m.get('Subscription')
        if m.get('SubscriptionImp') is not None:
            self.subscription_imp = m.get('SubscriptionImp')
        if m.get('SubscriptionPkg') is not None:
            self.subscription_pkg = m.get('SubscriptionPkg')
        return self


class LicenseInstanceAppDTO(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        begin_on: str = None,
        contract_no: str = None,
        creation_time: str = None,
        expired_on: str = None,
        instance_id: str = None,
        item_id: str = None,
        license_configs: List[LicenseInstanceAppDTOLicenseConfigs] = None,
        modification_time: str = None,
        status: str = None,
        user_id: int = None,
    ):
        self.app_id = app_id
        self.begin_on = begin_on
        self.contract_no = contract_no
        self.creation_time = creation_time
        self.expired_on = expired_on
        self.instance_id = instance_id
        self.item_id = item_id
        self.license_configs = license_configs
        self.modification_time = modification_time
        self.status = status
        self.user_id = user_id

    def validate(self):
        if self.license_configs:
            for k in self.license_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.begin_on is not None:
            result['BeginOn'] = self.begin_on
        if self.contract_no is not None:
            result['ContractNo'] = self.contract_no
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.expired_on is not None:
            result['ExpiredOn'] = self.expired_on
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        result['LicenseConfigs'] = []
        if self.license_configs is not None:
            for k in self.license_configs:
                result['LicenseConfigs'].append(k.to_map() if k else None)
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BeginOn') is not None:
            self.begin_on = m.get('BeginOn')
        if m.get('ContractNo') is not None:
            self.contract_no = m.get('ContractNo')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ExpiredOn') is not None:
            self.expired_on = m.get('ExpiredOn')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        self.license_configs = []
        if m.get('LicenseConfigs') is not None:
            for k in m.get('LicenseConfigs'):
                temp_model = LicenseInstanceAppDTOLicenseConfigs()
                self.license_configs.append(temp_model.from_map(k))
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LiveManifestConfig(TeaModel):
    def __init__(
        self,
        ad_markers: str = None,
        date_time_interval: int = None,
        manifest_duration: int = None,
        max_video_bitrate: int = None,
        min_buffer_time: int = None,
        min_update_period: int = None,
        min_video_bitrate: int = None,
        presentation_delay: int = None,
        segment_count: int = None,
        segment_template_format: str = None,
        stream_order: str = None,
    ):
        self.ad_markers = ad_markers
        self.date_time_interval = date_time_interval
        self.manifest_duration = manifest_duration
        self.max_video_bitrate = max_video_bitrate
        self.min_buffer_time = min_buffer_time
        self.min_update_period = min_update_period
        self.min_video_bitrate = min_video_bitrate
        self.presentation_delay = presentation_delay
        self.segment_count = segment_count
        self.segment_template_format = segment_template_format
        self.stream_order = stream_order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_markers is not None:
            result['AdMarkers'] = self.ad_markers
        if self.date_time_interval is not None:
            result['DateTimeInterval'] = self.date_time_interval
        if self.manifest_duration is not None:
            result['ManifestDuration'] = self.manifest_duration
        if self.max_video_bitrate is not None:
            result['MaxVideoBitrate'] = self.max_video_bitrate
        if self.min_buffer_time is not None:
            result['MinBufferTime'] = self.min_buffer_time
        if self.min_update_period is not None:
            result['MinUpdatePeriod'] = self.min_update_period
        if self.min_video_bitrate is not None:
            result['MinVideoBitrate'] = self.min_video_bitrate
        if self.presentation_delay is not None:
            result['PresentationDelay'] = self.presentation_delay
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_template_format is not None:
            result['SegmentTemplateFormat'] = self.segment_template_format
        if self.stream_order is not None:
            result['StreamOrder'] = self.stream_order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkers') is not None:
            self.ad_markers = m.get('AdMarkers')
        if m.get('DateTimeInterval') is not None:
            self.date_time_interval = m.get('DateTimeInterval')
        if m.get('ManifestDuration') is not None:
            self.manifest_duration = m.get('ManifestDuration')
        if m.get('MaxVideoBitrate') is not None:
            self.max_video_bitrate = m.get('MaxVideoBitrate')
        if m.get('MinBufferTime') is not None:
            self.min_buffer_time = m.get('MinBufferTime')
        if m.get('MinUpdatePeriod') is not None:
            self.min_update_period = m.get('MinUpdatePeriod')
        if m.get('MinVideoBitrate') is not None:
            self.min_video_bitrate = m.get('MinVideoBitrate')
        if m.get('PresentationDelay') is not None:
            self.presentation_delay = m.get('PresentationDelay')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentTemplateFormat') is not None:
            self.segment_template_format = m.get('SegmentTemplateFormat')
        if m.get('StreamOrder') is not None:
            self.stream_order = m.get('StreamOrder')
        return self


class LivePackagingConfigDrmConfig(TeaModel):
    def __init__(
        self,
        content_id: str = None,
        encryption_method: str = None,
        iv: str = None,
        rotate_period: int = None,
        system_ids: List[str] = None,
        url: str = None,
    ):
        self.content_id = content_id
        self.encryption_method = encryption_method
        self.iv = iv
        self.rotate_period = rotate_period
        self.system_ids = system_ids
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.encryption_method is not None:
            result['EncryptionMethod'] = self.encryption_method
        if self.iv is not None:
            result['IV'] = self.iv
        if self.rotate_period is not None:
            result['RotatePeriod'] = self.rotate_period
        if self.system_ids is not None:
            result['SystemIds'] = self.system_ids
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('EncryptionMethod') is not None:
            self.encryption_method = m.get('EncryptionMethod')
        if m.get('IV') is not None:
            self.iv = m.get('IV')
        if m.get('RotatePeriod') is not None:
            self.rotate_period = m.get('RotatePeriod')
        if m.get('SystemIds') is not None:
            self.system_ids = m.get('SystemIds')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class LivePackagingConfig(TeaModel):
    def __init__(
        self,
        drm_config: LivePackagingConfigDrmConfig = None,
        live_manifest_configs: List[LiveManifestConfig] = None,
        segment_duration: int = None,
        use_audio_rendition_groups: bool = None,
    ):
        self.drm_config = drm_config
        self.live_manifest_configs = live_manifest_configs
        self.segment_duration = segment_duration
        self.use_audio_rendition_groups = use_audio_rendition_groups

    def validate(self):
        if self.drm_config:
            self.drm_config.validate()
        if self.live_manifest_configs:
            for k in self.live_manifest_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drm_config is not None:
            result['DrmConfig'] = self.drm_config.to_map()
        result['LiveManifestConfigs'] = []
        if self.live_manifest_configs is not None:
            for k in self.live_manifest_configs:
                result['LiveManifestConfigs'].append(k.to_map() if k else None)
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.use_audio_rendition_groups is not None:
            result['UseAudioRenditionGroups'] = self.use_audio_rendition_groups
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DrmConfig') is not None:
            temp_model = LivePackagingConfigDrmConfig()
            self.drm_config = temp_model.from_map(m['DrmConfig'])
        self.live_manifest_configs = []
        if m.get('LiveManifestConfigs') is not None:
            for k in m.get('LiveManifestConfigs'):
                temp_model = LiveManifestConfig()
                self.live_manifest_configs.append(temp_model.from_map(k))
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('UseAudioRenditionGroups') is not None:
            self.use_audio_rendition_groups = m.get('UseAudioRenditionGroups')
        return self


class MediaConvertAudio(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        channels: int = None,
        codec: str = None,
        profile: str = None,
        remove: bool = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.remove = remove
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class MediaObject(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
        url: str = None,
    ):
        self.media = media
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class MediaConvertInput(TeaModel):
    def __init__(
        self,
        input_file: MediaObject = None,
        name: str = None,
    ):
        self.input_file = input_file
        self.name = name

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = MediaObject()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class MediaConvertSegment(TeaModel):
    def __init__(
        self,
        duration: int = None,
        force_seg_time: str = None,
    ):
        self.duration = duration
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class MediaConvertMuxConfig(TeaModel):
    def __init__(
        self,
        segment: MediaConvertSegment = None,
    ):
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = MediaConvertSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class MediaConvertOutput(TeaModel):
    def __init__(
        self,
        features: str = None,
        name: str = None,
        output_file: MediaObject = None,
        override_params: str = None,
        priority: int = None,
        template_id: str = None,
    ):
        self.features = features
        self.name = name
        self.output_file = output_file
        self.override_params = override_params
        self.priority = priority
        self.template_id = template_id

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.features is not None:
            result['Features'] = self.features
        if self.name is not None:
            result['Name'] = self.name
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.override_params is not None:
            result['OverrideParams'] = self.override_params
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Features') is not None:
            self.features = m.get('Features')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputFile') is not None:
            temp_model = MediaObject()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('OverrideParams') is not None:
            self.override_params = m.get('OverrideParams')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class MediaConvertOutputDetail(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        name: str = None,
        status: str = None,
        task_id: str = None,
    ):
        self.code = code
        self.message = message
        self.name = name
        self.status = status
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class MediaConvertOutputGroupConfig(TeaModel):
    def __init__(
        self,
        manifest_name: str = None,
        output_file_base: MediaObject = None,
        type: str = None,
    ):
        self.manifest_name = manifest_name
        self.output_file_base = output_file_base
        self.type = type

    def validate(self):
        if self.output_file_base:
            self.output_file_base.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.output_file_base is not None:
            result['OutputFileBase'] = self.output_file_base.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('OutputFileBase') is not None:
            temp_model = MediaObject()
            self.output_file_base = temp_model.from_map(m['OutputFileBase'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class MediaConvertOutputGroupOutput(TeaModel):
    def __init__(
        self,
        features: str = None,
        name: str = None,
        output_file_name: str = None,
        override_params: str = None,
        priority: int = None,
        template_id: str = None,
    ):
        self.features = features
        self.name = name
        self.output_file_name = output_file_name
        self.override_params = override_params
        self.priority = priority
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.features is not None:
            result['Features'] = self.features
        if self.name is not None:
            result['Name'] = self.name
        if self.output_file_name is not None:
            result['OutputFileName'] = self.output_file_name
        if self.override_params is not None:
            result['OverrideParams'] = self.override_params
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Features') is not None:
            self.features = m.get('Features')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputFileName') is not None:
            self.output_file_name = m.get('OutputFileName')
        if m.get('OverrideParams') is not None:
            self.override_params = m.get('OverrideParams')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class MediaConvertOutputGroup(TeaModel):
    def __init__(
        self,
        group_config: MediaConvertOutputGroupConfig = None,
        name: str = None,
        outputs: List[MediaConvertOutputGroupOutput] = None,
    ):
        self.group_config = group_config
        self.name = name
        self.outputs = outputs

    def validate(self):
        if self.group_config:
            self.group_config.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_config is not None:
            result['GroupConfig'] = self.group_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupConfig') is not None:
            temp_model = MediaConvertOutputGroupConfig()
            self.group_config = temp_model.from_map(m['GroupConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = MediaConvertOutputGroupOutput()
                self.outputs.append(temp_model.from_map(k))
        return self


class MediaConvertOutputGroupDetail(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        name: str = None,
        outputs: List[MediaConvertOutputDetail] = None,
        status: str = None,
        task_id: str = None,
    ):
        self.code = code
        self.message = message
        self.name = name
        self.outputs = outputs
        self.status = status
        self.task_id = task_id

    def validate(self):
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = MediaConvertOutputDetail()
                self.outputs.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class MediaConvertTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: bool = None,
        is_check_audio_bitrate_fail: bool = None,
        is_check_reso: bool = None,
        is_check_reso_fail: bool = None,
        is_check_video_bitrate: bool = None,
        is_check_video_bitrate_fail: bool = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class MediaConvertVideo(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        bufsize: int = None,
        codec: str = None,
        crf: Any = None,
        crop: str = None,
        fps: Any = None,
        gop: Any = None,
        height: int = None,
        long_short_mode: bool = None,
        max_fps: Any = None,
        maxrate: int = None,
        pad: str = None,
        profile: str = None,
        qscale: int = None,
        remove: bool = None,
        scan_mode: str = None,
        width: int = None,
    ):
        self.bitrate = bitrate
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.fps = fps
        self.gop = gop
        self.height = height
        self.long_short_mode = long_short_mode
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class MediaConvertVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: int = None,
        level: int = None,
        loudness_range_target: int = None,
        method: str = None,
        true_peak: int = None,
    ):
        self.integrated_loudness_target = integrated_loudness_target
        self.level = level
        self.loudness_range_target = loudness_range_target
        self.method = method
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.level is not None:
            result['Level'] = self.level
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class ProgramAdBreaks(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        message_type: str = None,
        offset_millis: int = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        splice_insert_settings: str = None,
        time_signal_settings: str = None,
    ):
        self.channel_name = channel_name
        self.message_type = message_type
        self.offset_millis = offset_millis
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.splice_insert_settings = splice_insert_settings
        self.time_signal_settings = time_signal_settings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.message_type is not None:
            result['MessageType'] = self.message_type
        if self.offset_millis is not None:
            result['OffsetMillis'] = self.offset_millis
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.splice_insert_settings is not None:
            result['SpliceInsertSettings'] = self.splice_insert_settings
        if self.time_signal_settings is not None:
            result['TimeSignalSettings'] = self.time_signal_settings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('MessageType') is not None:
            self.message_type = m.get('MessageType')
        if m.get('OffsetMillis') is not None:
            self.offset_millis = m.get('OffsetMillis')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SpliceInsertSettings') is not None:
            self.splice_insert_settings = m.get('SpliceInsertSettings')
        if m.get('TimeSignalSettings') is not None:
            self.time_signal_settings = m.get('TimeSignalSettings')
        return self


class Program(TeaModel):
    def __init__(
        self,
        ad_breaks: List[ProgramAdBreaks] = None,
        arn: str = None,
        channel_name: str = None,
        clip_range: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        transition: str = None,
    ):
        self.ad_breaks = ad_breaks
        self.arn = arn
        self.channel_name = channel_name
        self.clip_range = clip_range
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type
        self.transition = transition

    def validate(self):
        if self.ad_breaks:
            for k in self.ad_breaks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdBreaks'] = []
        if self.ad_breaks is not None:
            for k in self.ad_breaks:
                result['AdBreaks'].append(k.to_map() if k else None)
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.clip_range is not None:
            result['ClipRange'] = self.clip_range
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.transition is not None:
            result['Transition'] = self.transition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ad_breaks = []
        if m.get('AdBreaks') is not None:
            for k in m.get('AdBreaks'):
                temp_model = ProgramAdBreaks()
                self.ad_breaks.append(temp_model.from_map(k))
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClipRange') is not None:
            self.clip_range = m.get('ClipRange')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Transition') is not None:
            self.transition = m.get('Transition')
        return self


class ScheduleDataAdBreaks(TeaModel):
    def __init__(
        self,
        message_type: str = None,
        offset_millis: str = None,
        source_location_name: str = None,
        source_name: str = None,
        splice_insert_settings: str = None,
        time_signal_settings: str = None,
    ):
        self.message_type = message_type
        self.offset_millis = offset_millis
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.splice_insert_settings = splice_insert_settings
        self.time_signal_settings = time_signal_settings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_type is not None:
            result['MessageType'] = self.message_type
        if self.offset_millis is not None:
            result['OffsetMillis'] = self.offset_millis
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.splice_insert_settings is not None:
            result['SpliceInsertSettings'] = self.splice_insert_settings
        if self.time_signal_settings is not None:
            result['TimeSignalSettings'] = self.time_signal_settings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageType') is not None:
            self.message_type = m.get('MessageType')
        if m.get('OffsetMillis') is not None:
            self.offset_millis = m.get('OffsetMillis')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SpliceInsertSettings') is not None:
            self.splice_insert_settings = m.get('SpliceInsertSettings')
        if m.get('TimeSignalSettings') is not None:
            self.time_signal_settings = m.get('TimeSignalSettings')
        return self


class ScheduleData(TeaModel):
    def __init__(
        self,
        ad_breaks: List[ScheduleDataAdBreaks] = None,
        approximate_duration_seconds: int = None,
        approximate_start_time: str = None,
        entry_type: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        self.ad_breaks = ad_breaks
        self.approximate_duration_seconds = approximate_duration_seconds
        self.approximate_start_time = approximate_start_time
        self.entry_type = entry_type
        self.program_name = program_name
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type

    def validate(self):
        if self.ad_breaks:
            for k in self.ad_breaks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdBreaks'] = []
        if self.ad_breaks is not None:
            for k in self.ad_breaks:
                result['AdBreaks'].append(k.to_map() if k else None)
        if self.approximate_duration_seconds is not None:
            result['ApproximateDurationSeconds'] = self.approximate_duration_seconds
        if self.approximate_start_time is not None:
            result['ApproximateStartTime'] = self.approximate_start_time
        if self.entry_type is not None:
            result['EntryType'] = self.entry_type
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ad_breaks = []
        if m.get('AdBreaks') is not None:
            for k in m.get('AdBreaks'):
                temp_model = ScheduleDataAdBreaks()
                self.ad_breaks.append(temp_model.from_map(k))
        if m.get('ApproximateDurationSeconds') is not None:
            self.approximate_duration_seconds = m.get('ApproximateDurationSeconds')
        if m.get('ApproximateStartTime') is not None:
            self.approximate_start_time = m.get('ApproximateStartTime')
        if m.get('EntryType') is not None:
            self.entry_type = m.get('EntryType')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class Source(TeaModel):
    def __init__(
        self,
        arn: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        http_package_configurations: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        state: int = None,
    ):
        self.arn = arn
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.http_package_configurations = http_package_configurations
        self.source_location_name = source_location_name
        self.source_name = source_name
        self.source_type = source_type
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.http_package_configurations is not None:
            result['HttpPackageConfigurations'] = self.http_package_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HttpPackageConfigurations') is not None:
            self.http_package_configurations = m.get('HttpPackageConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SourceLocation(TeaModel):
    def __init__(
        self,
        arn: str = None,
        base_url: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        segment_delivery_configurations: str = None,
        source_location_name: str = None,
        state: int = None,
    ):
        self.arn = arn
        self.base_url = base_url
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.segment_delivery_configurations = segment_delivery_configurations
        self.source_location_name = source_location_name
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.base_url is not None:
            result['BaseUrl'] = self.base_url
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.segment_delivery_configurations is not None:
            result['SegmentDeliveryConfigurations'] = self.segment_delivery_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('BaseUrl') is not None:
            self.base_url = m.get('BaseUrl')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('SegmentDeliveryConfigurations') is not None:
            self.segment_delivery_configurations = m.get('SegmentDeliveryConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class VodPackagingAssetInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class VodPackagingAsset(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        content_id: str = None,
        create_time: str = None,
        group_name: str = None,
        input: VodPackagingAssetInput = None,
    ):
        self.asset_name = asset_name
        self.content_id = content_id
        self.create_time = create_time
        self.group_name = group_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Input') is not None:
            temp_model = VodPackagingAssetInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class VodPackagingConfigDrmProvider(TeaModel):
    def __init__(
        self,
        encryption_method: str = None,
        iv: str = None,
        system_ids: List[str] = None,
        url: str = None,
    ):
        self.encryption_method = encryption_method
        self.iv = iv
        self.system_ids = system_ids
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encryption_method is not None:
            result['EncryptionMethod'] = self.encryption_method
        if self.iv is not None:
            result['IV'] = self.iv
        if self.system_ids is not None:
            result['SystemIds'] = self.system_ids
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptionMethod') is not None:
            self.encryption_method = m.get('EncryptionMethod')
        if m.get('IV') is not None:
            self.iv = m.get('IV')
        if m.get('SystemIds') is not None:
            self.system_ids = m.get('SystemIds')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class VodPackagingConfigStreamSelection(TeaModel):
    def __init__(
        self,
        max_video_bits_per_second: int = None,
        min_video_bits_per_second: int = None,
        stream_order: str = None,
    ):
        self.max_video_bits_per_second = max_video_bits_per_second
        self.min_video_bits_per_second = min_video_bits_per_second
        self.stream_order = stream_order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_video_bits_per_second is not None:
            result['MaxVideoBitsPerSecond'] = self.max_video_bits_per_second
        if self.min_video_bits_per_second is not None:
            result['MinVideoBitsPerSecond'] = self.min_video_bits_per_second
        if self.stream_order is not None:
            result['StreamOrder'] = self.stream_order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxVideoBitsPerSecond') is not None:
            self.max_video_bits_per_second = m.get('MaxVideoBitsPerSecond')
        if m.get('MinVideoBitsPerSecond') is not None:
            self.min_video_bits_per_second = m.get('MinVideoBitsPerSecond')
        if m.get('StreamOrder') is not None:
            self.stream_order = m.get('StreamOrder')
        return self


class VodPackagingConfig(TeaModel):
    def __init__(
        self,
        drm_provider: VodPackagingConfigDrmProvider = None,
        manifest_name: str = None,
        segment_duration: int = None,
        stream_selection: VodPackagingConfigStreamSelection = None,
    ):
        self.drm_provider = drm_provider
        self.manifest_name = manifest_name
        self.segment_duration = segment_duration
        self.stream_selection = stream_selection

    def validate(self):
        if self.drm_provider:
            self.drm_provider.validate()
        if self.stream_selection:
            self.stream_selection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drm_provider is not None:
            result['DrmProvider'] = self.drm_provider.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.stream_selection is not None:
            result['StreamSelection'] = self.stream_selection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DrmProvider') is not None:
            temp_model = VodPackagingConfigDrmProvider()
            self.drm_provider = temp_model.from_map(m['DrmProvider'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('StreamSelection') is not None:
            temp_model = VodPackagingConfigStreamSelection()
            self.stream_selection = temp_model.from_map(m['StreamSelection'])
        return self


class VodPackagingConfiguration(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        package_config: VodPackagingConfig = None,
        protocol: str = None,
    ):
        self.configuration_name = configuration_name
        self.create_time = create_time
        self.description = description
        self.group_name = group_name
        self.package_config = package_config
        self.protocol = protocol

    def validate(self):
        if self.package_config:
            self.package_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.package_config is not None:
            result['PackageConfig'] = self.package_config.to_map()
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('PackageConfig') is not None:
            temp_model = VodPackagingConfig()
            self.package_config = temp_model.from_map(m['PackageConfig'])
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class VodPackagingGroup(TeaModel):
    def __init__(
        self,
        approximate_asset_count: int = None,
        configuration_count: int = None,
        create_time: str = None,
        description: str = None,
        domain_name: str = None,
        group_name: str = None,
    ):
        self.approximate_asset_count = approximate_asset_count
        self.configuration_count = configuration_count
        self.create_time = create_time
        self.description = description
        self.domain_name = domain_name
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approximate_asset_count is not None:
            result['ApproximateAssetCount'] = self.approximate_asset_count
        if self.configuration_count is not None:
            result['ConfigurationCount'] = self.configuration_count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApproximateAssetCount') is not None:
            self.approximate_asset_count = m.get('ApproximateAssetCount')
        if m.get('ConfigurationCount') is not None:
            self.configuration_count = m.get('ConfigurationCount')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class AddAdInsertionRequest(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_ad_segment_url_prefix: str = None,
        cdn_content_segment_url_prefix: str = None,
        client_token: str = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Specifies whether to enable ad marker passthrough. Default value: OFF.
        # 
        # Valid values:
        # 
        # *   OFF: Disable.
        # *   ON: Enable.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The request URL of the ad decision server (ADS). HTTP and HTTPS are supported. The maximum length is 2,048 characters.
        # 
        # This parameter is required.
        self.ads_url = ads_url
        # The CDN prefix for ad segments. HTTP and HTTPS are supported. The maximum length is 512 characters.
        self.cdn_ad_segment_url_prefix = cdn_ad_segment_url_prefix
        # The CDN prefix for content segments. HTTP and HTTPS are supported. The maximum length is 512 characters.
        self.cdn_content_segment_url_prefix = cdn_content_segment_url_prefix
        # The idempotency key that is used to avoid repeated submission. The value can be up to 200 characters in length.
        self.client_token = client_token
        # A JSON string that specifies the player parameter variables and aliases. You can add up to 20 player_params.{name} entries. The name field can be up to 150 characters in length. Each player parameter can include up to 50 key-value pairs. A key can be up to 150 characters long, and a value can be up to 500 characters. Example: { "player_params.{name}": { "{key}": "{value}" } }
        self.config_aliases = config_aliases
        # The URL prefix for the source content. HTTP and HTTPS are supported. The maximum length is 512 characters.
        # 
        # This parameter is required.
        self.content_url_prefix = content_url_prefix
        # The name of the configuration. The name must be unique and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        # 
        # This parameter is required.
        self.name = name
        # Specifies the maximum duration of underfilled time allowed in an ad break. Unit: seconds. Default value: 8 seconds.
        self.personalization_threshold = personalization_threshold
        # The HTTP or HTTPS URL of the slate ad. Only MP4 format is supported. The maximum length is 2,048 characters.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_ad_segment_url_prefix is not None:
            result['CdnAdSegmentUrlPrefix'] = self.cdn_ad_segment_url_prefix
        if self.cdn_content_segment_url_prefix is not None:
            result['CdnContentSegmentUrlPrefix'] = self.cdn_content_segment_url_prefix
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnAdSegmentUrlPrefix') is not None:
            self.cdn_ad_segment_url_prefix = m.get('CdnAdSegmentUrlPrefix')
        if m.get('CdnContentSegmentUrlPrefix') is not None:
            self.cdn_content_segment_url_prefix = m.get('CdnContentSegmentUrlPrefix')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class AddAdInsertionResponseBodyConfigCdnConfig(TeaModel):
    def __init__(
        self,
        ad_segment_url_prefix: str = None,
        content_segment_url_prefix: str = None,
    ):
        # The CDN prefix for ad segments.
        self.ad_segment_url_prefix = ad_segment_url_prefix
        # The CDN prefix for content segments.
        self.content_segment_url_prefix = content_segment_url_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_segment_url_prefix is not None:
            result['AdSegmentUrlPrefix'] = self.ad_segment_url_prefix
        if self.content_segment_url_prefix is not None:
            result['ContentSegmentUrlPrefix'] = self.content_segment_url_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdSegmentUrlPrefix') is not None:
            self.ad_segment_url_prefix = m.get('AdSegmentUrlPrefix')
        if m.get('ContentSegmentUrlPrefix') is not None:
            self.content_segment_url_prefix = m.get('ContentSegmentUrlPrefix')
        return self


class AddAdInsertionResponseBodyConfigManifestEndpointConfig(TeaModel):
    def __init__(
        self,
        dash_prefix: str = None,
        hls_prefix: str = None,
    ):
        # DASH
        self.dash_prefix = dash_prefix
        # The prefix of the playback endpoint for HLS manifests.
        self.hls_prefix = hls_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dash_prefix is not None:
            result['DashPrefix'] = self.dash_prefix
        if self.hls_prefix is not None:
            result['HlsPrefix'] = self.hls_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashPrefix') is not None:
            self.dash_prefix = m.get('DashPrefix')
        if m.get('HlsPrefix') is not None:
            self.hls_prefix = m.get('HlsPrefix')
        return self


class AddAdInsertionResponseBodyConfig(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_config: AddAdInsertionResponseBodyConfigCdnConfig = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        create_time: str = None,
        last_modified: str = None,
        manifest_endpoint_config: AddAdInsertionResponseBodyConfigManifestEndpointConfig = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Indicates whether ad marker passthrough is enabled.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The request URL of ADS.
        self.ads_url = ads_url
        # The CDN configurations.
        self.cdn_config = cdn_config
        # The player parameter variables and aliases.
        self.config_aliases = config_aliases
        # The URL prefix for the source content.
        self.content_url_prefix = content_url_prefix
        # The time when the configuration was created.
        self.create_time = create_time
        # The time when the configuration was last modified.
        self.last_modified = last_modified
        # The playback endpoint configuration.
        self.manifest_endpoint_config = manifest_endpoint_config
        # The name of the ad insertion configuration.
        self.name = name
        # The personalization threshold.
        self.personalization_threshold = personalization_threshold
        # The URL of the slate ad.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        if self.cdn_config:
            self.cdn_config.validate()
        if self.manifest_endpoint_config:
            self.manifest_endpoint_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_config is not None:
            result['CdnConfig'] = self.cdn_config.to_map()
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.manifest_endpoint_config is not None:
            result['ManifestEndpointConfig'] = self.manifest_endpoint_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnConfig') is not None:
            temp_model = AddAdInsertionResponseBodyConfigCdnConfig()
            self.cdn_config = temp_model.from_map(m['CdnConfig'])
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('ManifestEndpointConfig') is not None:
            temp_model = AddAdInsertionResponseBodyConfigManifestEndpointConfig()
            self.manifest_endpoint_config = temp_model.from_map(m['ManifestEndpointConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class AddAdInsertionResponseBody(TeaModel):
    def __init__(
        self,
        config: AddAdInsertionResponseBodyConfig = None,
        request_id: str = None,
    ):
        # The ad insertion configuration.
        self.config = config
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = AddAdInsertionResponseBodyConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddAdInsertionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAdInsertionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAdInsertionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_name: str = None,
        parent_id: int = None,
        type: str = None,
    ):
        # The category name.
        # 
        # *   The value can be up to 64 bytes in length.
        # *   The value must be encoded in UTF-8.
        # 
        # This parameter is required.
        self.cate_name = cate_name
        # The ID of the parent category.
        self.parent_id = parent_id
        # The type of the category. Valid values:
        # 
        # *   default: audio, video, and image files. This is the default value.
        # *   material: short video materials.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddCategoryResponseBodyCategory(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cate_name: str = None,
        level: int = None,
        parent_id: int = None,
        type: str = None,
    ):
        # The ID of the created category.
        self.cate_id = cate_id
        # The category name.
        self.cate_name = cate_name
        # The level of the category. A value of **0** indicates a level-1 category, a value of **1** indicates a level-2 category, and a value of **2** indicates a level-3 category.
        self.level = level
        # The ID of the parent category. By default, if ParentId is left empty or less than 1, -1 is returned, which indicates that the created category is the root directory.
        self.parent_id = parent_id
        # The type of the category. Valid values:
        # 
        # *   **default**: audio, video, and image files. This is the default value.
        # *   **material**: short video materials.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category: AddCategoryResponseBodyCategory = None,
        request_id: str = None,
    ):
        # The information about the category.
        self.category = category
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.category:
            self.category.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = AddCategoryResponseBodyCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddEditingProjectMaterialsRequest(TeaModel):
    def __init__(
        self,
        material_maps: str = None,
        project_id: str = None,
    ):
        # The material ID. Separate multiple material IDs with commas (,). Each type supports up to 10 material IDs. The following material types are supported:
        # 
        # *   video
        # *   audio
        # *   image
        # *   liveStream
        # *   editingProject
        # 
        # This parameter is required.
        self.material_maps = material_maps
        # The ID of the online editing project.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_maps is not None:
            result['MaterialMaps'] = self.material_maps
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaterialMaps') is not None:
            self.material_maps = m.get('MaterialMaps')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AddEditingProjectMaterialsResponseBodyLiveMaterials(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        live_url: str = None,
        stream_name: str = None,
    ):
        # The application name of the live stream.
        self.app_name = app_name
        # The domain name of the live stream.
        self.domain_name = domain_name
        # The URL of the live stream.
        self.live_url = live_url
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_url is not None:
            result['LiveUrl'] = self.live_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveUrl') is not None:
            self.live_url = m.get('LiveUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        # 
        # \\-Uploading
        # 
        # \\-Normal
        # 
        # \\-UploadFail
        # 
        # \\-Disable
        # 
        # \\-Deleted
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The Object Storage Service (OSS) URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo = None,
    ):
        # The basic information of the file, including the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        user_data: str = None,
    ):
        # The business type of the media asset.
        self.business_type = business_type
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The URL of the media asset in another service.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset.
        self.source = source
        # The sprite of the media asset.
        self.sprite_images = sprite_images
        # The status of the media asset. Valid values:
        # 
        # \\- Init
        # 
        # \\- Preparing
        # 
        # \\- PrepareFail
        # 
        # \\- Normal
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        self.transcode_status = transcode_status
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfos(TeaModel):
    def __init__(
        self,
        file_info_list: List[AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList] = None,
        media_basic_info: AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo = None,
        media_id: str = None,
    ):
        # FileInfos
        self.file_info_list = file_info_list
        # The basic information of the media assets.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class AddEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(
        self,
        live_materials: List[AddEditingProjectMaterialsResponseBodyLiveMaterials] = None,
        media_infos: List[AddEditingProjectMaterialsResponseBodyMediaInfos] = None,
        project_id: str = None,
        project_materials: List[str] = None,
        request_id: str = None,
    ):
        # The materials associated with the live stream.
        self.live_materials = live_materials
        # The media assets that meet the specified conditions.
        self.media_infos = media_infos
        # The ID of the online editing project.
        self.project_id = project_id
        # The materials associated with the editing project. A live stream editing project will be associated with a regular editing project after the live streaming ends.
        self.project_materials = project_materials
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_materials:
            for k in self.live_materials:
                if k:
                    k.validate()
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveMaterials'] = []
        if self.live_materials is not None:
            for k in self.live_materials:
                result['LiveMaterials'].append(k.to_map() if k else None)
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_materials is not None:
            result['ProjectMaterials'] = self.project_materials
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_materials = []
        if m.get('LiveMaterials') is not None:
            for k in m.get('LiveMaterials'):
                temp_model = AddEditingProjectMaterialsResponseBodyLiveMaterials()
                self.live_materials.append(temp_model.from_map(k))
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = AddEditingProjectMaterialsResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMaterials') is not None:
            self.project_materials = m.get('ProjectMaterials')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddEditingProjectMaterialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddEditingProjectMaterialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddFavoritePublicMediaRequest(TeaModel):
    def __init__(
        self,
        media_ids: str = None,
    ):
        self.media_ids = media_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class AddFavoritePublicMediaResponseBody(TeaModel):
    def __init__(
        self,
        ignored_list: List[str] = None,
        request_id: str = None,
    ):
        self.ignored_list = ignored_list
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddFavoritePublicMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddFavoritePublicMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddFavoritePublicMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaConnectFlowInputRequest(TeaModel):
    def __init__(
        self,
        cidrs: str = None,
        flow_id: str = None,
        input_from_url: str = None,
        input_name: str = None,
        input_protocol: str = None,
        max_bitrate: int = None,
        pair_flow_id: str = None,
        pair_output_name: str = None,
        srt_latency: int = None,
        srt_passphrase: str = None,
        srt_pbkey_len: str = None,
    ):
        # The IP address whitelist in CIDR format. Separate multiple CIDR blocks with commas (,).
        self.cidrs = cidrs
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The source URL. This parameter is required when the source type is RTMP-PULL or SRT-Listener.
        self.input_from_url = input_from_url
        # The source name.
        # 
        # This parameter is required.
        self.input_name = input_name
        # The source type.
        # 
        # Valid values:
        # 
        # *   RTMP-PUSH
        # *   SRT-Caller
        # *   RTMP-PULL
        # *   SRT-Listener
        # *   Flow
        # 
        # This parameter is required.
        self.input_protocol = input_protocol
        # The maximum bitrate. Unit: bit/s.
        self.max_bitrate = max_bitrate
        # The ID of the source flow. This parameter is required when the source type is Flow.
        self.pair_flow_id = pair_flow_id
        # The output of the source flow. This parameter is required when the source type is Flow.
        self.pair_output_name = pair_output_name
        # The latency for the SRT stream. This parameter is required the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. This parameter is required when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. This parameter is required when the source type is SRT-Listener or SRT-Caller.
        # 
        # Valid values:
        # 
        # *   0
        # *   16
        # *   24
        # *   32
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.input_from_url is not None:
            result['InputFromUrl'] = self.input_from_url
        if self.input_name is not None:
            result['InputName'] = self.input_name
        if self.input_protocol is not None:
            result['InputProtocol'] = self.input_protocol
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.pair_flow_id is not None:
            result['PairFlowId'] = self.pair_flow_id
        if self.pair_output_name is not None:
            result['PairOutputName'] = self.pair_output_name
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('InputFromUrl') is not None:
            self.input_from_url = m.get('InputFromUrl')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        if m.get('InputProtocol') is not None:
            self.input_protocol = m.get('InputProtocol')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('PairFlowId') is not None:
            self.pair_flow_id = m.get('PairFlowId')
        if m.get('PairOutputName') is not None:
            self.pair_output_name = m.get('PairOutputName')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class AddMediaConnectFlowInputResponseBodyContent(TeaModel):
    def __init__(
        self,
        input_url: str = None,
    ):
        # The source URL.
        self.input_url = input_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        return self


class AddMediaConnectFlowInputResponseBody(TeaModel):
    def __init__(
        self,
        content: AddMediaConnectFlowInputResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = AddMediaConnectFlowInputResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class AddMediaConnectFlowInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaConnectFlowInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaConnectFlowInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaConnectFlowOutputRequest(TeaModel):
    def __init__(
        self,
        cidrs: str = None,
        flow_id: str = None,
        output_name: str = None,
        output_protocol: str = None,
        output_to_url: str = None,
        pair_flow_id: str = None,
        pair_input_name: str = None,
        player_limit: int = None,
        srt_latency: int = None,
        srt_passphrase: str = None,
        srt_pbkey_len: str = None,
    ):
        # The IP address whitelist in CIDR format. Separate multiple CIDR blocks with commas (,).
        self.cidrs = cidrs
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The output name.
        # 
        # This parameter is required.
        self.output_name = output_name
        # The output type.
        # 
        # Valid values:
        # 
        # *   RTMP-PUSH
        # *   SRT-Caller
        # *   RTMP-PULL
        # *   SRT-Listener
        # *   Flow
        # 
        # This parameter is required.
        self.output_protocol = output_protocol
        # The output URL. This parameter is required when OutputProtocol is set to RTMP-PUSH or SRT-Caller.
        self.output_to_url = output_to_url
        # The ID of the destination flow. This parameter is required when OutputProtocol is set to Flow.
        self.pair_flow_id = pair_flow_id
        # The source name of the destination flow. This parameter is required when OutputProtocol is set to Flow.
        self.pair_input_name = pair_input_name
        # The maximum number of viewers.
        self.player_limit = player_limit
        # The latency for the SRT stream. This parameter is required when the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. This parameter is required when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. This parameter is required when the source type is SRT-Listener or SRT-Caller.
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.output_name is not None:
            result['OutputName'] = self.output_name
        if self.output_protocol is not None:
            result['OutputProtocol'] = self.output_protocol
        if self.output_to_url is not None:
            result['OutputToUrl'] = self.output_to_url
        if self.pair_flow_id is not None:
            result['PairFlowId'] = self.pair_flow_id
        if self.pair_input_name is not None:
            result['PairInputName'] = self.pair_input_name
        if self.player_limit is not None:
            result['PlayerLimit'] = self.player_limit
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('OutputName') is not None:
            self.output_name = m.get('OutputName')
        if m.get('OutputProtocol') is not None:
            self.output_protocol = m.get('OutputProtocol')
        if m.get('OutputToUrl') is not None:
            self.output_to_url = m.get('OutputToUrl')
        if m.get('PairFlowId') is not None:
            self.pair_flow_id = m.get('PairFlowId')
        if m.get('PairInputName') is not None:
            self.pair_input_name = m.get('PairInputName')
        if m.get('PlayerLimit') is not None:
            self.player_limit = m.get('PlayerLimit')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class AddMediaConnectFlowOutputResponseBodyContent(TeaModel):
    def __init__(
        self,
        output_url: str = None,
    ):
        # The output URL.
        self.output_url = output_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        return self


class AddMediaConnectFlowOutputResponseBody(TeaModel):
    def __init__(
        self,
        content: AddMediaConnectFlowOutputResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates that the call is successful.
        self.ret_code = ret_code

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = AddMediaConnectFlowOutputResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class AddMediaConnectFlowOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaConnectFlowOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaConnectFlowOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaMarksRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_marks: str = None,
    ):
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The mark information. The value must be a JSONArray.
        # 
        # This parameter is required.
        self.media_marks = media_marks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_marks is not None:
            result['MediaMarks'] = self.media_marks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarks') is not None:
            self.media_marks = m.get('MediaMarks')
        return self


class AddMediaMarksResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The IDs of the marks that are added.
        self.media_mark_ids = media_mark_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaMarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaMarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaMarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        cover_url: str = None,
        name: str = None,
        preview_media: str = None,
        related_mediaids: str = None,
        source: str = None,
        status: str = None,
        type: str = None,
    ):
        self.config = config
        # The URL of the template thumbnail.
        self.cover_url = cover_url
        # The name of the custom template.
        self.name = name
        # The ID of the template preview video.
        self.preview_media = preview_media
        # The IDs of the materials associated with the template for use by the regular template editor.
        self.related_mediaids = related_mediaids
        # The source from which the template is created. Valid values:
        # 
        # *   OpenAPI
        # *   AliyunConsole
        # *   WebSDK
        # 
        # <!---->
        self.source = source
        # The template state. Valid values:
        # 
        # *   Available: The template is available.
        # *   Created: The template is created but not ready for use.
        # *   Uploading: The video is being uploaded.
        # *   Processing: The advanced template is being processed.
        # *   UploadFailed: Failed to upload the video.
        # *   ProcessFailed: Failed to process the advanced template.
        # 
        # <!---->
        self.status = status
        # The template type. Valid values:
        # 
        # *   Timeline: a regular template created based on the timeline of a video editing project, in which multiple materials are arranged in sequence across multiple layers. It can be used to convert text and images into videos, create photo albums, add opening and closing parts, and apply the default watermark.
        # *   VETemplate: an advanced template created using effects of Adobe After Effects (AE). It can be used to produce complex animations and advanced media effects.
        # 
        # <!---->
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.related_mediaids is not None:
            result['RelatedMediaids'] = self.related_mediaids
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('RelatedMediaids') is not None:
            self.related_mediaids = m.get('RelatedMediaids')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        config: str = None,
        cover_url: str = None,
        create_source: str = None,
        modified_source: str = None,
        name: str = None,
        preview_media: str = None,
        status: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The template configurations.
        self.config = config
        # The URL of the template thumbnail.
        self.cover_url = cover_url
        # The source from which the template was created.
        # 
        # Valid values:
        # 
        # *   AliyunConsole
        # *   WebSDK
        # *   OpenAPI
        self.create_source = create_source
        # The source from which the template was modified.
        # 
        # Valid values:
        # 
        # *   AliyunConsole
        # *   WebSDK
        # *   OpenAPI
        self.modified_source = modified_source
        # The template name.
        self.name = name
        # The ID of the preview video.
        self.preview_media = preview_media
        # The template state.
        # 
        # Valid values:
        # 
        # *   UploadFailed: Failed to upload the video.
        # *   ProcessFailed: Failed to process the advanced template.
        # *   Available: The template is available.
        # *   Uploading: The video is being uploaded.
        # *   Created: The template is created but not ready for use.
        # *   Processing: The advanced template is being processed.
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The template type.
        # 
        # Valid values:
        # 
        # *   Timeline: regular template.
        # *   VETemplate: advanced template.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: AddTemplateResponseBodyTemplate = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The template information.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = AddTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class AddTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AlterSearchIndexRequest(TeaModel):
    def __init__(
        self,
        index_config: str = None,
        index_status: str = None,
        index_type: str = None,
        search_lib_name: str = None,
    ):
        # The configurations of the index.
        # 
        # >  You must specify either IndexStatus or IndexConfig.
        self.index_config = index_config
        # The state of the index. Valid values:
        # 
        # *   active (default): the index is enabled.
        # *   Deactive: the index is not enabled.
        # 
        # >  You must specify either IndexStatus or IndexConfig.
        self.index_status = index_status
        # The category of the index. Valid values:
        # 
        # *   mm: large visual model.
        # *   face: face recognition.
        # *   aiLabel: smart tagging.
        # 
        # This parameter is required.
        self.index_type = index_type
        # The name of the search library.
        # 
        # *   If you leave this parameter empty, the search index is created in the default search library of Intelligent Media Service (IMS). Default value: ims-default-search-lib.
        # *   To query information about an existing search library, call the [QuerySearchLib](https://help.aliyun.com/document_detail/2584455.html) API operation.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_config is not None:
            result['IndexConfig'] = self.index_config
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexConfig') is not None:
            self.index_config = m.get('IndexConfig')
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class AlterSearchIndexResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AlterSearchIndexResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AlterSearchIndexResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AlterSearchIndexResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateVodPackagingAssetRequestAssetsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media file. You can only specify a M3U8 file stored in Object Storage Service (OSS).
        self.media = media
        # The input type. Only OSS is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BatchCreateVodPackagingAssetRequestAssets(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        content_id: str = None,
        input: BatchCreateVodPackagingAssetRequestAssetsInput = None,
    ):
        # The name of the asset. The name must be unique and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.asset_name = asset_name
        # The content ID in the digital rights management (DRM) system. The maximum length is 256 characters. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.content_id = content_id
        # The asset input configurations.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('Input') is not None:
            temp_model = BatchCreateVodPackagingAssetRequestAssetsInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class BatchCreateVodPackagingAssetRequest(TeaModel):
    def __init__(
        self,
        assets: List[BatchCreateVodPackagingAssetRequestAssets] = None,
        group_name: str = None,
    ):
        # The assets that you want to ingest.
        self.assets = assets
        # The name of the packaging group.
        self.group_name = group_name

    def validate(self):
        if self.assets:
            for k in self.assets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Assets'] = []
        if self.assets is not None:
            for k in self.assets:
                result['Assets'].append(k.to_map() if k else None)
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.assets = []
        if m.get('Assets') is not None:
            for k in m.get('Assets'):
                temp_model = BatchCreateVodPackagingAssetRequestAssets()
                self.assets.append(temp_model.from_map(k))
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class BatchCreateVodPackagingAssetShrinkRequest(TeaModel):
    def __init__(
        self,
        assets_shrink: str = None,
        group_name: str = None,
    ):
        # The assets that you want to ingest.
        self.assets_shrink = assets_shrink
        # The name of the packaging group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_shrink is not None:
            result['Assets'] = self.assets_shrink
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assets') is not None:
            self.assets_shrink = m.get('Assets')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class BatchCreateVodPackagingAssetResponseBodyResultList(TeaModel):
    def __init__(
        self,
        asset: VodPackagingAsset = None,
        code: str = None,
        message: str = None,
    ):
        # The information about the ingested asset.
        self.asset = asset
        # The error code for failed ingestion.
        self.code = code
        # The error message for failed ingestion.
        self.message = message

    def validate(self):
        if self.asset:
            self.asset.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset is not None:
            result['Asset'] = self.asset.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asset') is not None:
            temp_model = VodPackagingAsset()
            self.asset = temp_model.from_map(m['Asset'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class BatchCreateVodPackagingAssetResponseBody(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        request_id: str = None,
        result_list: List[BatchCreateVodPackagingAssetResponseBodyResultList] = None,
    ):
        # The name of the packaging group.
        self.group_name = group_name
        # The ID of the request.
        self.request_id = request_id
        # The results of asset ingestion.
        self.result_list = result_list

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = BatchCreateVodPackagingAssetResponseBodyResultList()
                self.result_list.append(temp_model.from_map(k))
        return self


class BatchCreateVodPackagingAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCreateVodPackagingAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateVodPackagingAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetMediaInfosRequest(TeaModel):
    def __init__(
        self,
        addition_type: str = None,
        media_ids: str = None,
    ):
        # The additional information that you want to query about the media assets. By default, only BasicInfo is returned. The following additional information can be queried:
        # 
        # \\- FileInfo
        # 
        # \\- DynamicMetaData
        self.addition_type = addition_type
        # The IDs of the media assets that you want to query. Separate the IDs with commas (,).
        self.media_ids = media_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_type is not None:
            result['AdditionType'] = self.addition_type
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionType') is not None:
            self.addition_type = m.get('AdditionType')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The Object Storage Service (OSS) URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class BatchGetMediaInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo = None,
    ):
        # The basic information of the file, including the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(
        self,
        biz: str = None,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        user_data: str = None,
    ):
        self.biz = biz
        # The business type of the media asset.
        self.business_type = business_type
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The URL of the media asset in another service.
        self.input_url = input_url
        # MediaId
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset. Valid values:
        # 
        # \\- image
        # 
        # \\- video
        # 
        # \\- audio
        # 
        # \\- text
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset. Valid values:
        # 
        # \\- oss
        # 
        # \\- vod
        self.source = source
        # The sprite.
        self.sprite_images = sprite_images
        # The status of the media asset.
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        self.transcode_status = transcode_status
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class BatchGetMediaInfosResponseBodyMediaInfos(TeaModel):
    def __init__(
        self,
        file_info_list: List[BatchGetMediaInfosResponseBodyMediaInfosFileInfoList] = None,
        media_basic_info: BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo = None,
        media_id: str = None,
    ):
        # FileInfos
        self.file_info_list = file_info_list
        # The basic information of the media asset.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = BatchGetMediaInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class BatchGetMediaInfosResponseBody(TeaModel):
    def __init__(
        self,
        media_infos: List[BatchGetMediaInfosResponseBodyMediaInfos] = None,
        request_id: str = None,
    ):
        # The queried media assets.
        self.media_infos = media_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = BatchGetMediaInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchGetMediaInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetMediaInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetMediaInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelDNAJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media fingerprint analysis job that you want to cancel.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CancelDNAJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelDNAJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelDNAJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelDNAJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelFavoritePublicMediaRequest(TeaModel):
    def __init__(
        self,
        media_ids: str = None,
    ):
        self.media_ids = media_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class CancelFavoritePublicMediaResponseBody(TeaModel):
    def __init__(
        self,
        ignored_list: List[str] = None,
        request_id: str = None,
    ):
        self.ignored_list = ignored_list
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelFavoritePublicMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelFavoritePublicMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelFavoritePublicMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAuditRequest(TeaModel):
    def __init__(
        self,
        audit_content: str = None,
    ):
        # The review results. You can specify the results for a maximum of 20 videos at a time. The value must be converted to a string. For more information about the parameters in AuditContent, see the "AuditContent" section of this topic.
        # 
        # This parameter is required.
        self.audit_content = audit_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_content is not None:
            result['AuditContent'] = self.audit_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditContent') is not None:
            self.audit_content = m.get('AuditContent')
        return self


class CreateAuditResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAvatarTrainingJobRequest(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_name: str = None,
        avatar_type: str = None,
        portrait: str = None,
        thumbnail: str = None,
        transparent: bool = None,
        video: str = None,
    ):
        # *   The description of the digital human.
        # *   The description can be up to 1,000 characters in length.
        self.avatar_description = avatar_description
        # *   The name of the digital human.
        # *   The name can be up to seven characters in length.
        # 
        # This parameter is required.
        self.avatar_name = avatar_name
        # The type of the digital human.
        self.avatar_type = avatar_type
        # *   The media asset ID of the portrait image.
        # *   The value must be 32 characters in length.
        self.portrait = portrait
        # *   The thumbnail URL.
        # *   After the digital human is trained, the thumbnail is uploaded to this URL.
        # *   The URL must be a valid public Object Storage Service (OSS) URL.
        # *   The URL can be up to 512 characters in length.
        self.thumbnail = thumbnail
        # *   Specifies whether the training video supports alpha channels.
        # 
        #     **\
        # 
        #     **Note**: Make sure that the current settings are consistent with those of the submitted training video. Otherwise, the digital human may malfunction.
        self.transparent = transparent
        # *   The ID of the video used for training.
        # *   The value must be 32 characters in length.
        # *   Supported formats: MP4, MOV, and WebM.
        # *   The duration of the video must be 5 to 15 minutes.
        # *   The resolution of the video must be 19201080 or 10801920.
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        if self.transparent is not None:
            result['Transparent'] = self.transparent
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        if m.get('Transparent') is not None:
            self.transparent = m.get('Transparent')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class CreateAvatarTrainingJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CreateAvatarTrainingJobResponseBody(TeaModel):
    def __init__(
        self,
        data: CreateAvatarTrainingJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateAvatarTrainingJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateAvatarTrainingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAvatarTrainingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAvatarTrainingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateChannelRequest(TeaModel):
    def __init__(
        self,
        access_policy: bool = None,
        access_token: str = None,
        channel_name: str = None,
        channel_tier: str = None,
        filler_source_location_name: str = None,
        filler_source_name: str = None,
        out_put_config_list: str = None,
        playback_mode: str = None,
    ):
        # Specifies whether to enable access control.
        self.access_policy = access_policy
        # The token for accessing the channel.
        self.access_token = access_token
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The tier of the channel. Valid values: basic and standard.
        # 
        # This parameter is required.
        self.channel_tier = channel_tier
        # The source location of the filler slate.
        self.filler_source_location_name = filler_source_location_name
        # The name of the filler slate.
        self.filler_source_name = filler_source_name
        # The channel output configurations.
        # 
        # This parameter is required.
        self.out_put_config_list = out_put_config_list
        # The playback mode. Valid values: loop and linear.
        # 
        # This parameter is required.
        self.playback_mode = playback_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_policy is not None:
            result['AccessPolicy'] = self.access_policy
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.channel_tier is not None:
            result['ChannelTier'] = self.channel_tier
        if self.filler_source_location_name is not None:
            result['FillerSourceLocationName'] = self.filler_source_location_name
        if self.filler_source_name is not None:
            result['FillerSourceName'] = self.filler_source_name
        if self.out_put_config_list is not None:
            result['OutPutConfigList'] = self.out_put_config_list
        if self.playback_mode is not None:
            result['PlaybackMode'] = self.playback_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessPolicy') is not None:
            self.access_policy = m.get('AccessPolicy')
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ChannelTier') is not None:
            self.channel_tier = m.get('ChannelTier')
        if m.get('FillerSourceLocationName') is not None:
            self.filler_source_location_name = m.get('FillerSourceLocationName')
        if m.get('FillerSourceName') is not None:
            self.filler_source_name = m.get('FillerSourceName')
        if m.get('OutPutConfigList') is not None:
            self.out_put_config_list = m.get('OutPutConfigList')
        if m.get('PlaybackMode') is not None:
            self.playback_mode = m.get('PlaybackMode')
        return self


class CreateChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel: ChannelAssemblyChannel = None,
        request_id: str = None,
    ):
        # The channel information.
        self.channel = channel
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.channel:
            self.channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channel') is not None:
            temp_model = ChannelAssemblyChannel()
            self.channel = temp_model.from_map(m['Channel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        subtype: int = None,
        template_config: str = None,
        type: int = None,
    ):
        # The template name.
        # 
        # This parameter is required.
        self.name = name
        # The template subtype.
        # 
        # Valid values for transcoding templates:
        # 
        # *   1 (Normal): regular template.
        # *   2 (AudioTranscode): audio transcoding template.
        # *   3 (Remux): container format conversion template.
        # *   4 (NarrowBandV1): Narrowband HD 1.0 template.
        # *   5 (NarrowBandV2): Narrowband HD 2.0 template.
        # 
        # Valid values for snapshot templates:
        # 
        # *   1 (Normal): regular template.
        # *   2 (Sprite): sprite template.
        # *   3 (WebVtt): WebVTT template.
        # 
        # Valid values for AI-assisted content moderation templates:
        # 
        # *   1 (Video): video moderation template.
        # *   2 (Audio): audio moderation template.
        # *   3 (Image): image moderation template.
        # 
        # Valid values for AI-assisted intelligent erasure templates.
        # 
        # *   1 (VideoDelogo): logo erasure template.
        # *   2 (VideoDetext): subtitle erasure template.
        self.subtype = subtype
        # The template configurations. For more information, see [Template parameters](https://help.aliyun.com/document_detail/448291.html).
        # 
        # This parameter is required.
        self.template_config = template_config
        # The template type. Valid values:
        # 
        # *   1: transcoding template.
        # *   2: snapshot template.
        # *   3: animated image template.
        # *   4\\. image watermark template.
        # *   5: text watermark template.
        # *   6: subtitle template.
        # *   7: AI-assisted content moderation template.
        # *   8: AI-assisted intelligent thumbnail template.
        # *   9: AI-assisted intelligent erasure template.
        # *   10: AI-assisted media fingerprint analysis template.
        # *   11: AI-assisted smart tagging template.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateCustomTemplateResponseBodyCustomTemplate(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        is_default: bool = None,
        modified_time: str = None,
        status: str = None,
        subtype: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
        type: int = None,
        type_name: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # Indicates whether the template is the default template.
        self.is_default = is_default
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The template state.
        self.status = status
        # The subtype name of the template.
        self.subtype = subtype
        # The template configurations.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type ID of the template.
        self.type = type
        # The type name of the template.
        self.type_name = type_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class CreateCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        custom_template: CreateCustomTemplateResponseBodyCustomTemplate = None,
        request_id: str = None,
    ):
        # The template information.
        self.custom_template = custom_template
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.custom_template:
            self.custom_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            temp_model = CreateCustomTemplateResponseBodyCustomTemplate()
            self.custom_template = temp_model.from_map(m['CustomTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        gender: str = None,
        scenario: str = None,
        voice_desc: str = None,
        voice_id: str = None,
        voice_name: str = None,
    ):
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        # 
        # This parameter is required.
        self.gender = gender
        # The scenario. Valid values:
        # 
        # *   story
        # *   interaction
        # *   navigation
        # 
        # This parameter is required.
        self.scenario = scenario
        # The voice description.
        # 
        # *   The description can be up to 256 characters in length.
        self.voice_desc = voice_desc
        # The voice ID. It can be the English name or Chinese Pinyin of the voice.
        # 
        # *   The value must be a unique ID that is not used by other custom voices.
        # *   The ID can be up to 32 characters in length.
        # *   Only letters and digits are supported.
        # 
        # This parameter is required.
        self.voice_id = voice_id
        # The voice name.
        # 
        # *   The name can be up to 32 characters in length.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.voice_desc is not None:
            result['VoiceDesc'] = self.voice_desc
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('VoiceDesc') is not None:
            self.voice_desc = m.get('VoiceDesc')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class CreateCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        voice_id: str = None,
    ):
        # The ID of the human voice cloning job.
        self.job_id = job_id
        # The voice ID.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class CreateCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: CreateCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDNADBRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        model: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The description of the media fingerprint library.
        self.description = description
        # The model of the media fingerprint library. Valid values:
        # 
        # *   **Video**\
        # *   **Audio**\
        # *   **Image**\
        # *   **Text** (supported only in the China (Shanghai) region)
        self.model = model
        # The name of the media fingerprint library.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateDNADBResponseBodyDBInfo(TeaModel):
    def __init__(
        self,
        dbid: str = None,
        description: str = None,
        model: str = None,
        name: str = None,
        status: str = None,
    ):
        # The ID of the media fingerprint library. We recommend that you save this ID for subsequent calls of other operations.
        self.dbid = dbid
        # The description of the media fingerprint library.
        self.description = description
        # The model of the media fingerprint library.
        self.model = model
        # The name of the media fingerprint library.
        self.name = name
        # The state of the media fingerprint library. After a media fingerprint library is created, it enters the offline state. After the media fingerprint library is processed at the backend, it enters the active state.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.description is not None:
            result['Description'] = self.description
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreateDNADBResponseBody(TeaModel):
    def __init__(
        self,
        dbinfo: CreateDNADBResponseBodyDBInfo = None,
        request_id: str = None,
    ):
        # The details of the media fingerprint library.
        self.dbinfo = dbinfo
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dbinfo:
            self.dbinfo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbinfo is not None:
            result['DBInfo'] = self.dbinfo.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBInfo') is not None:
            temp_model = CreateDNADBResponseBodyDBInfo()
            self.dbinfo = temp_model.from_map(m['DBInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDNADBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDNADBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDNADBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEditingProjectRequest(TeaModel):
    def __init__(
        self,
        business_config: str = None,
        clips_param: str = None,
        cover_url: str = None,
        description: str = None,
        material_maps: str = None,
        project_type: str = None,
        template_id: str = None,
        template_type: str = None,
        timeline: str = None,
        title: str = None,
    ):
        # The business configuration of the project. This parameter can be ignored for general editing projects.
        # 
        # For a live stream editing project, observe the following rules: OutputMediaConfig.StorageLocation is required. OutputMediaConfig.Path is optional. If you do not specify this option, the live streaming clips are stored in the root directory by default.
        # 
        # Valid values of OutputMediaTarget include vod-media and oss-object. If you do not specify OutputMediaTarget, the default value oss-object is used.
        # 
        # If you set OutputMediaTarget to vod-media, the setting of OutputMediaConfig.Path does not take effect.
        self.business_config = business_config
        # The material parameter corresponding to the template, in the JSON format. If TemplateId is specified, ClipsParam must also be specified. For more information<props="china">, see [Create and use a regular template](https://help.aliyun.com/document_detail/328557.html) and [Create and use an advanced template](https://help.aliyun.com/document_detail/291418.html).
        self.clips_param = clips_param
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The description of the online editing project.
        self.description = description
        # The material associated with the project. Separate multiple material IDs with commas (,). Each type supports up to 10 material IDs.
        self.material_maps = material_maps
        # The type of the editing project. Valid values: EditingProject and LiveEditingProject. A value of EditingProject indicates a regular editing project, and a value of LiveEditingProject indicates a live stream editing project.
        self.project_type = project_type
        # The template ID. This parameter is used to quickly build a timeline with ease. Note: Only one of Timeline and TemplateId can be specified. If TemplateId is specified, ClipsParam must also be specified.
        self.template_id = template_id
        # The template type. This parameter is required if you create a template-based online editing project. Default value: Timeline. Valid values:
        # 
        # *   Timeline: a regular template.
        # *   VETemplate: an advanced template.
        self.template_type = template_type
        self.timeline = timeline
        # The title of the online editing project.
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.material_maps is not None:
            result['MaterialMaps'] = self.material_maps
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MaterialMaps') is not None:
            self.material_maps = m.get('MaterialMaps')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateEditingProjectResponseBodyProject(TeaModel):
    def __init__(
        self,
        business_config: str = None,
        business_status: str = None,
        clips_param: str = None,
        cover_url: str = None,
        create_source: str = None,
        create_time: str = None,
        description: str = None,
        duration: float = None,
        modified_source: str = None,
        modified_time: str = None,
        project_id: str = None,
        project_type: str = None,
        status: int = None,
        status_name: str = None,
        template_id: str = None,
        template_type: str = None,
        timeline: str = None,
        title: str = None,
    ):
        # The business configuration of the project. This parameter can be ignored for general editing projects.
        self.business_config = business_config
        # The business status of the project. This parameter can be ignored for general editing projects. Valid values:
        # 
        # *   Reserving
        # *   ReservationCanceled
        # *   BroadCasting
        # *   LoadingFailed
        # *   LiveFinished
        self.business_status = business_status
        # The template material parameters.
        self.clips_param = clips_param
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The method for creating the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        # 
        # \\- LiveEditingOpenAPI
        # 
        # \\- LiveEditingConsole
        self.create_source = create_source
        # The time when the online editing project was created.
        self.create_time = create_time
        # The description of the online editing project.
        self.description = description
        # The duration of the online editing project.
        self.duration = duration
        # The method for editing the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        # 
        # \\- LiveEditingOpenAPI
        # 
        # \\- LiveEditingConsole
        self.modified_source = modified_source
        # The time when the online editing project was last edited.
        self.modified_time = modified_time
        # The ID of the online editing project.
        self.project_id = project_id
        # The type of the editing project. Default value: EditingProject. Valid values:
        # 
        # \\- EditingProject: a regular editing project.
        # 
        # \\- LiveEditingProject: a live stream editing project.
        self.project_type = project_type
        # The status of the online editing project.
        # 
        # Valid values:
        # 
        # \\- 1: Draft
        # 
        # \\- 2: Editing
        # 
        # \\- 3: Producing
        # 
        # \\- 4: Produced
        # 
        # \\- 5: ProduceFailed
        # 
        # \\- 7: Deleted
        self.status = status
        # The status of the online editing project. For more information, see the status list.
        self.status_name = status_name
        # The template ID.
        self.template_id = template_id
        # The template type of the online editing project. Valid values:
        # 
        # \\- Timeline
        # 
        # \\- VETemplate
        self.template_type = template_type
        # The timeline of the online editing project, in the JSON format.<props="china">For more information about objects in a timeline, see [Timeline configurations](https://help.aliyun.com/document_detail/198823.htm?spm=a2c4g.11186623.2.9.90dc653dF67srN#topic-2024662).  If you leave this parameter empty, an empty timeline is created and the duration of the online editing project is zero.
        self.timeline = timeline
        # The title of the online editing project.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.status_name is not None:
            result['StatusName'] = self.status_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusName') is not None:
            self.status_name = m.get('StatusName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateEditingProjectResponseBody(TeaModel):
    def __init__(
        self,
        project: CreateEditingProjectResponseBodyProject = None,
        request_id: str = None,
    ):
        # The information about the online editing project.
        self.project = project
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = CreateEditingProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEditingProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEditingProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHotwordLibraryRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        hotwords: List[Hotword] = None,
        name: str = None,
        usage_scenario: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.hotwords = hotwords
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.usage_scenario = usage_scenario

    def validate(self):
        if self.hotwords:
            for k in self.hotwords:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Hotwords'] = []
        if self.hotwords is not None:
            for k in self.hotwords:
                result['Hotwords'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.usage_scenario is not None:
            result['UsageScenario'] = self.usage_scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hotwords = []
        if m.get('Hotwords') is not None:
            for k in m.get('Hotwords'):
                temp_model = Hotword()
                self.hotwords.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UsageScenario') is not None:
            self.usage_scenario = m.get('UsageScenario')
        return self


class CreateHotwordLibraryShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        hotwords_shrink: str = None,
        name: str = None,
        usage_scenario: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.hotwords_shrink = hotwords_shrink
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.usage_scenario = usage_scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.hotwords_shrink is not None:
            result['Hotwords'] = self.hotwords_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.usage_scenario is not None:
            result['UsageScenario'] = self.usage_scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Hotwords') is not None:
            self.hotwords_shrink = m.get('Hotwords')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UsageScenario') is not None:
            self.usage_scenario = m.get('UsageScenario')
        return self


class CreateHotwordLibraryResponseBody(TeaModel):
    def __init__(
        self,
        hotword_library_id: str = None,
        request_id: str = None,
    ):
        self.hotword_library_id = hotword_library_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateHotwordLibraryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHotwordLibraryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHotwordLibraryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLivePackageChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        client_token: str = None,
        description: str = None,
        group_name: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The channel description. It can be up to 1,000 characters in length.
        self.description = description
        # The channel group name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.group_name = group_name
        # The ingest protocol. Only HLS is supported.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of M3U8 segments. Valid values: 2 to 100.
        # 
        # This parameter is required.
        self.segment_count = segment_count
        # The segment duration. Valid values: 1 to 30.
        # 
        # This parameter is required.
        self.segment_duration = segment_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(TeaModel):
    def __init__(
        self,
        id: str = None,
        password: str = None,
        url: str = None,
        username: str = None,
    ):
        # The ingest endpoint ID.
        self.id = id
        # The password.
        self.password = password
        # The ingest endpoint URL.
        self.url = url
        # The username.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.password is not None:
            result['Password'] = self.password
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class CreateLivePackageChannelResponseBodyLivePackageChannel(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        ingest_endpoints: List[CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints] = None,
        last_modified: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name.
        self.channel_name = channel_name
        # The time when the channel was created. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.create_time = create_time
        # The channel description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The ingest endpoints.
        self.ingest_endpoints = ingest_endpoints
        # The time when the channel was last modified. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.last_modified = last_modified
        # The ingest protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of M3U8 segments.
        self.segment_count = segment_count
        # The segment duration.
        self.segment_duration = segment_duration

    def validate(self):
        if self.ingest_endpoints:
            for k in self.ingest_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        result['IngestEndpoints'] = []
        if self.ingest_endpoints is not None:
            for k in self.ingest_endpoints:
                result['IngestEndpoints'].append(k.to_map() if k else None)
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        self.ingest_endpoints = []
        if m.get('IngestEndpoints') is not None:
            for k in m.get('IngestEndpoints'):
                temp_model = CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints()
                self.ingest_endpoints.append(temp_model.from_map(k))
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class CreateLivePackageChannelResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel: CreateLivePackageChannelResponseBodyLivePackageChannel = None,
        request_id: str = None,
    ):
        # The information about the live package channel.
        self.live_package_channel = live_package_channel
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel:
            self.live_package_channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel is not None:
            result['LivePackageChannel'] = self.live_package_channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannel') is not None:
            temp_model = CreateLivePackageChannelResponseBodyLivePackageChannel()
            self.live_package_channel = temp_model.from_map(m['LivePackageChannel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLivePackageChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLivePackageChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLivePackageChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLivePackageChannelGroupRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        description: str = None,
        group_name: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The channel group description. It can be up to 1,000 characters in length.
        self.description = description
        # The channel group name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        last_modified: str = None,
        origin_domain: str = None,
    ):
        # The time when the channel group was created. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.create_time = create_time
        # The channel group description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The time when the channel group was last modified. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.last_modified = last_modified
        # The origin domain.
        self.origin_domain = origin_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.origin_domain is not None:
            result['OriginDomain'] = self.origin_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OriginDomain') is not None:
            self.origin_domain = m.get('OriginDomain')
        return self


class CreateLivePackageChannelGroupResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel_group: CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup = None,
        request_id: str = None,
    ):
        # The information about the channel group.
        self.live_package_channel_group = live_package_channel_group
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel_group:
            self.live_package_channel_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel_group is not None:
            result['LivePackageChannelGroup'] = self.live_package_channel_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannelGroup') is not None:
            temp_model = CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup()
            self.live_package_channel_group = temp_model.from_map(m['LivePackageChannelGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLivePackageChannelGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLivePackageChannelGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLivePackageChannelGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLivePackageOriginEndpointRequest(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        client_token: str = None,
        description: str = None,
        endpoint_name: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        live_packaging_config: LivePackagingConfig = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code. It can be up to 200 characters in length. You must configure AuthorizationCode, IpWhitelist, or both. Format: [A-Za-z0-9-_.]+\
        self.authorization_code = authorization_code
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The endpoint description.
        self.description = description
        # The origin endpoint name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The IP address blacklist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,).
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,). You must configure AuthorizationCode, IpWhitelist, or both.
        self.ip_whitelist = ip_whitelist
        self.live_packaging_config = live_packaging_config
        # The playlist name. Default value: manifest.
        self.manifest_name = manifest_name
        # The distribution protocol.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30. Default value: 0, which indicates that time shifting is not supported.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        if self.live_packaging_config:
            self.live_packaging_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.live_packaging_config is not None:
            result['LivePackagingConfig'] = self.live_packaging_config.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LivePackagingConfig') is not None:
            temp_model = LivePackagingConfig()
            self.live_packaging_config = temp_model.from_map(m['LivePackagingConfig'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class CreateLivePackageOriginEndpointShrinkRequest(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        client_token: str = None,
        description: str = None,
        endpoint_name: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        live_packaging_config_shrink: str = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code. It can be up to 200 characters in length. You must configure AuthorizationCode, IpWhitelist, or both. Format: [A-Za-z0-9-_.]+\
        self.authorization_code = authorization_code
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The endpoint description.
        self.description = description
        # The origin endpoint name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The IP address blacklist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,).
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,). You must configure AuthorizationCode, IpWhitelist, or both.
        self.ip_whitelist = ip_whitelist
        self.live_packaging_config_shrink = live_packaging_config_shrink
        # The playlist name. Default value: manifest.
        self.manifest_name = manifest_name
        # The distribution protocol.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30. Default value: 0, which indicates that time shifting is not supported.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.live_packaging_config_shrink is not None:
            result['LivePackagingConfig'] = self.live_packaging_config_shrink
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LivePackagingConfig') is not None:
            self.live_packaging_config_shrink = m.get('LivePackagingConfig')
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        endpoint_name: str = None,
        endpoint_url: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        last_modified: str = None,
        live_packaging_config: LivePackagingConfig = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code.
        self.authorization_code = authorization_code
        # The channel name.
        self.channel_name = channel_name
        # The time when the endpoint was created.
        self.create_time = create_time
        # The endpoint description.
        self.description = description
        # The endpoint name.
        self.endpoint_name = endpoint_name
        # The endpoint URL.
        self.endpoint_url = endpoint_url
        # The channel group name.
        self.group_name = group_name
        # The IP address blacklist.
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist.
        self.ip_whitelist = ip_whitelist
        # The time when the endpoint was last modified.
        self.last_modified = last_modified
        self.live_packaging_config = live_packaging_config
        # The playlist name.
        self.manifest_name = manifest_name
        # The protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        if self.live_packaging_config:
            self.live_packaging_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_url is not None:
            result['EndpointUrl'] = self.endpoint_url
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.live_packaging_config is not None:
            result['LivePackagingConfig'] = self.live_packaging_config.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointUrl') is not None:
            self.endpoint_url = m.get('EndpointUrl')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('LivePackagingConfig') is not None:
            temp_model = LivePackagingConfig()
            self.live_packaging_config = temp_model.from_map(m['LivePackagingConfig'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class CreateLivePackageOriginEndpointResponseBody(TeaModel):
    def __init__(
        self,
        live_package_origin_endpoint: CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint = None,
        request_id: str = None,
    ):
        # The information about the origin endpoint.
        self.live_package_origin_endpoint = live_package_origin_endpoint
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_origin_endpoint:
            self.live_package_origin_endpoint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_origin_endpoint is not None:
            result['LivePackageOriginEndpoint'] = self.live_package_origin_endpoint.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageOriginEndpoint') is not None:
            temp_model = CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint()
            self.live_package_origin_endpoint = temp_model.from_map(m['LivePackageOriginEndpoint'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLivePackageOriginEndpointResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLivePackageOriginEndpointResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLivePackageOriginEndpointResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveRecordTemplateRequestRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of the recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.
        # 
        # > 
        # 
        # *   If a live stream is interrupted during a recording cycle but is resumed within 3 minutes, the stream is recorded in the same recording before and after the interruption.
        # 
        # *   If a live stream is interrupted for more than 3 minutes, a new recording is generated. To change the default stream interruption time, submit a ticket.
        self.cycle_duration = cycle_duration
        # The format.
        # 
        # >  If you set this parameter to m3u8, you must also specify the SliceOssObjectPrefix and SliceDuration parameters.
        # 
        # This parameter is required.
        self.format = format
        # The name of the recording file that is stored in Object Storage Service (OSS).
        # 
        # *   The name must be less than 256 bytes in length and can contain the {JobId}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
        # *   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set Format to m3u8.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration
        # The name of the TS segment.
        # 
        # >  This parameter is required only if you set Format to m3u8.
        # 
        # *   By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {JobId}, {UnixTimestamp}, and {Sequence} variables.
        # *   The segment name must contain the {UnixTimestamp} and {Sequence} variables.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class CreateLiveRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        record_format: List[CreateLiveRecordTemplateRequestRecordFormat] = None,
    ):
        # The name of the template.
        # 
        # This parameter is required.
        self.name = name
        # The list of recording formats.
        # 
        # This parameter is required.
        self.record_format = record_format

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = CreateLiveRecordTemplateRequestRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        return self


class CreateLiveRecordTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        record_format_shrink: str = None,
    ):
        # The name of the template.
        # 
        # This parameter is required.
        self.name = name
        # The list of recording formats.
        # 
        # This parameter is required.
        self.record_format_shrink = record_format_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.record_format_shrink is not None:
            result['RecordFormat'] = self.record_format_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecordFormat') is not None:
            self.record_format_shrink = m.get('RecordFormat')
        return self


class CreateLiveRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The template ID.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateLiveRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveSnapshotTemplateRequest(TeaModel):
    def __init__(
        self,
        overwrite_format: str = None,
        sequence_format: str = None,
        template_name: str = None,
        time_interval: int = None,
    ):
        # The naming format of the snapshot captured in overwrite mode.
        # 
        # *   The value cannot start with a forward slash (/). Only the suffix .jpg is supported.
        # *   It cannot exceed 255 characters in length.
        # *   The {JobId} placeholder is supported. It specifies the ID of the snapshot job.
        # *   Placeholders such as {UnixTimestamp}, {Sequence}, and {Date} are not allowed.
        # *   You must specify at least one of the OverwriteFormat and SequenceFormat parameters.
        self.overwrite_format = overwrite_format
        # The naming format of the snapshot captured in time series mode.
        # 
        # *   The value cannot start with a forward slash (/). Only the suffix .jpg is supported.
        # *   It cannot exceed 255 characters in length.
        # *   The {JobId}, {Date}, {UnixTimestamp}, and {Sequence} placeholders are supported. {JobId} specifies the ID of the snapshot job. {Date} specifies the date on which the snapshot is captured. {UnixTimestamp} specifies the timestamp of the snapshot. {Sequence} specifies the sequence number of the snapshot. You must specify at least one of the {UnixTimestamp} and {Sequence} placeholders.
        # *   You must specify at least one of the OverwriteFormat and SequenceFormat parameters.
        self.sequence_format = sequence_format
        # The name of the template.
        # 
        # *   It cannot exceed 128 characters in length.
        # 
        # This parameter is required.
        self.template_name = template_name
        # The interval between two adjacent snapshots. Unit: seconds.
        # 
        # *   Valid values: [5,3600].
        # 
        # This parameter is required.
        self.time_interval = time_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_format is not None:
            result['OverwriteFormat'] = self.overwrite_format
        if self.sequence_format is not None:
            result['SequenceFormat'] = self.sequence_format
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteFormat') is not None:
            self.overwrite_format = m.get('OverwriteFormat')
        if m.get('SequenceFormat') is not None:
            self.sequence_format = m.get('SequenceFormat')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class CreateLiveSnapshotTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The template ID.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateLiveSnapshotTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveSnapshotTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveSnapshotTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        samplerate: str = None,
    ):
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: 1 to 1000.
        self.bitrate = bitrate
        # The number of sound channels. Valid values: 1: mono 2: binaural
        self.channels = channels
        # The audio codec. Valid values:
        # 
        # *   AAC
        # *   MP3
        self.codec = codec
        # The audio codec profile. Valid values when the Codec parameter is set to AAC:
        # 
        # *   aac_low
        # *   aac_he
        # *   aac_he_v2
        # *   aac_ld
        self.profile = profile
        # The audio sampling rate. Valid values: 22050 to 96000.
        # 
        # Note: If you set AudioProfile to aac_ld, the audio sampling rate cannot exceed 44,100.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        profile: str = None,
        width: str = None,
    ):
        # The bitrate of the output video. Unit: Kbit/s. Valid values: 1 to 6000.
        self.bitrate = bitrate
        # The encoding type. Valid values:
        # 
        # *   H.264
        # *   H.265
        self.codec = codec
        # The frame rate of the output video. Unit: frames per second (FPS). Valid values: 1 to 60.
        self.fps = fps
        # The group of pictures (GOP) of the output video. Unit: frame. Valid values: 1 to 3000.
        self.gop = gop
        # The height of the output video. Valid values: Height  128 max (Height,Width)  2560 min (Height,Width)  1440
        # 
        # Note: The resolution of the output video that is transcoded by using the H.265 Narrowband HD transcoding template cannot exceed 1280  720 pixels.
        self.height = height
        # The encoding profile. The profile determines how a video is encoded. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values: 1: baseline. This value is suitable for mobile devices. 2: main. This value is suitable for standard-definition devices. 3: high. This value is suitable for high-definition devices.
        self.profile = profile
        # The width of the output video. Valid values: Width  128 max (Height,Width)  2560 min (Height,Width)  1440
        # 
        # Note: The resolution of the output video that is transcoded by using the H.265 Narrowband HD transcoding template cannot exceed 1280  720 pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CreateLiveTranscodeTemplateRequestTemplateConfig(TeaModel):
    def __init__(
        self,
        audio_params: CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams = None,
        video_params: CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams = None,
    ):
        # The audio parameters.
        self.audio_params = audio_params
        # The video parameters.
        self.video_params = video_params

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class CreateLiveTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_config: CreateLiveTranscodeTemplateRequestTemplateConfig = None,
        type: str = None,
    ):
        # The name of the template.
        # 
        # This parameter is required.
        self.name = name
        # The configuration of the template.
        self.template_config = template_config
        # The type of the template. Valid values:
        # 
        # *   normal
        # *   narrow-band
        # *   audio-only
        # *   origin
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = CreateLiveTranscodeTemplateRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateLiveTranscodeTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_config_shrink: str = None,
        type: str = None,
    ):
        # The name of the template.
        # 
        # This parameter is required.
        self.name = name
        # The configuration of the template.
        self.template_config_shrink = template_config_shrink
        # The type of the template. Valid values:
        # 
        # *   normal
        # *   narrow-band
        # *   audio-only
        # *   origin
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateLiveTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMediaConnectFlowRequest(TeaModel):
    def __init__(
        self,
        flow_name: str = None,
        flow_region: str = None,
    ):
        # The flow name.
        # 
        # This parameter is required.
        self.flow_name = flow_name
        # The region in which the flow resides.
        # 
        # This parameter is required.
        self.flow_region = flow_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_name is not None:
            result['FlowName'] = self.flow_name
        if self.flow_region is not None:
            result['FlowRegion'] = self.flow_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowName') is not None:
            self.flow_name = m.get('FlowName')
        if m.get('FlowRegion') is not None:
            self.flow_region = m.get('FlowRegion')
        return self


class CreateMediaConnectFlowResponseBodyContent(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
    ):
        # The flow ID.
        self.flow_id = flow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        return self


class CreateMediaConnectFlowResponseBody(TeaModel):
    def __init__(
        self,
        content: CreateMediaConnectFlowResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The returned message.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = CreateMediaConnectFlowResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class CreateMediaConnectFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMediaConnectFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMediaConnectFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        profile: str = None,
        sample_rate: int = None,
    ):
        # The audio bitrate. Unit: bit/s. Valid values: 8000 to 1000000. The value must be divisible by 1000.
        self.bitrate = bitrate
        # The audio codec profile. When AudioCodec is set to aac, AAC-LOW and AAC-MAIN are supported. When AudioCodec is set to libfdk_aac, AAC-LOW, AAC-HE, and AAC-HEV2 are supported.
        self.profile = profile
        # The audio sample rate. Unit: Hz. Valid values: 22050, 32000, 44100, 48000, and 96000.
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        return self


class CreateMediaLiveChannelRequestAudioSettings(TeaModel):
    def __init__(
        self,
        audio_codec: str = None,
        audio_codec_setting: CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting = None,
        audio_selector_name: str = None,
        language_code: str = None,
        language_name: str = None,
        name: str = None,
    ):
        # The audio codec. If it is not specified, the source specification is used. Valid values: aac and libfdk_aac.
        self.audio_codec = audio_codec
        # The audio encoding settings.
        self.audio_codec_setting = audio_codec_setting
        # The name of the audio selector.
        self.audio_selector_name = audio_selector_name
        # Enter a three-letter ISO 639-2 language code. If the audio track selected by the audio selector has a language code, the language code specified in the audio selector is used. If the selected audio track does not have a language code, or if the audio selector cannot find a track that matches its criteria, this language code is used.
        self.language_code = language_code
        # The tag that identifies the language of the RTMP input. It can be referenced by the output. The maximum length is 32 characters. Supported characters:
        # 
        # *   Unicode letters
        # *   Digits (0-9)
        # *   Underscore (_)
        # *   Hyphen (-)
        # *   Space (a space cannot be at the beginning or end)
        self.language_name = language_name
        # The name of the audio settings. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_codec_setting:
            self.audio_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_codec_setting is not None:
            result['AudioCodecSetting'] = self.audio_codec_setting.to_map()
        if self.audio_selector_name is not None:
            result['AudioSelectorName'] = self.audio_selector_name
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioCodecSetting') is not None:
            temp_model = CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting()
            self.audio_codec_setting = temp_model.from_map(m['AudioCodecSetting'])
        if m.get('AudioSelectorName') is not None:
            self.audio_selector_name = m.get('AudioSelectorName')
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection(TeaModel):
    def __init__(
        self,
        language_code: str = None,
    ):
        # Enter a three-letter ISO 639-2 language code from within an audio source.
        # 
        # This parameter is required.
        self.language_code = language_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        return self


class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection(TeaModel):
    def __init__(
        self,
        pid: int = None,
    ):
        # Enter a specific PID from within a source.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection(TeaModel):
    def __init__(
        self,
        track_id: int = None,
    ):
        # Specify one or more audio tracks from within a source using Track ID.
        # 
        # This parameter is required.
        self.track_id = track_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.track_id is not None:
            result['TrackId'] = self.track_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TrackId') is not None:
            self.track_id = m.get('TrackId')
        return self


class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors(TeaModel):
    def __init__(
        self,
        audio_language_selection: CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection = None,
        audio_pid_selection: CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection = None,
        audio_track_selection: List[CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection] = None,
        name: str = None,
    ):
        # The audio language selection.
        self.audio_language_selection = audio_language_selection
        # The audio PID selection.
        self.audio_pid_selection = audio_pid_selection
        # The audio track selection.
        self.audio_track_selection = audio_track_selection
        # The name of the audio selector. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_language_selection:
            self.audio_language_selection.validate()
        if self.audio_pid_selection:
            self.audio_pid_selection.validate()
        if self.audio_track_selection:
            for k in self.audio_track_selection:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_language_selection is not None:
            result['AudioLanguageSelection'] = self.audio_language_selection.to_map()
        if self.audio_pid_selection is not None:
            result['AudioPidSelection'] = self.audio_pid_selection.to_map()
        result['AudioTrackSelection'] = []
        if self.audio_track_selection is not None:
            for k in self.audio_track_selection:
                result['AudioTrackSelection'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLanguageSelection') is not None:
            temp_model = CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection()
            self.audio_language_selection = temp_model.from_map(m['AudioLanguageSelection'])
        if m.get('AudioPidSelection') is not None:
            temp_model = CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection()
            self.audio_pid_selection = temp_model.from_map(m['AudioPidSelection'])
        self.audio_track_selection = []
        if m.get('AudioTrackSelection') is not None:
            for k in m.get('AudioTrackSelection'):
                temp_model = CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection()
                self.audio_track_selection.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateMediaLiveChannelRequestInputAttachments(TeaModel):
    def __init__(
        self,
        audio_selectors: List[CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors] = None,
        input_id: str = None,
        language_name: str = None,
    ):
        # The audio selectors.
        self.audio_selectors = audio_selectors
        # The ID of the associated input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The tag that identifies the language of the RTMP input. It can be referenced by the output. The maximum length is 32 characters. Supported characters:
        # 
        # *   Unicode letters
        # *   Digits (0-9)
        # *   Underscore (_)
        # *   Hyphen (-)
        # *   Space (a space cannot be at the beginning or end)
        self.language_name = language_name

    def validate(self):
        if self.audio_selectors:
            for k in self.audio_selectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSelectors'] = []
        if self.audio_selectors is not None:
            for k in self.audio_selectors:
                result['AudioSelectors'].append(k.to_map() if k else None)
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_selectors = []
        if m.get('AudioSelectors') is not None:
            for k in m.get('AudioSelectors'):
                temp_model = CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors()
                self.audio_selectors.append(temp_model.from_map(k))
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        return self


class CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # ChannelName in MediaPackage.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # GroupName in MediaPackage.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting(TeaModel):
    def __init__(
        self,
        audio_group_id: str = None,
        name_modifier: str = None,
    ):
        # The manifest audio group ID. To associate several audio tracks into one group, assign the same audio group ID. Viewers can select a track as needed. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 40 characters in length.
        self.audio_group_id = audio_group_id
        # The manifest name modifier. The child manifests include this modifier in their M3U8 file names. Letters, digits, hyphens (-), and underscores (_) are supported. The maximum length is 40 characters.
        self.name_modifier = name_modifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_group_id is not None:
            result['AudioGroupId'] = self.audio_group_id
        if self.name_modifier is not None:
            result['NameModifier'] = self.name_modifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioGroupId') is not None:
            self.audio_group_id = m.get('AudioGroupId')
        if m.get('NameModifier') is not None:
            self.name_modifier = m.get('NameModifier')
        return self


class CreateMediaLiveChannelRequestOutputGroupsOutputs(TeaModel):
    def __init__(
        self,
        audio_setting_names: List[str] = None,
        media_package_output_setting: CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting = None,
        media_type: int = None,
        name: str = None,
        video_setting_name: str = None,
    ):
        # The referenced AudioSettings.
        self.audio_setting_names = audio_setting_names
        # The settings of the output delivered to MediaPackage.
        self.media_package_output_setting = media_package_output_setting
        # The media type of the output. Valid values:
        # 
        # *   0: Audio and Video.
        # *   1: Audio. If you set the value to 1, you cannot reference VideoSettings.
        # *   2: Video. If you set the value to 2, you cannot reference AudioSettings.
        self.media_type = media_type
        # The name of the output. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The name of the referenced VideoSettings.
        self.video_setting_name = video_setting_name

    def validate(self):
        if self.media_package_output_setting:
            self.media_package_output_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_setting_names is not None:
            result['AudioSettingNames'] = self.audio_setting_names
        if self.media_package_output_setting is not None:
            result['MediaPackageOutputSetting'] = self.media_package_output_setting.to_map()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.video_setting_name is not None:
            result['VideoSettingName'] = self.video_setting_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettingNames') is not None:
            self.audio_setting_names = m.get('AudioSettingNames')
        if m.get('MediaPackageOutputSetting') is not None:
            temp_model = CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting()
            self.media_package_output_setting = temp_model.from_map(m['MediaPackageOutputSetting'])
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoSettingName') is not None:
            self.video_setting_name = m.get('VideoSettingName')
        return self


class CreateMediaLiveChannelRequestOutputGroups(TeaModel):
    def __init__(
        self,
        media_package_group_setting: CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting = None,
        name: str = None,
        outputs: List[CreateMediaLiveChannelRequestOutputGroupsOutputs] = None,
        type: str = None,
    ):
        # The MediaPackage destination.
        self.media_package_group_setting = media_package_group_setting
        # The name of the output group. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The outputs in the output group.
        # 
        # This parameter is required.
        self.outputs = outputs
        # The output group type. Only MediaPackage is supported.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.media_package_group_setting:
            self.media_package_group_setting.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_package_group_setting is not None:
            result['MediaPackageGroupSetting'] = self.media_package_group_setting.to_map()
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaPackageGroupSetting') is not None:
            temp_model = CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting()
            self.media_package_group_setting = temp_model.from_map(m['MediaPackageGroupSetting'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = CreateMediaLiveChannelRequestOutputGroupsOutputs()
                self.outputs.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail(TeaModel):
    def __init__(
        self,
        level: str = None,
        profile: str = None,
    ):
        # The video encoding level. It is not supported yet.
        self.level = level
        # The H.264 profile. Valid values: BASELINE, HIGH, and MAIN. Default value: MAIN. The parameter takes effect only when the codec is H.264.
        self.profile = profile

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.profile is not None:
            result['Profile'] = self.profile
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        return self


class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate(TeaModel):
    def __init__(
        self,
        framerate_control: str = None,
        framerate_denominator: int = None,
        framerate_numerator: int = None,
    ):
        # The frame rate mode. Valid values: SPECIFIED (fixed frame rate) and FROM_SOURCE (use source specification).
        self.framerate_control = framerate_control
        # The denominator of the fixed frame rate. The parameter is required when FramerateControl is set to SPECIFIED. Valid values: 1 to 60. The numerator must be divisible by the denominator.
        self.framerate_denominator = framerate_denominator
        # The numerator of the fixed frame rate. The parameter is required when FramerateControl is set to SPECIFIED. Valid values: 1 to 60. The numerator must be divisible by the denominator.
        self.framerate_numerator = framerate_numerator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.framerate_control is not None:
            result['FramerateControl'] = self.framerate_control
        if self.framerate_denominator is not None:
            result['FramerateDenominator'] = self.framerate_denominator
        if self.framerate_numerator is not None:
            result['FramerateNumerator'] = self.framerate_numerator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FramerateControl') is not None:
            self.framerate_control = m.get('FramerateControl')
        if m.get('FramerateDenominator') is not None:
            self.framerate_denominator = m.get('FramerateDenominator')
        if m.get('FramerateNumerator') is not None:
            self.framerate_numerator = m.get('FramerateNumerator')
        return self


class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop(TeaModel):
    def __init__(
        self,
        bframes_num: int = None,
        gop_size: int = None,
        gop_size_units: str = None,
    ):
        # The number of B frames. Valid values: 1 to 3.
        self.bframes_num = bframes_num
        # The GOP size. When GopSizeUnits is set to SECONDS, the value range is from 1 to 20. When GopSizeUnits is set to FRAMES, the value range is from 1 to 3000.
        self.gop_size = gop_size
        # The GOP size unit. Valid values: FRAMES and SECONDS.
        self.gop_size_units = gop_size_units

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bframes_num is not None:
            result['BframesNum'] = self.bframes_num
        if self.gop_size is not None:
            result['GopSize'] = self.gop_size
        if self.gop_size_units is not None:
            result['GopSizeUnits'] = self.gop_size_units
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BframesNum') is not None:
            self.bframes_num = m.get('BframesNum')
        if m.get('GopSize') is not None:
            self.gop_size = m.get('GopSize')
        if m.get('GopSizeUnits') is not None:
            self.gop_size_units = m.get('GopSizeUnits')
        return self


class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        buffer_size: int = None,
        max_bitrate: int = None,
        rate_control_mode: str = None,
    ):
        # The video bitrate. Unit: bit/s. If you set it to 0 or leave it empty, the source specification is used. Valid values: 50000 to 6000000. The value must be divisible by 1000.
        self.bitrate = bitrate
        # The video buffer size. Unit: bit/s. Valid values: 100000 to 6000000. The value must be divisible by 1000.
        self.buffer_size = buffer_size
        # The maximum bitrate. Unit: bit/s. Valid values: 100000 to 6000000. The value must be divisible by 1000.
        self.max_bitrate = max_bitrate
        # The bitrate control mode. Valid values: CBR, ABR, and VBR.
        self.rate_control_mode = rate_control_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.buffer_size is not None:
            result['BufferSize'] = self.buffer_size
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.rate_control_mode is not None:
            result['RateControlMode'] = self.rate_control_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BufferSize') is not None:
            self.buffer_size = m.get('BufferSize')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('RateControlMode') is not None:
            self.rate_control_mode = m.get('RateControlMode')
        return self


class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting(TeaModel):
    def __init__(
        self,
        codec_detail: CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail = None,
        framerate: CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate = None,
        gop: CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop = None,
        rate: CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate = None,
    ):
        # The video encoding settings.
        self.codec_detail = codec_detail
        # The frame rate. If it is not specified, the source specification is used.
        self.framerate = framerate
        # The GOP setting. If it is not specified, the source specification is used.
        self.gop = gop
        # The video encoding rate. If it is not specified, the source specification is used.
        self.rate = rate

    def validate(self):
        if self.codec_detail:
            self.codec_detail.validate()
        if self.framerate:
            self.framerate.validate()
        if self.gop:
            self.gop.validate()
        if self.rate:
            self.rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_detail is not None:
            result['CodecDetail'] = self.codec_detail.to_map()
        if self.framerate is not None:
            result['Framerate'] = self.framerate.to_map()
        if self.gop is not None:
            result['Gop'] = self.gop.to_map()
        if self.rate is not None:
            result['Rate'] = self.rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecDetail') is not None:
            temp_model = CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail()
            self.codec_detail = temp_model.from_map(m['CodecDetail'])
        if m.get('Framerate') is not None:
            temp_model = CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate()
            self.framerate = temp_model.from_map(m['Framerate'])
        if m.get('Gop') is not None:
            temp_model = CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop()
            self.gop = temp_model.from_map(m['Gop'])
        if m.get('Rate') is not None:
            temp_model = CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate()
            self.rate = temp_model.from_map(m['Rate'])
        return self


class CreateMediaLiveChannelRequestVideoSettings(TeaModel):
    def __init__(
        self,
        height: int = None,
        name: str = None,
        video_codec: str = None,
        video_codec_setting: CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting = None,
        video_codec_type: str = None,
        width: int = None,
    ):
        # The height of the output. Valid values: 0 to 2000. If you set it to 0 or leave it empty, the height automatically adapts to the specified width to maintain the original aspect ratio.
        self.height = height
        # The name of the video settings. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The video codec. Valid values: H264 and H265.
        self.video_codec = video_codec
        # The video encoding settings.
        self.video_codec_setting = video_codec_setting
        self.video_codec_type = video_codec_type
        # The width of the output. Valid values: 0 to 2000. If you set it to 0 or leave it empty, the width automatically adapts to the specified height to maintain the original aspect ratio.
        self.width = width

    def validate(self):
        if self.video_codec_setting:
            self.video_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_codec_setting is not None:
            result['VideoCodecSetting'] = self.video_codec_setting.to_map()
        if self.video_codec_type is not None:
            result['VideoCodecType'] = self.video_codec_type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoCodecSetting') is not None:
            temp_model = CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting()
            self.video_codec_setting = temp_model.from_map(m['VideoCodecSetting'])
        if m.get('VideoCodecType') is not None:
            self.video_codec_type = m.get('VideoCodecType')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CreateMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        audio_settings: List[CreateMediaLiveChannelRequestAudioSettings] = None,
        input_attachments: List[CreateMediaLiveChannelRequestInputAttachments] = None,
        name: str = None,
        output_groups: List[CreateMediaLiveChannelRequestOutputGroups] = None,
        video_settings: List[CreateMediaLiveChannelRequestVideoSettings] = None,
    ):
        # The audio settings.
        self.audio_settings = audio_settings
        # The associated inputs.
        # 
        # This parameter is required.
        self.input_attachments = input_attachments
        # The name of the channel. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The output groups.
        # 
        # This parameter is required.
        self.output_groups = output_groups
        # The video settings.
        self.video_settings = video_settings

    def validate(self):
        if self.audio_settings:
            for k in self.audio_settings:
                if k:
                    k.validate()
        if self.input_attachments:
            for k in self.input_attachments:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.video_settings:
            for k in self.video_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSettings'] = []
        if self.audio_settings is not None:
            for k in self.audio_settings:
                result['AudioSettings'].append(k.to_map() if k else None)
        result['InputAttachments'] = []
        if self.input_attachments is not None:
            for k in self.input_attachments:
                result['InputAttachments'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        result['VideoSettings'] = []
        if self.video_settings is not None:
            for k in self.video_settings:
                result['VideoSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_settings = []
        if m.get('AudioSettings') is not None:
            for k in m.get('AudioSettings'):
                temp_model = CreateMediaLiveChannelRequestAudioSettings()
                self.audio_settings.append(temp_model.from_map(k))
        self.input_attachments = []
        if m.get('InputAttachments') is not None:
            for k in m.get('InputAttachments'):
                temp_model = CreateMediaLiveChannelRequestInputAttachments()
                self.input_attachments.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = CreateMediaLiveChannelRequestOutputGroups()
                self.output_groups.append(temp_model.from_map(k))
        self.video_settings = []
        if m.get('VideoSettings') is not None:
            for k in m.get('VideoSettings'):
                temp_model = CreateMediaLiveChannelRequestVideoSettings()
                self.video_settings.append(temp_model.from_map(k))
        return self


class CreateMediaLiveChannelShrinkRequest(TeaModel):
    def __init__(
        self,
        audio_settings_shrink: str = None,
        input_attachments_shrink: str = None,
        name: str = None,
        output_groups_shrink: str = None,
        video_settings_shrink: str = None,
    ):
        # The audio settings.
        self.audio_settings_shrink = audio_settings_shrink
        # The associated inputs.
        # 
        # This parameter is required.
        self.input_attachments_shrink = input_attachments_shrink
        # The name of the channel. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The output groups.
        # 
        # This parameter is required.
        self.output_groups_shrink = output_groups_shrink
        # The video settings.
        self.video_settings_shrink = video_settings_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_settings_shrink is not None:
            result['AudioSettings'] = self.audio_settings_shrink
        if self.input_attachments_shrink is not None:
            result['InputAttachments'] = self.input_attachments_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_groups_shrink is not None:
            result['OutputGroups'] = self.output_groups_shrink
        if self.video_settings_shrink is not None:
            result['VideoSettings'] = self.video_settings_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettings') is not None:
            self.audio_settings_shrink = m.get('AudioSettings')
        if m.get('InputAttachments') is not None:
            self.input_attachments_shrink = m.get('InputAttachments')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputGroups') is not None:
            self.output_groups_shrink = m.get('OutputGroups')
        if m.get('VideoSettings') is not None:
            self.video_settings_shrink = m.get('VideoSettings')
        return self


class CreateMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        request_id: str = None,
    ):
        # The ID of the channel.
        self.channel_id = channel_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMediaLiveInputRequestInputSettings(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        flow_output_name: str = None,
        source_url: str = None,
        stream_name: str = None,
    ):
        self.flow_id = flow_id
        self.flow_output_name = flow_output_name
        # The source URL where the stream is pulled from. This parameter is required for PULL inputs.
        self.source_url = source_url
        # The name of the pushed stream. This parameter is required for PUSH inputs. It can be up to 255 characters in length.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_output_name is not None:
            result['FlowOutputName'] = self.flow_output_name
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowOutputName') is not None:
            self.flow_output_name = m.get('FlowOutputName')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class CreateMediaLiveInputRequest(TeaModel):
    def __init__(
        self,
        input_settings: List[CreateMediaLiveInputRequestInputSettings] = None,
        name: str = None,
        security_group_ids: List[str] = None,
        type: str = None,
    ):
        # The input settings. An input can have up to two sources: primary and backup sources.
        # 
        # This parameter is required.
        self.input_settings = input_settings
        # The name of the input. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The IDs of the security groups to be associated with the input. This parameter is required for PUSH inputs.
        self.security_group_ids = security_group_ids
        # The input type. Valid values: RTMP_PUSH, RTMP_PULL, SRT_PUSH, and SRT_PULL.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.input_settings:
            for k in self.input_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InputSettings'] = []
        if self.input_settings is not None:
            for k in self.input_settings:
                result['InputSettings'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.input_settings = []
        if m.get('InputSettings') is not None:
            for k in m.get('InputSettings'):
                temp_model = CreateMediaLiveInputRequestInputSettings()
                self.input_settings.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMediaLiveInputShrinkRequest(TeaModel):
    def __init__(
        self,
        input_settings_shrink: str = None,
        name: str = None,
        security_group_ids_shrink: str = None,
        type: str = None,
    ):
        # The input settings. An input can have up to two sources: primary and backup sources.
        # 
        # This parameter is required.
        self.input_settings_shrink = input_settings_shrink
        # The name of the input. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The IDs of the security groups to be associated with the input. This parameter is required for PUSH inputs.
        self.security_group_ids_shrink = security_group_ids_shrink
        # The input type. Valid values: RTMP_PUSH, RTMP_PULL, SRT_PUSH, and SRT_PULL.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_settings_shrink is not None:
            result['InputSettings'] = self.input_settings_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids_shrink is not None:
            result['SecurityGroupIds'] = self.security_group_ids_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputSettings') is not None:
            self.input_settings_shrink = m.get('InputSettings')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids_shrink = m.get('SecurityGroupIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMediaLiveInputResponseBody(TeaModel):
    def __init__(
        self,
        input_id: str = None,
        request_id: str = None,
    ):
        # The ID of the input.
        self.input_id = input_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateMediaLiveInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMediaLiveInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMediaLiveInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMediaLiveInputSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        whitelist_rules: List[str] = None,
    ):
        # The name of the security group. Letters, digits, hyphens (-), and underscores (_) are supported. The maximum length is 64 characters.
        # 
        # This parameter is required.
        self.name = name
        # The security group rules.
        # 
        # This parameter is required.
        self.whitelist_rules = whitelist_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.whitelist_rules is not None:
            result['WhitelistRules'] = self.whitelist_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules = m.get('WhitelistRules')
        return self


class CreateMediaLiveInputSecurityGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        whitelist_rules_shrink: str = None,
    ):
        # The name of the security group. Letters, digits, hyphens (-), and underscores (_) are supported. The maximum length is 64 characters.
        # 
        # This parameter is required.
        self.name = name
        # The security group rules.
        # 
        # This parameter is required.
        self.whitelist_rules_shrink = whitelist_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.whitelist_rules_shrink is not None:
            result['WhitelistRules'] = self.whitelist_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules_shrink = m.get('WhitelistRules')
        return self


class CreateMediaLiveInputSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_group_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the security group.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class CreateMediaLiveInputSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMediaLiveInputSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMediaLiveInputSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePipelineRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        priority: int = None,
        speed: str = None,
    ):
        # The name of the MPS queue.
        # 
        # This parameter is required.
        self.name = name
        # The priority. Default value: 6. Valid values: 1 to 10. A greater value specifies a higher priority.
        self.priority = priority
        # The type of the MPS queue. Valid values:
        # 
        # 1.  Standard: standard MPS queue.
        # 2.  Boost: MPS queue with transcoding speed boosted.
        # 3.  NarrowBandHDV2: MPS queue that supports Narrowband HD 2.0.
        # 
        # This parameter is required.
        self.speed = speed

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        return self


class CreatePipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modified_time: str = None,
        name: str = None,
        pipeline_id: str = None,
        priority: int = None,
        speed: str = None,
        status: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The name of the MPS queue.
        self.name = name
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The priority of the MPS queue.
        self.priority = priority
        # The type of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Boost: MPS queue with transcoding speed boosted.
        # *   Standard: standard MPS queue.
        # *   NarrowBandHDV2: MPS queue that supports Narrowband HD 2.0.
        self.speed = speed
        # The state of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Active
        # *   Paused
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: CreatePipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The information about the MPS queue.
        self.pipeline = pipeline
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = CreatePipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProgramRequest(TeaModel):
    def __init__(
        self,
        ad_breaks: str = None,
        channel_name: str = None,
        clip_range: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        transition: str = None,
    ):
        # The information about ad breaks.
        self.ad_breaks = ad_breaks
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # Extracts a clip from the source.
        self.clip_range = clip_range
        # The name of the program.
        # 
        # This parameter is required.
        self.program_name = program_name
        # The source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name
        # The name of the source.
        # 
        # This parameter is required.
        self.source_name = source_name
        # The source type of the program.
        # 
        # This parameter is required.
        self.source_type = source_type
        # The program transition method.
        # 
        # This parameter is required.
        self.transition = transition

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_breaks is not None:
            result['AdBreaks'] = self.ad_breaks
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.clip_range is not None:
            result['ClipRange'] = self.clip_range
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.transition is not None:
            result['Transition'] = self.transition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdBreaks') is not None:
            self.ad_breaks = m.get('AdBreaks')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClipRange') is not None:
            self.clip_range = m.get('ClipRange')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Transition') is not None:
            self.transition = m.get('Transition')
        return self


class CreateProgramResponseBody(TeaModel):
    def __init__(
        self,
        program: ChannelAssemblyProgram = None,
        request_id: str = None,
    ):
        # The information about the program.
        self.program = program
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.program:
            self.program.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program is not None:
            result['Program'] = self.program.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Program') is not None:
            temp_model = ChannelAssemblyProgram()
            self.program = temp_model.from_map(m['Program'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRecognitionEntityRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        entity_info: str = None,
        entity_name: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.entity_info = entity_info
        # This parameter is required.
        self.entity_name = entity_name
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.entity_info is not None:
            result['EntityInfo'] = self.entity_info
        if self.entity_name is not None:
            result['EntityName'] = self.entity_name
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('EntityInfo') is not None:
            self.entity_info = m.get('EntityInfo')
        if m.get('EntityName') is not None:
            self.entity_name = m.get('EntityName')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateRecognitionEntityResponseBody(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        request_id: str = None,
    ):
        self.entity_id = entity_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRecognitionEntityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRecognitionEntityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRecognitionEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRecognitionLibRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        lib_description: str = None,
        lib_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.lib_description = lib_description
        # This parameter is required.
        self.lib_name = lib_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.lib_description is not None:
            result['LibDescription'] = self.lib_description
        if self.lib_name is not None:
            result['LibName'] = self.lib_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('LibDescription') is not None:
            self.lib_description = m.get('LibDescription')
        if m.get('LibName') is not None:
            self.lib_name = m.get('LibName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateRecognitionLibResponseBody(TeaModel):
    def __init__(
        self,
        lib_id: str = None,
        request_id: str = None,
    ):
        self.lib_id = lib_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRecognitionLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRecognitionLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRecognitionLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRecognitionSampleRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        entity_id: str = None,
        image_url: str = None,
        label_prompt: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.entity_id = entity_id
        self.image_url = image_url
        self.label_prompt = label_prompt
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.label_prompt is not None:
            result['LabelPrompt'] = self.label_prompt
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LabelPrompt') is not None:
            self.label_prompt = m.get('LabelPrompt')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateRecognitionSampleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sample_id: str = None,
    ):
        self.request_id = request_id
        self.sample_id = sample_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sample_id is not None:
            result['SampleId'] = self.sample_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SampleId') is not None:
            self.sample_id = m.get('SampleId')
        return self


class CreateRecognitionSampleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRecognitionSampleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRecognitionSampleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSearchIndexRequest(TeaModel):
    def __init__(
        self,
        index_config: str = None,
        index_status: str = None,
        index_type: str = None,
        search_lib_name: str = None,
    ):
        self.index_config = index_config
        self.index_status = index_status
        # The category of the index. Valid values:
        # 
        # *   mm: large visual model. You can use this model to describe complex visual features and identify and search for specific actions, movements, and events in videos, such as when athletes score a goal or get injured.
        # 
        # >  This feature is in the public preview phase. You can use this feature for free for 1,000 hours of videos.
        # 
        # *   face: face recognition. You can use the face recognition technology to describe face characteristics and automatically mark or search for faces in videos.
        # *   aiLabel: smart tagging. The smart tagging category is used to describe content such as subtitles and audio in videos. You can use the speech recognition technology to automatically extract, mark, and search for subtitles and dialog content from videos. This helps you quickly locate the video content that is related to specific topics or keywords.
        # 
        # This parameter is required.
        self.index_type = index_type
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_config is not None:
            result['IndexConfig'] = self.index_config
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexConfig') is not None:
            self.index_config = m.get('IndexConfig')
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class CreateSearchIndexResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSearchIndexResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSearchIndexResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSearchIndexResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSearchLibRequest(TeaModel):
    def __init__(
        self,
        search_lib_name: str = None,
    ):
        # The name of the search library. The name can contain letters and digits and must start with a letter.
        # 
        # This parameter is required.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class CreateSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        search_lib_name: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the request.
        self.request_id = request_id
        # The name of the search library.
        self.search_lib_name = search_lib_name
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSourceRequest(TeaModel):
    def __init__(
        self,
        http_package_configurations: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        # The source configurations.
        # 
        # This parameter is required.
        self.http_package_configurations = http_package_configurations
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name
        # The name of the source.
        # 
        # This parameter is required.
        self.source_name = source_name
        # The source type. Valid values: vodSource and liveSource.
        # 
        # This parameter is required.
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_package_configurations is not None:
            result['HttpPackageConfigurations'] = self.http_package_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpPackageConfigurations') is not None:
            self.http_package_configurations = m.get('HttpPackageConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class CreateSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source: ChannelAssemblySource = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source information.
        self.source = source

    def validate(self):
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            temp_model = ChannelAssemblySource()
            self.source = temp_model.from_map(m['Source'])
        return self


class CreateSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSourceLocationRequest(TeaModel):
    def __init__(
        self,
        base_url: str = None,
        enable_segment_delivery: bool = None,
        segment_delivery_url: str = None,
        source_location_name: str = None,
    ):
        # The protocol and hostname of the source location.
        # 
        # This parameter is required.
        self.base_url = base_url
        # Specifies whether to use an independent domain name to access the segments.
        self.enable_segment_delivery = enable_segment_delivery
        # The domain name used to access the segments.
        self.segment_delivery_url = segment_delivery_url
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_url is not None:
            result['BaseUrl'] = self.base_url
        if self.enable_segment_delivery is not None:
            result['EnableSegmentDelivery'] = self.enable_segment_delivery
        if self.segment_delivery_url is not None:
            result['SegmentDeliveryUrl'] = self.segment_delivery_url
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseUrl') is not None:
            self.base_url = m.get('BaseUrl')
        if m.get('EnableSegmentDelivery') is not None:
            self.enable_segment_delivery = m.get('EnableSegmentDelivery')
        if m.get('SegmentDeliveryUrl') is not None:
            self.segment_delivery_url = m.get('SegmentDeliveryUrl')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        return self


class CreateSourceLocationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source_location: ChannelAssemblySourceLocation = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source location information.
        self.source_location = source_location

    def validate(self):
        if self.source_location:
            self.source_location.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source_location is not None:
            result['SourceLocation'] = self.source_location.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SourceLocation') is not None:
            temp_model = ChannelAssemblySourceLocation()
            self.source_location = temp_model.from_map(m['SourceLocation'])
        return self


class CreateSourceLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSourceLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSourceLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadMediaRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        entity_id: str = None,
        file_info: str = None,
        media_meta_data: str = None,
        post_process_config: str = None,
        upload_target_config: str = None,
        user_data: str = None,
    ):
        # The application ID. Default value: app-1000000.
        self.app_id = app_id
        # The entity ID. You can call the CreateEntity operation to create an entity and specify a dynamic metadata structure.
        self.entity_id = entity_id
        # The file information, which is in the JSON format and contains the following fields:
        # 
        # *   Type: required. The file type. Valid values: video, image, audio, text, and other.
        # *   Name: required. The file name without the extension.
        # *   Size: optional. The file size.
        # *   Ext: required. The file name extension.
        self.file_info = file_info
        # The metadata of the media asset, which is a JSON string that contains the following fields:
        # 
        # Title: required.
        # 
        # *   The value can be up to 128 characters in length.
        # *   The value must be encoded in UTF-8.
        # 
        # Description: optional.
        # 
        # *   The value can be up to 1,024 characters in length.
        # *   The value must be encoded in UTF-8.
        # 
        # CateId: optional.
        # 
        # Tags: optional.
        # 
        # BusinessType: required. Valid values:
        # 
        # *   opening or ending if Type is set to video
        # *   default or cover if Type is set to image
        # *   subtitles or font if Type is set to text
        # *   watermark if Type is set to material
        # *   general CoverURL: optional.
        # 
        # DynamicMetaData: The value is a string.
        self.media_meta_data = media_meta_data
        # The postprocessing configurations. You can specify this parameter if Type is set to video or audio.
        # 
        # Set ProcessType to Workflow.
        self.post_process_config = post_process_config
        # The destination storage address.
        # 
        # Set StorageType to oss.
        # 
        # Set StorageLocation to an address in ApsaraVideo VOD. You cannot set this field to an OSS URL.
        self.upload_target_config = upload_target_config
        # The user data. The value must be a JSON string. You can configure settings such as message callbacks.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.file_info is not None:
            result['FileInfo'] = self.file_info
        if self.media_meta_data is not None:
            result['MediaMetaData'] = self.media_meta_data
        if self.post_process_config is not None:
            result['PostProcessConfig'] = self.post_process_config
        if self.upload_target_config is not None:
            result['UploadTargetConfig'] = self.upload_target_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('FileInfo') is not None:
            self.file_info = m.get('FileInfo')
        if m.get('MediaMetaData') is not None:
            self.media_meta_data = m.get('MediaMetaData')
        if m.get('PostProcessConfig') is not None:
            self.post_process_config = m.get('PostProcessConfig')
        if m.get('UploadTargetConfig') is not None:
            self.upload_target_config = m.get('UploadTargetConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class CreateUploadMediaResponseBody(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_url: str = None,
        request_id: str = None,
        upload_address: str = None,
        upload_auth: str = None,
    ):
        # The OSS URL of the file. The URL does not contain the information used for authentication.
        self.file_url = file_url
        # The ID of the media asset.
        self.media_id = media_id
        # The URL of the media asset.
        # 
        # >  If a domain name for Alibaba Cloud CDN (CDN) is specified, a CDN URL is returned. Otherwise, an OSS URL is returned. If the HTTP status code 403 is returned when you access the URL from your browser, the URL authentication feature of ApsaraVideo VOD is enabled. To resolve this issue, disable URL authentication or generate an authentication signature.
        self.media_url = media_url
        # The request ID.
        self.request_id = request_id
        # The upload URL.
        # 
        # >  The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAddress only if you use OSS SDK or call an OSS API operation to upload media files.
        self.upload_address = upload_address
        # The upload credential.
        # 
        # >  The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAuth only if you use OSS SDK or call an OSS API operation to upload media files.
        self.upload_auth = upload_auth

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class CreateUploadMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadStreamRequest(TeaModel):
    def __init__(
        self,
        definition: str = None,
        file_extension: str = None,
        hdrtype: str = None,
        media_id: str = None,
        user_data: str = None,
    ):
        # The quality of the media stream. Valid values:
        # 
        # *   FD: low definition.
        # *   LD: standard definition.
        # *   SD: high definition.
        # *   HD: ultra-high definition.
        # *   OD: original quality.
        # *   2K: 2K resolution.
        # *   4K: 4K resolution.
        # *   SQ: standard sound quality.
        # *   HQ: high sound quality.
        self.definition = definition
        # The file name extension of the media stream.
        self.file_extension = file_extension
        # The high dynamic range (HDR) format of the transcoded stream. Valid values:
        # 
        # *   HDR
        # *   HDR10
        # *   HLG
        # *   DolbyVision
        # *   HDRVivid
        # *   SDR+\
        # 
        # > 
        # 
        # *   The value is not case-sensitive,
        # 
        # *   You can leave this parameter empty for non-HDR streams.
        self.hdrtype = hdrtype
        # The ID of the media asset.
        self.media_id = media_id
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.file_extension is not None:
            result['FileExtension'] = self.file_extension
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('FileExtension') is not None:
            self.file_extension = m.get('FileExtension')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class CreateUploadStreamResponseBody(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        request_id: str = None,
        upload_address: str = None,
        upload_auth: str = None,
    ):
        # The Object Storage Service (OSS) URL of the file. The URL does not contain the information used for authentication.
        self.file_url = file_url
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id
        # The upload URL.
        # 
        # >  The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAddress only if you use OSS SDK or call an OSS API operation to upload media files.
        self.upload_address = upload_address
        # The upload credential.
        # 
        # >  The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAuth only if you use OSS SDK or call an OSS API operation to upload media files.
        self.upload_auth = upload_auth

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class CreateUploadStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVodPackagingAssetRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media file. Only M3U8 files stored in OSS are supported.
        self.media = media
        # The input type. Only Object Storage Service (OSS) is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateVodPackagingAssetRequest(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        content_id: str = None,
        description: str = None,
        group_name: str = None,
        input: CreateVodPackagingAssetRequestInput = None,
    ):
        # The name of the asset. The name must be unique and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.asset_name = asset_name
        # The content ID in the digital rights management (DRM) system. The maximum length is 256 characters. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.content_id = content_id
        # The asset description.
        self.description = description
        # The name of the packaging group.
        self.group_name = group_name
        # The asset input configurations.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Input') is not None:
            temp_model = CreateVodPackagingAssetRequestInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class CreateVodPackagingAssetShrinkRequest(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        content_id: str = None,
        description: str = None,
        group_name: str = None,
        input_shrink: str = None,
    ):
        # The name of the asset. The name must be unique and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.asset_name = asset_name
        # The content ID in the digital rights management (DRM) system. The maximum length is 256 characters. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.content_id = content_id
        # The asset description.
        self.description = description
        # The name of the packaging group.
        self.group_name = group_name
        # The asset input configurations.
        self.input_shrink = input_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        return self


class CreateVodPackagingAssetResponseBody(TeaModel):
    def __init__(
        self,
        asset: VodPackagingAsset = None,
        request_id: str = None,
    ):
        # The information about the asset.
        self.asset = asset
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.asset:
            self.asset.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset is not None:
            result['Asset'] = self.asset.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asset') is not None:
            temp_model = VodPackagingAsset()
            self.asset = temp_model.from_map(m['Asset'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateVodPackagingAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVodPackagingAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVodPackagingAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVodPackagingConfigurationRequestPackageConfigDrmProvider(TeaModel):
    def __init__(
        self,
        encryption_method: str = None,
        iv: str = None,
        system_ids: List[str] = None,
        url: str = None,
    ):
        # The encryption method. Valid values:
        # 
        # *   AES_128: Advanced Encryption Standard (AES) with 128-bit key length.
        # *   SAMPLE_AES: an encryption method that encrypts individual media samples.
        self.encryption_method = encryption_method
        # A 128-bit, 16-byte hex value represented by a 32-character string that is used with the key for encrypting data blocks. If you leave this parameter empty, MediaPackage creates a constant initialization vector (IV). If it is specified, the value is passed to the DRM service.
        self.iv = iv
        # The ID of the DRM system. The maximum number of system IDs allowed is determined by the protocol type. Limits:
        # 
        # *   DASH: 2
        # *   HLS: 1
        # *   HLS_CMAF: 2
        # 
        # Apple FairPlay, Google Widevine, and Microsoft PlayReady are supported. Their system IDs are as follows:
        # 
        # *   Apple FairPlay: 94ce86fb-07ff-4f43-adb8-93d2fa968ca2
        # *   Google Widevine: edef8ba9-79d6-4ace-a3c8-27dcd51d21e
        # *   Microsoft PlayReady: 9a04f079-9840-4286-ab92-e65be0885f95
        self.system_ids = system_ids
        # The URL of the DRM key provider.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encryption_method is not None:
            result['EncryptionMethod'] = self.encryption_method
        if self.iv is not None:
            result['IV'] = self.iv
        if self.system_ids is not None:
            result['SystemIds'] = self.system_ids
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptionMethod') is not None:
            self.encryption_method = m.get('EncryptionMethod')
        if m.get('IV') is not None:
            self.iv = m.get('IV')
        if m.get('SystemIds') is not None:
            self.system_ids = m.get('SystemIds')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateVodPackagingConfigurationRequestPackageConfigStreamSelection(TeaModel):
    def __init__(
        self,
        max_video_bits_per_second: int = None,
        min_video_bits_per_second: int = None,
        stream_order: str = None,
    ):
        # The maximum bitrate of the video stream. Unit: bit/s.
        self.max_video_bits_per_second = max_video_bits_per_second
        # The minimum bitrate of the video stream. Unit: bit/s.
        self.min_video_bits_per_second = min_video_bits_per_second
        # The order of manifest files in the master playlist. Valid values:
        # 
        # *   ORIGINAL: sorts the manifest files in the same order as the source.
        # *   VIDEO_BITRATE_ASCENDING: sorts the manifest files in ascending order of bitrates, from lowest to highest.
        # *   VIDEO_BITRATE_DESCENDING: sorts the manifest files in descending order of bitrates, from highest to lowest.
        self.stream_order = stream_order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_video_bits_per_second is not None:
            result['MaxVideoBitsPerSecond'] = self.max_video_bits_per_second
        if self.min_video_bits_per_second is not None:
            result['MinVideoBitsPerSecond'] = self.min_video_bits_per_second
        if self.stream_order is not None:
            result['StreamOrder'] = self.stream_order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxVideoBitsPerSecond') is not None:
            self.max_video_bits_per_second = m.get('MaxVideoBitsPerSecond')
        if m.get('MinVideoBitsPerSecond') is not None:
            self.min_video_bits_per_second = m.get('MinVideoBitsPerSecond')
        if m.get('StreamOrder') is not None:
            self.stream_order = m.get('StreamOrder')
        return self


class CreateVodPackagingConfigurationRequestPackageConfig(TeaModel):
    def __init__(
        self,
        drm_provider: CreateVodPackagingConfigurationRequestPackageConfigDrmProvider = None,
        manifest_name: str = None,
        segment_duration: int = None,
        stream_selection: CreateVodPackagingConfigurationRequestPackageConfigStreamSelection = None,
    ):
        # The settings of digital rights management (DRM) encryption.
        self.drm_provider = drm_provider
        # The manifest name. The name can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.manifest_name = manifest_name
        # The duration of each segment in a packaged stream. Unit: seconds. MediaPackage rounds segments to the nearest multiple of the input segment duration. Valid values: 1 to 30.
        self.segment_duration = segment_duration
        # The settings of stream selection.
        self.stream_selection = stream_selection

    def validate(self):
        if self.drm_provider:
            self.drm_provider.validate()
        if self.stream_selection:
            self.stream_selection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drm_provider is not None:
            result['DrmProvider'] = self.drm_provider.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.stream_selection is not None:
            result['StreamSelection'] = self.stream_selection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DrmProvider') is not None:
            temp_model = CreateVodPackagingConfigurationRequestPackageConfigDrmProvider()
            self.drm_provider = temp_model.from_map(m['DrmProvider'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('StreamSelection') is not None:
            temp_model = CreateVodPackagingConfigurationRequestPackageConfigStreamSelection()
            self.stream_selection = temp_model.from_map(m['StreamSelection'])
        return self


class CreateVodPackagingConfigurationRequest(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
        description: str = None,
        group_name: str = None,
        package_config: CreateVodPackagingConfigurationRequestPackageConfig = None,
        protocol: str = None,
    ):
        # The name of the packaging configuration. The name must be unique in an account and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.configuration_name = configuration_name
        # The description of the packaging configuration.
        self.description = description
        # The name of the packaging group. The name can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.group_name = group_name
        # The packaging configuration.
        self.package_config = package_config
        # The package type.
        # 
        # *   HLS: packages content into TS segments for delivery over the HLS protocol.
        # *   HLS_CMAF: packages content into CMAF segments for delivery over the HLS protocol.
        # *   DASH: packages content for delivery over the DASH protocol.
        self.protocol = protocol

    def validate(self):
        if self.package_config:
            self.package_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.package_config is not None:
            result['PackageConfig'] = self.package_config.to_map()
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('PackageConfig') is not None:
            temp_model = CreateVodPackagingConfigurationRequestPackageConfig()
            self.package_config = temp_model.from_map(m['PackageConfig'])
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class CreateVodPackagingConfigurationShrinkRequest(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
        description: str = None,
        group_name: str = None,
        package_config_shrink: str = None,
        protocol: str = None,
    ):
        # The name of the packaging configuration. The name must be unique in an account and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.configuration_name = configuration_name
        # The description of the packaging configuration.
        self.description = description
        # The name of the packaging group. The name can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.group_name = group_name
        # The packaging configuration.
        self.package_config_shrink = package_config_shrink
        # The package type.
        # 
        # *   HLS: packages content into TS segments for delivery over the HLS protocol.
        # *   HLS_CMAF: packages content into CMAF segments for delivery over the HLS protocol.
        # *   DASH: packages content for delivery over the DASH protocol.
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.package_config_shrink is not None:
            result['PackageConfig'] = self.package_config_shrink
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('PackageConfig') is not None:
            self.package_config_shrink = m.get('PackageConfig')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class CreateVodPackagingConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        packaging_configuration: VodPackagingConfiguration = None,
        request_id: str = None,
    ):
        # The packaging configuration.
        self.packaging_configuration = packaging_configuration
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.packaging_configuration:
            self.packaging_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.packaging_configuration is not None:
            result['PackagingConfiguration'] = self.packaging_configuration.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackagingConfiguration') is not None:
            temp_model = VodPackagingConfiguration()
            self.packaging_configuration = temp_model.from_map(m['PackagingConfiguration'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateVodPackagingConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVodPackagingConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVodPackagingConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVodPackagingGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        group_name: str = None,
    ):
        # The packaging group description.
        self.description = description
        # The name of the packaging group. The name must be unique in an account and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class CreateVodPackagingGroupResponseBody(TeaModel):
    def __init__(
        self,
        packaging_group: VodPackagingGroup = None,
        request_id: str = None,
    ):
        # The packaging group information.
        self.packaging_group = packaging_group
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.packaging_group:
            self.packaging_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.packaging_group is not None:
            result['PackagingGroup'] = self.packaging_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackagingGroup') is not None:
            temp_model = VodPackagingGroup()
            self.packaging_group = temp_model.from_map(m['PackagingGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateVodPackagingGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVodPackagingGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVodPackagingGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DecryptKMSDataKeyRequest(TeaModel):
    def __init__(
        self,
        ciphertext_blob: str = None,
    ):
        # The ciphertext that you want to decrypt.
        # 
        # This parameter is required.
        self.ciphertext_blob = ciphertext_blob

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ciphertext_blob is not None:
            result['CiphertextBlob'] = self.ciphertext_blob
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CiphertextBlob') is not None:
            self.ciphertext_blob = m.get('CiphertextBlob')
        return self


class DecryptKMSDataKeyResponseBodyDataKey(TeaModel):
    def __init__(
        self,
        key_id: str = None,
        plaintext: str = None,
    ):
        # The ID of the customer master key (CMK) that was used to decrypt the ciphertext.
        self.key_id = key_id
        # The plaintext that is generated after decryption.
        self.plaintext = plaintext

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_id is not None:
            result['KeyId'] = self.key_id
        if self.plaintext is not None:
            result['Plaintext'] = self.plaintext
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyId') is not None:
            self.key_id = m.get('KeyId')
        if m.get('Plaintext') is not None:
            self.plaintext = m.get('Plaintext')
        return self


class DecryptKMSDataKeyResponseBody(TeaModel):
    def __init__(
        self,
        data_key: DecryptKMSDataKeyResponseBodyDataKey = None,
        request_id: str = None,
    ):
        # The information about the decryption result.
        self.data_key = data_key
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_key:
            self.data_key.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_key is not None:
            result['DataKey'] = self.data_key.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataKey') is not None:
            temp_model = DecryptKMSDataKeyResponseBodyDataKey()
            self.data_key = temp_model.from_map(m['DataKey'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DecryptKMSDataKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DecryptKMSDataKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DecryptKMSDataKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAIAgentDialogueRequest(TeaModel):
    def __init__(
        self,
        dialogue_id: str = None,
        node_id: str = None,
        session_id: str = None,
    ):
        # This parameter is required.
        self.dialogue_id = dialogue_id
        self.node_id = node_id
        # This parameter is required.
        self.session_id = session_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialogue_id is not None:
            result['DialogueId'] = self.dialogue_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DialogueId') is not None:
            self.dialogue_id = m.get('DialogueId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        return self


class DeleteAIAgentDialogueResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAIAgentDialogueResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAIAgentDialogueResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAIAgentDialogueResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAdInsertionRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the configuration that you want to delete.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DeleteAdInsertionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAdInsertionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAdInsertionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAdInsertionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAvatarTrainingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteAvatarTrainingJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteAvatarTrainingJobResponseBody(TeaModel):
    def __init__(
        self,
        data: DeleteAvatarTrainingJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DeleteAvatarTrainingJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAvatarTrainingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAvatarTrainingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAvatarTrainingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
    ):
        # The category ID. You can use one of the following methods to obtain the ID:
        # 
        # *   Log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com) and choose **Media Asset Management** > **Category Management** to view the category ID.
        # *   View the value of CateId returned by the AddCategory operation that you called to create a category.
        # *   View the value of CateId returned by the GetCategories operation that you called to query a category.
        # 
        # This parameter is required.
        self.cate_id = cate_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        return self


class DeleteCategoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        return self


class DeleteChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The ID of the custom template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the human voice cloning job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDNADBRequest(TeaModel):
    def __init__(
        self,
        dbid: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media fingerprint library that you want to delete.
        # 
        # This parameter is required.
        self.dbid = dbid
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDNADBResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDNADBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDNADBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDNADBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDNAFilesRequest(TeaModel):
    def __init__(
        self,
        dbid: str = None,
        owner_account: str = None,
        owner_id: int = None,
        primary_keys: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media fingerprint library from which you want to delete files.
        # 
        # This parameter is required.
        self.dbid = dbid
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The primary key values of the files that you want to delete. Separate multiple values with commas (,). You can delete up to 50 files at a time.
        # 
        # This parameter is required.
        self.primary_keys = primary_keys
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDNAFilesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDNAFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDNAFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDNAFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEditingProjectMaterialsRequest(TeaModel):
    def __init__(
        self,
        material_ids: str = None,
        material_type: str = None,
        project_id: str = None,
    ):
        # The material ID. Separate multiple material IDs with commas (,). You can specify up to 10 IDs.
        # 
        # This parameter is required.
        self.material_ids = material_ids
        # The material type. Valid values:
        # 
        # \\- video
        # 
        # \\- image
        # 
        # \\- audio
        # 
        # \\- subtitle
        # 
        # \\- text
        # 
        # This parameter is required.
        self.material_type = material_type
        # The ID of the online editing project.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_ids is not None:
            result['MaterialIds'] = self.material_ids
        if self.material_type is not None:
            result['MaterialType'] = self.material_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaterialIds') is not None:
            self.material_ids = m.get('MaterialIds')
        if m.get('MaterialType') is not None:
            self.material_type = m.get('MaterialType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEditingProjectMaterialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEditingProjectMaterialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEditingProjectsRequest(TeaModel):
    def __init__(
        self,
        project_ids: str = None,
    ):
        # The ID of the online editing project. You can specify multiple IDs separated with commas (,).
        self.project_ids = project_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_ids is not None:
            result['ProjectIds'] = self.project_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectIds') is not None:
            self.project_ids = m.get('ProjectIds')
        return self


class DeleteEditingProjectsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEditingProjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEditingProjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEditingProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHotwordLibraryRequest(TeaModel):
    def __init__(
        self,
        hotword_library_id: str = None,
    ):
        self.hotword_library_id = hotword_library_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        return self


class DeleteHotwordLibraryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHotwordLibraryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHotwordLibraryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHotwordLibraryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePackageChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteLivePackageChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePackageChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePackageChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePackageChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePackageChannelGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteLivePackageChannelGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePackageChannelGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePackageChannelGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePackageChannelGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePackageOriginEndpointRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        endpoint_name: str = None,
        group_name: str = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The endpoint name.
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteLivePackageOriginEndpointResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePackageOriginEndpointResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePackageOriginEndpointResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePackageOriginEndpointResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRecordFilesRequest(TeaModel):
    def __init__(
        self,
        record_ids: List[str] = None,
        remove_file: bool = None,
    ):
        # The collection of IDs of recording files.
        # 
        # This parameter is required.
        self.record_ids = record_ids
        # Specifies whether to delete the original files in OSS.
        self.remove_file = remove_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_ids is not None:
            result['RecordIds'] = self.record_ids
        if self.remove_file is not None:
            result['RemoveFile'] = self.remove_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordIds') is not None:
            self.record_ids = m.get('RecordIds')
        if m.get('RemoveFile') is not None:
            self.remove_file = m.get('RemoveFile')
        return self


class DeleteLiveRecordFilesResponseBodyDeleteFileInfoList(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        record_id: str = None,
    ):
        # The code that identifies the result of the deletion.
        self.code = code
        # The result of deletion.
        self.message = message
        # The ID of the deleted recording file.
        self.record_id = record_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        return self


class DeleteLiveRecordFilesResponseBody(TeaModel):
    def __init__(
        self,
        delete_file_info_list: List[DeleteLiveRecordFilesResponseBodyDeleteFileInfoList] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The list of files deleted.
        self.delete_file_info_list = delete_file_info_list
        # The description of the state returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.delete_file_info_list:
            for k in self.delete_file_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeleteFileInfoList'] = []
        if self.delete_file_info_list is not None:
            for k in self.delete_file_info_list:
                result['DeleteFileInfoList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.delete_file_info_list = []
        if m.get('DeleteFileInfoList') is not None:
            for k in m.get('DeleteFileInfoList'):
                temp_model = DeleteLiveRecordFilesResponseBodyDeleteFileInfoList()
                self.delete_file_info_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRecordFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRecordFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRecordFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The ID of the template to be deleted. To obtain the template ID, log on to the [Intelligent Media Services (IMS) console](https://ice.console.aliyun.com/live-processing/template/list/record), choose Real-time Media Processing > Template Management, and then click the Recording tab. Alternatively, find the ID from the response parameters of the [CreateLiveRecordTemplate](https://help.aliyun.com/document_detail/448213.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteLiveRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveSnapshotFilesRequest(TeaModel):
    def __init__(
        self,
        create_timestamp_list: List[int] = None,
        delete_original_file: bool = None,
        job_id: str = None,
    ):
        # The list of timestamps when the jobs were created. The values are UNIX timestamps representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. A maximum of 200 jobs can be deleted at a time.
        # 
        # This parameter is required.
        self.create_timestamp_list = create_timestamp_list
        # Specifies whether to delete the original files at the same time. Default value: false.
        self.delete_original_file = delete_original_file
        # The ID of the snapshot job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp_list is not None:
            result['CreateTimestampList'] = self.create_timestamp_list
        if self.delete_original_file is not None:
            result['DeleteOriginalFile'] = self.delete_original_file
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestampList') is not None:
            self.create_timestamp_list = m.get('CreateTimestampList')
        if m.get('DeleteOriginalFile') is not None:
            self.delete_original_file = m.get('DeleteOriginalFile')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteLiveSnapshotFilesShrinkRequest(TeaModel):
    def __init__(
        self,
        create_timestamp_list_shrink: str = None,
        delete_original_file: bool = None,
        job_id: str = None,
    ):
        # The list of timestamps when the jobs were created. The values are UNIX timestamps representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. A maximum of 200 jobs can be deleted at a time.
        # 
        # This parameter is required.
        self.create_timestamp_list_shrink = create_timestamp_list_shrink
        # Specifies whether to delete the original files at the same time. Default value: false.
        self.delete_original_file = delete_original_file
        # The ID of the snapshot job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp_list_shrink is not None:
            result['CreateTimestampList'] = self.create_timestamp_list_shrink
        if self.delete_original_file is not None:
            result['DeleteOriginalFile'] = self.delete_original_file
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestampList') is not None:
            self.create_timestamp_list_shrink = m.get('CreateTimestampList')
        if m.get('DeleteOriginalFile') is not None:
            self.delete_original_file = m.get('DeleteOriginalFile')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList(TeaModel):
    def __init__(
        self,
        create_timestamp: int = None,
        result: str = None,
    ):
        # The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The result of deletion. A value of OK indicates that the file is deleted. Other values indicate that the file failed to be deleted.
        # 
        # Valid values:
        # 
        # *   OK: The file was deleted.
        # *   NotFound: The file was not found.
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DeleteLiveSnapshotFilesResponseBody(TeaModel):
    def __init__(
        self,
        delete_file_result_list: List[DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList] = None,
        request_id: str = None,
    ):
        # The list of deleted files.
        self.delete_file_result_list = delete_file_result_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.delete_file_result_list:
            for k in self.delete_file_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeleteFileResultList'] = []
        if self.delete_file_result_list is not None:
            for k in self.delete_file_result_list:
                result['DeleteFileResultList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.delete_file_result_list = []
        if m.get('DeleteFileResultList') is not None:
            for k in m.get('DeleteFileResultList'):
                temp_model = DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList()
                self.delete_file_result_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveSnapshotFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveSnapshotFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveSnapshotFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveSnapshotTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteLiveSnapshotTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveSnapshotTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveSnapshotTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveSnapshotTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the transcoding job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteLiveTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID. To obtain the template ID, log on to the [Intelligent Media Services (IMS) console](https://ice.console.aliyun.com/summary), choose Real-time Media Processing > Template Management, and then click the Transcoding tab. Alternatively, find the ID from the response parameters of the [CreateLiveTranscodeTemplate](https://help.aliyun.com/document_detail/449217.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaConnectFlowRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        return self


class DeleteMediaConnectFlowResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of `0` indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class DeleteMediaConnectFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaConnectFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaConnectFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaConnectFlowInputRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        input_name: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        self.input_name = input_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.input_name is not None:
            result['InputName'] = self.input_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        return self


class DeleteMediaConnectFlowInputResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class DeleteMediaConnectFlowInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaConnectFlowInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaConnectFlowInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaConnectFlowOutputRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        output_name: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The name of the output that you want to delete.
        # 
        # This parameter is required.
        self.output_name = output_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.output_name is not None:
            result['OutputName'] = self.output_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('OutputName') is not None:
            self.output_name = m.get('OutputName')
        return self


class DeleteMediaConnectFlowOutputResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class DeleteMediaConnectFlowOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaConnectFlowOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaConnectFlowOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaFromSearchLibRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        msg_body: str = None,
        search_lib_name: str = None,
    ):
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The message body.
        self.msg_body = msg_body
        # The name of the search library. Default value: ims-default-search-lib.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.msg_body is not None:
            result['MsgBody'] = self.msg_body
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MsgBody') is not None:
            self.msg_body = m.get('MsgBody')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class DeleteMediaFromSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_id: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the media asset.
        self.media_id = media_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMediaFromSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaFromSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaFromSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaInfosRequest(TeaModel):
    def __init__(
        self,
        delete_physical_files: bool = None,
        input_urls: str = None,
        media_ids: str = None,
    ):
        # Specifies whether to delete the physical file of the media asset.
        # 
        # If the media asset is stored in your own OSS bucket, you must authorize the service role AliyunICEDefaultRole in advance. For more information<props="china">, see [Authorize IMS to delete recording files in OSS](https://help.aliyun.com/zh/ims/user-guide/record?spm=a2c4g.11186623.0.i8#0737d9c437bmn).
        self.delete_physical_files = delete_physical_files
        # The URL of the media asset that you want to delete. The file corresponding to the URL must be registered with IMS. Separate multiple URLs with commas (,). The following two formats are supported:
        # 
        # 1.  http(s)://example-bucket.oss-cn-shanghai.aliyuncs.com/example.mp4?
        # 2.  OSS://example-bucket/example.mp4?\\
        #     In this format, it is considered by default that the region of the OSS bucket in which the media asset resides is the same as the region in which IMS is activated.
        self.input_urls = input_urls
        # The ID of the media asset that you want to delete from Intelligent Media Services (IMS).
        # 
        # *   Separate multiple IDs with commas (,).
        # 
        # If you leave MediaIds empty, you must specify InputURLs.
        self.media_ids = media_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_physical_files is not None:
            result['DeletePhysicalFiles'] = self.delete_physical_files
        if self.input_urls is not None:
            result['InputURLs'] = self.input_urls
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletePhysicalFiles') is not None:
            self.delete_physical_files = m.get('DeletePhysicalFiles')
        if m.get('InputURLs') is not None:
            self.input_urls = m.get('InputURLs')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class DeleteMediaInfosResponseBody(TeaModel):
    def __init__(
        self,
        forbidden_list: List[str] = None,
        ignored_list: List[str] = None,
        request_id: str = None,
    ):
        # The IDs or URLs of media assets that cannot be deleted. Generally, media assets cannot be deleted if you do not have the required permissions.
        self.forbidden_list = forbidden_list
        # The IDs or URLs of ignored media assets. An error occurred while obtaining such media assets.
        self.ignored_list = ignored_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forbidden_list is not None:
            result['ForbiddenList'] = self.forbidden_list
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForbiddenList') is not None:
            self.forbidden_list = m.get('ForbiddenList')
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
    ):
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class DeleteMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaLiveInputRequest(TeaModel):
    def __init__(
        self,
        input_id: str = None,
    ):
        # The ID of the input.
        # 
        # This parameter is required.
        self.input_id = input_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_id is not None:
            result['InputId'] = self.input_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        return self


class DeleteMediaLiveInputResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaLiveInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaLiveInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaLiveInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaLiveInputSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
    ):
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DeleteMediaLiveInputSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaLiveInputSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaLiveInputSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaLiveInputSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaMarksRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The mark ID. You can specify multiple mark IDs separated with commas (,).
        # 
        # If you do not specify MediaMarkIds, all the marks of the media asset are deleted.
        self.media_mark_ids = media_mark_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        return self


class DeleteMediaMarksResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The IDs of the deleted marks separated with commas (,).
        self.media_mark_ids = media_mark_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaMarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaMarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaMarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineRequest(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the MPS queue.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class DeletePipelineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeletePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePlayInfoRequest(TeaModel):
    def __init__(
        self,
        delete_physical_files: bool = None,
        file_urls: str = None,
        media_id: str = None,
    ):
        # Specifies whether to delete the physical file of the media stream.
        # 
        # If the media asset is stored in your own Object Storage Service (OSS) bucket, you must authorize the service role AliyunICEDefaultRole in advance. <props="china">For more information, see [Authorize IMS to delete recording files in OSS](https://help.aliyun.com/document_detail/449331.html#p-ko2-wc7-iad).
        # 
        # You can delete only the physical files of transcoded streams, but not the physical files of source files.
        self.delete_physical_files = delete_physical_files
        # The URL of the media stream file that you want to delete. Separate multiple URLs with commas (,).
        self.file_urls = file_urls
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_physical_files is not None:
            result['DeletePhysicalFiles'] = self.delete_physical_files
        if self.file_urls is not None:
            result['FileURLs'] = self.file_urls
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletePhysicalFiles') is not None:
            self.delete_physical_files = m.get('DeletePhysicalFiles')
        if m.get('FileURLs') is not None:
            self.file_urls = m.get('FileURLs')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class DeletePlayInfoResponseBody(TeaModel):
    def __init__(
        self,
        forbidden_list: List[str] = None,
        ignored_list: List[str] = None,
        request_id: str = None,
    ):
        # The URLs of the media streams that cannot be deleted. Generally, media streams cannot be deleted if you do not have the required permissions.
        self.forbidden_list = forbidden_list
        # The URLs of ignored media streams. An error occurred while obtaining such media assets because the IDs or URLs of the media assets do not exist.
        self.ignored_list = ignored_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forbidden_list is not None:
            result['ForbiddenList'] = self.forbidden_list
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForbiddenList') is not None:
            self.forbidden_list = m.get('ForbiddenList')
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePlayInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePlayInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePlayInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProgramRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        program_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The name of the program.
        # 
        # This parameter is required.
        self.program_name = program_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        return self


class DeleteProgramResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRecognitionEntityRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        entity_id: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.entity_id = entity_id
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteRecognitionEntityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRecognitionEntityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRecognitionEntityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRecognitionEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRecognitionLibRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteRecognitionLibResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRecognitionLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRecognitionLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRecognitionLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRecognitionSampleRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        entity_id: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        sample_id: str = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.entity_id = entity_id
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.sample_id = sample_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.sample_id is not None:
            result['SampleId'] = self.sample_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SampleId') is not None:
            self.sample_id = m.get('SampleId')
        return self


class DeleteRecognitionSampleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRecognitionSampleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRecognitionSampleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRecognitionSampleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSmartJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The IDs of the jobs to delete. Separate multiple IDs with commas (,).
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteSmartJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSmartJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSmartJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSmartJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSourceRequest(TeaModel):
    def __init__(
        self,
        soft_delete: bool = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        # Specifies whether to use delete markers.
        self.soft_delete = soft_delete
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name
        # The name of the source.
        # 
        # This parameter is required.
        self.source_name = source_name
        # The source type. Valid values: vodSource and liveSource.
        # 
        # This parameter is required.
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.soft_delete is not None:
            result['SoftDelete'] = self.soft_delete
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SoftDelete') is not None:
            self.soft_delete = m.get('SoftDelete')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class DeleteSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSourceLocationRequest(TeaModel):
    def __init__(
        self,
        soft_delete: bool = None,
        source_location_name: str = None,
    ):
        # Specifies whether to use delete markers.
        self.soft_delete = soft_delete
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.soft_delete is not None:
            result['SoftDelete'] = self.soft_delete
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SoftDelete') is not None:
            self.soft_delete = m.get('SoftDelete')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        return self


class DeleteSourceLocationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful. Valid value:
        # 
        # *   true: The request succeeded.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSourceLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSourceLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSourceLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTemplateRequest(TeaModel):
    def __init__(
        self,
        template_ids: str = None,
    ):
        # The IDs of the templates that you want to delete. Separate multiple IDs with commas (,).
        self.template_ids = template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        return self


class DeleteTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVodPackagingAssetRequest(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
    ):
        # The name of the VOD packaging asset.
        self.asset_name = asset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        return self


class DeleteVodPackagingAssetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVodPackagingAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVodPackagingAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVodPackagingAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVodPackagingConfigurationRequest(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
    ):
        # The name of the packaging configuration.
        self.configuration_name = configuration_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        return self


class DeleteVodPackagingConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVodPackagingConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVodPackagingConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVodPackagingConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVodPackagingGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The name of the packaging group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteVodPackagingGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVodPackagingGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVodPackagingGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVodPackagingGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAIAgentInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the AI agent that you want to query.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeAIAgentInstanceResponseBodyInstance(TeaModel):
    def __init__(
        self,
        agent_config: AIAgentConfig = None,
        call_log_url: str = None,
        runtime_config: AIAgentRuntimeConfig = None,
        session_id: str = None,
        status: str = None,
        template_config: AIAgentTemplateConfig = None,
        user_data: str = None,
    ):
        self.agent_config = agent_config
        # The URL of the call log file.
        self.call_log_url = call_log_url
        # The runtime configurations of the AI agent.
        self.runtime_config = runtime_config
        self.session_id = session_id
        # The state of the AI agent. Valid values: Finished and Executing.
        self.status = status
        # The template configurations of the AI agent.
        self.template_config = template_config
        # The custom information.
        self.user_data = user_data

    def validate(self):
        if self.agent_config:
            self.agent_config.validate()
        if self.runtime_config:
            self.runtime_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_config is not None:
            result['AgentConfig'] = self.agent_config.to_map()
        if self.call_log_url is not None:
            result['CallLogUrl'] = self.call_log_url
        if self.runtime_config is not None:
            result['RuntimeConfig'] = self.runtime_config.to_map()
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status is not None:
            result['Status'] = self.status
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentConfig') is not None:
            temp_model = AIAgentConfig()
            self.agent_config = temp_model.from_map(m['AgentConfig'])
        if m.get('CallLogUrl') is not None:
            self.call_log_url = m.get('CallLogUrl')
        if m.get('RuntimeConfig') is not None:
            temp_model = AIAgentRuntimeConfig()
            self.runtime_config = temp_model.from_map(m['RuntimeConfig'])
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateConfig') is not None:
            temp_model = AIAgentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class DescribeAIAgentInstanceResponseBody(TeaModel):
    def __init__(
        self,
        instance: DescribeAIAgentInstanceResponseBodyInstance = None,
        request_id: str = None,
    ):
        # The information about the AI agent.
        self.instance = instance
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Instance') is not None:
            temp_model = DescribeAIAgentInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAIAgentInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAIAgentInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAIAgentInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterImsEditUsageRequest(TeaModel):
    def __init__(
        self,
        end_ts: int = None,
        interval: int = None,
        region: str = None,
        start_ts: int = None,
    ):
        # The end of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # The time granularity of the query. Valid values: 3600 (hour) and 86400 (day).
        # 
        # This parameter is required.
        self.interval = interval
        # This parameter does not take effect. By default, the usage data of all regions is returned.
        self.region = region
        # The beginning of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterImsEditUsageResponseBodyData(TeaModel):
    def __init__(
        self,
        duration: int = None,
        profile: str = None,
        time: int = None,
    ):
        # The usage duration, in minutes.
        self.duration = duration
        # The video profile.
        self.profile = profile
        # The beginning time of usage. The value is a 10-digit timestamp.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterImsEditUsageResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeMeterImsEditUsageResponseBodyData] = None,
        request_id: str = None,
    ):
        # The usage statistics of IMS on VOD editing.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterImsEditUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterImsEditUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterImsEditUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterImsEditUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterImsMediaConvertUHDUsageRequest(TeaModel):
    def __init__(
        self,
        end_ts: int = None,
        interval: str = None,
        region_id: str = None,
        start_ts: int = None,
    ):
        # The end of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # The time granularity of the query. Valid values: 3600 (hour) and 86400 (day).
        # 
        # This parameter is required.
        self.interval = interval
        # This parameter does not take effect. By default, the usage data of all regions is returned.
        self.region_id = region_id
        # The beginning of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterImsMediaConvertUHDUsageResponseBodyData(TeaModel):
    def __init__(
        self,
        duration: int = None,
        specification: str = None,
        time: int = None,
    ):
        # The usage duration, in minutes.
        self.duration = duration
        # The transcoding specifications.
        self.specification = specification
        # The beginning time of usage. The value is a 10-digit timestamp.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterImsMediaConvertUHDUsageResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeMeterImsMediaConvertUHDUsageResponseBodyData] = None,
        request_id: str = None,
    ):
        # The usage statistics of IMS on UHD transcoding of MPS.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterImsMediaConvertUHDUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterImsMediaConvertUHDUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterImsMediaConvertUHDUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterImsMediaConvertUHDUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterImsMediaConvertUsageRequest(TeaModel):
    def __init__(
        self,
        end_ts: int = None,
        interval: int = None,
        region: str = None,
        start_ts: int = None,
    ):
        # The end of the time range to query. The value is a 10-digit timestamp. The maximum query range is 31 days. The duration between StartTs and EndTs cannot exceed 31 days.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # The time granularity of the query. Valid values: 3600 (hour) and 86400 (day).
        # 
        # This parameter is required.
        self.interval = interval
        # This parameter does not take effect. By default, the usage data of all regions is returned.
        self.region = region
        # The beginning of the time range to query. The value is a 10-digit timestamp. You can query data within the last 90 days.
        # 
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterImsMediaConvertUsageResponseBodyData(TeaModel):
    def __init__(
        self,
        duration: int = None,
        specification: str = None,
        time: int = None,
    ):
        # The usage duration, in minutes.
        self.duration = duration
        # The transcoding specifications.
        self.specification = specification
        # The beginning time of usage. The value is a 10-digit timestamp.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterImsMediaConvertUsageResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeMeterImsMediaConvertUsageResponseBodyData] = None,
        request_id: str = None,
    ):
        # The usage statistics of IMS on VOD transcoding.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterImsMediaConvertUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterImsMediaConvertUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterImsMediaConvertUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterImsMediaConvertUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterImsMpsAiUsageRequest(TeaModel):
    def __init__(
        self,
        end_ts: int = None,
        interval: int = None,
        region: str = None,
        start_ts: int = None,
    ):
        # The end of the time range to query. The value is a 10-digit timestamp. The maximum query range is 31 days. The duration between StartTs and EndTs cannot exceed 31 days.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # The time granularity of the query. Valid values: 3600 (hour) and 86400 (day).
        # 
        # This parameter is required.
        self.interval = interval
        # This parameter does not take effect. By default, the usage data of all regions is returned.
        self.region = region
        # The beginning of the time range to query. The value is a 10-digit timestamp. You can query data within the last 90 days.
        # 
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterImsMpsAiUsageResponseBodyData(TeaModel):
    def __init__(
        self,
        duration: int = None,
        time: int = None,
        type: str = None,
    ):
        # The usage duration, in minutes.
        self.duration = duration
        # The beginning time of usage. The value is a 10-digit timestamp.
        self.time = time
        # The AI type. Valid values:
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeMeterImsMpsAiUsageResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeMeterImsMpsAiUsageResponseBodyData] = None,
        request_id: str = None,
    ):
        # The usage statistics of IMS on AI processing of MPS.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterImsMpsAiUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterImsMpsAiUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterImsMpsAiUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterImsMpsAiUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterImsSummaryRequest(TeaModel):
    def __init__(
        self,
        end_ts: int = None,
        region: str = None,
        start_ts: int = None,
    ):
        # The end of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # This parameter does not take effect. By default, the usage data of all regions is returned.
        self.region = region
        # The beginning of the time range to query. The value is a 10-digit timestamp.
        # 
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterImsSummaryResponseBodyData(TeaModel):
    def __init__(
        self,
        editing_duration: str = None,
        live_edit_duration: str = None,
        live_record_duration: str = None,
        live_snapshot_count: str = None,
        live_transcode_duration: int = None,
        mps_ai_duration: int = None,
        mps_transcode_duration: int = None,
        mps_transcode_uhdduration: int = None,
    ):
        # The duration of video editing.
        self.editing_duration = editing_duration
        # The duration of live editing.
        self.live_edit_duration = live_edit_duration
        # The duration of live stream recording.
        self.live_record_duration = live_record_duration
        # The number of live stream snapshots.
        self.live_snapshot_count = live_snapshot_count
        # The duration of live stream transcoding.
        self.live_transcode_duration = live_transcode_duration
        # The duration of AI processing.
        self.mps_ai_duration = mps_ai_duration
        # The duration of video-on-demand (VOD) transcoding.
        self.mps_transcode_duration = mps_transcode_duration
        # The duration of audio and video enhancement.
        self.mps_transcode_uhdduration = mps_transcode_uhdduration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_duration is not None:
            result['EditingDuration'] = self.editing_duration
        if self.live_edit_duration is not None:
            result['LiveEditDuration'] = self.live_edit_duration
        if self.live_record_duration is not None:
            result['LiveRecordDuration'] = self.live_record_duration
        if self.live_snapshot_count is not None:
            result['LiveSnapshotCount'] = self.live_snapshot_count
        if self.live_transcode_duration is not None:
            result['LiveTranscodeDuration'] = self.live_transcode_duration
        if self.mps_ai_duration is not None:
            result['MpsAiDuration'] = self.mps_ai_duration
        if self.mps_transcode_duration is not None:
            result['MpsTranscodeDuration'] = self.mps_transcode_duration
        if self.mps_transcode_uhdduration is not None:
            result['MpsTranscodeUHDDuration'] = self.mps_transcode_uhdduration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingDuration') is not None:
            self.editing_duration = m.get('EditingDuration')
        if m.get('LiveEditDuration') is not None:
            self.live_edit_duration = m.get('LiveEditDuration')
        if m.get('LiveRecordDuration') is not None:
            self.live_record_duration = m.get('LiveRecordDuration')
        if m.get('LiveSnapshotCount') is not None:
            self.live_snapshot_count = m.get('LiveSnapshotCount')
        if m.get('LiveTranscodeDuration') is not None:
            self.live_transcode_duration = m.get('LiveTranscodeDuration')
        if m.get('MpsAiDuration') is not None:
            self.mps_ai_duration = m.get('MpsAiDuration')
        if m.get('MpsTranscodeDuration') is not None:
            self.mps_transcode_duration = m.get('MpsTranscodeDuration')
        if m.get('MpsTranscodeUHDDuration') is not None:
            self.mps_transcode_uhdduration = m.get('MpsTranscodeUHDDuration')
        return self


class DescribeMeterImsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeMeterImsSummaryResponseBodyData] = None,
        request_id: str = None,
    ):
        # The usage statistics of IMS.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterImsSummaryResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterImsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterImsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterImsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        return self


class DescribeNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        audio_oss_path: str = None,
        callback_url: str = None,
        enable_audio_recording: bool = None,
        enable_notify: bool = None,
        event_types: str = None,
        request_id: str = None,
        token: str = None,
    ):
        self.audio_oss_path = audio_oss_path
        self.callback_url = callback_url
        self.enable_audio_recording = enable_audio_recording
        self.enable_notify = enable_notify
        # The event types. If this parameter is empty, all event types are selected.
        # 
        # *   agent_start: The agent is started.
        # *   agent_stop: The agent is stopped.
        # *   error: An error occurred.
        self.event_types = event_types
        self.request_id = request_id
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_oss_path is not None:
            result['AudioOssPath'] = self.audio_oss_path
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.enable_audio_recording is not None:
            result['EnableAudioRecording'] = self.enable_audio_recording
        if self.enable_notify is not None:
            result['EnableNotify'] = self.enable_notify
        if self.event_types is not None:
            result['EventTypes'] = self.event_types
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioOssPath') is not None:
            self.audio_oss_path = m.get('AudioOssPath')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('EnableAudioRecording') is not None:
            self.enable_audio_recording = m.get('EnableAudioRecording')
        if m.get('EnableNotify') is not None:
            self.enable_notify = m.get('EnableNotify')
        if m.get('EventTypes') is not None:
            self.event_types = m.get('EventTypes')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class DescribeNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayListRequest(TeaModel):
    def __init__(
        self,
        begin_ts: str = None,
        end_ts: str = None,
        order_name: str = None,
        order_type: str = None,
        page_no: int = None,
        page_size: int = None,
        play_type: str = None,
        status: str = None,
        trace_id: str = None,
    ):
        # This parameter is required.
        self.begin_ts = begin_ts
        # This parameter is required.
        self.end_ts = end_ts
        self.order_name = order_name
        self.order_type = order_type
        # This parameter is required.
        self.page_no = page_no
        # This parameter is required.
        self.page_size = page_size
        self.play_type = play_type
        self.status = status
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.order_name is not None:
            result['OrderName'] = self.order_name
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.play_type is not None:
            result['PlayType'] = self.play_type
        if self.status is not None:
            result['Status'] = self.status
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('OrderName') is not None:
            self.order_name = m.get('OrderName')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PlayType') is not None:
            self.play_type = m.get('PlayType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePlayListResponseBodyPlayList(TeaModel):
    def __init__(
        self,
        first_frame_duration: str = None,
        play_duration: str = None,
        play_ts: str = None,
        play_type: str = None,
        session_id: str = None,
        status: str = None,
        stuck_duration: str = None,
        trace_id: str = None,
        video_duration: str = None,
        video_id: str = None,
    ):
        self.first_frame_duration = first_frame_duration
        self.play_duration = play_duration
        self.play_ts = play_ts
        self.play_type = play_type
        self.session_id = session_id
        self.status = status
        self.stuck_duration = stuck_duration
        self.trace_id = trace_id
        self.video_duration = video_duration
        self.video_id = video_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_frame_duration is not None:
            result['FirstFrameDuration'] = self.first_frame_duration
        if self.play_duration is not None:
            result['PlayDuration'] = self.play_duration
        if self.play_ts is not None:
            result['PlayTs'] = self.play_ts
        if self.play_type is not None:
            result['PlayType'] = self.play_type
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status is not None:
            result['Status'] = self.status
        if self.stuck_duration is not None:
            result['StuckDuration'] = self.stuck_duration
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        if self.video_duration is not None:
            result['VideoDuration'] = self.video_duration
        if self.video_id is not None:
            result['VideoId'] = self.video_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstFrameDuration') is not None:
            self.first_frame_duration = m.get('FirstFrameDuration')
        if m.get('PlayDuration') is not None:
            self.play_duration = m.get('PlayDuration')
        if m.get('PlayTs') is not None:
            self.play_ts = m.get('PlayTs')
        if m.get('PlayType') is not None:
            self.play_type = m.get('PlayType')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StuckDuration') is not None:
            self.stuck_duration = m.get('StuckDuration')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        if m.get('VideoDuration') is not None:
            self.video_duration = m.get('VideoDuration')
        if m.get('VideoId') is not None:
            self.video_id = m.get('VideoId')
        return self


class DescribePlayListResponseBody(TeaModel):
    def __init__(
        self,
        page_num: int = None,
        page_size: int = None,
        play_list: List[DescribePlayListResponseBodyPlayList] = None,
        request_id: str = None,
        total_num: int = None,
    ):
        self.page_num = page_num
        self.page_size = page_size
        self.play_list = play_list
        # Id
        self.request_id = request_id
        self.total_num = total_num

    def validate(self):
        if self.play_list:
            for k in self.play_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PlayList'] = []
        if self.play_list is not None:
            for k in self.play_list:
                result['PlayList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.play_list = []
        if m.get('PlayList') is not None:
            for k in m.get('PlayList'):
                temp_model = DescribePlayListResponseBodyPlayList()
                self.play_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        return self


class DescribePlayListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePlayListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcRobotInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeRtcRobotInstanceResponseBodyConfig(TeaModel):
    def __init__(
        self,
        enable_voice_interrupt: bool = None,
        greeting: str = None,
        voice_id: str = None,
    ):
        self.enable_voice_interrupt = enable_voice_interrupt
        self.greeting = greeting
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class DescribeRtcRobotInstanceResponseBody(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        channel_id: str = None,
        config: DescribeRtcRobotInstanceResponseBodyConfig = None,
        request_id: str = None,
        status: str = None,
        user_data: str = None,
        user_id: str = None,
    ):
        self.auth_token = auth_token
        self.channel_id = channel_id
        self.config = config
        # Id of the request
        self.request_id = request_id
        self.status = status
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Config') is not None:
            temp_model = DescribeRtcRobotInstanceResponseBodyConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeRtcRobotInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcRobotInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcRobotInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetectAudioForCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        audio_record_id: int = None,
        record_url: str = None,
        voice_id: str = None,
    ):
        # The sequence number of the recording file.
        # 
        # This parameter is required.
        self.audio_record_id = audio_record_id
        # The URL of the recording file.
        # 
        # > : The URL must be an Object Storage Service (OSS) URL within your Alibaba Cloud account. The OSS bucket must be in the same region in which IMS is activated.
        # 
        # > : The audio file must be in the WAV or PCM format and must be a 16-bit mono audio file at 48000 Hz.
        # 
        # This parameter is required.
        self.record_url = record_url
        # The voice ID.
        # 
        # This parameter is required.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_record_id is not None:
            result['AudioRecordId'] = self.audio_record_id
        if self.record_url is not None:
            result['RecordUrl'] = self.record_url
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioRecordId') is not None:
            self.audio_record_id = m.get('AudioRecordId')
        if m.get('RecordUrl') is not None:
            self.record_url = m.get('RecordUrl')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class DetectAudioForCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        pass_: bool = None,
        reason: str = None,
    ):
        # Indicates whether the audio file passes the check. Valid values:
        # 
        # *   true
        # *   false
        self.pass_ = pass_
        # The reason returned if the audio file failed to pass the check.
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pass_ is not None:
            result['Pass'] = self.pass_
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pass') is not None:
            self.pass_ = m.get('Pass')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class DetectAudioForCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: DetectAudioForCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DetectAudioForCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetectAudioForCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetectAudioForCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetectAudioForCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DropSearchIndexRequest(TeaModel):
    def __init__(
        self,
        index_type: str = None,
        search_lib_name: str = None,
    ):
        # The category of the index. Valid values:
        # 
        # *   mm: large visual model.
        # *   face: face recognition.
        # *   aiLabel: smart tagging.
        # 
        # This parameter is required.
        self.index_type = index_type
        # The name of the search library.
        # 
        # *   If you leave this parameter empty, the search index is created in the default search library of Intelligent Media Service (IMS). Default value: ims-default-search-lib.
        # *   To query information about an existing search library, call the [QuerySearchLib](https://help.aliyun.com/document_detail/2584455.html) API operation.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class DropSearchIndexResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DropSearchIndexResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DropSearchIndexResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DropSearchIndexResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DropSearchLibRequest(TeaModel):
    def __init__(
        self,
        search_lib_name: str = None,
    ):
        # The name of the search library.
        # 
        # This parameter is required.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class DropSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DropSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DropSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DropSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateAIAgentCallRequestChatSyncConfig(TeaModel):
    def __init__(
        self,
        imaiagent_id: str = None,
        receiver_id: str = None,
    ):
        self.imaiagent_id = imaiagent_id
        self.receiver_id = receiver_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.imaiagent_id is not None:
            result['IMAIAgentId'] = self.imaiagent_id
        if self.receiver_id is not None:
            result['ReceiverId'] = self.receiver_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IMAIAgentId') is not None:
            self.imaiagent_id = m.get('IMAIAgentId')
        if m.get('ReceiverId') is not None:
            self.receiver_id = m.get('ReceiverId')
        return self


class GenerateAIAgentCallRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        agent_config: AIAgentConfig = None,
        chat_sync_config: GenerateAIAgentCallRequestChatSyncConfig = None,
        expire: int = None,
        session_id: str = None,
        template_config: AIAgentTemplateConfig = None,
        user_data: str = None,
        user_id: str = None,
    ):
        # The ID of the AI agent.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.agent_config = agent_config
        self.chat_sync_config = chat_sync_config
        # The time when the token expires. Unit: seconds. Default value: 3600. Valid values: 0 to 604800.
        self.expire = expire
        self.session_id = session_id
        # The template configurations of the AI agent. The specified configurations are merged with the template configurations that are specified in the console. If you do not specify this parameter, the system uses the default configurations for an AI agent created in the console.
        self.template_config = template_config
        self.user_data = user_data
        # The username of the AI agent in the channel. If you do not specify this parameter, the system automatically generates a username. The value can be up to 64 characters in length.
        self.user_id = user_id

    def validate(self):
        if self.agent_config:
            self.agent_config.validate()
        if self.chat_sync_config:
            self.chat_sync_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.agent_config is not None:
            result['AgentConfig'] = self.agent_config.to_map()
        if self.chat_sync_config is not None:
            result['ChatSyncConfig'] = self.chat_sync_config.to_map()
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AgentConfig') is not None:
            temp_model = AIAgentConfig()
            self.agent_config = temp_model.from_map(m['AgentConfig'])
        if m.get('ChatSyncConfig') is not None:
            temp_model = GenerateAIAgentCallRequestChatSyncConfig()
            self.chat_sync_config = temp_model.from_map(m['ChatSyncConfig'])
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TemplateConfig') is not None:
            temp_model = AIAgentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GenerateAIAgentCallShrinkRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        agent_config_shrink: str = None,
        chat_sync_config_shrink: str = None,
        expire: int = None,
        session_id: str = None,
        template_config_shrink: str = None,
        user_data: str = None,
        user_id: str = None,
    ):
        # The ID of the AI agent.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.agent_config_shrink = agent_config_shrink
        self.chat_sync_config_shrink = chat_sync_config_shrink
        # The time when the token expires. Unit: seconds. Default value: 3600. Valid values: 0 to 604800.
        self.expire = expire
        self.session_id = session_id
        # The template configurations of the AI agent. The specified configurations are merged with the template configurations that are specified in the console. If you do not specify this parameter, the system uses the default configurations for an AI agent created in the console.
        self.template_config_shrink = template_config_shrink
        self.user_data = user_data
        # The username of the AI agent in the channel. If you do not specify this parameter, the system automatically generates a username. The value can be up to 64 characters in length.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.agent_config_shrink is not None:
            result['AgentConfig'] = self.agent_config_shrink
        if self.chat_sync_config_shrink is not None:
            result['ChatSyncConfig'] = self.chat_sync_config_shrink
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AgentConfig') is not None:
            self.agent_config_shrink = m.get('AgentConfig')
        if m.get('ChatSyncConfig') is not None:
            self.chat_sync_config_shrink = m.get('ChatSyncConfig')
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GenerateAIAgentCallResponseBody(TeaModel):
    def __init__(
        self,
        aiagent_user_id: str = None,
        channel_id: str = None,
        instance_id: str = None,
        request_id: str = None,
        token: str = None,
        user_id: str = None,
    ):
        # The username of the AI agent in the Alibaba Real-Time Communication (ARTC) channel.
        self.aiagent_user_id = aiagent_user_id
        # The ARTC channel ID.
        self.channel_id = channel_id
        # The ID of the AI agent.
        self.instance_id = instance_id
        # The request ID.
        self.request_id = request_id
        # The ARTC token of the client.
        self.token = token
        # The username in the ARTC channel.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_user_id is not None:
            result['AIAgentUserId'] = self.aiagent_user_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.token is not None:
            result['Token'] = self.token
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentUserId') is not None:
            self.aiagent_user_id = m.get('AIAgentUserId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GenerateAIAgentCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateAIAgentCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateAIAgentCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateKMSDataKeyResponseBodyDataKey(TeaModel):
    def __init__(
        self,
        ciphertext_blob: str = None,
        key_id: str = None,
        plaintext: str = None,
    ):
        # The ciphertext of the encrypted data key. This parameter is used as CipherText when you create a transcoding job.
        self.ciphertext_blob = ciphertext_blob
        # The ID of the customer master key (CMK). The ID must be globally unique.
        self.key_id = key_id
        # The Base64-encoded plaintext of the data key.
        self.plaintext = plaintext

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ciphertext_blob is not None:
            result['CiphertextBlob'] = self.ciphertext_blob
        if self.key_id is not None:
            result['KeyId'] = self.key_id
        if self.plaintext is not None:
            result['Plaintext'] = self.plaintext
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CiphertextBlob') is not None:
            self.ciphertext_blob = m.get('CiphertextBlob')
        if m.get('KeyId') is not None:
            self.key_id = m.get('KeyId')
        if m.get('Plaintext') is not None:
            self.plaintext = m.get('Plaintext')
        return self


class GenerateKMSDataKeyResponseBody(TeaModel):
    def __init__(
        self,
        data_key: GenerateKMSDataKeyResponseBodyDataKey = None,
        request_id: str = None,
    ):
        # The information about the data key.
        self.data_key = data_key
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_key:
            self.data_key.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_key is not None:
            result['DataKey'] = self.data_key.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataKey') is not None:
            temp_model = GenerateKMSDataKeyResponseBodyDataKey()
            self.data_key = temp_model.from_map(m['DataKey'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GenerateKMSDataKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateKMSDataKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateKMSDataKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateMessageChatTokenRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        expire: int = None,
        role: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.expire = expire
        self.role = role
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.role is not None:
            result['Role'] = self.role
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GenerateMessageChatTokenResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_sign: str = None,
        nonce: str = None,
        request_id: str = None,
        role: str = None,
        time_stamp: int = None,
        token: str = None,
        user_id: str = None,
    ):
        self.app_id = app_id
        self.app_sign = app_sign
        self.nonce = nonce
        self.request_id = request_id
        self.role = role
        self.time_stamp = time_stamp
        self.token = token
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.nonce is not None:
            result['Nonce'] = self.nonce
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role is not None:
            result['Role'] = self.role
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.token is not None:
            result['Token'] = self.token
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('Nonce') is not None:
            self.nonce = m.get('Nonce')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GenerateMessageChatTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateMessageChatTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateMessageChatTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAdInsertionRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the ad insertion configuration that you want to query.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetAdInsertionResponseBodyConfigCdnConfig(TeaModel):
    def __init__(
        self,
        ad_segment_url_prefix: str = None,
        content_segment_url_prefix: str = None,
    ):
        # The CDN prefix for accessing ad segments.
        self.ad_segment_url_prefix = ad_segment_url_prefix
        # The CDN prefix for accessing content segments.
        self.content_segment_url_prefix = content_segment_url_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_segment_url_prefix is not None:
            result['AdSegmentUrlPrefix'] = self.ad_segment_url_prefix
        if self.content_segment_url_prefix is not None:
            result['ContentSegmentUrlPrefix'] = self.content_segment_url_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdSegmentUrlPrefix') is not None:
            self.ad_segment_url_prefix = m.get('AdSegmentUrlPrefix')
        if m.get('ContentSegmentUrlPrefix') is not None:
            self.content_segment_url_prefix = m.get('ContentSegmentUrlPrefix')
        return self


class GetAdInsertionResponseBodyConfigManifestEndpointConfig(TeaModel):
    def __init__(
        self,
        dash_prefix: str = None,
        hls_prefix: str = None,
    ):
        # DASH
        self.dash_prefix = dash_prefix
        # The playback endpoint prefix for accessing HLS manifests.
        self.hls_prefix = hls_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dash_prefix is not None:
            result['DashPrefix'] = self.dash_prefix
        if self.hls_prefix is not None:
            result['HlsPrefix'] = self.hls_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashPrefix') is not None:
            self.dash_prefix = m.get('DashPrefix')
        if m.get('HlsPrefix') is not None:
            self.hls_prefix = m.get('HlsPrefix')
        return self


class GetAdInsertionResponseBodyConfig(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_config: GetAdInsertionResponseBodyConfigCdnConfig = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        create_time: str = None,
        last_modified: str = None,
        manifest_endpoint_config: GetAdInsertionResponseBodyConfigManifestEndpointConfig = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Indicates whether ad marker passthrough is enabled.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The URL of the ad decision server (ADS).
        self.ads_url = ads_url
        # The CDN configurations.
        self.cdn_config = cdn_config
        # The aliases for dynamic variable replacement.
        self.config_aliases = config_aliases
        # The prefix of the source URL.
        self.content_url_prefix = content_url_prefix
        # The time when the configuration was created.
        self.create_time = create_time
        # The time when the configuration was last modified.
        self.last_modified = last_modified
        # The playback endpoint prefix for accessing manifests.
        self.manifest_endpoint_config = manifest_endpoint_config
        # The name of the configuration.
        self.name = name
        # The personalization threshold.
        self.personalization_threshold = personalization_threshold
        # The URL of the slate ad.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        if self.cdn_config:
            self.cdn_config.validate()
        if self.manifest_endpoint_config:
            self.manifest_endpoint_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_config is not None:
            result['CdnConfig'] = self.cdn_config.to_map()
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.manifest_endpoint_config is not None:
            result['ManifestEndpointConfig'] = self.manifest_endpoint_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnConfig') is not None:
            temp_model = GetAdInsertionResponseBodyConfigCdnConfig()
            self.cdn_config = temp_model.from_map(m['CdnConfig'])
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('ManifestEndpointConfig') is not None:
            temp_model = GetAdInsertionResponseBodyConfigManifestEndpointConfig()
            self.manifest_endpoint_config = temp_model.from_map(m['ManifestEndpointConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class GetAdInsertionResponseBody(TeaModel):
    def __init__(
        self,
        config: GetAdInsertionResponseBodyConfig = None,
        request_id: str = None,
    ):
        # The ad insertion configuration.
        self.config = config
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = GetAdInsertionResponseBodyConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAdInsertionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAdInsertionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAdInsertionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAvatarRequest(TeaModel):
    def __init__(
        self,
        avatar_id: str = None,
    ):
        # *   The ID of the digital human.
        # 
        # This parameter is required.
        self.avatar_id = avatar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        return self


class GetAvatarResponseBodyDataAvatar(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_id: str = None,
        avatar_name: str = None,
        avatar_type: str = None,
        height: int = None,
        portrait: str = None,
        thumbnail: str = None,
        transparent: bool = None,
        width: int = None,
    ):
        # The description of the digital human.
        self.avatar_description = avatar_description
        # The ID of the digital human.
        self.avatar_id = avatar_id
        # The name of the digital human.
        self.avatar_name = avatar_name
        # The type of the digital human.
        self.avatar_type = avatar_type
        # The height of the digital human image in pixels.
        self.height = height
        # The media asset ID of the portrait image.
        self.portrait = portrait
        # The thumbnail URL.
        self.thumbnail = thumbnail
        # Indicates whether the digital human supports alpha channels.
        self.transparent = transparent
        # The width of the digital human image in pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.height is not None:
            result['Height'] = self.height
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        if self.transparent is not None:
            result['Transparent'] = self.transparent
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        if m.get('Transparent') is not None:
            self.transparent = m.get('Transparent')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetAvatarResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar: GetAvatarResponseBodyDataAvatar = None,
    ):
        # The information about the digital human.
        self.avatar = avatar

    def validate(self):
        if self.avatar:
            self.avatar.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['Avatar'] = self.avatar.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avatar') is not None:
            temp_model = GetAvatarResponseBodyDataAvatar()
            self.avatar = temp_model.from_map(m['Avatar'])
        return self


class GetAvatarResponseBody(TeaModel):
    def __init__(
        self,
        data: GetAvatarResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetAvatarResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAvatarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAvatarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAvatarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAvatarTrainingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_id: str = None,
        avatar_name: str = None,
        avatar_type: str = None,
        first_training_time: str = None,
        job_id: str = None,
        last_training_time: str = None,
        message: str = None,
        portrait: str = None,
        status: str = None,
        thumbnail: str = None,
        transparent: bool = None,
        video: str = None,
    ):
        # The description of the digital human.
        self.avatar_description = avatar_description
        # The ID of the digital human.
        self.avatar_id = avatar_id
        # The name of the digital human.
        self.avatar_name = avatar_name
        # The type of the digital human.
        self.avatar_type = avatar_type
        # *   The time when the first training was initiated.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.first_training_time = first_training_time
        # The ID of the digital human training job.
        self.job_id = job_id
        # *   The time when the last training was initiated.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.last_training_time = last_training_time
        # The status description.
        self.message = message
        # The media asset ID of the portrait image.
        self.portrait = portrait
        # *   The state of the digital human training job.
        # *   Valid values: Init, Queuing, Training, Success, and Fail.
        self.status = status
        # The thumbnail URL.
        self.thumbnail = thumbnail
        # Indicates whether the input video supports alpha channels.
        self.transparent = transparent
        # The ID of the video used for training.
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.first_training_time is not None:
            result['FirstTrainingTime'] = self.first_training_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.last_training_time is not None:
            result['LastTrainingTime'] = self.last_training_time
        if self.message is not None:
            result['Message'] = self.message
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.status is not None:
            result['Status'] = self.status
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        if self.transparent is not None:
            result['Transparent'] = self.transparent
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('FirstTrainingTime') is not None:
            self.first_training_time = m.get('FirstTrainingTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LastTrainingTime') is not None:
            self.last_training_time = m.get('LastTrainingTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        if m.get('Transparent') is not None:
            self.transparent = m.get('Transparent')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class GetAvatarTrainingJobResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar_training_job: GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob = None,
    ):
        # The information about the digital human training job.
        self.avatar_training_job = avatar_training_job

    def validate(self):
        if self.avatar_training_job:
            self.avatar_training_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_training_job is not None:
            result['AvatarTrainingJob'] = self.avatar_training_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarTrainingJob') is not None:
            temp_model = GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob()
            self.avatar_training_job = temp_model.from_map(m['AvatarTrainingJob'])
        return self


class GetAvatarTrainingJobResponseBody(TeaModel):
    def __init__(
        self,
        data: GetAvatarTrainingJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned if the request was successful.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetAvatarTrainingJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAvatarTrainingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAvatarTrainingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAvatarTrainingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBatchMediaProducingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the quick video production job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList(TeaModel):
    def __init__(
        self,
        duration: float = None,
        error_code: str = None,
        error_message: str = None,
        job_id: str = None,
        media_id: str = None,
        media_url: str = None,
        project_id: str = None,
        status: str = None,
    ):
        self.duration = duration
        # The error code that is returned if the subjob failed. This parameter is not returned if the subjob is successful.
        self.error_code = error_code
        # The error message that is returned if the subjob failed. This parameter is not returned if the subjob is successful.
        self.error_message = error_message
        # The subjob ID.
        self.job_id = job_id
        # The ID of the output media asset.
        self.media_id = media_id
        # The URL of the output file.
        self.media_url = media_url
        # The ID of the online editing project.
        self.project_id = project_id
        # The subjob state. Valid values:
        # 
        # Init: The subjob is initialized.
        # 
        # Processing: The subjob is in progress.
        # 
        # Success: The subjob is successful.
        # 
        # Failed: The subjob failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetBatchMediaProducingJobResponseBodyEditingBatchJob(TeaModel):
    def __init__(
        self,
        complete_time: str = None,
        create_time: str = None,
        editing_config: str = None,
        extend: str = None,
        input_config: str = None,
        job_id: str = None,
        job_type: str = None,
        modified_time: str = None,
        output_config: str = None,
        status: str = None,
        sub_job_list: List[GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList] = None,
        user_data: str = None,
    ):
        # The time when the job was complete.
        # 
        # The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The editing configurations. For more information, see [EditingConfig](~~2692547#1be9bba03b7qu~~).
        self.editing_config = editing_config
        # The extended information. This parameter contains the following fields:
        # 
        # ErrorCode: the error code of the main job.
        # 
        # ErrorMessage: the error message of the main job.
        self.extend = extend
        # The input configurations. For more information, see [InputConfig](~~2692547#2faed1559549n~~).
        self.input_config = input_config
        # The job ID.
        self.job_id = job_id
        self.job_type = job_type
        # The time when the job was last modified.
        # 
        # The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modified_time = modified_time
        # The output configurations. For more information, see [OutputConfig](~~2692547#447b928fcbuoa~~).
        self.output_config = output_config
        # The job state. Valid values:
        # 
        # Init: The job is initialized.
        # 
        # Processing: The job is in progress.
        # 
        # Finished: The job is complete.
        self.status = status
        # The quick video production subjobs.
        self.sub_job_list = sub_job_list
        # The user-defined data, including the business and callback configurations. For more information, see [UserData](https://help.aliyun.com/document_detail/357745.html).
        self.user_data = user_data

    def validate(self):
        if self.sub_job_list:
            for k in self.sub_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.status is not None:
            result['Status'] = self.status
        result['SubJobList'] = []
        if self.sub_job_list is not None:
            for k in self.sub_job_list:
                result['SubJobList'].append(k.to_map() if k else None)
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.sub_job_list = []
        if m.get('SubJobList') is not None:
            for k in m.get('SubJobList'):
                temp_model = GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList()
                self.sub_job_list.append(temp_model.from_map(k))
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetBatchMediaProducingJobResponseBody(TeaModel):
    def __init__(
        self,
        editing_batch_job: GetBatchMediaProducingJobResponseBodyEditingBatchJob = None,
        request_id: str = None,
    ):
        # The information about the quick video production job.
        self.editing_batch_job = editing_batch_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.editing_batch_job:
            self.editing_batch_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_batch_job is not None:
            result['EditingBatchJob'] = self.editing_batch_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingBatchJob') is not None:
            temp_model = GetBatchMediaProducingJobResponseBodyEditingBatchJob()
            self.editing_batch_job = temp_model.from_map(m['EditingBatchJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetBatchMediaProducingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBatchMediaProducingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBatchMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCategoriesRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        type: str = None,
    ):
        # The category ID. You can use one of the following methods to obtain the ID:
        # 
        # *   Log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com) and choose **Media Asset Management** > **Category Management** to view the category ID.
        # *   View the value of CateId returned by the AddCategory operation that you called to create a category.
        # *   View the value of CateId returned by the GetCategories operation that you called to query a category.
        self.cate_id = cate_id
        # The page number. Default value: 1
        self.page_no = page_no
        # The number of entries per page. Valid values: 10 to 100.
        self.page_size = page_size
        # The sorting rule of results. Valid values:
        # 
        # \\- CreationTime:Desc (default): The results are sorted in reverse chronological order based on the creation time.
        # 
        # \\- CreationTime:Asc: The results are sorted in chronological order based on the creation time.
        self.sort_by = sort_by
        # The type of the category. Valid values: default and material. A value of default indicates audio, video, and image files. This is the default value. A value of material indicates short video materials.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodyCategory(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cate_name: str = None,
        level: int = None,
        parent_id: int = None,
        type: str = None,
    ):
        # The category ID.
        self.cate_id = cate_id
        # The category name.
        self.cate_name = cate_name
        # The level of the category. A value of **0** indicates a level-1 category, a value of **1** indicates a level-2 category, and a value of **2** indicates a level-3 category.
        self.level = level
        # The ID of the parent category.
        self.parent_id = parent_id
        # The type of the category. Valid values:
        # 
        # *   **default**: audio, video, and image files. This is the default value.
        # *   **material**: short video materials.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodySubCategoriesCategory(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cate_name: str = None,
        level: int = None,
        parent_id: int = None,
        sub_total: int = None,
        type: str = None,
    ):
        # The category ID.
        self.cate_id = cate_id
        # The category name.
        # 
        # *   The value can be up to 64 bytes in length.
        # *   The value is encoded in UTF-8.
        self.cate_name = cate_name
        # The level of the category. A value of **0** indicates a level-1 category, a value of **1** indicates a level-2 category, and a value of **2** indicates a level-3 category.
        self.level = level
        # The ID of the parent category.
        self.parent_id = parent_id
        # The total number of subcategories.
        self.sub_total = sub_total
        # The type of the category. Valid values:
        # 
        # *   **default**: audio, video, and image files. This is the default value.
        # *   **material**: short video materials.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.sub_total is not None:
            result['SubTotal'] = self.sub_total
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SubTotal') is not None:
            self.sub_total = m.get('SubTotal')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodySubCategories(TeaModel):
    def __init__(
        self,
        category: List[GetCategoriesResponseBodySubCategoriesCategory] = None,
    ):
        self.category = category

    def validate(self):
        if self.category:
            for k in self.category:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Category'] = []
        if self.category is not None:
            for k in self.category:
                result['Category'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.category = []
        if m.get('Category') is not None:
            for k in m.get('Category'):
                temp_model = GetCategoriesResponseBodySubCategoriesCategory()
                self.category.append(temp_model.from_map(k))
        return self


class GetCategoriesResponseBody(TeaModel):
    def __init__(
        self,
        category: GetCategoriesResponseBodyCategory = None,
        request_id: str = None,
        sub_categories: GetCategoriesResponseBodySubCategories = None,
        sub_total: int = None,
    ):
        # The information about the category.
        self.category = category
        # The request ID.
        self.request_id = request_id
        # The subcategories in the category.
        self.sub_categories = sub_categories
        # The total number of subcategories.
        self.sub_total = sub_total

    def validate(self):
        if self.category:
            self.category.validate()
        if self.sub_categories:
            self.sub_categories.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_categories is not None:
            result['SubCategories'] = self.sub_categories.to_map()
        if self.sub_total is not None:
            result['SubTotal'] = self.sub_total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = GetCategoriesResponseBodyCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubCategories') is not None:
            temp_model = GetCategoriesResponseBodySubCategories()
            self.sub_categories = temp_model.from_map(m['SubCategories'])
        if m.get('SubTotal') is not None:
            self.sub_total = m.get('SubTotal')
        return self


class GetCategoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCategoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCategoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        return self


class GetChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel: ChannelAssemblyChannel = None,
        request_id: str = None,
    ):
        # The channel information.
        self.channel = channel
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.channel:
            self.channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channel') is not None:
            temp_model = ChannelAssemblyChannel()
            self.channel = temp_model.from_map(m['Channel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig(TeaModel):
    def __init__(
        self,
        auto: bool = None,
        save_type: str = None,
        template_id: str = None,
    ):
        self.auto = auto
        self.save_type = save_type
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto is not None:
            result['Auto'] = self.auto
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Auto') is not None:
            self.auto = m.get('Auto')
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetContentAnalyzeConfigResponseBody(TeaModel):
    def __init__(
        self,
        content_analyze_config: GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig = None,
        request_id: str = None,
    ):
        self.content_analyze_config = content_analyze_config
        self.request_id = request_id

    def validate(self):
        if self.content_analyze_config:
            self.content_analyze_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_analyze_config is not None:
            result['ContentAnalyzeConfig'] = self.content_analyze_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentAnalyzeConfig') is not None:
            temp_model = GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig()
            self.content_analyze_config = temp_model.from_map(m['ContentAnalyzeConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetContentAnalyzeConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetContentAnalyzeConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetContentAnalyzeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        subtype: int = None,
        template_id: str = None,
        type: int = None,
    ):
        # The template subtype.
        self.subtype = subtype
        # The template ID.
        self.template_id = template_id
        # The ID of the template type that is used to query the default template. This parameter is required if TemplateId is not specified.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint(TeaModel):
    def __init__(
        self,
        bitrate_control_type: str = None,
    ):
        self.bitrate_control_type = bitrate_control_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate_control_type is not None:
            result['BitrateControlType'] = self.bitrate_control_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BitrateControlType') is not None:
            self.bitrate_control_type = m.get('BitrateControlType')
        return self


class GetCustomTemplateResponseBodyCustomTemplateFrontendHint(TeaModel):
    def __init__(
        self,
        transcode_template_hint: GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint = None,
    ):
        self.transcode_template_hint = transcode_template_hint

    def validate(self):
        if self.transcode_template_hint:
            self.transcode_template_hint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.transcode_template_hint is not None:
            result['TranscodeTemplateHint'] = self.transcode_template_hint.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TranscodeTemplateHint') is not None:
            temp_model = GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint()
            self.transcode_template_hint = temp_model.from_map(m['TranscodeTemplateHint'])
        return self


class GetCustomTemplateResponseBodyCustomTemplate(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        frontend_hint: GetCustomTemplateResponseBodyCustomTemplateFrontendHint = None,
        is_default: bool = None,
        modified_time: str = None,
        status: str = None,
        subtype: int = None,
        subtype_name: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
        type: int = None,
        type_name: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        self.frontend_hint = frontend_hint
        # Indicates whether the template is the default template.
        self.is_default = is_default
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The template state.
        self.status = status
        # The subtype ID of the template.
        self.subtype = subtype
        # The subtype name of the template.
        self.subtype_name = subtype_name
        # The template parameters.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type ID of the template.
        self.type = type
        # The type name of the template.
        self.type_name = type_name

    def validate(self):
        if self.frontend_hint:
            self.frontend_hint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.frontend_hint is not None:
            result['FrontendHint'] = self.frontend_hint.to_map()
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FrontendHint') is not None:
            temp_model = GetCustomTemplateResponseBodyCustomTemplateFrontendHint()
            self.frontend_hint = temp_model.from_map(m['FrontendHint'])
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        custom_template: GetCustomTemplateResponseBodyCustomTemplate = None,
        request_id: str = None,
    ):
        # The template information.
        self.custom_template = custom_template
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.custom_template:
            self.custom_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            temp_model = GetCustomTemplateResponseBodyCustomTemplate()
            self.custom_template = temp_model.from_map(m['CustomTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomizedVoiceRequest(TeaModel):
    def __init__(
        self,
        voice_id: str = None,
    ):
        # The voice ID.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class GetCustomizedVoiceResponseBodyDataCustomizedVoice(TeaModel):
    def __init__(
        self,
        demo_audio_media_id: str = None,
        gender: str = None,
        scenario: str = None,
        voice_desc: str = None,
        voice_id: str = None,
        voice_name: str = None,
    ):
        # The media asset ID of the sample audio file.
        self.demo_audio_media_id = demo_audio_media_id
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        self.gender = gender
        # The demonstration scenario.
        # 
        # Valid values:
        # 
        # *   **story**\
        # *   **interaction**\
        # *   **navigation**\
        self.scenario = scenario
        # The voice description.
        self.voice_desc = voice_desc
        # The voice ID.
        self.voice_id = voice_id
        # The voice name.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_audio_media_id is not None:
            result['DemoAudioMediaId'] = self.demo_audio_media_id
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.voice_desc is not None:
            result['VoiceDesc'] = self.voice_desc
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoAudioMediaId') is not None:
            self.demo_audio_media_id = m.get('DemoAudioMediaId')
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('VoiceDesc') is not None:
            self.voice_desc = m.get('VoiceDesc')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class GetCustomizedVoiceResponseBodyData(TeaModel):
    def __init__(
        self,
        customized_voice: GetCustomizedVoiceResponseBodyDataCustomizedVoice = None,
    ):
        # The personalized human voice.
        self.customized_voice = customized_voice

    def validate(self):
        if self.customized_voice:
            self.customized_voice.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.customized_voice is not None:
            result['CustomizedVoice'] = self.customized_voice.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomizedVoice') is not None:
            temp_model = GetCustomizedVoiceResponseBodyDataCustomizedVoice()
            self.customized_voice = temp_model.from_map(m['CustomizedVoice'])
        return self


class GetCustomizedVoiceResponseBody(TeaModel):
    def __init__(
        self,
        data: GetCustomizedVoiceResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetCustomizedVoiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomizedVoiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomizedVoiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomizedVoiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the human voice cloning job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        gender: str = None,
        job_id: str = None,
        message: str = None,
        scenario: str = None,
        status: str = None,
        type: str = None,
        voice_desc: str = None,
        voice_id: str = None,
        voice_name: str = None,
    ):
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        self.gender = gender
        # The ID of the human voice cloning job.
        self.job_id = job_id
        # The status description.
        self.message = message
        # The scenario. Valid values:
        # 
        # *   story
        # *   interaction
        # *   navigation
        self.scenario = scenario
        # The job state. Valid values:
        # 
        # *   Initialization
        # *   AudioDetecting
        # *   PreTraining
        # *   Training
        # *   Success
        # *   Fail
        self.status = status
        # The type of the human voice cloning job. Valid values:
        # 
        # *   Basic
        # *   Standard
        self.type = type
        # The voice description.
        self.voice_desc = voice_desc
        # The voice ID.
        self.voice_id = voice_id
        # The voice name.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.voice_desc is not None:
            result['VoiceDesc'] = self.voice_desc
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VoiceDesc') is not None:
            self.voice_desc = m.get('VoiceDesc')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class GetCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        customized_voice_job: GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob = None,
    ):
        # The information about the human voice cloning job.
        self.customized_voice_job = customized_voice_job

    def validate(self):
        if self.customized_voice_job:
            self.customized_voice_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.customized_voice_job is not None:
            result['CustomizedVoiceJob'] = self.customized_voice_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomizedVoiceJob') is not None:
            temp_model = GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob()
            self.customized_voice_job = temp_model.from_map(m['CustomizedVoiceJob'])
        return self


class GetCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: GetCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned if the request was successful.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDefaultStorageLocationResponseBody(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        path: str = None,
        request_id: str = None,
        status: str = None,
        storage_type: str = None,
    ):
        self.bucket = bucket
        self.path = path
        self.request_id = request_id
        self.status = status
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.path is not None:
            result['Path'] = self.path
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class GetDefaultStorageLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDefaultStorageLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDefaultStorageLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDemonstrationForCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        scenario: str = None,
    ):
        # The demonstration scenario.
        # 
        # Valid values:
        # 
        # *   **story**\
        # *   **interaction**\
        # *   **navigation**\
        # 
        # This parameter is required.
        self.scenario = scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        return self


class GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList(TeaModel):
    def __init__(
        self,
        audio_id: int = None,
        demo_audio: str = None,
        text: str = None,
    ):
        # The sequence number of the text, which corresponds to the AduioRecordId parameter to be passed during audio check.
        self.audio_id = audio_id
        # The URL of the sample audio.
        # 
        # *   The value is an Object Storage Service (OSS) URL.
        # 
        #     **\
        # 
        #     **Note**: The URL expires in 12 hours.
        self.demo_audio = demo_audio
        # The text content to be read.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_id is not None:
            result['AudioId'] = self.audio_id
        if self.demo_audio is not None:
            result['DemoAudio'] = self.demo_audio
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioId') is not None:
            self.audio_id = m.get('AudioId')
        if m.get('DemoAudio') is not None:
            self.demo_audio = m.get('DemoAudio')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class GetDemonstrationForCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        demonstration_list: List[GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList] = None,
    ):
        # A list of 20 text entries to be read and the corresponding sample audio.
        self.demonstration_list = demonstration_list

    def validate(self):
        if self.demonstration_list:
            for k in self.demonstration_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DemonstrationList'] = []
        if self.demonstration_list is not None:
            for k in self.demonstration_list:
                result['DemonstrationList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.demonstration_list = []
        if m.get('DemonstrationList') is not None:
            for k in m.get('DemonstrationList'):
                temp_model = GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList()
                self.demonstration_list.append(temp_model.from_map(k))
        return self


class GetDemonstrationForCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDemonstrationForCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDemonstrationForCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDemonstrationForCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDemonstrationForCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDemonstrationForCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDynamicImageJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket.
        self.bucket = bucket
        # The OSS location.
        self.location = location
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        oss_file: GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  OSS://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The three key elements of OSS.
        self.oss_file = oss_file
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        self.type = type

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket.
        self.bucket = bucket
        # The OSS location.
        self.location = location
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        oss_file: GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  OSS://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The three key elements of OSS.
        self.oss_file = oss_file
        # The type of the input file. Valid values: OSS: an OSS object. Media: a media asset.
        self.type = type

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        create_time: str = None,
        finish_time: str = None,
        input: GetDynamicImageJobResponseBodyDynamicImageJobInput = None,
        job_id: str = None,
        message: str = None,
        modified_time: str = None,
        name: str = None,
        output: GetDynamicImageJobResponseBodyDynamicImageJobOutput = None,
        output_url: str = None,
        pipeline_id: str = None,
        status: str = None,
        submit_time: str = None,
        template_config: str = None,
        template_id: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # Error codes
        self.code = code
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The error message that is returned.
        self.message = message
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The URL of the output animated image.
        self.output_url = output_url
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The animation template configuration.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The request trigger source.
        # 
        # Valid values:
        # 
        # *   Console
        # *   Workflow
        # *   API
        self.trigger_source = trigger_source
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetDynamicImageJobResponseBody(TeaModel):
    def __init__(
        self,
        dynamic_image_job: GetDynamicImageJobResponseBodyDynamicImageJob = None,
        request_id: str = None,
    ):
        # The information about the snapshot job.
        self.dynamic_image_job = dynamic_image_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dynamic_image_job:
            self.dynamic_image_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_image_job is not None:
            result['DynamicImageJob'] = self.dynamic_image_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DynamicImageJob') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJob()
            self.dynamic_image_job = temp_model.from_map(m['DynamicImageJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDynamicImageJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDynamicImageJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDynamicImageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEditingProjectRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
        request_source: str = None,
    ):
        # The ID of the online editing project.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the request source. Valid values:
        # 
        # \\- OpenAPI (default): Timeline conversion is not performed.
        # 
        # \\- WebSDK: If you specify this value, the project timeline is automatically converted into the frontend style, and the materials in the timeline are associated with the project to enable preview by using frontend web SDKs.
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class GetEditingProjectResponseBodyProject(TeaModel):
    def __init__(
        self,
        business_config: str = None,
        business_status: str = None,
        clips_param: str = None,
        cover_url: str = None,
        create_source: str = None,
        create_time: str = None,
        description: str = None,
        duration: int = None,
        modified_source: str = None,
        modified_time: str = None,
        project_id: str = None,
        project_type: str = None,
        status: str = None,
        template_id: str = None,
        template_type: str = None,
        timeline: str = None,
        timeline_convert_error_message: str = None,
        timeline_convert_status: str = None,
        title: str = None,
    ):
        # The business configuration of the project. This parameter can be ignored for general editing projects.
        self.business_config = business_config
        # The business status of the project. This parameter can be ignored for general editing projects. Valid values:
        # 
        # Reserving
        # 
        # ReservationCanceled
        # 
        # BroadCasting
        # 
        # LoadingFailed
        # 
        # LiveFinished
        self.business_status = business_status
        # The material parameter corresponding to the template, in the JSON format. If TemplateId is specified, ClipsParam must also be specified. For more information<props="china">, see [Create and use a regular template](https://help.aliyun.com/document_detail/328557.html) and [Create and use an advanced template](https://help.aliyun.com/document_detail/291418.html).
        self.clips_param = clips_param
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The method for creating the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        # 
        # \\- LiveEditingOpenAPI
        # 
        # \\- LiveEditingConsole
        self.create_source = create_source
        # The time when the online editing project was created.
        self.create_time = create_time
        # The description of the online editing project.
        self.description = description
        # The total duration of the online editing project.
        self.duration = duration
        # The method for editing the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        # 
        # \\- LiveEditingOpenAPI
        # 
        # \\- LiveEditingConsole
        self.modified_source = modified_source
        # The time when the online editing project was last modified.
        self.modified_time = modified_time
        # The ID of the online editing project.
        self.project_id = project_id
        # The type of the editing project. Default value: EditingProject. Valid values:
        # 
        # \\- EditingProject: a regular editing project.
        # 
        # \\- LiveEditingProject: a live stream editing project.
        self.project_type = project_type
        # The status of the online editing project. Valid values:
        # 
        # \\- Draft
        # 
        # \\- Editing
        # 
        # \\- Producing
        # 
        # \\- Produced
        # 
        # \\- ProduceFailed
        # 
        # \\- Deleted
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The template type of the online editing project. Valid values:
        # 
        # \\- Timeline
        # 
        # \\- VETemplate
        self.template_type = template_type
        # The timeline of the online editing project.
        self.timeline = timeline
        # The error message returned if the project conversion failed. The error message displays the detailed information about the failure, and is returned only if the value of TimelineConvertStatus is ConvertFailed.
        self.timeline_convert_error_message = timeline_convert_error_message
        # The project conversion status. Conversion of an API-style timeline into a frontend-style timeline is an asynchronous process and takes effect only if RequestSource:WebSDK is specified.
        # 
        # \\- Unconverted
        # 
        # \\- Converting
        # 
        # \\- Converted
        # 
        # \\- ConvertFailed
        self.timeline_convert_status = timeline_convert_status
        # The title of the online editing project.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.timeline_convert_error_message is not None:
            result['TimelineConvertErrorMessage'] = self.timeline_convert_error_message
        if self.timeline_convert_status is not None:
            result['TimelineConvertStatus'] = self.timeline_convert_status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('TimelineConvertErrorMessage') is not None:
            self.timeline_convert_error_message = m.get('TimelineConvertErrorMessage')
        if m.get('TimelineConvertStatus') is not None:
            self.timeline_convert_status = m.get('TimelineConvertStatus')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetEditingProjectResponseBody(TeaModel):
    def __init__(
        self,
        project: GetEditingProjectResponseBodyProject = None,
        request_id: str = None,
    ):
        # The information about the online editing project.
        self.project = project
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = GetEditingProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEditingProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEditingProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEditingProjectMaterialsRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
    ):
        # The ID of the online editing project.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetEditingProjectMaterialsResponseBodyLiveMaterials(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        live_url: str = None,
        stream_name: str = None,
    ):
        # The application name of the live stream.
        self.app_name = app_name
        # The domain name of the live stream.
        self.domain_name = domain_name
        # The URL of the live stream.
        self.live_url = live_url
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_url is not None:
            result['LiveUrl'] = self.live_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveUrl') is not None:
            self.live_url = m.get('LiveUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The Object Storage Service (OSS) URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo = None,
    ):
        # The basic information of the file, such as the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        user_data: str = None,
    ):
        # The business type of the media asset.
        self.business_type = business_type
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The URL of the media asset in another service.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset.
        self.source = source
        # The sprite of the media asset
        self.sprite_images = sprite_images
        # The status of the media asset.
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        # 
        # Valid values:
        # 
        # *   TranscodeSuccess: transcoding completed.
        # *   TranscodeFailed: transcoding failed.
        # *   Init: initializing.
        # *   Transcoding: transcoding in progress.
        self.transcode_status = transcode_status
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfos(TeaModel):
    def __init__(
        self,
        file_info_list: List[GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList] = None,
        media_basic_info: GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo = None,
        media_id: str = None,
    ):
        # The information about the file.
        self.file_info_list = file_info_list
        # The basic information of the media asset.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(
        self,
        live_materials: List[GetEditingProjectMaterialsResponseBodyLiveMaterials] = None,
        media_infos: List[GetEditingProjectMaterialsResponseBodyMediaInfos] = None,
        project_id: str = None,
        project_materials: List[str] = None,
        request_id: str = None,
    ):
        # The materials associated with the live stream.
        self.live_materials = live_materials
        # The media assets that meet the specified conditions.
        self.media_infos = media_infos
        # The project ID.
        self.project_id = project_id
        # The materials associated with the editing project. A live stream editing project will be associated with a regular editing project after the live streaming ends.
        self.project_materials = project_materials
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_materials:
            for k in self.live_materials:
                if k:
                    k.validate()
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveMaterials'] = []
        if self.live_materials is not None:
            for k in self.live_materials:
                result['LiveMaterials'].append(k.to_map() if k else None)
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_materials is not None:
            result['ProjectMaterials'] = self.project_materials
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_materials = []
        if m.get('LiveMaterials') is not None:
            for k in m.get('LiveMaterials'):
                temp_model = GetEditingProjectMaterialsResponseBodyLiveMaterials()
                self.live_materials.append(temp_model.from_map(k))
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = GetEditingProjectMaterialsResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMaterials') is not None:
            self.project_materials = m.get('ProjectMaterials')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEditingProjectMaterialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEditingProjectMaterialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEventCallbackResponseBody(TeaModel):
    def __init__(
        self,
        auth_key: str = None,
        auth_switch: str = None,
        callback_queue_name: str = None,
        callback_type: str = None,
        callback_url: str = None,
        event_type_list: str = None,
        request_id: str = None,
    ):
        # The authentication key. This parameter is returned only for HTTP callbacks.
        self.auth_key = auth_key
        # Specifies whether callback authentication is enabled. This parameter is returned only for **HTTP** callbacks. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.auth_switch = auth_switch
        # The name of the Simple Message Queue (SMQ) queue to which callback messages are sent.
        self.callback_queue_name = callback_queue_name
        # The callback method. Valid values:
        # 
        # *   **HTTP**\
        # *   **MNS**\
        self.callback_type = callback_type
        # The callback URL to which event notifications are sent.
        self.callback_url = callback_url
        # The type of the callback event. Multiple values are separated with commas (,). For more information about callback event types, see [Event notification content](https://help.aliyun.com/document_detail/610204.html).
        self.event_type_list = event_type_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.auth_switch is not None:
            result['AuthSwitch'] = self.auth_switch
        if self.callback_queue_name is not None:
            result['CallbackQueueName'] = self.callback_queue_name
        if self.callback_type is not None:
            result['CallbackType'] = self.callback_type
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('AuthSwitch') is not None:
            self.auth_switch = m.get('AuthSwitch')
        if m.get('CallbackQueueName') is not None:
            self.callback_queue_name = m.get('CallbackQueueName')
        if m.get('CallbackType') is not None:
            self.callback_type = m.get('CallbackType')
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEventCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEventCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEventCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHotwordLibraryRequest(TeaModel):
    def __init__(
        self,
        hotword_library_id: str = None,
    ):
        # This parameter is required.
        self.hotword_library_id = hotword_library_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        return self


class GetHotwordLibraryResponseBody(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        hotword_library_id: str = None,
        hotwords: List[Hotword] = None,
        name: str = None,
        request_id: str = None,
        usage_scenario: str = None,
    ):
        self.creation_time = creation_time
        self.description = description
        self.hotword_library_id = hotword_library_id
        self.hotwords = hotwords
        self.name = name
        # Id of the request
        self.request_id = request_id
        self.usage_scenario = usage_scenario

    def validate(self):
        if self.hotwords:
            for k in self.hotwords:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        result['Hotwords'] = []
        if self.hotwords is not None:
            for k in self.hotwords:
                result['Hotwords'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.usage_scenario is not None:
            result['UsageScenario'] = self.usage_scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        self.hotwords = []
        if m.get('Hotwords') is not None:
            for k in m.get('Hotwords'):
                temp_model = Hotword()
                self.hotwords.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UsageScenario') is not None:
            self.usage_scenario = m.get('UsageScenario')
        return self


class GetHotwordLibraryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHotwordLibraryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHotwordLibraryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveEditingIndexFileRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        project_id: str = None,
        stream_name: str = None,
    ):
        # The application name of the live stream.
        self.app_name = app_name
        # The domain name of the live stream.
        self.domain_name = domain_name
        # The ID of the live stream editing project.
        self.project_id = project_id
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetLiveEditingIndexFileResponseBody(TeaModel):
    def __init__(
        self,
        index_file: str = None,
        request_id: str = None,
    ):
        # The URL of the index file.
        self.index_file = index_file
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_file is not None:
            result['IndexFile'] = self.index_file
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexFile') is not None:
            self.index_file = m.get('IndexFile')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveEditingIndexFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveEditingIndexFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveEditingIndexFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveEditingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the live editing job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The domain name of the live stream.
        self.domain_name = domain_name
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig(TeaModel):
    def __init__(
        self,
        mode: str = None,
    ):
        # The editing mode. Default value: Accurate.
        self.mode = mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        file_name: str = None,
        height: int = None,
        media_url: str = None,
        storage_location: str = None,
        vod_template_group_id: str = None,
        width: int = None,
    ):
        # The bitrate of the output file. Unit: Kbit/s. You can leave this parameter empty. The default value is the maximum bitrate of the input materials.
        self.bitrate = bitrate
        # If OutputMediaTarget is set to vod-media, this parameter indicates the file name of the output file. The value contains the file name extension but not the path.
        self.file_name = file_name
        # The height of the output file. You can leave this parameter empty. The default value is the maximum height of the input materials.
        self.height = height
        # The URL of the output file.
        self.media_url = media_url
        # If OutputMediaTarget is set to vod-media, this parameter indicates the storage location of the media asset in ApsaraVideo VOD. The storage location is the path of the file in ApsaraVideo VOD, excluding the prefix http://. Example: outin-xxxxxx.oss-cn-shanghai.aliyuncs.com.
        self.storage_location = storage_location
        # The ID of the VOD transcoding template group. If VOD transcoding is not required, set the value to VOD_NO_TRANSCODE.
        self.vod_template_group_id = vod_template_group_id
        # The width of the output file. You can leave this parameter empty. The default value is the maximum width of the input materials.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.vod_template_group_id is not None:
            result['VodTemplateGroupId'] = self.vod_template_group_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('VodTemplateGroupId') is not None:
            self.vod_template_group_id = m.get('VodTemplateGroupId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJob(TeaModel):
    def __init__(
        self,
        clips: str = None,
        code: str = None,
        complete_time: str = None,
        creation_time: str = None,
        job_id: str = None,
        live_stream_config: GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig = None,
        media_id: str = None,
        media_produce_config: GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig = None,
        media_url: str = None,
        message: str = None,
        modified_time: str = None,
        output_media_config: GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig = None,
        project_id: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The clips.
        self.clips = clips
        # The response code. Note: Pay attention to this parameter if the job failed.
        self.code = code
        # The time when the live editing job was completed. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the live editing job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The ID of the live editing job.
        self.job_id = job_id
        # The live editing configurations.
        self.live_stream_config = live_stream_config
        # The media asset ID of the output file.
        self.media_id = media_id
        # The production configurations.
        self.media_produce_config = media_produce_config
        # The URL of the output file.
        self.media_url = media_url
        # The returned message. Note: Pay attention to this parameter if the job failed.
        self.message = message
        # The time when the live editing job was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modified_time = modified_time
        # The storage configurations of the output file.
        self.output_media_config = output_media_config
        # The ID of the live editing project.
        self.project_id = project_id
        # The state of the live editing job. Valid values: Init, Queuing, Processing, Success, and Failed.
        self.status = status
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.live_stream_config:
            self.live_stream_config.validate()
        if self.media_produce_config:
            self.media_produce_config.validate()
        if self.output_media_config:
            self.output_media_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips
        if self.code is not None:
            result['Code'] = self.code
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.live_stream_config is not None:
            result['LiveStreamConfig'] = self.live_stream_config.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_produce_config is not None:
            result['MediaProduceConfig'] = self.media_produce_config.to_map()
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clips') is not None:
            self.clips = m.get('Clips')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LiveStreamConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig()
            self.live_stream_config = temp_model.from_map(m['LiveStreamConfig'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaProduceConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig()
            self.media_produce_config = temp_model.from_map(m['MediaProduceConfig'])
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputMediaConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig()
            self.output_media_config = temp_model.from_map(m['OutputMediaConfig'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetLiveEditingJobResponseBody(TeaModel):
    def __init__(
        self,
        live_editing_job: GetLiveEditingJobResponseBodyLiveEditingJob = None,
        request_id: str = None,
    ):
        # The information about the live editing job.
        self.live_editing_job = live_editing_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_editing_job:
            self.live_editing_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_editing_job is not None:
            result['LiveEditingJob'] = self.live_editing_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveEditingJob') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJob()
            self.live_editing_job = temp_model.from_map(m['LiveEditingJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveEditingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveEditingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveEditingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLivePackageChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(TeaModel):
    def __init__(
        self,
        id: str = None,
        password: str = None,
        url: str = None,
        username: str = None,
    ):
        # The ingest endpoint ID.
        self.id = id
        # The password.
        self.password = password
        # The ingest endpoint URL.
        self.url = url
        # The username.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.password is not None:
            result['Password'] = self.password
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class GetLivePackageChannelResponseBodyLivePackageChannel(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        ingest_endpoints: List[GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints] = None,
        last_modified: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name.
        self.channel_name = channel_name
        # The time when the channel was created.
        self.create_time = create_time
        # The channel description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The ingest endpoints.
        self.ingest_endpoints = ingest_endpoints
        # The time when the endpoint was last modified.
        self.last_modified = last_modified
        # The ingest protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of M3U8 segments.
        self.segment_count = segment_count
        # The segment duration.
        self.segment_duration = segment_duration

    def validate(self):
        if self.ingest_endpoints:
            for k in self.ingest_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        result['IngestEndpoints'] = []
        if self.ingest_endpoints is not None:
            for k in self.ingest_endpoints:
                result['IngestEndpoints'].append(k.to_map() if k else None)
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        self.ingest_endpoints = []
        if m.get('IngestEndpoints') is not None:
            for k in m.get('IngestEndpoints'):
                temp_model = GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints()
                self.ingest_endpoints.append(temp_model.from_map(k))
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class GetLivePackageChannelResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel: GetLivePackageChannelResponseBodyLivePackageChannel = None,
        request_id: str = None,
    ):
        # Details of the live package channel.
        self.live_package_channel = live_package_channel
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel:
            self.live_package_channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel is not None:
            result['LivePackageChannel'] = self.live_package_channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannel') is not None:
            temp_model = GetLivePackageChannelResponseBodyLivePackageChannel()
            self.live_package_channel = temp_model.from_map(m['LivePackageChannel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLivePackageChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLivePackageChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLivePackageChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLivePackageChannelGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        last_modified: str = None,
        origin_domain: str = None,
    ):
        # The time when the channel group was created. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.create_time = create_time
        # The channel group description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The time when the channel group was last modified. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.last_modified = last_modified
        # The origin domain.
        self.origin_domain = origin_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.origin_domain is not None:
            result['OriginDomain'] = self.origin_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OriginDomain') is not None:
            self.origin_domain = m.get('OriginDomain')
        return self


class GetLivePackageChannelGroupResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel_group: GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup = None,
        request_id: str = None,
    ):
        # Details of the channel group.
        self.live_package_channel_group = live_package_channel_group
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel_group:
            self.live_package_channel_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel_group is not None:
            result['LivePackageChannelGroup'] = self.live_package_channel_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannelGroup') is not None:
            temp_model = GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup()
            self.live_package_channel_group = temp_model.from_map(m['LivePackageChannelGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLivePackageChannelGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLivePackageChannelGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLivePackageChannelGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLivePackageOriginEndpointRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        endpoint_name: str = None,
        group_name: str = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The endpoint name.
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        endpoint_name: str = None,
        endpoint_url: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        last_modified: str = None,
        live_packaging_config: LivePackagingConfig = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code.
        self.authorization_code = authorization_code
        # The channel name.
        self.channel_name = channel_name
        # The time when the endpoint was created.
        self.create_time = create_time
        # The endpoint description.
        self.description = description
        # The endpoint name.
        self.endpoint_name = endpoint_name
        # The endpoint URL.
        self.endpoint_url = endpoint_url
        # The channel group name.
        self.group_name = group_name
        # The IP address blacklist.
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist.
        self.ip_whitelist = ip_whitelist
        # The time when the endpoint was last modified.
        self.last_modified = last_modified
        self.live_packaging_config = live_packaging_config
        # The playlist name.
        self.manifest_name = manifest_name
        # The distribution protocol.
        self.protocol = protocol
        # The number of days that time-shifted content is available.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        if self.live_packaging_config:
            self.live_packaging_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_url is not None:
            result['EndpointUrl'] = self.endpoint_url
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.live_packaging_config is not None:
            result['LivePackagingConfig'] = self.live_packaging_config.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointUrl') is not None:
            self.endpoint_url = m.get('EndpointUrl')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('LivePackagingConfig') is not None:
            temp_model = LivePackagingConfig()
            self.live_packaging_config = temp_model.from_map(m['LivePackagingConfig'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class GetLivePackageOriginEndpointResponseBody(TeaModel):
    def __init__(
        self,
        live_package_origin_endpoint: GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint = None,
        request_id: str = None,
    ):
        # The information about the origin endpoints.
        self.live_package_origin_endpoint = live_package_origin_endpoint
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_origin_endpoint:
            self.live_package_origin_endpoint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_origin_endpoint is not None:
            result['LivePackageOriginEndpoint'] = self.live_package_origin_endpoint.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageOriginEndpoint') is not None:
            temp_model = GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint()
            self.live_package_origin_endpoint = temp_model.from_map(m['LivePackageOriginEndpoint'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLivePackageOriginEndpointResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLivePackageOriginEndpointResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLivePackageOriginEndpointResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveRecordJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the recording job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveRecordJobResponseBodyRecordJobRecordOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        type: str = None,
    ):
        # The bucket name.
        self.bucket = bucket
        # The endpoint of the storage service.
        self.endpoint = endpoint
        # The type of the storage address.
        # 
        # Valid values:
        # 
        # *   vod
        # *   oss
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveRecordJobResponseBodyRecordJobStreamInput(TeaModel):
    def __init__(
        self,
        type: str = None,
        url: str = None,
    ):
        # The type of the live stream. The value can only be rtmp.
        self.type = type
        # The URL of the live stream.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetLiveRecordJobResponseBodyRecordJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        name: str = None,
        notify_url: str = None,
        record_output: GetLiveRecordJobResponseBodyRecordJobRecordOutput = None,
        status: str = None,
        stream_input: GetLiveRecordJobResponseBodyRecordJobStreamInput = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The time when the job was created.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.create_time = create_time
        # The ID of the recording job.
        self.job_id = job_id
        # The name of the recording job.
        self.name = name
        # The callback URL.
        self.notify_url = notify_url
        # The storage address of the recording.
        self.record_output = record_output
        # The state of the recording job.
        # 
        # Valid values:
        # 
        # *   paused: The job is paused.
        # *   initial: The job is not started.
        # *   started: The job is in progress.
        self.status = status
        # The URL of the live stream.
        self.stream_input = stream_input
        # The ID of the recording template.
        self.template_id = template_id
        # The name of the recording template.
        self.template_name = template_name

    def validate(self):
        if self.record_output:
            self.record_output.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_output is not None:
            result['RecordOutput'] = self.record_output.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordOutput') is not None:
            temp_model = GetLiveRecordJobResponseBodyRecordJobRecordOutput()
            self.record_output = temp_model.from_map(m['RecordOutput'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = GetLiveRecordJobResponseBodyRecordJobStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class GetLiveRecordJobResponseBody(TeaModel):
    def __init__(
        self,
        record_job: GetLiveRecordJobResponseBodyRecordJob = None,
        request_id: str = None,
    ):
        # The details of the recording job.
        self.record_job = record_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.record_job:
            self.record_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_job is not None:
            result['RecordJob'] = self.record_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordJob') is not None:
            temp_model = GetLiveRecordJobResponseBodyRecordJob()
            self.record_job = temp_model.from_map(m['RecordJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveRecordJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveRecordJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveRecordJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        template_id: str = None,
    ):
        # The ID of the recording job. You can specify the JobId parameter to retrieve the snapshot of the template used by the job.
        self.job_id = job_id
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of the recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.
        self.cycle_duration = cycle_duration
        # The output file format.
        self.format = format
        # The name of the recording file that is stored in Object Storage Service (OSS).
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment. Unit: seconds.
        self.slice_duration = slice_duration
        # The name of the TS segment.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class GetLiveRecordTemplateResponseBodyRecordTemplate(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        last_modified: str = None,
        name: str = None,
        record_format_list: List[GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList] = None,
        template_id: str = None,
        type: str = None,
    ):
        # The time when the job was created.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.create_time = create_time
        # The time when the template was last modified.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.last_modified = last_modified
        # The template name.
        self.name = name
        # The list of recording formats.
        self.record_format_list = record_format_list
        # The template ID.
        self.template_id = template_id
        # The type of the template.
        # 
        # Valid values:
        # 
        # *   system
        # *   custom
        self.type = type

    def validate(self):
        if self.record_format_list:
            for k in self.record_format_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormatList'] = []
        if self.record_format_list is not None:
            for k in self.record_format_list:
                result['RecordFormatList'].append(k.to_map() if k else None)
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format_list = []
        if m.get('RecordFormatList') is not None:
            for k in m.get('RecordFormatList'):
                temp_model = GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList()
                self.record_format_list.append(temp_model.from_map(k))
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        record_template: GetLiveRecordTemplateResponseBodyRecordTemplate = None,
        request_id: str = None,
    ):
        # The recording template.
        self.record_template = record_template
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.record_template:
            self.record_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_template is not None:
            result['RecordTemplate'] = self.record_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordTemplate') is not None:
            temp_model = GetLiveRecordTemplateResponseBodyRecordTemplate()
            self.record_template = temp_model.from_map(m['RecordTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The job ID.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveSnapshotJobResponseBodySnapshotOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        storage_type: str = None,
    ):
        # The bucket of the output endpoint. If the storage type is set to oss, the OSS bucket is returned.
        self.bucket = bucket
        # The output endpoint. If the storage type is set to oss, the Object Storage Service (OSS) domain name is returned.
        self.endpoint = endpoint
        # The storage type. The value can only be oss.
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class GetLiveSnapshotJobResponseBodyStreamInput(TeaModel):
    def __init__(
        self,
        type: str = None,
        url: str = None,
    ):
        # The type of the input stream. The value can only be rtmp.
        self.type = type
        # The URL of the input stream.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetLiveSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        create_time: str = None,
        job_id: str = None,
        job_name: str = None,
        last_modified: str = None,
        overwrite_format: str = None,
        request_id: str = None,
        sequence_format: str = None,
        snapshot_output: GetLiveSnapshotJobResponseBodySnapshotOutput = None,
        status: str = None,
        stream_input: GetLiveSnapshotJobResponseBodyStreamInput = None,
        template_id: str = None,
        template_name: str = None,
        time_interval: int = None,
    ):
        # The snapshot callback URL.
        self.callback_url = callback_url
        # The time when the file was created.
        self.create_time = create_time
        # The job ID.
        self.job_id = job_id
        # The name of the job.
        self.job_name = job_name
        # The time when the file was last modified.
        self.last_modified = last_modified
        # The naming format of the snapshot captured in overwrite mode.
        self.overwrite_format = overwrite_format
        # The request ID.
        self.request_id = request_id
        # The naming format of the snapshot captured in time series mode.
        self.sequence_format = sequence_format
        # The output information.
        self.snapshot_output = snapshot_output
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   init: The job is not started.
        # *   paused: The job is paused.
        # *   started: The job is in progress.
        self.status = status
        # The input information.
        self.stream_input = stream_input
        # The template ID.
        self.template_id = template_id
        # The name of the template.
        self.template_name = template_name
        # The interval between two adjacent snapshots.
        self.time_interval = time_interval

    def validate(self):
        if self.snapshot_output:
            self.snapshot_output.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.overwrite_format is not None:
            result['OverwriteFormat'] = self.overwrite_format
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sequence_format is not None:
            result['SequenceFormat'] = self.sequence_format
        if self.snapshot_output is not None:
            result['SnapshotOutput'] = self.snapshot_output.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OverwriteFormat') is not None:
            self.overwrite_format = m.get('OverwriteFormat')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SequenceFormat') is not None:
            self.sequence_format = m.get('SequenceFormat')
        if m.get('SnapshotOutput') is not None:
            temp_model = GetLiveSnapshotJobResponseBodySnapshotOutput()
            self.snapshot_output = temp_model.from_map(m['SnapshotOutput'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = GetLiveSnapshotJobResponseBodyStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class GetLiveSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveSnapshotTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetLiveSnapshotTemplateResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        last_modified: str = None,
        overwrite_format: str = None,
        request_id: str = None,
        sequence_format: str = None,
        template_id: str = None,
        template_name: str = None,
        time_interval: int = None,
        type: str = None,
    ):
        # The time when the configuration was modified.
        self.create_time = create_time
        # The time when the template was created.
        self.last_modified = last_modified
        # The naming format of the snapshot captured in overwrite mode.
        self.overwrite_format = overwrite_format
        # The request ID.
        self.request_id = request_id
        # The naming format of the snapshot captured in time series mode.
        self.sequence_format = sequence_format
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The interval between two adjacent snapshots.
        self.time_interval = time_interval
        # The type of the template.
        # 
        # Valid values:
        # 
        # *   system
        # *   custom
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.overwrite_format is not None:
            result['OverwriteFormat'] = self.overwrite_format
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sequence_format is not None:
            result['SequenceFormat'] = self.sequence_format
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OverwriteFormat') is not None:
            self.overwrite_format = m.get('OverwriteFormat')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SequenceFormat') is not None:
            self.sequence_format = m.get('SequenceFormat')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveSnapshotTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveSnapshotTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveSnapshotTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the transcoding job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos(TeaModel):
    def __init__(
        self,
        output_url: str = None,
        type: str = None,
    ):
        # The URL of the output stream.
        self.output_url = output_url
        # The type of the output stream protocol. Only the RTMP protocol is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeJobResponseBodyJobOutputStream(TeaModel):
    def __init__(
        self,
        stream_infos: List[GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos] = None,
    ):
        # The information about the output stream.
        self.stream_infos = stream_infos

    def validate(self):
        if self.stream_infos:
            for k in self.stream_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfos'] = []
        if self.stream_infos is not None:
            for k in self.stream_infos:
                result['StreamInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_infos = []
        if m.get('StreamInfos') is not None:
            for k in m.get('StreamInfos'):
                temp_model = GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos()
                self.stream_infos.append(temp_model.from_map(k))
        return self


class GetLiveTranscodeJobResponseBodyJobStreamInput(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        type: str = None,
    ):
        # The URL of the input stream.
        self.input_url = input_url
        # The type of the input stream.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeJobResponseBodyJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        name: str = None,
        output_stream: GetLiveTranscodeJobResponseBodyJobOutputStream = None,
        start_mode: int = None,
        status: int = None,
        stream_input: GetLiveTranscodeJobResponseBodyJobStreamInput = None,
        template_id: str = None,
        template_name: str = None,
        template_type: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The ID of the transcoding job.
        self.job_id = job_id
        # The name of the transcoding job.
        self.name = name
        # The information about the output stream.
        self.output_stream = output_stream
        # The start mode of the job.
        self.start_mode = start_mode
        # The state of the job.
        # 
        # *   0: The job is not started.
        # *   1: The job is in progress.
        # *   2: The job is stopped.
        self.status = status
        # The information about the input stream.
        self.stream_input = stream_input
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type of the template.
        self.template_type = template_type

    def validate(self):
        if self.output_stream:
            self.output_stream.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output_stream is not None:
            result['OutputStream'] = self.output_stream.to_map()
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputStream') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJobOutputStream()
            self.output_stream = temp_model.from_map(m['OutputStream'])
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJobStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class GetLiveTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job: GetLiveTranscodeJobResponseBodyJob = None,
        request_id: str = None,
    ):
        # The information about the transcoding job.
        self.job = job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Job') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        samplerate: str = None,
    ):
        # The bitrate of the output audio.
        self.bitrate = bitrate
        # The number of sound channels.
        self.channels = channels
        # The audio codec.
        self.codec = codec
        # The audio codec profile.
        self.profile = profile
        # The audio sampling rate.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        profile: str = None,
        width: str = None,
    ):
        # The bitrate of the output video.
        self.bitrate = bitrate
        # The encoding type.
        self.codec = codec
        # The frame rate of the output video.
        self.fps = fps
        # The group of pictures (GOP) of the output video.
        self.gop = gop
        # The height of the output video.
        self.height = height
        # The encoding profile.
        self.profile = profile
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig(TeaModel):
    def __init__(
        self,
        audio_params: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams = None,
        video_params: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams = None,
    ):
        # The audio parameters.
        self.audio_params = audio_params
        # The video parameters.
        self.video_params = video_params

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContent(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        name: str = None,
        template_config: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig = None,
        template_id: str = None,
        type: str = None,
    ):
        # The category of the template. Valid values:
        # 
        # *   system
        # *   customized
        self.category = category
        # The time when the template was created.
        self.create_time = create_time
        # The name of the template.
        self.name = name
        # The configuration of the template.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The type of the template.
        self.type = type

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_content: GetLiveTranscodeTemplateResponseBodyTemplateContent = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The content of the template.
        self.template_content = template_content

    def validate(self):
        if self.template_content:
            self.template_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_content is not None:
            result['TemplateContent'] = self.template_content.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateContent') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContent()
            self.template_content = temp_model.from_map(m['TemplateContent'])
        return self


class GetLiveTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaConnectFlowRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        return self


class GetMediaConnectFlowResponseBodyContent(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        flow_failover: str = None,
        flow_id: str = None,
        flow_name: str = None,
        flow_status: str = None,
        start_time: str = None,
    ):
        # The time when the flow was created.
        self.create_time = create_time
        self.flow_failover = flow_failover
        # The flow ID.
        self.flow_id = flow_id
        # The flow name.
        self.flow_name = flow_name
        # The state of the flow.
        self.flow_status = flow_status
        # The time when the flow is started.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.flow_failover is not None:
            result['FlowFailover'] = self.flow_failover
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_name is not None:
            result['FlowName'] = self.flow_name
        if self.flow_status is not None:
            result['FlowStatus'] = self.flow_status
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FlowFailover') is not None:
            self.flow_failover = m.get('FlowFailover')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowName') is not None:
            self.flow_name = m.get('FlowName')
        if m.get('FlowStatus') is not None:
            self.flow_status = m.get('FlowStatus')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetMediaConnectFlowResponseBody(TeaModel):
    def __init__(
        self,
        content: GetMediaConnectFlowResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        retcode: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned code. A value of 0 indicates the call is successful.
        self.retcode = retcode

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.retcode is not None:
            result['Retcode'] = self.retcode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = GetMediaConnectFlowResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Retcode') is not None:
            self.retcode = m.get('Retcode')
        return self


class GetMediaConnectFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaConnectFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaConnectFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaConnectFlowInputRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        return self


class GetMediaConnectFlowInputResponseBodyContent(TeaModel):
    def __init__(
        self,
        backup_cidrs: str = None,
        backup_create_time: str = None,
        backup_input_name: str = None,
        backup_input_status: str = None,
        backup_input_url: str = None,
        backup_max_bitrate: int = None,
        backup_srt_latency: int = None,
        backup_srt_passphrase: str = None,
        backup_srt_pbkey_len: int = None,
        cidrs: str = None,
        create_time: str = None,
        input_name: str = None,
        input_protocol: str = None,
        input_status: str = None,
        input_url: str = None,
        max_bitrate: int = None,
        pair_flow_id: str = None,
        pair_output_name: str = None,
        srt_latency: int = None,
        srt_passphrase: str = None,
        srt_pbkey_len: int = None,
    ):
        self.backup_cidrs = backup_cidrs
        self.backup_create_time = backup_create_time
        self.backup_input_name = backup_input_name
        self.backup_input_status = backup_input_status
        self.backup_input_url = backup_input_url
        self.backup_max_bitrate = backup_max_bitrate
        self.backup_srt_latency = backup_srt_latency
        self.backup_srt_passphrase = backup_srt_passphrase
        self.backup_srt_pbkey_len = backup_srt_pbkey_len
        # The IP address whitelist in CIDR format. CIDR blocks are separated with commas (,).
        self.cidrs = cidrs
        # The time when the flow was created.
        self.create_time = create_time
        # The source name.
        self.input_name = input_name
        # The source type.
        # 
        # Valid values:
        # 
        # *   RTMP-PUSH
        # *   SRT-Caller
        # *   RTMP-PULL
        # *   SRT-Listener
        # *   Flow
        self.input_protocol = input_protocol
        self.input_status = input_status
        # The source URL.
        self.input_url = input_url
        # The maximum bitrate. Unit: bit/s.
        self.max_bitrate = max_bitrate
        # The ID of the source flow. This parameter is returned when the source type is Flow.
        self.pair_flow_id = pair_flow_id
        # The output of the source flow. This parameter is returned when the source type is Flow.
        self.pair_output_name = pair_output_name
        # The latency for the SRT stream. Unit: milliseconds. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        # 
        # Valid values:
        # 
        # *   0
        # *   16
        # *   24
        # *   32
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_cidrs is not None:
            result['BackupCidrs'] = self.backup_cidrs
        if self.backup_create_time is not None:
            result['BackupCreateTime'] = self.backup_create_time
        if self.backup_input_name is not None:
            result['BackupInputName'] = self.backup_input_name
        if self.backup_input_status is not None:
            result['BackupInputStatus'] = self.backup_input_status
        if self.backup_input_url is not None:
            result['BackupInputUrl'] = self.backup_input_url
        if self.backup_max_bitrate is not None:
            result['BackupMaxBitrate'] = self.backup_max_bitrate
        if self.backup_srt_latency is not None:
            result['BackupSrtLatency'] = self.backup_srt_latency
        if self.backup_srt_passphrase is not None:
            result['BackupSrtPassphrase'] = self.backup_srt_passphrase
        if self.backup_srt_pbkey_len is not None:
            result['BackupSrtPbkeyLen'] = self.backup_srt_pbkey_len
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.input_name is not None:
            result['InputName'] = self.input_name
        if self.input_protocol is not None:
            result['InputProtocol'] = self.input_protocol
        if self.input_status is not None:
            result['InputStatus'] = self.input_status
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.pair_flow_id is not None:
            result['PairFlowId'] = self.pair_flow_id
        if self.pair_output_name is not None:
            result['PairOutputName'] = self.pair_output_name
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupCidrs') is not None:
            self.backup_cidrs = m.get('BackupCidrs')
        if m.get('BackupCreateTime') is not None:
            self.backup_create_time = m.get('BackupCreateTime')
        if m.get('BackupInputName') is not None:
            self.backup_input_name = m.get('BackupInputName')
        if m.get('BackupInputStatus') is not None:
            self.backup_input_status = m.get('BackupInputStatus')
        if m.get('BackupInputUrl') is not None:
            self.backup_input_url = m.get('BackupInputUrl')
        if m.get('BackupMaxBitrate') is not None:
            self.backup_max_bitrate = m.get('BackupMaxBitrate')
        if m.get('BackupSrtLatency') is not None:
            self.backup_srt_latency = m.get('BackupSrtLatency')
        if m.get('BackupSrtPassphrase') is not None:
            self.backup_srt_passphrase = m.get('BackupSrtPassphrase')
        if m.get('BackupSrtPbkeyLen') is not None:
            self.backup_srt_pbkey_len = m.get('BackupSrtPbkeyLen')
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        if m.get('InputProtocol') is not None:
            self.input_protocol = m.get('InputProtocol')
        if m.get('InputStatus') is not None:
            self.input_status = m.get('InputStatus')
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('PairFlowId') is not None:
            self.pair_flow_id = m.get('PairFlowId')
        if m.get('PairOutputName') is not None:
            self.pair_output_name = m.get('PairOutputName')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class GetMediaConnectFlowInputResponseBody(TeaModel):
    def __init__(
        self,
        content: GetMediaConnectFlowInputResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = GetMediaConnectFlowInputResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class GetMediaConnectFlowInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaConnectFlowInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaConnectFlowInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaConnectFlowOutputRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        output_name: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The name of the output that you want to query.
        # 
        # This parameter is required.
        self.output_name = output_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.output_name is not None:
            result['OutputName'] = self.output_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('OutputName') is not None:
            self.output_name = m.get('OutputName')
        return self


class GetMediaConnectFlowOutputResponseBodyContent(TeaModel):
    def __init__(
        self,
        cidrs: str = None,
        create_time: str = None,
        forbid: str = None,
        output_name: str = None,
        output_protocol: str = None,
        output_url: str = None,
        pair_flow_id: str = None,
        pair_input_name: str = None,
        player_limit: int = None,
        srt_latency: int = None,
        srt_passphrase: str = None,
        srt_pbkey_len: int = None,
    ):
        # The IP address whitelist in CIDR format. CIDR blocks are separated with commas (,).
        self.cidrs = cidrs
        # The time when the flow was created.
        self.create_time = create_time
        self.forbid = forbid
        # The output name.
        self.output_name = output_name
        # The output type.
        # 
        # Valid values:
        # 
        # *   RTMP-PUSH
        # *   SRT-Caller
        # *   RTMP-PULL
        # *   SRT-Listener
        # *   Flow
        self.output_protocol = output_protocol
        # The output URL.
        self.output_url = output_url
        # The ID of the destination flow. This parameter is returned when the output type is Flow.
        self.pair_flow_id = pair_flow_id
        # The source name of the destination flow. This parameter is returned when the output type is Flow.
        self.pair_input_name = pair_input_name
        # The maximum number of viewers.
        self.player_limit = player_limit
        # The latency for the SRT stream. Unit: milliseconds. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. This parameter is returned when the source type is SRT-Listener or SRT-Caller.
        # 
        # Valid values:
        # 
        # *   0
        # *   16
        # *   24
        # *   32
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.forbid is not None:
            result['Forbid'] = self.forbid
        if self.output_name is not None:
            result['OutputName'] = self.output_name
        if self.output_protocol is not None:
            result['OutputProtocol'] = self.output_protocol
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.pair_flow_id is not None:
            result['PairFlowId'] = self.pair_flow_id
        if self.pair_input_name is not None:
            result['PairInputName'] = self.pair_input_name
        if self.player_limit is not None:
            result['PlayerLimit'] = self.player_limit
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Forbid') is not None:
            self.forbid = m.get('Forbid')
        if m.get('OutputName') is not None:
            self.output_name = m.get('OutputName')
        if m.get('OutputProtocol') is not None:
            self.output_protocol = m.get('OutputProtocol')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('PairFlowId') is not None:
            self.pair_flow_id = m.get('PairFlowId')
        if m.get('PairInputName') is not None:
            self.pair_input_name = m.get('PairInputName')
        if m.get('PlayerLimit') is not None:
            self.player_limit = m.get('PlayerLimit')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class GetMediaConnectFlowOutputResponseBody(TeaModel):
    def __init__(
        self,
        content: GetMediaConnectFlowOutputResponseBodyContent = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = GetMediaConnectFlowOutputResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class GetMediaConnectFlowOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaConnectFlowOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaConnectFlowOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaConvertJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the transcoding task.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetMediaConvertJobResponseBodyJobConfig(TeaModel):
    def __init__(
        self,
        inputs: List[MediaConvertInput] = None,
        output_groups: List[MediaConvertOutputGroup] = None,
        outputs: List[MediaConvertOutput] = None,
    ):
        # The inputs of the transcoding task.
        self.inputs = inputs
        # The output group configurations.
        self.output_groups = output_groups
        # The output configurations.
        self.outputs = outputs

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = MediaConvertInput()
                self.inputs.append(temp_model.from_map(k))
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = MediaConvertOutputGroup()
                self.output_groups.append(temp_model.from_map(k))
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = MediaConvertOutput()
                self.outputs.append(temp_model.from_map(k))
        return self


class GetMediaConvertJobResponseBodyJob(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        code: str = None,
        config: GetMediaConvertJobResponseBodyJobConfig = None,
        job_id: str = None,
        message: str = None,
        output_details: List[MediaConvertOutputDetail] = None,
        output_group_details: List[MediaConvertOutputGroupDetail] = None,
        pipeline_id: str = None,
        request_id: str = None,
        state: str = None,
        user_data: str = None,
    ):
        # The idempotency key of the request for creating the transcoding task.
        self.client_token = client_token
        # The error code returned when the transcoding task failed.
        self.code = code
        # The configurations of the transcoding task.
        self.config = config
        # The ID of the transcoding task, which is a 32-bit string.
        self.job_id = job_id
        # The error message returned when the transcoding task failed.
        self.message = message
        # The details of the transcoded outputs, each corresponding to an output configuration.
        self.output_details = output_details
        # The details of the output groups, each corresponding to an output group configuration.
        self.output_group_details = output_group_details
        # The ID of the queue.
        self.pipeline_id = pipeline_id
        # The ID of the request for creating the transcoding task.
        self.request_id = request_id
        # The status of the transcoding task. Valid values:
        # 
        # *   Inited: The task is initialized.
        # *   Running
        # *   Success
        # *   Failed
        # *   Cancelled
        self.state = state
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.config:
            self.config.validate()
        if self.output_details:
            for k in self.output_details:
                if k:
                    k.validate()
        if self.output_group_details:
            for k in self.output_group_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.code is not None:
            result['Code'] = self.code
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        result['OutputDetails'] = []
        if self.output_details is not None:
            for k in self.output_details:
                result['OutputDetails'].append(k.to_map() if k else None)
        result['OutputGroupDetails'] = []
        if self.output_group_details is not None:
            for k in self.output_group_details:
                result['OutputGroupDetails'].append(k.to_map() if k else None)
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Config') is not None:
            temp_model = GetMediaConvertJobResponseBodyJobConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        self.output_details = []
        if m.get('OutputDetails') is not None:
            for k in m.get('OutputDetails'):
                temp_model = MediaConvertOutputDetail()
                self.output_details.append(temp_model.from_map(k))
        self.output_group_details = []
        if m.get('OutputGroupDetails') is not None:
            for k in m.get('OutputGroupDetails'):
                temp_model = MediaConvertOutputGroupDetail()
                self.output_group_details.append(temp_model.from_map(k))
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetMediaConvertJobResponseBody(TeaModel):
    def __init__(
        self,
        job: GetMediaConvertJobResponseBodyJob = None,
        request_id: str = None,
    ):
        # The transcoding task.
        self.job = job
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Job') is not None:
            temp_model = GetMediaConvertJobResponseBodyJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaConvertJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaConvertJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaConvertJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaInfoRequest(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media_id: str = None,
        output_type: str = None,
        return_detailed_info: str = None,
    ):
        # The input URL of the media asset in another service. The URL must be registered in the IMS content library and bound to the ID of the media asset in IMS.
        # 
        # *   For a media asset from Object Storage Service (OSS), the URL may have one of the following formats:
        # 
        # http(s)://example-bucket.oss-cn-shanghai.aliyuncs.com/example.mp4 or
        # 
        # oss://example-bucket/example.mp4. The second format indicates that the region in which the OSS bucket of the media asset resides is the same as the region in which OSS is activated.
        self.input_url = input_url
        # The ID of the media asset in IMS. If this parameter is left empty, the InputURL parameter must be specified.
        self.media_id = media_id
        # The type of the URL of the media asset to return in the response. Valid values:
        # 
        # *   oss (default): an OSS URL.
        # *   cdn: a CDN URL. A CDN URL is returned only if the media asset is imported from ApsaraVideo VOD and the relevant domain name is an accelerated domain name in ApsaraVideo VOD.
        self.output_type = output_type
        # Specifies whether to return detailed information for specific media asset attributes. Supported attributes: AiRoughData.StandardSmartTagJob, which specifies whether to return detailed tag information if a tagging job has been submitted for the media asset. Valid values for the attribute:
        # 
        # *   false (default): The job result is returned as a URL.
        # *   true: The job result is returned as text.
        self.return_detailed_info = return_detailed_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.output_type is not None:
            result['OutputType'] = self.output_type
        if self.return_detailed_info is not None:
            result['ReturnDetailedInfo'] = self.return_detailed_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OutputType') is not None:
            self.output_type = m.get('OutputType')
        if m.get('ReturnDetailedInfo') is not None:
            self.return_detailed_info = m.get('ReturnDetailedInfo')
        return self


class GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults(TeaModel):
    def __init__(
        self,
        data: str = None,
        type: str = None,
    ):
        # The result data. The value is a JSON string. For information about the data structures of different data types<props="china">, see [Description of the Results parameter](https://help.aliyun.com/zh/ims/developer-reference/api-ice-2020-11-09-querysmarttagjob?spm=a2c4g.11186623.0.0.521d48b7KfapOL#api-detail-40).
        self.data = data
        # The tagging type. Valid values:
        # 
        # *   NLP: natural language processing (NLP)-based tagging
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob(TeaModel):
    def __init__(
        self,
        ai_job_id: str = None,
        result_url: str = None,
        results: List[GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults] = None,
        status: str = None,
    ):
        # The ID of the AI task.
        self.ai_job_id = ai_job_id
        # The URL of the tagging result.
        self.result_url = result_url
        # The recognized tags.
        self.results = results
        # The analysis status. Valid values:
        # 
        # *   Analyzing
        # *   AnalyzeSuccess
        # *   AnalyzeFailed
        self.status = status

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_job_id is not None:
            result['AiJobId'] = self.ai_job_id
        if self.result_url is not None:
            result['ResultUrl'] = self.result_url
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiJobId') is not None:
            self.ai_job_id = m.get('AiJobId')
        if m.get('ResultUrl') is not None:
            self.result_url = m.get('ResultUrl')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults()
                self.results.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMediaInfoResponseBodyMediaInfoAiRoughData(TeaModel):
    def __init__(
        self,
        ai_category: str = None,
        ai_job_id: str = None,
        result: str = None,
        save_type: str = None,
        standard_smart_tag_job: GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob = None,
        status: str = None,
    ):
        # The AI category. Valid values:
        # 
        # *   Life
        # *   Good-looking
        # *   Cute pets
        # *   News
        # *   Ads
        # *   Environmental resources
        # *   Automobile
        self.ai_category = ai_category
        # The ID of the AI task.
        self.ai_job_id = ai_job_id
        # The analysis result.
        self.result = result
        # The storage type. This parameter indicates the library in which the analysis data is stored. Valid values:
        # 
        # *   TEXT: the text library.
        self.save_type = save_type
        # The information about the tagging job.
        self.standard_smart_tag_job = standard_smart_tag_job
        # The analysis status. Valid values:
        # 
        # *   Analyzing
        # *   AnalyzeSuccess
        # *   AnalyzeFailed
        # *   Saving
        # *   SaveSuccess
        # *   SaveFailed
        # *   Deleting
        # *   DeleteSuccess
        # *   DeleteFailed
        self.status = status

    def validate(self):
        if self.standard_smart_tag_job:
            self.standard_smart_tag_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_category is not None:
            result['AiCategory'] = self.ai_category
        if self.ai_job_id is not None:
            result['AiJobId'] = self.ai_job_id
        if self.result is not None:
            result['Result'] = self.result
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        if self.standard_smart_tag_job is not None:
            result['StandardSmartTagJob'] = self.standard_smart_tag_job.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiCategory') is not None:
            self.ai_category = m.get('AiCategory')
        if m.get('AiJobId') is not None:
            self.ai_job_id = m.get('AiJobId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        if m.get('StandardSmartTagJob') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob()
            self.standard_smart_tag_job = temp_model.from_map(m['StandardSmartTagJob'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        fps: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        profile: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The output layout of sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The time base of the codec.
        self.codec_time_base = codec_time_base
        # The duration.
        self.duration = duration
        # The audio frame rate.
        self.fps = fps
        # The sequence number of the audio track.
        self.index = index
        # The language.
        self.lang = lang
        # The number of frames.
        self.num_frames = num_frames
        # The codec profile.
        self.profile = profile
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate.
        self.sample_rate = sample_rate
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        create_time: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        modified_time: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The time when the file was created.
        self.create_time = create_time
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The OSS URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The time when the file was last modified.
        self.modified_time = modified_time
        # The region in which the file is stored.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(TeaModel):
    def __init__(
        self,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The time base of the codec.
        self.codec_time_base = codec_time_base
        # The duration.
        self.duration = duration
        # The sequence number of the subtitle track.
        self.index = index
        # The language.
        self.lang = lang
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        nb_frames: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average video frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bitrate = bitrate
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The time base of the codec.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR).
        self.dar = dar
        # The duration.
        self.duration = duration
        # The video frame rate.
        self.fps = fps
        # Indicates whether the video track contains bidirectional frames (B-frames).
        self.has_bframes = has_bframes
        # The height.
        self.height = height
        # The sequence number of the video track.
        self.index = index
        # The language.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.nb_frames = nb_frames
        # The number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The rotation angle.
        self.rotate = rotate
        # The sample aspect ratio (SAR).
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.nb_frames is not None:
            result['Nb_frames'] = self.nb_frames
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Nb_frames') is not None:
            self.nb_frames = m.get('Nb_frames')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoList(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList] = None,
        file_basic_info: GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo = None,
        subtitle_stream_info_list: List[GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList] = None,
        video_stream_info_list: List[GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList] = None,
    ):
        # The information about the audio tracks. A media asset may have multiple audio tracks.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic information about the file, including the duration and size.
        self.file_basic_info = file_basic_info
        # The information about the subtitle tracks. A media asset may have multiple subtitle tracks.
        self.subtitle_stream_info_list = subtitle_stream_info_list
        # The information about the video tracks. A media asset may have multiple video tracks.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.subtitle_stream_info_list:
            for k in self.subtitle_stream_info_list:
                if k:
                    k.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['SubtitleStreamInfoList'] = []
        if self.subtitle_stream_info_list is not None:
            for k in self.subtitle_stream_info_list:
                result['SubtitleStreamInfoList'].append(k.to_map() if k else None)
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.subtitle_stream_info_list = []
        if m.get('SubtitleStreamInfoList') is not None:
            for k in m.get('SubtitleStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList()
                self.subtitle_stream_info_list.append(temp_model.from_map(k))
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetMediaInfoResponseBodyMediaInfoMediaBasicInfo(TeaModel):
    def __init__(
        self,
        biz: str = None,
        business_type: str = None,
        cate_id: int = None,
        cate_name: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        reference_id: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        upload_source: str = None,
        user_data: str = None,
    ):
        # The service to which the media asset belongs.
        self.biz = biz
        # The business type.
        self.business_type = business_type
        # The category ID.
        self.cate_id = cate_id
        # The category name.
        self.cate_name = cate_name
        # The category.
        self.category = category
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The content description.
        self.description = description
        # The input URL of the media asset in another service.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The custom ID. The ID can be 6 to 64 characters in length and can contain only letters, digits, hyphens (-), and underscores (_). The ID is unique among users.
        self.reference_id = reference_id
        # The snapshots.
        self.snapshots = snapshots
        # The source.
        self.source = source
        # The sprite.
        self.sprite_images = sprite_images
        # The resource status.
        self.status = status
        # The title.
        self.title = title
        # The upload source of the media asset.
        self.upload_source = upload_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetMediaInfoResponseBodyMediaInfo(TeaModel):
    def __init__(
        self,
        ai_rough_data: GetMediaInfoResponseBodyMediaInfoAiRoughData = None,
        file_info_list: List[GetMediaInfoResponseBodyMediaInfoFileInfoList] = None,
        media_basic_info: GetMediaInfoResponseBodyMediaInfoMediaBasicInfo = None,
        media_id: str = None,
    ):
        # The original AI analysis data.
        self.ai_rough_data = ai_rough_data
        # The file information.
        self.file_info_list = file_info_list
        # The basic information about the media asset.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.ai_rough_data:
            self.ai_rough_data.validate()
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_rough_data is not None:
            result['AiRoughData'] = self.ai_rough_data.to_map()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiRoughData') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoAiRoughData()
            self.ai_rough_data = temp_model.from_map(m['AiRoughData'])
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetMediaInfoResponseBody(TeaModel):
    def __init__(
        self,
        media_info: GetMediaInfoResponseBodyMediaInfo = None,
        request_id: str = None,
    ):
        # The information about the media asset.
        self.media_info = media_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaInfoJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported. If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sample format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video. Unit: seconds.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size.
        self.file_size = file_size
        # The state of the file.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height of the output video.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the file.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height of the output video.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList] = None,
        file_basic_info: GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo = None,
        video_stream_info_list: List[GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        finish_time: str = None,
        input: GetMediaInfoJobResponseBodyMediaInfoJobInput = None,
        job_id: str = None,
        media_info_property: GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty = None,
        name: str = None,
        request_id: str = None,
        schedule_config: GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # Indicates whether asynchronous processing was performed.
        self.async_ = async_
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The details of the media information.
        self.media_info_property = media_info_property
        # The job name.
        self.name = name
        # The request ID.
        self.request_id = request_id
        # The scheduling information.
        self.schedule_config = schedule_config
        # The state of the job. Valid values: Init (the job is submitted), Success (the job is successful), and Fail (the job failed).
        self.status = status
        # The job submission information.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The source of the job. Valid values: API, WorkFlow, and Console.
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetMediaInfoJobResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job: GetMediaInfoJobResponseBodyMediaInfoJob = None,
        request_id: str = None,
    ):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaInfoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaInfoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
    ):
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        profile: str = None,
        sample_rate: int = None,
    ):
        # The audio bitrate. Unit: bit/s.
        self.bitrate = bitrate
        # The audio codec profile.
        self.profile = profile
        # The audio sample rate. Unit: Hz.
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        return self


class GetMediaLiveChannelResponseBodyChannelAudioSettings(TeaModel):
    def __init__(
        self,
        audio_codec: str = None,
        audio_codec_setting: GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting = None,
        audio_selector_name: str = None,
        language_code: str = None,
        language_name: str = None,
        name: str = None,
    ):
        # The audio codec.
        self.audio_codec = audio_codec
        # The audio encoding settings.
        self.audio_codec_setting = audio_codec_setting
        # The name of the audio selector.
        self.audio_selector_name = audio_selector_name
        # A three-letter ISO 639-2 language code.
        self.language_code = language_code
        # The name of the language.
        self.language_name = language_name
        # The name of the audio settings.
        self.name = name

    def validate(self):
        if self.audio_codec_setting:
            self.audio_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_codec_setting is not None:
            result['AudioCodecSetting'] = self.audio_codec_setting.to_map()
        if self.audio_selector_name is not None:
            result['AudioSelectorName'] = self.audio_selector_name
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioCodecSetting') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting()
            self.audio_codec_setting = temp_model.from_map(m['AudioCodecSetting'])
        if m.get('AudioSelectorName') is not None:
            self.audio_selector_name = m.get('AudioSelectorName')
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection(TeaModel):
    def __init__(
        self,
        language_code: str = None,
    ):
        # A three-letter ISO 639-2 language code from within an audio source.
        # 
        # This parameter is required.
        self.language_code = language_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        return self


class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection(TeaModel):
    def __init__(
        self,
        pid: int = None,
    ):
        # A PID from within a source.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection(TeaModel):
    def __init__(
        self,
        track_id: int = None,
    ):
        # The track ID from within a source.
        # 
        # This parameter is required.
        self.track_id = track_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.track_id is not None:
            result['TrackId'] = self.track_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TrackId') is not None:
            self.track_id = m.get('TrackId')
        return self


class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors(TeaModel):
    def __init__(
        self,
        audio_language_selection: GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection = None,
        audio_pid_selection: GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection = None,
        audio_track_selection: List[GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection] = None,
        name: str = None,
    ):
        # The audio language selection.
        self.audio_language_selection = audio_language_selection
        # The audio PID selection.
        self.audio_pid_selection = audio_pid_selection
        # The audio track selection.
        self.audio_track_selection = audio_track_selection
        # The name of the audio selector.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_language_selection:
            self.audio_language_selection.validate()
        if self.audio_pid_selection:
            self.audio_pid_selection.validate()
        if self.audio_track_selection:
            for k in self.audio_track_selection:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_language_selection is not None:
            result['AudioLanguageSelection'] = self.audio_language_selection.to_map()
        if self.audio_pid_selection is not None:
            result['AudioPidSelection'] = self.audio_pid_selection.to_map()
        result['AudioTrackSelection'] = []
        if self.audio_track_selection is not None:
            for k in self.audio_track_selection:
                result['AudioTrackSelection'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLanguageSelection') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection()
            self.audio_language_selection = temp_model.from_map(m['AudioLanguageSelection'])
        if m.get('AudioPidSelection') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection()
            self.audio_pid_selection = temp_model.from_map(m['AudioPidSelection'])
        self.audio_track_selection = []
        if m.get('AudioTrackSelection') is not None:
            for k in m.get('AudioTrackSelection'):
                temp_model = GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection()
                self.audio_track_selection.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetMediaLiveChannelResponseBodyChannelInputAttachments(TeaModel):
    def __init__(
        self,
        audio_selectors: List[GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors] = None,
        input_id: str = None,
        input_name: str = None,
        language_name: str = None,
    ):
        # The audio selectors.
        self.audio_selectors = audio_selectors
        # The ID of the associated input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The name of the input.
        self.input_name = input_name
        # The language name.
        self.language_name = language_name

    def validate(self):
        if self.audio_selectors:
            for k in self.audio_selectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSelectors'] = []
        if self.audio_selectors is not None:
            for k in self.audio_selectors:
                result['AudioSelectors'].append(k.to_map() if k else None)
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.input_name is not None:
            result['InputName'] = self.input_name
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_selectors = []
        if m.get('AudioSelectors') is not None:
            for k in m.get('AudioSelectors'):
                temp_model = GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors()
                self.audio_selectors.append(temp_model.from_map(k))
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        return self


class GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # ChannelName in MediaPackage.
        self.channel_name = channel_name
        # GroupName in MediaPackage.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting(TeaModel):
    def __init__(
        self,
        audio_group_id: str = None,
        name_modifier: str = None,
    ):
        # The manifest audio group ID.
        self.audio_group_id = audio_group_id
        # The manifest name modifier. The child manifests include this modifier in their M3U8 file names.
        self.name_modifier = name_modifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_group_id is not None:
            result['AudioGroupId'] = self.audio_group_id
        if self.name_modifier is not None:
            result['NameModifier'] = self.name_modifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioGroupId') is not None:
            self.audio_group_id = m.get('AudioGroupId')
        if m.get('NameModifier') is not None:
            self.name_modifier = m.get('NameModifier')
        return self


class GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs(TeaModel):
    def __init__(
        self,
        audio_setting_names: List[str] = None,
        media_package_output_setting: GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting = None,
        media_type: int = None,
        name: str = None,
        video_setting_name: str = None,
    ):
        # The referenced AudioSettings.
        self.audio_setting_names = audio_setting_names
        # The settings of the output delivered to MediaPackage.
        self.media_package_output_setting = media_package_output_setting
        # The media type of the output.
        self.media_type = media_type
        # The name of the output.
        self.name = name
        # The name of the referenced VideoSettings.
        self.video_setting_name = video_setting_name

    def validate(self):
        if self.media_package_output_setting:
            self.media_package_output_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_setting_names is not None:
            result['AudioSettingNames'] = self.audio_setting_names
        if self.media_package_output_setting is not None:
            result['MediaPackageOutputSetting'] = self.media_package_output_setting.to_map()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.video_setting_name is not None:
            result['VideoSettingName'] = self.video_setting_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettingNames') is not None:
            self.audio_setting_names = m.get('AudioSettingNames')
        if m.get('MediaPackageOutputSetting') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting()
            self.media_package_output_setting = temp_model.from_map(m['MediaPackageOutputSetting'])
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoSettingName') is not None:
            self.video_setting_name = m.get('VideoSettingName')
        return self


class GetMediaLiveChannelResponseBodyChannelOutputGroups(TeaModel):
    def __init__(
        self,
        media_package_group_setting: GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting = None,
        monitor_url: str = None,
        name: str = None,
        outputs: List[GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs] = None,
        type: str = None,
    ):
        # The MediaPackage destination.
        self.media_package_group_setting = media_package_group_setting
        # The URL for monitoring the output group. The parameter is returned only when the output gourp type is MediaPackage.
        self.monitor_url = monitor_url
        # The name of the output group.
        self.name = name
        # The outputs in the output group.
        self.outputs = outputs
        # The output group type.
        self.type = type

    def validate(self):
        if self.media_package_group_setting:
            self.media_package_group_setting.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_package_group_setting is not None:
            result['MediaPackageGroupSetting'] = self.media_package_group_setting.to_map()
        if self.monitor_url is not None:
            result['MonitorUrl'] = self.monitor_url
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaPackageGroupSetting') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting()
            self.media_package_group_setting = temp_model.from_map(m['MediaPackageGroupSetting'])
        if m.get('MonitorUrl') is not None:
            self.monitor_url = m.get('MonitorUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs()
                self.outputs.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail(TeaModel):
    def __init__(
        self,
        level: str = None,
        profile: str = None,
    ):
        # The video encoding level. It is not supported yet.
        self.level = level
        # The H.264 profile.
        self.profile = profile

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.profile is not None:
            result['Profile'] = self.profile
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate(TeaModel):
    def __init__(
        self,
        framerate_control: str = None,
        framerate_denominator: int = None,
        framerate_numerator: int = None,
    ):
        # The frame rate mode.
        self.framerate_control = framerate_control
        # The denominator of the fixed frame rate.
        self.framerate_denominator = framerate_denominator
        # The numerator of the fixed frame rate.
        self.framerate_numerator = framerate_numerator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.framerate_control is not None:
            result['FramerateControl'] = self.framerate_control
        if self.framerate_denominator is not None:
            result['FramerateDenominator'] = self.framerate_denominator
        if self.framerate_numerator is not None:
            result['FramerateNumerator'] = self.framerate_numerator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FramerateControl') is not None:
            self.framerate_control = m.get('FramerateControl')
        if m.get('FramerateDenominator') is not None:
            self.framerate_denominator = m.get('FramerateDenominator')
        if m.get('FramerateNumerator') is not None:
            self.framerate_numerator = m.get('FramerateNumerator')
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop(TeaModel):
    def __init__(
        self,
        bframes_num: int = None,
        gop_size: int = None,
        gop_size_units: str = None,
    ):
        # The number of B frames.
        self.bframes_num = bframes_num
        # The GOP size.
        self.gop_size = gop_size
        # The GOP size unit.
        self.gop_size_units = gop_size_units

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bframes_num is not None:
            result['BframesNum'] = self.bframes_num
        if self.gop_size is not None:
            result['GopSize'] = self.gop_size
        if self.gop_size_units is not None:
            result['GopSizeUnits'] = self.gop_size_units
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BframesNum') is not None:
            self.bframes_num = m.get('BframesNum')
        if m.get('GopSize') is not None:
            self.gop_size = m.get('GopSize')
        if m.get('GopSizeUnits') is not None:
            self.gop_size_units = m.get('GopSizeUnits')
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        buffer_size: int = None,
        max_bitrate: int = None,
        rate_control_mode: str = None,
    ):
        # The video bitrate. Unit: bit/s.
        self.bitrate = bitrate
        # The video buffer size. Unit: bit/s.
        self.buffer_size = buffer_size
        # The maximum bitrate. Unit: bit/s.
        self.max_bitrate = max_bitrate
        # The bitrate control mode.
        self.rate_control_mode = rate_control_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.buffer_size is not None:
            result['BufferSize'] = self.buffer_size
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.rate_control_mode is not None:
            result['RateControlMode'] = self.rate_control_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BufferSize') is not None:
            self.buffer_size = m.get('BufferSize')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('RateControlMode') is not None:
            self.rate_control_mode = m.get('RateControlMode')
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting(TeaModel):
    def __init__(
        self,
        codec_detail: GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail = None,
        framerate: GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate = None,
        gop: GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop = None,
        rate: GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate = None,
    ):
        # The video encoding settings.
        self.codec_detail = codec_detail
        # The frame rate.
        self.framerate = framerate
        # The GOP setting.
        self.gop = gop
        # The video encoding rate.
        self.rate = rate

    def validate(self):
        if self.codec_detail:
            self.codec_detail.validate()
        if self.framerate:
            self.framerate.validate()
        if self.gop:
            self.gop.validate()
        if self.rate:
            self.rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_detail is not None:
            result['CodecDetail'] = self.codec_detail.to_map()
        if self.framerate is not None:
            result['Framerate'] = self.framerate.to_map()
        if self.gop is not None:
            result['Gop'] = self.gop.to_map()
        if self.rate is not None:
            result['Rate'] = self.rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecDetail') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail()
            self.codec_detail = temp_model.from_map(m['CodecDetail'])
        if m.get('Framerate') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate()
            self.framerate = temp_model.from_map(m['Framerate'])
        if m.get('Gop') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop()
            self.gop = temp_model.from_map(m['Gop'])
        if m.get('Rate') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate()
            self.rate = temp_model.from_map(m['Rate'])
        return self


class GetMediaLiveChannelResponseBodyChannelVideoSettings(TeaModel):
    def __init__(
        self,
        height: int = None,
        name: str = None,
        video_codec: str = None,
        video_codec_setting: GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting = None,
        video_codec_type: str = None,
        width: int = None,
    ):
        # The height of the video in pixels.
        self.height = height
        # The name of the video settings.
        self.name = name
        # The video codec.
        self.video_codec = video_codec
        # The video encoding settings.
        self.video_codec_setting = video_codec_setting
        # 
        self.video_codec_type = video_codec_type
        # The width of the video in pixels.
        self.width = width

    def validate(self):
        if self.video_codec_setting:
            self.video_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_codec_setting is not None:
            result['VideoCodecSetting'] = self.video_codec_setting.to_map()
        if self.video_codec_type is not None:
            result['VideoCodecType'] = self.video_codec_type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoCodecSetting') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting()
            self.video_codec_setting = temp_model.from_map(m['VideoCodecSetting'])
        if m.get('VideoCodecType') is not None:
            self.video_codec_type = m.get('VideoCodecType')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaLiveChannelResponseBodyChannel(TeaModel):
    def __init__(
        self,
        audio_settings: List[GetMediaLiveChannelResponseBodyChannelAudioSettings] = None,
        channel_id: str = None,
        create_time: str = None,
        input_attachments: List[GetMediaLiveChannelResponseBodyChannelInputAttachments] = None,
        last_start_time: str = None,
        last_stop_time: str = None,
        name: str = None,
        output_groups: List[GetMediaLiveChannelResponseBodyChannelOutputGroups] = None,
        state: str = None,
        video_settings: List[GetMediaLiveChannelResponseBodyChannelVideoSettings] = None,
    ):
        # The audio settings.
        self.audio_settings = audio_settings
        # The ID of the channel.
        self.channel_id = channel_id
        # The time when the channel was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The inputs associated with the channel.
        self.input_attachments = input_attachments
        # The time when the channel was last started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. If the channel has never been started since it was created, an empty string is returned.
        self.last_start_time = last_start_time
        # The time when the channel was last stopped. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. If the channel has never stopped since it was created, an empty string is returned.
        self.last_stop_time = last_stop_time
        # The channel name.
        self.name = name
        # The output groups.
        self.output_groups = output_groups
        # The state of the channel. Valid values: IDLE, STARTING, RUNNING, RECOVERING, and STOPPING.
        self.state = state
        # The video settings.
        self.video_settings = video_settings

    def validate(self):
        if self.audio_settings:
            for k in self.audio_settings:
                if k:
                    k.validate()
        if self.input_attachments:
            for k in self.input_attachments:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.video_settings:
            for k in self.video_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSettings'] = []
        if self.audio_settings is not None:
            for k in self.audio_settings:
                result['AudioSettings'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['InputAttachments'] = []
        if self.input_attachments is not None:
            for k in self.input_attachments:
                result['InputAttachments'].append(k.to_map() if k else None)
        if self.last_start_time is not None:
            result['LastStartTime'] = self.last_start_time
        if self.last_stop_time is not None:
            result['LastStopTime'] = self.last_stop_time
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        if self.state is not None:
            result['State'] = self.state
        result['VideoSettings'] = []
        if self.video_settings is not None:
            for k in self.video_settings:
                result['VideoSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_settings = []
        if m.get('AudioSettings') is not None:
            for k in m.get('AudioSettings'):
                temp_model = GetMediaLiveChannelResponseBodyChannelAudioSettings()
                self.audio_settings.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.input_attachments = []
        if m.get('InputAttachments') is not None:
            for k in m.get('InputAttachments'):
                temp_model = GetMediaLiveChannelResponseBodyChannelInputAttachments()
                self.input_attachments.append(temp_model.from_map(k))
        if m.get('LastStartTime') is not None:
            self.last_start_time = m.get('LastStartTime')
        if m.get('LastStopTime') is not None:
            self.last_stop_time = m.get('LastStopTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = GetMediaLiveChannelResponseBodyChannelOutputGroups()
                self.output_groups.append(temp_model.from_map(k))
        if m.get('State') is not None:
            self.state = m.get('State')
        self.video_settings = []
        if m.get('VideoSettings') is not None:
            for k in m.get('VideoSettings'):
                temp_model = GetMediaLiveChannelResponseBodyChannelVideoSettings()
                self.video_settings.append(temp_model.from_map(k))
        return self


class GetMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel: GetMediaLiveChannelResponseBodyChannel = None,
        request_id: str = None,
    ):
        # The channel information.
        self.channel = channel
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.channel:
            self.channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channel') is not None:
            temp_model = GetMediaLiveChannelResponseBodyChannel()
            self.channel = temp_model.from_map(m['Channel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaLiveInputRequest(TeaModel):
    def __init__(
        self,
        input_id: str = None,
    ):
        # The ID of the input.
        # 
        # This parameter is required.
        self.input_id = input_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_id is not None:
            result['InputId'] = self.input_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        return self


class GetMediaLiveInputResponseBodyInputInputInfos(TeaModel):
    def __init__(
        self,
        dest_host: str = None,
        flow_id: str = None,
        flow_output_name: str = None,
        monitor_url: str = None,
        source_url: str = None,
        stream_name: str = None,
    ):
        # The endpoint that the stream is pushed to. This parameter is returned for PUSH inputs.
        self.dest_host = dest_host
        self.flow_id = flow_id
        self.flow_output_name = flow_output_name
        # The URL for input monitoring.
        self.monitor_url = monitor_url
        # The source URL where the stream is pulled from. This parameter is returned for PULL inputs.
        self.source_url = source_url
        # The name of the pushed stream. This parameter is returned for PUSH inputs.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_host is not None:
            result['DestHost'] = self.dest_host
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_output_name is not None:
            result['FlowOutputName'] = self.flow_output_name
        if self.monitor_url is not None:
            result['MonitorUrl'] = self.monitor_url
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestHost') is not None:
            self.dest_host = m.get('DestHost')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowOutputName') is not None:
            self.flow_output_name = m.get('FlowOutputName')
        if m.get('MonitorUrl') is not None:
            self.monitor_url = m.get('MonitorUrl')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetMediaLiveInputResponseBodyInput(TeaModel):
    def __init__(
        self,
        channel_ids: List[str] = None,
        create_time: str = None,
        input_id: str = None,
        input_infos: List[GetMediaLiveInputResponseBodyInputInputInfos] = None,
        name: str = None,
        security_group_ids: List[str] = None,
        type: str = None,
    ):
        # The IDs of the channels associated with the input.
        self.channel_ids = channel_ids
        # The time when the input was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the input.
        self.input_id = input_id
        # The input configurations.
        self.input_infos = input_infos
        # The name of the input.
        self.name = name
        # The IDs of the security groups associated with the input.
        self.security_group_ids = security_group_ids
        # The input type.
        self.type = type

    def validate(self):
        if self.input_infos:
            for k in self.input_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.input_id is not None:
            result['InputId'] = self.input_id
        result['InputInfos'] = []
        if self.input_infos is not None:
            for k in self.input_infos:
                result['InputInfos'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        self.input_infos = []
        if m.get('InputInfos') is not None:
            for k in m.get('InputInfos'):
                temp_model = GetMediaLiveInputResponseBodyInputInputInfos()
                self.input_infos.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMediaLiveInputResponseBody(TeaModel):
    def __init__(
        self,
        input: GetMediaLiveInputResponseBodyInput = None,
        request_id: str = None,
    ):
        # The input information.
        self.input = input
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = GetMediaLiveInputResponseBodyInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaLiveInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaLiveInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaLiveInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaLiveInputSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
    ):
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class GetMediaLiveInputSecurityGroupResponseBodySecurityGroup(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        input_ids: List[str] = None,
        name: str = None,
        security_group_id: str = None,
        whitelist_rules: List[str] = None,
    ):
        # The time when the security group was created. It follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The IDs of the inputs associated with the security group.
        self.input_ids = input_ids
        # The name of the security group.
        self.name = name
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The security group rules.
        self.whitelist_rules = whitelist_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.input_ids is not None:
            result['InputIds'] = self.input_ids
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.whitelist_rules is not None:
            result['WhitelistRules'] = self.whitelist_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InputIds') is not None:
            self.input_ids = m.get('InputIds')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules = m.get('WhitelistRules')
        return self


class GetMediaLiveInputSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_group: GetMediaLiveInputSecurityGroupResponseBodySecurityGroup = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The security group information.
        self.security_group = security_group

    def validate(self):
        if self.security_group:
            self.security_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group is not None:
            result['SecurityGroup'] = self.security_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroup') is not None:
            temp_model = GetMediaLiveInputSecurityGroupResponseBodySecurityGroup()
            self.security_group = temp_model.from_map(m['SecurityGroup'])
        return self


class GetMediaLiveInputSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaLiveInputSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaLiveInputSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaMarksRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The mark ID. You can specify multiple mark IDs separated with commas (,).
        self.media_mark_ids = media_mark_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        return self


class GetMediaMarksResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_marks: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The queried marks.
        # 
        # *   The value is in the JSONArray format.
        self.media_marks = media_marks
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_marks is not None:
            result['MediaMarks'] = self.media_marks
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarks') is not None:
            self.media_marks = m.get('MediaMarks')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaMarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaMarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaMarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaProducingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the media editing and production job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetMediaProducingJobResponseBodyMediaProducingJob(TeaModel):
    def __init__(
        self,
        clips_param: str = None,
        code: str = None,
        complete_time: str = None,
        create_time: str = None,
        duration: float = None,
        job_id: str = None,
        media_id: str = None,
        media_url: str = None,
        message: str = None,
        modified_time: str = None,
        progress: int = None,
        project_id: str = None,
        status: str = None,
        sub_job_materials: str = None,
        template_id: str = None,
        timeline: str = None,
        user_data: str = None,
        vod_media_id: str = None,
    ):
        # The template parameters of the media editing and production job.
        self.clips_param = clips_param
        # The response code
        # 
        # Note: Pay attention to this parameter if the job failed.
        self.code = code
        # The time when the media editing and production job was complete.
        # 
        # The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the media editing and production job was created.
        # 
        # The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The duration of the output file.
        # 
        # Note: This parameter has a value if the job is successful and the output file is an audio or video file.
        self.duration = duration
        # The ID of the media editing and production job.
        self.job_id = job_id
        # The media asset ID of the output file.
        self.media_id = media_id
        # The URL of the output file.
        self.media_url = media_url
        # The returned message.
        # 
        # Note: Pay attention to this parameter if the job failed.
        self.message = message
        # The time when the media editing and production job was last modified.
        # 
        # The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modified_time = modified_time
        self.progress = progress
        # The ID of the online editing project.
        self.project_id = project_id
        # The state of the media editing and production job. Valid values:
        # 
        # Init
        # 
        # Queuing
        # 
        # Processing
        # 
        # Success
        # 
        # Failed
        self.status = status
        # The materials of the media editing and production job if the job is a subjob of a quick video production job, including the broadcast text and title.
        self.sub_job_materials = sub_job_materials
        # The ID of the template used by the media editing and production job.
        self.template_id = template_id
        # The timeline of the media editing and production job.
        self.timeline = timeline
        # The user-defined data in the JSON format.
        self.user_data = user_data
        # The media asset ID of the output file in ApsaraVideo VOD if the output file is stored in ApsaraVideo VOD.
        self.vod_media_id = vod_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.code is not None:
            result['Code'] = self.code
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_job_materials is not None:
            result['SubJobMaterials'] = self.sub_job_materials
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vod_media_id is not None:
            result['VodMediaId'] = self.vod_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubJobMaterials') is not None:
            self.sub_job_materials = m.get('SubJobMaterials')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VodMediaId') is not None:
            self.vod_media_id = m.get('VodMediaId')
        return self


class GetMediaProducingJobResponseBody(TeaModel):
    def __init__(
        self,
        media_producing_job: GetMediaProducingJobResponseBodyMediaProducingJob = None,
        request_id: str = None,
    ):
        # The information about the online editing project.
        self.media_producing_job = media_producing_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_producing_job:
            self.media_producing_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_producing_job is not None:
            result['MediaProducingJob'] = self.media_producing_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaProducingJob') is not None:
            temp_model = GetMediaProducingJobResponseBodyMediaProducingJob()
            self.media_producing_job = temp_model.from_map(m['MediaProducingJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaProducingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMediaProducingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPackageJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The job ID. You can obtain the job ID from the response parameters of the [SubmitPackageJob](https://help.aliyun.com/document_detail/461964.html) operation.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetPackageJobResponseBodyPackageJobInputsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPackageJobResponseBodyPackageJobInputs(TeaModel):
    def __init__(
        self,
        input: GetPackageJobResponseBodyPackageJobInputsInput = None,
    ):
        # The information about the input stream file.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = GetPackageJobResponseBodyPackageJobInputsInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class GetPackageJobResponseBodyPackageJobOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPackageJobResponseBodyPackageJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        create_time: str = None,
        finish_time: str = None,
        inputs: List[GetPackageJobResponseBodyPackageJobInputs] = None,
        job_id: str = None,
        message: str = None,
        modified_time: str = None,
        name: str = None,
        output: GetPackageJobResponseBodyPackageJobOutput = None,
        output_url: str = None,
        pipeline_id: str = None,
        priority: int = None,
        status: str = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input of the job.
        self.inputs = inputs
        # The job ID.
        self.job_id = job_id
        # The error message that is returned.
        self.message = message
        # The time when the job was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The URL of the output file.
        self.output_url = output_url
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority
        # The state of the job.
        self.status = status
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The source of the job. Valid values:
        # 
        # *   API
        # *   WorkFlow
        # *   Console
        self.trigger_source = trigger_source
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = GetPackageJobResponseBodyPackageJobInputs()
                self.inputs.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = GetPackageJobResponseBodyPackageJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetPackageJobResponseBody(TeaModel):
    def __init__(
        self,
        package_job: GetPackageJobResponseBodyPackageJob = None,
        request_id: str = None,
    ):
        # The information about the packaging job.
        self.package_job = package_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.package_job:
            self.package_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_job is not None:
            result['PackageJob'] = self.package_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackageJob') is not None:
            temp_model = GetPackageJobResponseBodyPackageJob()
            self.package_job = temp_model.from_map(m['PackageJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPackageJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPackageJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPackageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineRequest(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the MPS queue.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class GetPipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modified_time: str = None,
        name: str = None,
        pipeline_id: str = None,
        priority: int = None,
        speed: str = None,
        status: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The name of the MPS queue.
        self.name = name
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The priority of the MPS queue. Valid values: 1 to 10.
        self.priority = priority
        # The type of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Standard: standard MPS queue.
        # *   Boost: MPS queue with transcoding speed boosted.
        # *   NarrowBandHDV2: MPS queue that supports Narrowband HD 2.0.
        self.speed = speed
        # The state of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Active
        # *   Paused
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetPipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: GetPipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The information about the MPS queue.
        self.pipeline = pipeline
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = GetPipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPlayInfoRequest(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media_id: str = None,
    ):
        # The input URL that you specified for the media asset when you registered the media asset. For more information, see [RegisterMediaInfo](https://help.aliyun.com/document_detail/441152.html).
        # 
        # >  You must specify at least one of the MediaId and InputURL parameters.
        self.input_url = input_url
        # The ID of the media asset.
        # 
        # >  You must specify at least one of the MediaId and InputURL parameters.
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPlayInfoResponseBodyMediaBase(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        status: str = None,
        title: str = None,
    ):
        # The category ID. You can use one of the following methods to obtain the ID:
        # 
        # *   Log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com) and choose **Media Asset Management** > **Category Management** to view the category ID.
        # *   View the value of the CateId parameter returned by the AddCategory operation that you called to create a category.
        # *   View the value of the CateId parameter returned by the GetCategories operation that you called to query a category.
        self.cate_id = cate_id
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.creation_time = creation_time
        # The content description.
        self.description = description
        # The ID of the media asset.
        self.media_id = media_id
        # The tags.
        # 
        # *   Up to 16 tags are supported.
        # *   Multiple tags are separated by commas (,).
        # *   Each tag can be up to 32 bytes in length.
        # *   The value is encoded in UTF-8.
        self.media_tags = media_tags
        # The type of the media asset. Valid values:
        # 
        # video audio
        self.media_type = media_type
        # The resource status. Valid values:
        # 
        # Init: the initial state, which indicates that the source file is not ready.
        # 
        # Preparing: The source file is being prepared. For example, the file is being uploaded or edited.
        # 
        # PrepareFail: The source file failed to be prepared. For example, the information of the source file failed to be obtained.
        # 
        # Normal: The source file is ready.
        self.status = status
        # The title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetPlayInfoResponseBodyPlayInfoList(TeaModel):
    def __init__(
        self,
        bit_depth: int = None,
        bitrate: str = None,
        creation_time: str = None,
        definition: str = None,
        duration: str = None,
        encrypt: int = None,
        encrypt_type: str = None,
        file_url: str = None,
        format: str = None,
        fps: str = None,
        hdrtype: str = None,
        height: int = None,
        job_id: str = None,
        modification_time: str = None,
        narrow_band_type: str = None,
        play_url: str = None,
        size: int = None,
        status: str = None,
        stream_tags: str = None,
        stream_type: str = None,
        trans_template_type: str = None,
        watermark_id: str = None,
        width: int = None,
    ):
        # The color depth.
        self.bit_depth = bit_depth
        # The bitrate of the media stream. Unit: Kbit/s.
        self.bitrate = bitrate
        # The time when the media stream was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The quality of the media stream. Valid values:
        # 
        # *   **FD**: low definition
        # *   **LD**: standard definition
        # *   **SD**: high definition
        # *   **HD**: ultra-high definition
        # *   **OD**: original definition
        # *   **2K**\
        # *   **4K**\
        # *   **SQ**: standard sound quality
        # *   **HQ**: high sound quality
        # *   **AUTO**: adaptive bitrate
        self.definition = definition
        # The duration of the media stream. Unit: seconds.
        self.duration = duration
        # Indicates whether the media stream is encrypted. Valid values:
        # 
        # *   **0**: The media stream is not encrypted.
        # *   **1**: The media stream is encrypted.
        self.encrypt = encrypt
        # The encryption type of the media stream. Valid values:
        # 
        # *   **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
        # *   **HLSEncryption**: HTTP Live Streaming (HLS) encryption
        # 
        # >  If the encryption type is AliyunVoDEncryption, only ApsaraVideo Player SDK can be used to play videos.
        self.encrypt_type = encrypt_type
        # The OSS URL of the file.
        self.file_url = file_url
        # The format of the media stream.
        # 
        # *   If the media asset is a video file, the valid values are **mp4** and **m3u8**.
        # *   If the media asset is an audio-only file, the value is **mp3**.
        self.format = format
        # The frame rate of the media stream. Unit: frames per second (FPS).
        self.fps = fps
        # The high dynamic range (HDR) type of the media stream. Valid values:
        # 
        # *   HDR
        # *   HDR10
        # *   HLG
        # *   DolbyVision
        # *   HDRVivid
        # *   SDR+\
        self.hdrtype = hdrtype
        # The height of the media stream. Unit: pixels.
        self.height = height
        # The task ID.
        self.job_id = job_id
        # The time when the media stream was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.modification_time = modification_time
        # The type of Narrowband HD transcoding. Valid values:
        # 
        # *   **0**: standard transcoding
        # *   **1.0**: Narrowband HD 1.0 transcoding
        # *   **2.0**: Narrowband HD 2.0 transcoding
        # 
        # This parameter is returned only when a definition that is available in the built-in Narrowband HD 1.0 transcoding template is specified. For more information, see the [Definition parameter in TranscodeTemplate](https://help.aliyun.com/document_detail/52839.html) table.
        self.narrow_band_type = narrow_band_type
        # The playback URL of the media stream.
        self.play_url = play_url
        # The size of the media stream. Unit: bytes.
        self.size = size
        # The status of the media stream. Valid values:
        # 
        # *   **Normal**\
        # *   **Invisible**\
        self.status = status
        # The tags of the media stream, which are used to identify the transcoding type.
        self.stream_tags = stream_tags
        # The type of the media stream. If the media stream is a video stream, the value is **video**. If the media stream is an audio-only stream, the value is **audio**.
        self.stream_type = stream_type
        # The type of the transcoding template. Valid values:
        # 
        # *   Normal: standard transcoding
        # *   AudioTranscode: audio transcoding
        # *   Remux: container format conversion
        # *   NarrowBandV1: Narrowband HD 1.0
        # *   NarrowBandV2: Narrowband HD 2.0
        # *   UHD: audio and video enhancement (ultra-high definition)
        self.trans_template_type = trans_template_type
        # The ID of the watermark that is associated with the media stream.
        self.watermark_id = watermark_id
        # The width of the media stream. Unit: pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bit_depth is not None:
            result['BitDepth'] = self.bit_depth
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encrypt is not None:
            result['Encrypt'] = self.encrypt
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.height is not None:
            result['Height'] = self.height
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.narrow_band_type is not None:
            result['NarrowBandType'] = self.narrow_band_type
        if self.play_url is not None:
            result['PlayURL'] = self.play_url
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_tags is not None:
            result['StreamTags'] = self.stream_tags
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.trans_template_type is not None:
            result['TransTemplateType'] = self.trans_template_type
        if self.watermark_id is not None:
            result['WatermarkId'] = self.watermark_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BitDepth') is not None:
            self.bit_depth = m.get('BitDepth')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encrypt') is not None:
            self.encrypt = m.get('Encrypt')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('NarrowBandType') is not None:
            self.narrow_band_type = m.get('NarrowBandType')
        if m.get('PlayURL') is not None:
            self.play_url = m.get('PlayURL')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamTags') is not None:
            self.stream_tags = m.get('StreamTags')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('TransTemplateType') is not None:
            self.trans_template_type = m.get('TransTemplateType')
        if m.get('WatermarkId') is not None:
            self.watermark_id = m.get('WatermarkId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPlayInfoResponseBody(TeaModel):
    def __init__(
        self,
        media_base: GetPlayInfoResponseBodyMediaBase = None,
        play_info_list: List[GetPlayInfoResponseBodyPlayInfoList] = None,
        request_id: str = None,
    ):
        # The information about the media asset.
        self.media_base = media_base
        # The information about the audio or video stream.
        self.play_info_list = play_info_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_base:
            self.media_base.validate()
        if self.play_info_list:
            for k in self.play_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_base is not None:
            result['MediaBase'] = self.media_base.to_map()
        result['PlayInfoList'] = []
        if self.play_info_list is not None:
            for k in self.play_info_list:
                result['PlayInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaBase') is not None:
            temp_model = GetPlayInfoResponseBodyMediaBase()
            self.media_base = temp_model.from_map(m['MediaBase'])
        self.play_info_list = []
        if m.get('PlayInfoList') is not None:
            for k in m.get('PlayInfoList'):
                temp_model = GetPlayInfoResponseBodyPlayInfoList()
                self.play_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPlayInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPlayInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPlayInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProgramRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        program_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The name of the program.
        # 
        # This parameter is required.
        self.program_name = program_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        return self


class GetProgramResponseBody(TeaModel):
    def __init__(
        self,
        program: ChannelAssemblyProgram = None,
        request_id: str = None,
    ):
        # The information about the program.
        self.program = program
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.program:
            self.program.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program is not None:
            result['Program'] = self.program.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Program') is not None:
            temp_model = ChannelAssemblyProgram()
            self.program = temp_model.from_map(m['Program'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectExportJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetProjectExportJobResponseBodyProjectExportJobExportResult(TeaModel):
    def __init__(
        self,
        timeline: str = None,
    ):
        self.timeline = timeline

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        return self


class GetProjectExportJobResponseBodyProjectExportJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        export_result: GetProjectExportJobResponseBodyProjectExportJobExportResult = None,
        export_type: str = None,
        job_id: str = None,
        message: str = None,
        project_id: str = None,
        status: str = None,
        user_data: str = None,
    ):
        self.code = code
        self.export_result = export_result
        self.export_type = export_type
        self.job_id = job_id
        self.message = message
        self.project_id = project_id
        self.status = status
        self.user_data = user_data

    def validate(self):
        if self.export_result:
            self.export_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.export_result is not None:
            result['ExportResult'] = self.export_result.to_map()
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExportResult') is not None:
            temp_model = GetProjectExportJobResponseBodyProjectExportJobExportResult()
            self.export_result = temp_model.from_map(m['ExportResult'])
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetProjectExportJobResponseBody(TeaModel):
    def __init__(
        self,
        project_export_job: GetProjectExportJobResponseBodyProjectExportJob = None,
        request_id: str = None,
    ):
        self.project_export_job = project_export_job
        self.request_id = request_id

    def validate(self):
        if self.project_export_job:
            self.project_export_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_export_job is not None:
            result['ProjectExportJob'] = self.project_export_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectExportJob') is not None:
            temp_model = GetProjectExportJobResponseBodyProjectExportJob()
            self.project_export_job = temp_model.from_map(m['ProjectExportJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPublicMediaInfoRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
    ):
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData(TeaModel):
    def __init__(
        self,
        data: str = None,
        type: str = None,
    ):
        self.data = data
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        fps: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        profile: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.fps = fps
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.profile = profile
        self.sample_fmt = sample_fmt
        self.sample_rate = sample_rate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        region: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_name = file_name
        self.file_size = file_size
        self.file_status = file_status
        self.file_type = file_type
        self.file_url = file_url
        self.format_name = format_name
        self.height = height
        self.region = region
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(TeaModel):
    def __init__(
        self,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        nb_frames: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.nb_frames = nb_frames
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.rotate = rotate
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.nb_frames is not None:
            result['Nb_frames'] = self.nb_frames
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Nb_frames') is not None:
            self.nb_frames = m.get('Nb_frames')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoList(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList] = None,
        file_basic_info: GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo = None,
        subtitle_stream_info_list: List[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList] = None,
        video_stream_info_list: List[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList] = None,
    ):
        self.audio_stream_info_list = audio_stream_info_list
        self.file_basic_info = file_basic_info
        self.subtitle_stream_info_list = subtitle_stream_info_list
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.subtitle_stream_info_list:
            for k in self.subtitle_stream_info_list:
                if k:
                    k.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['SubtitleStreamInfoList'] = []
        if self.subtitle_stream_info_list is not None:
            for k in self.subtitle_stream_info_list:
                result['SubtitleStreamInfoList'].append(k.to_map() if k else None)
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.subtitle_stream_info_list = []
        if m.get('SubtitleStreamInfoList') is not None:
            for k in m.get('SubtitleStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList()
                self.subtitle_stream_info_list.append(temp_model.from_map(k))
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        user_data: str = None,
    ):
        self.business_type = business_type
        self.category = category
        self.cover_url = cover_url
        self.create_time = create_time
        self.deleted_time = deleted_time
        self.description = description
        # MediaId
        self.media_id = media_id
        self.media_tags = media_tags
        self.media_type = media_type
        self.modified_time = modified_time
        self.source = source
        self.sprite_images = sprite_images
        self.status = status
        self.title = title
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetPublicMediaInfoResponseBodyMediaInfo(TeaModel):
    def __init__(
        self,
        dynamic_meta_data: GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData = None,
        file_info_list: List[GetPublicMediaInfoResponseBodyMediaInfoFileInfoList] = None,
        media_basic_info: GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo = None,
        media_id: str = None,
    ):
        self.dynamic_meta_data = dynamic_meta_data
        # FileInfos
        self.file_info_list = file_info_list
        # BasicInfo
        self.media_basic_info = media_basic_info
        self.media_id = media_id

    def validate(self):
        if self.dynamic_meta_data:
            self.dynamic_meta_data.validate()
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_meta_data is not None:
            result['DynamicMetaData'] = self.dynamic_meta_data.to_map()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DynamicMetaData') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData()
            self.dynamic_meta_data = temp_model.from_map(m['DynamicMetaData'])
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPublicMediaInfoResponseBody(TeaModel):
    def __init__(
        self,
        media_info: GetPublicMediaInfoResponseBodyMediaInfo = None,
        request_id: str = None,
    ):
        self.media_info = media_info
        # RequestId
        self.request_id = request_id

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPublicMediaInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPublicMediaInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPublicMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSmartHandleJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetSmartHandleJobResponseBodyJobResult(TeaModel):
    def __init__(
        self,
        ai_result: str = None,
        media_id: str = None,
        media_url: str = None,
        usage: str = None,
    ):
        # The AI analysis result.
        self.ai_result = ai_result
        # The ID of the media asset.
        self.media_id = media_id
        self.media_url = media_url
        # The token usage. This parameter is returned only for keyword-based text generation jobs.
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_result is not None:
            result['AiResult'] = self.ai_result
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaUrl'] = self.media_url
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiResult') is not None:
            self.ai_result = m.get('AiResult')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaUrl') is not None:
            self.media_url = m.get('MediaUrl')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class GetSmartHandleJobResponseBodySmartJobInfoInputConfig(TeaModel):
    def __init__(
        self,
        input_file: str = None,
    ):
        # The OSS URL or the ID of the material in the media asset library.
        self.input_file = input_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        return self


class GetSmartHandleJobResponseBodySmartJobInfoOutputConfig(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        object: str = None,
    ):
        # The OSS bucket.
        self.bucket = bucket
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSmartHandleJobResponseBodySmartJobInfo(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        input_config: GetSmartHandleJobResponseBodySmartJobInfoInputConfig = None,
        job_type: str = None,
        modified_time: str = None,
        output_config: GetSmartHandleJobResponseBodySmartJobInfoOutputConfig = None,
        title: str = None,
        user_id: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The job description.
        self.description = description
        # The input configurations.
        self.input_config = input_config
        # The job type.
        self.job_type = job_type
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The output configurations.
        self.output_config = output_config
        # The job title.
        self.title = title
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.output_config:
            self.output_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputConfig') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfoInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfoOutputConfig()
            self.output_config = temp_model.from_map(m['OutputConfig'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSmartHandleJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        job_result: GetSmartHandleJobResponseBodyJobResult = None,
        output: str = None,
        request_id: str = None,
        smart_job_info: GetSmartHandleJobResponseBodySmartJobInfo = None,
        state: str = None,
        user_data: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The job results.
        self.job_result = job_result
        # The job results.
        self.output = output
        # The request ID.
        self.request_id = request_id
        # The information about the intelligent job.
        self.smart_job_info = smart_job_info
        # The job state.
        # 
        # Valid values:
        # 
        # *   Finished
        # *   Failed
        # *   Executing
        # *   Created
        self.state = state
        # The user-defined data in the JSON format.
        self.user_data = user_data

    def validate(self):
        if self.job_result:
            self.job_result.validate()
        if self.smart_job_info:
            self.smart_job_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_result is not None:
            result['JobResult'] = self.job_result.to_map()
        if self.output is not None:
            result['Output'] = self.output
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.smart_job_info is not None:
            result['SmartJobInfo'] = self.smart_job_info.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobResult') is not None:
            temp_model = GetSmartHandleJobResponseBodyJobResult()
            self.job_result = temp_model.from_map(m['JobResult'])
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SmartJobInfo') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfo()
            self.smart_job_info = temp_model.from_map(m['SmartJobInfo'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetSmartHandleJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSmartHandleJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSmartHandleJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the snapshot job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetSnapshotJobResponseBodySnapshotJobInputOssFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket.
        self.bucket = bucket
        # The OSS location.
        self.location = location
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSnapshotJobResponseBodySnapshotJobInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        oss_file: GetSnapshotJobResponseBodySnapshotJobInputOssFile = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The three key elements of OSS.
        self.oss_file = oss_file
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        self.type = type

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobInputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSnapshotJobResponseBodySnapshotJobOutputOssFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket.
        self.bucket = bucket
        # The OSS location.
        self.location = location
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSnapshotJobResponseBodySnapshotJobOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        oss_file: GetSnapshotJobResponseBodySnapshotJobOutputOssFile = None,
        type: str = None,
    ):
        # The output file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS. If multiple static snapshots were captured, the object must contain the "{Count}" placeholder. In the case of a sprite, the object must contain the "{TileCount}" placeholder. The suffix of the WebVTT snapshot objects must be ".vtt".
        self.media = media
        # The three key elements of OSS.
        self.oss_file = oss_file
        # The type of the output file. Valid values:
        # 
        # 1.  OSS: an OSS object.
        # 2.  Media: a media asset.
        self.type = type

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobOutputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSnapshotJobResponseBodySnapshotJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        code: str = None,
        count: int = None,
        create_time: str = None,
        finish_time: str = None,
        input: GetSnapshotJobResponseBodySnapshotJobInput = None,
        job_id: str = None,
        message: str = None,
        modified_time: str = None,
        name: str = None,
        output: GetSnapshotJobResponseBodySnapshotJobOutput = None,
        pipeline_id: str = None,
        status: str = None,
        submit_time: str = None,
        template_config: str = None,
        template_id: str = None,
        trigger_source: str = None,
        type: str = None,
        user_data: str = None,
    ):
        # Indicates whether the snapshots were captured in asynchronous mode. Default value: true.
        self.async_ = async_
        # Error codes
        self.code = code
        # The number of snapshots.
        self.count = count
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The error message that is returned.
        self.message = message
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The snapshot template configuration.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The request trigger source.
        # 
        # Valid values:
        # 
        # *   Console
        # *   Workflow
        # *   API
        self.trigger_source = trigger_source
        # Snapshot types
        # 
        # Valid values:
        # 
        # *   WebVtt
        # *   Sprite
        # *   Normal
        self.type = type
        # The user-defined parameters.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.type is not None:
            result['Type'] = self.type
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snapshot_job: GetSnapshotJobResponseBodySnapshotJob = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the snapshot job.
        self.snapshot_job = snapshot_job

    def validate(self):
        if self.snapshot_job:
            self.snapshot_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job is not None:
            result['SnapshotJob'] = self.snapshot_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJob') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJob()
            self.snapshot_job = temp_model.from_map(m['SnapshotJob'])
        return self


class GetSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSnapshotUrlsRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        timeout: int = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The order that you use to sort the query results. Valid values: Asc and Desc.
        # 
        # - Asc
        # 
        # - Desc
        self.order_by = order_by
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 30. Default value: 10.
        self.page_size = page_size
        # The authentication timeout period. Unit: seconds Default value: 3600. Maximum value: 129600 (36 hours).
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetSnapshotUrlsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snapshot_urls: List[str] = None,
        total: int = None,
        web_vtturl: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The list of snapshot URLs.
        self.snapshot_urls = snapshot_urls
        # The total number of snapshots.
        self.total = total
        # The URL of the WebVTT file.
        self.web_vtturl = web_vtturl

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_urls is not None:
            result['SnapshotUrls'] = self.snapshot_urls
        if self.total is not None:
            result['Total'] = self.total
        if self.web_vtturl is not None:
            result['WebVTTUrl'] = self.web_vtturl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotUrls') is not None:
            self.snapshot_urls = m.get('SnapshotUrls')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('WebVTTUrl') is not None:
            self.web_vtturl = m.get('WebVTTUrl')
        return self


class GetSnapshotUrlsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSnapshotUrlsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSnapshotUrlsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSourceRequest(TeaModel):
    def __init__(
        self,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        # The source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name
        # The name of the source.
        # 
        # This parameter is required.
        self.source_name = source_name
        # The source type. Valid values: vodSource and liveSource.
        # 
        # This parameter is required.
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class GetSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source: ChannelAssemblySource = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source information.
        self.source = source

    def validate(self):
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            temp_model = ChannelAssemblySource()
            self.source = temp_model.from_map(m['Source'])
        return self


class GetSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSourceLocationRequest(TeaModel):
    def __init__(
        self,
        source_location_name: str = None,
    ):
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        return self


class GetSourceLocationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source_location: ChannelAssemblySourceLocation = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source location information.
        self.source_location = source_location

    def validate(self):
        if self.source_location:
            self.source_location.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source_location is not None:
            result['SourceLocation'] = self.source_location.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SourceLocation') is not None:
            temp_model = ChannelAssemblySourceLocation()
            self.source_location = temp_model.from_map(m['SourceLocation'])
        return self


class GetSourceLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSourceLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSourceLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStorageListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        status: str = None,
        storage_type: str = None,
    ):
        self.app_id = app_id
        self.status = status
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class GetStorageListResponseBodyStorageInfoList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        creation_time: str = None,
        default_storage: bool = None,
        editing_temp_file_storage: bool = None,
        modified_time: str = None,
        path: str = None,
        status: str = None,
        storage_location: str = None,
        storage_type: str = None,
    ):
        self.app_id = app_id
        self.creation_time = creation_time
        self.default_storage = default_storage
        self.editing_temp_file_storage = editing_temp_file_storage
        self.modified_time = modified_time
        self.path = path
        self.status = status
        self.storage_location = storage_location
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.default_storage is not None:
            result['DefaultStorage'] = self.default_storage
        if self.editing_temp_file_storage is not None:
            result['EditingTempFileStorage'] = self.editing_temp_file_storage
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.path is not None:
            result['Path'] = self.path
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DefaultStorage') is not None:
            self.default_storage = m.get('DefaultStorage')
        if m.get('EditingTempFileStorage') is not None:
            self.editing_temp_file_storage = m.get('EditingTempFileStorage')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class GetStorageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        storage_info_list: List[GetStorageListResponseBodyStorageInfoList] = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.storage_info_list = storage_info_list

    def validate(self):
        if self.storage_info_list:
            for k in self.storage_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StorageInfoList'] = []
        if self.storage_info_list is not None:
            for k in self.storage_info_list:
                result['StorageInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.storage_info_list = []
        if m.get('StorageInfoList') is not None:
            for k in m.get('StorageInfoList'):
                temp_model = GetStorageListResponseBodyStorageInfoList()
                self.storage_info_list.append(temp_model.from_map(k))
        return self


class GetStorageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStorageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStorageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSystemTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetSystemTemplateResponseBodySystemTemplate(TeaModel):
    def __init__(
        self,
        status: str = None,
        subtype: int = None,
        subtype_name: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
        type: int = None,
        type_name: str = None,
    ):
        # The template state.
        self.status = status
        # The subtype ID of the template.
        self.subtype = subtype
        # The subtype name of the template.
        self.subtype_name = subtype_name
        # The template parameters.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type ID of the template.
        self.type = type
        # The type name of the template.
        self.type_name = type_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetSystemTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        system_template: GetSystemTemplateResponseBodySystemTemplate = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The template information.
        self.system_template = system_template

    def validate(self):
        if self.system_template:
            self.system_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_template is not None:
            result['SystemTemplate'] = self.system_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemTemplate') is not None:
            temp_model = GetSystemTemplateResponseBodySystemTemplate()
            self.system_template = temp_model.from_map(m['SystemTemplate'])
        return self


class GetSystemTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSystemTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSystemTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateRequest(TeaModel):
    def __init__(
        self,
        related_mediaid_flag: str = None,
        template_id: str = None,
    ):
        # Specifies whether to return the information about the associated materials. Default value: 0. Valid values: 0 and 1. A value of 1 specifies that the information about the associated materials is returned. This parameter is valid only for regular templates.
        self.related_mediaid_flag = related_mediaid_flag
        # The template ID.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.related_mediaid_flag is not None:
            result['RelatedMediaidFlag'] = self.related_mediaid_flag
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RelatedMediaidFlag') is not None:
            self.related_mediaid_flag = m.get('RelatedMediaidFlag')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        clips_param: str = None,
        config: str = None,
        cover_url: str = None,
        create_source: str = None,
        creation_time: str = None,
        modified_source: str = None,
        modified_time: str = None,
        name: str = None,
        preview_media: str = None,
        preview_media_status: str = None,
        related_mediaids: str = None,
        status: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The clip parameters for submitting a video production job. You can replace mediaId and text with real values to submit a job. References:
        # 
        # *   [Create and use a regular template](https://help.aliyun.com/document_detail/445399.html)
        # *   [Create and use advanced templates](https://help.aliyun.com/document_detail/445389.html)
        self.clips_param = clips_param
        # The template configurations.
        # 
        # *   For more information about the configurations of a regular template, see [Config object of a regular template](https://help.aliyun.com/document_detail/456193.html).
        # *   For more information about the configurations of an advanced template, see [Create and use advanced templates](https://help.aliyun.com/document_detail/445389.html).
        self.config = config
        # The thumbnail URL.
        self.cover_url = cover_url
        # The source from which the template was created. Valid values:
        # 
        # *   AliyunConsole
        # *   OpenAPI
        # *   WebSDK
        self.create_source = create_source
        # The time when the template was created.
        self.creation_time = creation_time
        # The source from which the template was modified. Valid values:
        # 
        # *   AliyunConsole
        # *   OpenAPI
        # *   WebSDK
        self.modified_source = modified_source
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The template name.
        self.name = name
        # The preview media asset.
        self.preview_media = preview_media
        # The state of the preview media asset. Valid values:
        # 
        # *   Init: the initial state, which indicates that the source file is not ready.
        # *   Preparing: The source file is being prepared. For example, the file is being uploaded or edited.
        # *   PrepareFail: The source file failed to be prepared. For example, the information about the source file failed to be obtained.
        # *   Normal: The source file is ready.
        self.preview_media_status = preview_media_status
        # The IDs of the materials associated with the template for use by the regular template editor.
        self.related_mediaids = related_mediaids
        # The template state. Valid values:
        # 
        # *   Available
        # *   Created
        # *   Uploading
        # *   Processing
        # *   UploadFailed
        # *   ProcessFailed
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The template type. Valid values:
        # 
        # *   Timeline
        # *   VETemplate
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.preview_media_status is not None:
            result['PreviewMediaStatus'] = self.preview_media_status
        if self.related_mediaids is not None:
            result['RelatedMediaids'] = self.related_mediaids
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('PreviewMediaStatus') is not None:
            self.preview_media_status = m.get('PreviewMediaStatus')
        if m.get('RelatedMediaids') is not None:
            self.related_mediaids = m.get('RelatedMediaids')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: GetTemplateResponseBodyTemplate = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The template information.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = GetTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class GetTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateMaterialsRequest(TeaModel):
    def __init__(
        self,
        file_list: str = None,
        template_id: str = None,
    ):
        # The materials that you want to query.
        self.file_list = file_list
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_list is not None:
            result['FileList'] = self.file_list
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileList') is not None:
            self.file_list = m.get('FileList')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateMaterialsResponseBody(TeaModel):
    def __init__(
        self,
        material_urls: str = None,
        request_id: str = None,
    ):
        # The URLs of the associated materials.
        self.material_urls = material_urls
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_urls is not None:
            result['MaterialUrls'] = self.material_urls
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaterialUrls') is not None:
            self.material_urls = m.get('MaterialUrls')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTemplateMaterialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTemplateMaterialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateParamsRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateParamsResponseBodyParamList(TeaModel):
    def __init__(
        self,
        content: str = None,
        cover_url: str = None,
        key: str = None,
        media_url: str = None,
        type: str = None,
    ):
        # The original subtitle content.
        self.content = content
        # The thumbnail URL of the original material.
        self.cover_url = cover_url
        # The parameter name.
        self.key = key
        # The URL of the original material.
        self.media_url = media_url
        # The material type.
        # 
        # Valid values:
        # 
        # *   Video
        # *   Text
        # *   Image
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.key is not None:
            result['Key'] = self.key
        if self.media_url is not None:
            result['MediaUrl'] = self.media_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MediaUrl') is not None:
            self.media_url = m.get('MediaUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTemplateParamsResponseBody(TeaModel):
    def __init__(
        self,
        param_list: List[GetTemplateParamsResponseBodyParamList] = None,
        request_id: str = None,
        template_id: str = None,
    ):
        # The queried parameters.
        self.param_list = param_list
        # The request ID.
        self.request_id = request_id
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = GetTemplateParamsResponseBodyParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateParamsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTemplateParamsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateParamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        parent_job_id: str = None,
    ):
        # The job ID.
        self.parent_job_id = parent_job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobInputGroup(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The URL of the output stream.
        self.output_url = output_url
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
        key_service_type: str = None,
    ):
        # The ciphertext of HLS encryption.
        self.cipher_text = cipher_text
        # The endpoint of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # The encryption type.
        self.encrypt_type = encrypt_type
        # The type of the key service. Valid values: KMS and Base64.
        self.key_service_type = key_service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.key_service_type is not None:
            result['KeyServiceType'] = self.key_service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KeyServiceType') is not None:
            self.key_service_type = m.get('KeyServiceType')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the stream. Valid values: the number of seconds or "ToEND".
        self.duration = duration
        # The start time of the stream.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The position of the watermark on the x-axis.
        self.dx = dx
        # The position of the watermark on the y-axis.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the output video.
        self.height = height
        # The reference position of the watermark. Valid values: TopLeft, TopRight, BottomLeft, and BottomRight. Default value: TopLeft.
        self.refer_pos = refer_pos
        # The timeline settings.
        self.timeline = timeline
        # The width of the output video.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Indicates whether the text size was adjusted based on the output video dimensions. Valid values: true and false. Default value: false.
        self.adaptive = adaptive
        # The border color.
        self.border_color = border_color
        # The border width.
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the watermark.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text.
        self.font_name = font_name
        # The size of the text.
        self.font_size = font_size
        # The distance of the watermark from the left edge.
        self.left = left
        # The distance of the watermark from the top edge.
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: [8,1000].
        # *   Unit: Kbit/s.
        # *   Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Indicates whether the audio stream is deleted.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Default value: 44100.
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method that is used to adjust the resolution. This parameter takes effect only if both the Width and Height parameters are specified. You can use this parameter together with the LongShortMode parameter.
        # 
        # Valid values: rescale, crop, pad, and none.
        # 
        # Default value: none.
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate was checked. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input audio is less than that of the output audio, the bitrate of the input audio is used for transcoding.
        # *   false
        # 
        # Default value:
        # 
        # *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        # *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate was checked. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input audio is less than that of the output audio, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the video resolution was checked. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true If the width or height of the input video is less than that of the output video, the resolution of the input video is used for transcoding.
        # *   false
        # 
        # Default value: false.
        self.is_check_reso = is_check_reso
        # Indicates whether the video resolution was checked. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true If the width or height of the input video is less than that of the output video, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate was checked. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input video is less than that of the output video, the bitrate of the input video is used for transcoding.
        # *   false
        # 
        # Default value: false.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate was checked. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input video is less than that of the output video, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The video transcoding mode. Valid values:
        # 
        # *   onepass: You can set this parameter to onepass if the Bitrate parameter is set to ABR. The encoding speed of this mode is faster than that of the twopass mode.
        # *   twopass: You can set this parameter to twopass if the Bitrate parameter is set to VBR. The encoding speed of this mode is slower than that of the onepass mode.
        # *   CBR: the constant bitrate mode.
        # 
        # Default value: onepass.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum ABR. This parameter takes effect only for Narrowband HD 1.0.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.abr_max = abr_max
        # The average bitrate of the video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size.
        # 
        # *   Valid values: [1000,128000].
        # *   Default value: 6000.
        # *   Unit: KB.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Valid values: [0,51].
        # *   Default value: 23 if the encoding format is H.264, or 26 if the encoding format is H.265.
        # *   If this parameter is specified, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values: border: automatically detects and removes black bars. A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The frame rate.
        # 
        # *   Valid values: (0,60].
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes.
        # 
        # *   Valid values: [1,1080000].
        # *   Default value: 250.
        self.gop = gop
        # The height of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the height of the input video.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the output video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Indicates whether the video was removed.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio = None,
        container: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        trans_config: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig = None,
        video: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        # The conditional transcoding configurations.
        self.trans_config = trans_config
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('TransConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs] = None,
        encryption: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption = None,
        image_watermarks: List[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks] = None,
        subtitles: List[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles] = None,
        text_watermarks: List[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks] = None,
        transcode: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration of an image.
        self.image_watermarks = image_watermarks
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermark.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup(TeaModel):
    def __init__(
        self,
        output: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput = None,
        process_config: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig = None,
    ):
        # The output file configuration.
        self.output = output
        # The job processing configuration.
        self.process_config = process_config

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the snapshot job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media asset. This parameter is specified only when the media asset is transcoded.
        self.input_url = input_url
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sample format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video. Unit: seconds.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The state of the file.
        self.file_status = file_status
        # The file type. Valid values: source_file and transcode_file.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height of the output video.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height of the output video.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image. Valid values: 0, 90, 180, and 270. Default value: 0.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList] = None,
        file_basic_info: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo = None,
        video_stream_info_list: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The path of the transcoded output stream. This parameter is required only when the output is a media asset.
        self.output_url = output_url
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
        key_service_type: str = None,
    ):
        # The ciphertext of HTTP Live Streaming (HLS) encryption.
        self.cipher_text = cipher_text
        # The endpoint of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # The encryption type.
        self.encrypt_type = encrypt_type
        # The type of the key service. Valid values: KMS and Base64.
        self.key_service_type = key_service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.key_service_type is not None:
            result['KeyServiceType'] = self.key_service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KeyServiceType') is not None:
            self.key_service_type = m.get('KeyServiceType')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the stream. Valid values: the number of seconds or "ToEND".
        self.duration = duration
        # The start time of the stream.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The position of the watermark on the x-axis.
        self.dx = dx
        # The position of the watermark on the y-axis.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the output video.
        self.height = height
        # The reference position of the watermark. Valid values: TopLeft, TopRight, BottomLeft, and BottomRight. Default value: TopLeft.
        self.refer_pos = refer_pos
        # The timeline settings.
        self.timeline = timeline
        # The width of the output video.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Indicates whether the text size was adjusted based on the output video dimensions. Valid values: true and false. Default value: false.
        self.adaptive = adaptive
        # The border color.
        self.border_color = border_color
        # The border width.
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the watermark.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text.
        self.font_name = font_name
        # The size of the text.
        self.font_size = font_size
        # The distance of the watermark from the left edge.
        self.left = left
        # The distance of the watermark from the top edge.
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: [8,1000].
        # *   Unit: Kbit/s.
        # *   Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Indicates whether the audio stream is deleted.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Default value: 44100. Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method that is used to adjust the resolution. This parameter takes effect only if both the Width and Height parameters are specified. You can use this parameter together with the LongShortMode parameter.
        # 
        # Valid values: rescale, crop, pad, and none.
        # 
        # Default value: none.
        # 
        # For more information about examples, see How do I set the resolution for an output video?
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate was checked. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input audio is less than that of the output audio, the bitrate of the input audio is used for transcoding.
        # *   false
        # 
        # Default value:
        # 
        # *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        # *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate was checked. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input audio is less than that of the output audio, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the video resolution was checked. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true If the width or height of the input video is less than that of the output video, the resolution of the input video is used for transcoding.
        # *   false
        # 
        # Default value: false.
        self.is_check_reso = is_check_reso
        # Indicates whether the video resolution was checked. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true If the width or height of the input video is less than that of the output video, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate was checked. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input video is less than that of the output video, the bitrate of the input video is used for transcoding.
        # *   false
        # 
        # Default value: false.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate was checked. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true If the bitrate of the input video is less than that of the output video, the transcoding job fails.
        # *   false
        # 
        # Default value: false.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The video transcoding mode. Valid values:
        # 
        # *   onepass: You can set this parameter to onepass if the Bitrate parameter is set to ABR. The encoding speed of this mode is faster than that of the twopass mode.
        # *   twopass: You can set this parameter to twopass if the Bitrate parameter is set to VBR. The encoding speed of this mode is slower than that of the onepass mode.
        # *   CBR: the constant bitrate mode.
        # 
        # Default value: onepass.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum adaptive bitrate (ABR). This parameter takes effect only for Narrowband HD 1.0.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.abr_max = abr_max
        # The average bitrate of the video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size.
        # 
        # *   Valid values: [1000,128000].
        # *   Default value: 6000.
        # *   Unit: Kbit/s.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Valid values: [0,51].
        # *   Default value: 23 if the encoding format is H.264, or 26 if the encoding format is H.265.
        # 
        # If this parameter is specified, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   border: automatically detects and removes black bars.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings.
        self.crop = crop
        # The frame rate.
        # 
        # *   Valid values: (0,60]. The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes.
        # 
        # *   Valid values: [1,1080000].
        # *   Default value: 250.
        self.gop = gop
        # The height of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # 
        # Default value: the height of the input video.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the output video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video. Format: width:height:left:top.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Indicates whether the video was removed.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # 
        # Default value: the width of the input video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio = None,
        container: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        tags: Dict[str, str] = None,
        trans_config: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig = None,
        video: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        self.tags = tags
        # The conditional transcoding configurations.
        self.trans_config = trans_config
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TransConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs] = None,
        encryption: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption = None,
        image_watermarks: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks] = None,
        is_inherit_tags: bool = None,
        subtitles: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles] = None,
        text_watermarks: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks] = None,
        transcode: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration of an image.
        self.image_watermarks = image_watermarks
        # Indicates whether the tags of the input stream are inherited in the output stream. This parameter does not take effect when the input is not a media asset. Default value: false.
        self.is_inherit_tags = is_inherit_tags
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermark.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        if self.is_inherit_tags is not None:
            result['IsInheritTags'] = self.is_inherit_tags
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        if m.get('IsInheritTags') is not None:
            self.is_inherit_tags = m.get('IsInheritTags')
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the snapshot job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input_group: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup] = None,
        job_id: str = None,
        job_index: int = None,
        name: str = None,
        out_file_meta: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta = None,
        output: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput = None,
        parent_job_id: str = None,
        process_config: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig = None,
        request_id: str = None,
        schedule_config: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        user_data: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        self.input_group = input_group
        # The subjob ID.
        self.job_id = job_id
        # The index number of the subjob in the entire job.
        self.job_index = job_index
        # The job name.
        self.name = name
        # The media information about the video generated by the job.
        self.out_file_meta = out_file_meta
        # The output file configuration.
        self.output = output
        # The main job ID.
        self.parent_job_id = parent_job_id
        # The transcoding configuration.
        self.process_config = process_config
        # The ID of the request that submitted the job.
        self.request_id = request_id
        # The scheduling information about the job.
        self.schedule_config = schedule_config
        # The state of the transcoding job. Valid values: Init (the job is submitted), Success (the job is successful), Fail (the job failed), and Deleted (the job is deleted).
        self.status = status
        # The job submission result.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.out_file_meta:
            self.out_file_meta.validate()
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_index is not None:
            result['JobIndex'] = self.job_index
        if self.name is not None:
            result['Name'] = self.name
        if self.out_file_meta is not None:
            result['OutFileMeta'] = self.out_file_meta.to_map()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobIndex') is not None:
            self.job_index = m.get('JobIndex')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutFileMeta') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta()
            self.out_file_meta = temp_model.from_map(m['OutFileMeta'])
        if m.get('Output') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('ProcessConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input_group: List[GetTranscodeJobResponseBodyTranscodeParentJobInputGroup] = None,
        job_count: int = None,
        name: str = None,
        output_group: List[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup] = None,
        parent_job_id: str = None,
        percent: int = None,
        request_id: str = None,
        schedule_config: GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig = None,
        status: str = None,
        submit_time: str = None,
        transcode_job_list: List[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList] = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        self.input_group = input_group
        # The number of subjobs.
        self.job_count = job_count
        # The job name.
        self.name = name
        # The output group of the job.
        self.output_group = output_group
        # The main job ID.
        self.parent_job_id = parent_job_id
        # The completion percentage of the job.
        self.percent = percent
        # The ID of the request that submitted the job.
        self.request_id = request_id
        # The scheduling configuration of the job.
        self.schedule_config = schedule_config
        # The state of the job.
        # 
        # *   Success: At least one of the subjobs is successful.
        # *   Fail: All subjobs failed.
        self.status = status
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The list of subjobs.
        self.transcode_job_list = transcode_job_list
        # The source of the job. Valid values:
        # 
        # *   API
        # *   WorkFlow
        # *   Console
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.transcode_job_list:
            for k in self.transcode_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        result['TranscodeJobList'] = []
        if self.transcode_job_list is not None:
            for k in self.transcode_job_list:
                result['TranscodeJobList'].append(k.to_map() if k else None)
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        self.transcode_job_list = []
        if m.get('TranscodeJobList') is not None:
            for k in m.get('TranscodeJobList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList()
                self.transcode_job_list.append(temp_model.from_map(k))
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transcode_parent_job: GetTranscodeJobResponseBodyTranscodeParentJob = None,
    ):
        # The request ID.
        self.request_id = request_id
        # TranscodeParentJobWithSubJobDTO
        self.transcode_parent_job = transcode_parent_job

    def validate(self):
        if self.transcode_parent_job:
            self.transcode_parent_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.transcode_parent_job is not None:
            result['TranscodeParentJob'] = self.transcode_parent_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TranscodeParentJob') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJob()
            self.transcode_parent_job = temp_model.from_map(m['TranscodeParentJob'])
        return self


class GetTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUrlUploadInfosRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        upload_urls: str = None,
    ):
        # The IDs of the upload jobs. You can specify one or more job IDs. You can obtain the job IDs from the response parameter JobId of the [UploadMediaByURL](https://help.aliyun.com/document_detail/86311.html) operation.
        # 
        # *   You can specify a maximum of 10 job IDs.
        # *   Separate the job IDs with commas (,).
        # 
        # >  You must specify either JobIds or UploadURLs. If you specify both parameters, only the value of JobIds takes effect.
        self.job_ids = job_ids
        # The upload URLs of the source files. You can specify a maximum of 10 URLs. Separate the URLs with commas (,).
        # 
        # > 
        # 
        # *   The URLs must be encoded.
        # 
        # *   If a media file is uploaded multiple times, we recommend that you specify the URL of the media file only once in this parameter.
        # 
        # *   You must specify either JobIds or UploadURLs. If you specify both parameters, only the value of JobIds takes effect.
        self.upload_urls = upload_urls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.upload_urls is not None:
            result['UploadURLs'] = self.upload_urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('UploadURLs') is not None:
            self.upload_urls = m.get('UploadURLs')
        return self


class GetUrlUploadInfosResponseBodyURLUploadInfoList(TeaModel):
    def __init__(
        self,
        complete_time: str = None,
        creation_time: str = None,
        error_code: str = None,
        error_message: str = None,
        file_size: str = None,
        job_id: str = None,
        media_id: str = None,
        status: str = None,
        upload_url: str = None,
        user_data: str = None,
    ):
        # The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The error code returned if the upload job failed.
        self.error_code = error_code
        # The error message returned if the upload job failed.
        self.error_message = error_message
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The ID of the upload job.
        self.job_id = job_id
        # The ID of the uploaded media file.
        self.media_id = media_id
        # The status of the upload job. For more information about the valid values of the parameter, see the "Status: the status of a URL-based upload job" section of the [Basic data types](https://help.aliyun.com/document_detail/52839.html) topic.
        self.status = status
        # The upload URL of the source file.
        # 
        # >  A maximum of 100 URLs can be returned.
        self.upload_url = upload_url
        # The user data. The value is a JSON string.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.status is not None:
            result['Status'] = self.status
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetUrlUploadInfosResponseBody(TeaModel):
    def __init__(
        self,
        non_exists: List[str] = None,
        request_id: str = None,
        urlupload_info_list: List[GetUrlUploadInfosResponseBodyURLUploadInfoList] = None,
    ):
        # The job IDs or upload URLs that do not exist.
        self.non_exists = non_exists
        # The request ID.
        self.request_id = request_id
        # The details about URL-based upload jobs.
        self.urlupload_info_list = urlupload_info_list

    def validate(self):
        if self.urlupload_info_list:
            for k in self.urlupload_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exists is not None:
            result['NonExists'] = self.non_exists
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['URLUploadInfoList'] = []
        if self.urlupload_info_list is not None:
            for k in self.urlupload_info_list:
                result['URLUploadInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExists') is not None:
            self.non_exists = m.get('NonExists')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.urlupload_info_list = []
        if m.get('URLUploadInfoList') is not None:
            for k in m.get('URLUploadInfoList'):
                temp_model = GetUrlUploadInfosResponseBodyURLUploadInfoList()
                self.urlupload_info_list.append(temp_model.from_map(k))
        return self


class GetUrlUploadInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUrlUploadInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUrlUploadInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoListRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        end_time: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The ID of the category.
        self.cate_id = cate_id
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The sorting method of the results. Valid values:
        # 
        # *   CreationTime:Desc (default): sorts results in reverse chronological order.
        # *   CreationTime:Asc: sorts results in chronological order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The status of the video. You can specify multiple video statuses and separate them with commas (,).
        # 
        # Valid values:
        # 
        # *   PrepareFail: The file is abnormal.
        # *   UploadFail: The video failed to be uploaded.
        # *   UploadSucc: The video is uploaded.
        # *   Transcoding: The video is being transcoded.
        # *   TranscodeFail: The video failed to be transcoded.
        # *   ProduceFail: The video failed to be produced.
        # *   Normal: The video is normal.
        # *   Uploading: The video is being uploaded.
        # *   Preparing: The file is being generated.
        # *   Blocked: The video is blocked.
        # *   checking: The video is being reviewed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetVideoListResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cate_id: int = None,
        cate_name: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: float = None,
        media_id: str = None,
        modification_time: str = None,
        size: int = None,
        snapshots: List[str] = None,
        status: str = None,
        storage_location: str = None,
        tags: str = None,
        title: str = None,
    ):
        # The ID of the application. Default value: app-1000000.
        self.app_id = app_id
        # The ID of the category.
        self.cate_id = cate_id
        # The name of the category.
        self.cate_name = cate_name
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the audio or video file was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the audio or video file.
        self.description = description
        # The duration. Unit: seconds.
        self.duration = duration
        # The ID of the audio or video file.
        self.media_id = media_id
        # The time when the audio or video file was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modification_time = modification_time
        # The size of the source file. Unit: bytes.
        self.size = size
        # The array of video snapshot URLs.
        self.snapshots = snapshots
        # The status of the video.
        # 
        # Valid values:
        # 
        # *   PrepareFail: The file is abnormal.
        # *   UploadFail: The video failed to be uploaded.
        # *   UploadSucc: The video is uploaded.
        # *   Transcoding: The video is being transcoded.
        # *   TranscodeFail: The video failed to be transcoded.
        # *   ProduceFail: The video failed to be produced.
        # *   Normal: The video is normal.
        # *   Uploading: The video is being uploaded.
        # *   Preparing: The file is being generated.
        # *   Blocked: The video is blocked.
        # *   checking: The video is being reviewed.
        self.status = status
        # The storage address.
        self.storage_location = storage_location
        # The tags of the audio or video file.
        self.tags = tags
        # The title of the audio or video file.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetVideoListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_list: List[GetVideoListResponseBodyMediaList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The information about the audio and video files.
        self.media_list = media_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success
        # The total number of audio and video files that meet the conditions.
        self.total = total

    def validate(self):
        if self.media_list:
            for k in self.media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaList'] = []
        if self.media_list is not None:
            for k in self.media_list:
                result['MediaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_list = []
        if m.get('MediaList') is not None:
            for k in m.get('MediaList'):
                temp_model = GetVideoListResponseBodyMediaList()
                self.media_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetVideoListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVideoListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVideoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVodPackagingAssetRequest(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
    ):
        # The name of the VOD packaging asset.
        self.asset_name = asset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        return self


class GetVodPackagingAssetResponseBodyAssetEgressEndpoints(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
        status: str = None,
        url: str = None,
    ):
        # The name of the packaging configuration.
        self.configuration_name = configuration_name
        # The asset status. Valid values:
        # 
        # *   Queuing: The asset is waiting for packaging.
        # *   Playable: The asset is packaged and playable.
        # *   Failed: The asset fails to be packaged.
        self.status = status
        # The playback URL. If the asset fails to be packaged, no playback URL is returned.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        if self.status is not None:
            result['Status'] = self.status
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetVodPackagingAssetResponseBodyAssetInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media file. Only M3U8 files stored in OSS are supported.
        self.media = media
        # The input type. Only Object Storage Service (OSS) is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetVodPackagingAssetResponseBodyAsset(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        content_id: str = None,
        create_time: str = None,
        egress_endpoints: List[GetVodPackagingAssetResponseBodyAssetEgressEndpoints] = None,
        group_name: str = None,
        input: GetVodPackagingAssetResponseBodyAssetInput = None,
    ):
        # The name of the asset.
        self.asset_name = asset_name
        # The content ID in the DRM system. The maximum length is 256 characters. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.content_id = content_id
        # The time when the asset was created. It follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The egress endpoints, each corresponding to a packaging configuration.
        self.egress_endpoints = egress_endpoints
        # The name of the packaging group.
        self.group_name = group_name
        # The asset input configurations.
        self.input = input

    def validate(self):
        if self.egress_endpoints:
            for k in self.egress_endpoints:
                if k:
                    k.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.content_id is not None:
            result['ContentId'] = self.content_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['EgressEndpoints'] = []
        if self.egress_endpoints is not None:
            for k in self.egress_endpoints:
                result['EgressEndpoints'].append(k.to_map() if k else None)
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('ContentId') is not None:
            self.content_id = m.get('ContentId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.egress_endpoints = []
        if m.get('EgressEndpoints') is not None:
            for k in m.get('EgressEndpoints'):
                temp_model = GetVodPackagingAssetResponseBodyAssetEgressEndpoints()
                self.egress_endpoints.append(temp_model.from_map(k))
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Input') is not None:
            temp_model = GetVodPackagingAssetResponseBodyAssetInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class GetVodPackagingAssetResponseBody(TeaModel):
    def __init__(
        self,
        asset: GetVodPackagingAssetResponseBodyAsset = None,
        request_id: str = None,
    ):
        # The information about the asset.
        self.asset = asset
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.asset:
            self.asset.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset is not None:
            result['Asset'] = self.asset.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asset') is not None:
            temp_model = GetVodPackagingAssetResponseBodyAsset()
            self.asset = temp_model.from_map(m['Asset'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVodPackagingAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVodPackagingAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVodPackagingAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVodPackagingConfigurationRequest(TeaModel):
    def __init__(
        self,
        configuration_name: str = None,
    ):
        # The name of the packaging configuration.
        self.configuration_name = configuration_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_name is not None:
            result['ConfigurationName'] = self.configuration_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigurationName') is not None:
            self.configuration_name = m.get('ConfigurationName')
        return self


class GetVodPackagingConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        packaging_configuration: VodPackagingConfiguration = None,
        request_id: str = None,
    ):
        # The information about the packaging configuration.
        self.packaging_configuration = packaging_configuration
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.packaging_configuration:
            self.packaging_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.packaging_configuration is not None:
            result['PackagingConfiguration'] = self.packaging_configuration.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackagingConfiguration') is not None:
            temp_model = VodPackagingConfiguration()
            self.packaging_configuration = temp_model.from_map(m['PackagingConfiguration'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVodPackagingConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVodPackagingConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVodPackagingConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVodPackagingGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The name of the packaging group. The name must be unique and can be up to 128 characters in length. Letters, digits, underscores (_), and hyphens (-) are supported.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetVodPackagingGroupResponseBody(TeaModel):
    def __init__(
        self,
        packaging_group: VodPackagingGroup = None,
        request_id: str = None,
    ):
        # The information about the packaging group.
        self.packaging_group = packaging_group
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.packaging_group:
            self.packaging_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.packaging_group is not None:
            result['PackagingGroup'] = self.packaging_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackagingGroup') is not None:
            temp_model = VodPackagingGroup()
            self.packaging_group = temp_model.from_map(m['PackagingGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVodPackagingGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVodPackagingGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVodPackagingGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkflowTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        # The ID of the workflow task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetWorkflowTaskResponseBodyWorkflowTaskWorkflow(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modified_time: str = None,
        name: str = None,
        status: str = None,
        type: str = None,
        workflow_id: str = None,
    ):
        # The time when the workflow was created.
        self.create_time = create_time
        # The time when the workflow was last modified.
        self.modified_time = modified_time
        # The workflow name.
        self.name = name
        # The workflow state.
        # 
        # Valid values:
        # 
        # *   Active
        # *   Inactive
        self.status = status
        # The workflow type.
        # 
        # Valid values:
        # 
        # *   Customize: custom workflow.
        # *   System: system workflow.
        # *   Common: user-created workflow.
        self.type = type
        # The workflow ID.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetWorkflowTaskResponseBodyWorkflowTask(TeaModel):
    def __init__(
        self,
        activity_results: str = None,
        create_time: str = None,
        finish_time: str = None,
        status: str = None,
        task_id: str = None,
        task_input: str = None,
        user_data: str = None,
        workflow: GetWorkflowTaskResponseBodyWorkflowTaskWorkflow = None,
    ):
        # The results for all nodes of the workflow task.
        self.activity_results = activity_results
        # The time when the task was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the task was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The task state.
        # 
        # Valid values:
        # 
        # *   Init: The task is being initialized.
        # *   Failed: The task failed.
        # *   Canceled: The task is canceled.
        # *   Processing: The task is in progress.
        # *   Succeed: The task is successful.
        self.status = status
        # The ID of the workflow task.
        self.task_id = task_id
        # The input of the workflow task.
        self.task_input = task_input
        # The user-defined field that was specified when the workflow task was submitted.
        self.user_data = user_data
        # The workflow Information.
        self.workflow = workflow

    def validate(self):
        if self.workflow:
            self.workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_results is not None:
            result['ActivityResults'] = self.activity_results
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_input is not None:
            result['TaskInput'] = self.task_input
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.workflow is not None:
            result['Workflow'] = self.workflow.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityResults') is not None:
            self.activity_results = m.get('ActivityResults')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInput') is not None:
            self.task_input = m.get('TaskInput')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Workflow') is not None:
            temp_model = GetWorkflowTaskResponseBodyWorkflowTaskWorkflow()
            self.workflow = temp_model.from_map(m['Workflow'])
        return self


class GetWorkflowTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow_task: GetWorkflowTaskResponseBodyWorkflowTask = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the workflow task.
        self.workflow_task = workflow_task

    def validate(self):
        if self.workflow_task:
            self.workflow_task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_task is not None:
            result['WorkflowTask'] = self.workflow_task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowTask') is not None:
            temp_model = GetWorkflowTaskResponseBodyWorkflowTask()
            self.workflow_task = temp_model.from_map(m['WorkflowTask'])
        return self


class GetWorkflowTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkflowTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkflowTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertMediaToSearchLibRequest(TeaModel):
    def __init__(
        self,
        images_input: str = None,
        input: str = None,
        media_id: str = None,
        media_type: str = None,
        msg_body: str = None,
        search_lib_name: str = None,
    ):
        self.images_input = images_input
        # The URL of the video, audio, or image file that you want to import to the search library.
        # 
        # Note: Make sure that you specify a correct file name and the bucket in which the file resides is in the same region where this operation is called. Otherwise, the file cannot be found or the operation may fail.
        # 
        # Specify an Object Storage Service (OSS) URL in the following format: oss://[Bucket name]/[File path]. For example, you can specify oss://[example-bucket-****]/[object_path-****].
        # 
        # Specify an HTTP URL in the following format: public endpoint. For example, you can specify http://example-test-\\*\\*\\*\\*.mp4.
        # 
        # This parameter is required.
        self.input = input
        # The ID of the media asset. Each media ID is unique. If you leave this parameter empty, a media ID is automatically generated for this parameter.
        self.media_id = media_id
        # The type of the media asset. Valid values:
        # 
        # *   video (default)
        # *   image
        # *   audio
        self.media_type = media_type
        # The message body.
        self.msg_body = msg_body
        # The name of the search library. Default value: ims-default-search-lib.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images_input is not None:
            result['ImagesInput'] = self.images_input
        if self.input is not None:
            result['Input'] = self.input
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.msg_body is not None:
            result['MsgBody'] = self.msg_body
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImagesInput') is not None:
            self.images_input = m.get('ImagesInput')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('MsgBody') is not None:
            self.msg_body = m.get('MsgBody')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class InsertMediaToSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_id: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the media asset.
        self.media_id = media_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InsertMediaToSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertMediaToSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertMediaToSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAIAgentDialoguesRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        round_limit: str = None,
        session_id: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.round_limit = round_limit
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.round_limit is not None:
            result['RoundLimit'] = self.round_limit
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RoundLimit') is not None:
            self.round_limit = m.get('RoundLimit')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList(TeaModel):
    def __init__(
        self,
        format: str = None,
        id: str = None,
        name: str = None,
        type: int = None,
        url: str = None,
    ):
        self.format = format
        self.id = id
        self.name = name
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListAIAgentDialoguesResponseBodyDialogues(TeaModel):
    def __init__(
        self,
        attached_file_list: List[ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList] = None,
        dialogue_id: str = None,
        extend: str = None,
        node_id: str = None,
        producer: str = None,
        reasoning_text: str = None,
        round_id: str = None,
        source: str = None,
        text: str = None,
        time: int = None,
        type: str = None,
    ):
        self.attached_file_list = attached_file_list
        self.dialogue_id = dialogue_id
        self.extend = extend
        self.node_id = node_id
        self.producer = producer
        self.reasoning_text = reasoning_text
        self.round_id = round_id
        self.source = source
        self.text = text
        self.time = time
        self.type = type

    def validate(self):
        if self.attached_file_list:
            for k in self.attached_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttachedFileList'] = []
        if self.attached_file_list is not None:
            for k in self.attached_file_list:
                result['AttachedFileList'].append(k.to_map() if k else None)
        if self.dialogue_id is not None:
            result['DialogueId'] = self.dialogue_id
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.producer is not None:
            result['Producer'] = self.producer
        if self.reasoning_text is not None:
            result['ReasoningText'] = self.reasoning_text
        if self.round_id is not None:
            result['RoundId'] = self.round_id
        if self.source is not None:
            result['Source'] = self.source
        if self.text is not None:
            result['Text'] = self.text
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attached_file_list = []
        if m.get('AttachedFileList') is not None:
            for k in m.get('AttachedFileList'):
                temp_model = ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList()
                self.attached_file_list.append(temp_model.from_map(k))
        if m.get('DialogueId') is not None:
            self.dialogue_id = m.get('DialogueId')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Producer') is not None:
            self.producer = m.get('Producer')
        if m.get('ReasoningText') is not None:
            self.reasoning_text = m.get('ReasoningText')
        if m.get('RoundId') is not None:
            self.round_id = m.get('RoundId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAIAgentDialoguesResponseBody(TeaModel):
    def __init__(
        self,
        dialogues: List[ListAIAgentDialoguesResponseBodyDialogues] = None,
        request_id: str = None,
    ):
        self.dialogues = dialogues
        self.request_id = request_id

    def validate(self):
        if self.dialogues:
            for k in self.dialogues:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dialogues'] = []
        if self.dialogues is not None:
            for k in self.dialogues:
                result['Dialogues'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dialogues = []
        if m.get('Dialogues') is not None:
            for k in m.get('Dialogues'):
                temp_model = ListAIAgentDialoguesResponseBodyDialogues()
                self.dialogues.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAIAgentDialoguesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAIAgentDialoguesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAIAgentDialoguesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAIAgentInstanceRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        end_time: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
    ):
        # The ID of the AI agent.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. This parameter does not have a default value.
        self.end_time = end_time
        # The page number. Default value: 1. Valid values: 1 to 100.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: 0 to 100.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. This parameter does not have a default value.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAIAgentInstanceResponseBodyInstances(TeaModel):
    def __init__(
        self,
        agent_config: AIAgentConfig = None,
        call_log_url: str = None,
        runtime_config: AIAgentRuntimeConfig = None,
        status: str = None,
        template_config: AIAgentTemplateConfig = None,
        user_data: str = None,
    ):
        self.agent_config = agent_config
        # The URL of the call log file for the AI agent. The structure of the file is CallLog in the JSON format.
        self.call_log_url = call_log_url
        # The runtime configurations of the AI agent.
        self.runtime_config = runtime_config
        # The state of the instance. Valid values:
        # 
        # *   Executing
        # *   Finished
        self.status = status
        # The template configurations of the AI agent.
        self.template_config = template_config
        # The custom information.
        self.user_data = user_data

    def validate(self):
        if self.agent_config:
            self.agent_config.validate()
        if self.runtime_config:
            self.runtime_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_config is not None:
            result['AgentConfig'] = self.agent_config.to_map()
        if self.call_log_url is not None:
            result['CallLogUrl'] = self.call_log_url
        if self.runtime_config is not None:
            result['RuntimeConfig'] = self.runtime_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentConfig') is not None:
            temp_model = AIAgentConfig()
            self.agent_config = temp_model.from_map(m['AgentConfig'])
        if m.get('CallLogUrl') is not None:
            self.call_log_url = m.get('CallLogUrl')
        if m.get('RuntimeConfig') is not None:
            temp_model = AIAgentRuntimeConfig()
            self.runtime_config = temp_model.from_map(m['RuntimeConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateConfig') is not None:
            temp_model = AIAgentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListAIAgentInstanceResponseBody(TeaModel):
    def __init__(
        self,
        instances: List[ListAIAgentInstanceResponseBodyInstances] = None,
        request_id: str = None,
    ):
        # The list of the AI agents.
        self.instances = instances
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = ListAIAgentInstanceResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAIAgentInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAIAgentInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAIAgentInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAIAgentPhoneNumberRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListAIAgentPhoneNumberResponseBodyData(TeaModel):
    def __init__(
        self,
        phone_number: str = None,
        status: int = None,
    ):
        self.phone_number = phone_number
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListAIAgentPhoneNumberResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAIAgentPhoneNumberResponseBodyData] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_number: int = None,
    ):
        self.data = data
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_number = total_number

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_number is not None:
            result['TotalNumber'] = self.total_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAIAgentPhoneNumberResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNumber') is not None:
            self.total_number = m.get('TotalNumber')
        return self


class ListAIAgentPhoneNumberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAIAgentPhoneNumberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAIAgentPhoneNumberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAdInsertionsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        max_results: int = None,
        next_token: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The configuration name. Fuzzy match is supported.
        self.keyword = keyword
        # The maximum number of entries to retrieve in a subsequent request. If this parameter is used, the pagination parameters become invalid. Default value: 10.
        self.max_results = max_results
        # The token that is used in the next request to retrieve a new page of results. If this parameter is used, the pagination parameters become invalid.
        self.next_token = next_token
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sorting order of the configurations by creation time. asc: ascending. desc: descending.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListAdInsertionsResponseBodyConfigsCdnConfig(TeaModel):
    def __init__(
        self,
        ad_segment_url_prefix: str = None,
        content_segment_url_prefix: str = None,
    ):
        # The CDN prefix for ad segments.
        self.ad_segment_url_prefix = ad_segment_url_prefix
        # The CDN prefix for content segments.
        self.content_segment_url_prefix = content_segment_url_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_segment_url_prefix is not None:
            result['AdSegmentUrlPrefix'] = self.ad_segment_url_prefix
        if self.content_segment_url_prefix is not None:
            result['ContentSegmentUrlPrefix'] = self.content_segment_url_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdSegmentUrlPrefix') is not None:
            self.ad_segment_url_prefix = m.get('AdSegmentUrlPrefix')
        if m.get('ContentSegmentUrlPrefix') is not None:
            self.content_segment_url_prefix = m.get('ContentSegmentUrlPrefix')
        return self


class ListAdInsertionsResponseBodyConfigsManifestEndpointConfig(TeaModel):
    def __init__(
        self,
        dash_prefix: str = None,
        hls_prefix: str = None,
    ):
        # DASH
        self.dash_prefix = dash_prefix
        # The prefix of the playback endpoint for HLS manifests.
        self.hls_prefix = hls_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dash_prefix is not None:
            result['DashPrefix'] = self.dash_prefix
        if self.hls_prefix is not None:
            result['HlsPrefix'] = self.hls_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashPrefix') is not None:
            self.dash_prefix = m.get('DashPrefix')
        if m.get('HlsPrefix') is not None:
            self.hls_prefix = m.get('HlsPrefix')
        return self


class ListAdInsertionsResponseBodyConfigs(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_config: ListAdInsertionsResponseBodyConfigsCdnConfig = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        create_time: str = None,
        last_modified: str = None,
        manifest_endpoint_config: ListAdInsertionsResponseBodyConfigsManifestEndpointConfig = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Indicates whether ad marker passthrough is enabled.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The request URL of the ad decision server (ADS).
        self.ads_url = ads_url
        # The CDN configurations.
        self.cdn_config = cdn_config
        # The player parameter variables and aliases.
        self.config_aliases = config_aliases
        # The URL prefix for the source content.
        self.content_url_prefix = content_url_prefix
        # The time when the configuration was created.
        self.create_time = create_time
        # The time when the configuration was last modified.
        self.last_modified = last_modified
        # The playback endpoint configuration.
        self.manifest_endpoint_config = manifest_endpoint_config
        # The name of the ad insertion configuration.
        self.name = name
        # The personalization threshold that defines the maximum duration of underfilled time allowed in an ad break.
        self.personalization_threshold = personalization_threshold
        # The URL of the slate ad.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        if self.cdn_config:
            self.cdn_config.validate()
        if self.manifest_endpoint_config:
            self.manifest_endpoint_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_config is not None:
            result['CdnConfig'] = self.cdn_config.to_map()
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.manifest_endpoint_config is not None:
            result['ManifestEndpointConfig'] = self.manifest_endpoint_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnConfig') is not None:
            temp_model = ListAdInsertionsResponseBodyConfigsCdnConfig()
            self.cdn_config = temp_model.from_map(m['CdnConfig'])
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('ManifestEndpointConfig') is not None:
            temp_model = ListAdInsertionsResponseBodyConfigsManifestEndpointConfig()
            self.manifest_endpoint_config = temp_model.from_map(m['ManifestEndpointConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class ListAdInsertionsResponseBody(TeaModel):
    def __init__(
        self,
        configs: List[ListAdInsertionsResponseBodyConfigs] = None,
        max_results: int = None,
        next_token: str = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # Array
        self.configs = configs
        # The maximum number of entries to retrieve in a subsequent request. If this parameter is used, the pagination parameters become invalid.
        self.max_results = max_results
        # The token that is used in the next request to retrieve a new page of results. If this parameter is used, the pagination parameters become invalid.
        self.next_token = next_token
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The sorting order of the configurations by creation time. asc: ascending. desc: descending.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.configs:
            for k in self.configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Configs'] = []
        if self.configs is not None:
            for k in self.configs:
                result['Configs'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.configs = []
        if m.get('Configs') is not None:
            for k in m.get('Configs'):
                temp_model = ListAdInsertionsResponseBodyConfigs()
                self.configs.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAdInsertionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAdInsertionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAdInsertionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        gmt_end: str = None,
        gmt_start: str = None,
        page_no: int = None,
        page_size: int = None,
        resource_arn: str = None,
        sort_by: str = None,
        sort_by_modified_time: str = None,
    ):
        # The alert type.
        self.category = category
        # The end of the time range to query.
        self.gmt_end = gmt_end
        # The beginning of the time range to query.
        self.gmt_start = gmt_start
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The ARN of the source or program.
        # 
        # This parameter is required.
        self.resource_arn = resource_arn
        # The sorting order. By default, the query results are sorted by creation time in descending order. Valid values: asc and desc.
        self.sort_by = sort_by
        # The sorting order by modification time. Valid values: asc and desc.
        self.sort_by_modified_time = sort_by_modified_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.gmt_end is not None:
            result['GmtEnd'] = self.gmt_end
        if self.gmt_start is not None:
            result['GmtStart'] = self.gmt_start
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_arn is not None:
            result['ResourceArn'] = self.resource_arn
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.sort_by_modified_time is not None:
            result['SortByModifiedTime'] = self.sort_by_modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GmtEnd') is not None:
            self.gmt_end = m.get('GmtEnd')
        if m.get('GmtStart') is not None:
            self.gmt_start = m.get('GmtStart')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceArn') is not None:
            self.resource_arn = m.get('ResourceArn')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SortByModifiedTime') is not None:
            self.sort_by_modified_time = m.get('SortByModifiedTime')
        return self


class ListAlertsResponseBodyAlerts(TeaModel):
    def __init__(
        self,
        category: str = None,
        code: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        message: str = None,
        related_resource_arns: str = None,
        resource_arn: str = None,
    ):
        # The alert type.
        self.category = category
        # The error code.
        self.code = code
        # The time when the alert was received in UTC.
        self.gmt_create = gmt_create
        # The time when the alert was modified in UTC.
        self.gmt_modified = gmt_modified
        # The error message.
        self.message = message
        # The ARN of the related resource.
        self.related_resource_arns = related_resource_arns
        # The ARN of the resource.
        self.resource_arn = resource_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.code is not None:
            result['Code'] = self.code
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.message is not None:
            result['Message'] = self.message
        if self.related_resource_arns is not None:
            result['RelatedResourceArns'] = self.related_resource_arns
        if self.resource_arn is not None:
            result['ResourceArn'] = self.resource_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RelatedResourceArns') is not None:
            self.related_resource_arns = m.get('RelatedResourceArns')
        if m.get('ResourceArn') is not None:
            self.resource_arn = m.get('ResourceArn')
        return self


class ListAlertsResponseBody(TeaModel):
    def __init__(
        self,
        alerts: List[ListAlertsResponseBodyAlerts] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The alerts.
        self.alerts = alerts
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        # **Request ID**\
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.alerts:
            for k in self.alerts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alerts'] = []
        if self.alerts is not None:
            for k in self.alerts:
                result['Alerts'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alerts = []
        if m.get('Alerts') is not None:
            for k in m.get('Alerts'):
                temp_model = ListAlertsResponseBodyAlerts()
                self.alerts.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAlertsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllPublicMediaTagsRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        entity_id: str = None,
    ):
        # The business type of the media asset.
        self.business_type = business_type
        # The entity ID, which is used to distinguish between media assets of different types in the public domain.
        # 
        # Set this parameter to Copyright_Music, which indicates music in the public domain.
        self.entity_id = entity_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        return self


class ListAllPublicMediaTagsResponseBodyMediaTagListOptions(TeaModel):
    def __init__(
        self,
        option_chinese_name: str = None,
        option_english_name: str = None,
        option_id: str = None,
    ):
        # The option name in Chinese.
        self.option_chinese_name = option_chinese_name
        # The option name in English.
        self.option_english_name = option_english_name
        # The option ID.
        self.option_id = option_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_chinese_name is not None:
            result['OptionChineseName'] = self.option_chinese_name
        if self.option_english_name is not None:
            result['OptionEnglishName'] = self.option_english_name
        if self.option_id is not None:
            result['OptionId'] = self.option_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OptionChineseName') is not None:
            self.option_chinese_name = m.get('OptionChineseName')
        if m.get('OptionEnglishName') is not None:
            self.option_english_name = m.get('OptionEnglishName')
        if m.get('OptionId') is not None:
            self.option_id = m.get('OptionId')
        return self


class ListAllPublicMediaTagsResponseBodyMediaTagList(TeaModel):
    def __init__(
        self,
        media_tag_id: str = None,
        media_tag_name_chinese: str = None,
        media_tag_name_english: str = None,
        options: List[ListAllPublicMediaTagsResponseBodyMediaTagListOptions] = None,
    ):
        # The ID of the media tag.
        self.media_tag_id = media_tag_id
        # The name of the media tag in Chinese.
        self.media_tag_name_chinese = media_tag_name_chinese
        # The name of the material tag in English.
        self.media_tag_name_english = media_tag_name_english
        # The options.
        self.options = options

    def validate(self):
        if self.options:
            for k in self.options:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_tag_id is not None:
            result['MediaTagId'] = self.media_tag_id
        if self.media_tag_name_chinese is not None:
            result['MediaTagNameChinese'] = self.media_tag_name_chinese
        if self.media_tag_name_english is not None:
            result['MediaTagNameEnglish'] = self.media_tag_name_english
        result['Options'] = []
        if self.options is not None:
            for k in self.options:
                result['Options'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaTagId') is not None:
            self.media_tag_id = m.get('MediaTagId')
        if m.get('MediaTagNameChinese') is not None:
            self.media_tag_name_chinese = m.get('MediaTagNameChinese')
        if m.get('MediaTagNameEnglish') is not None:
            self.media_tag_name_english = m.get('MediaTagNameEnglish')
        self.options = []
        if m.get('Options') is not None:
            for k in m.get('Options'):
                temp_model = ListAllPublicMediaTagsResponseBodyMediaTagListOptions()
                self.options.append(temp_model.from_map(k))
        return self


class ListAllPublicMediaTagsResponseBody(TeaModel):
    def __init__(
        self,
        media_tag_list: List[ListAllPublicMediaTagsResponseBodyMediaTagList] = None,
        request_id: str = None,
    ):
        # The tags of media assets in the public media library.
        self.media_tag_list = media_tag_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_tag_list:
            for k in self.media_tag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaTagList'] = []
        if self.media_tag_list is not None:
            for k in self.media_tag_list:
                result['MediaTagList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_tag_list = []
        if m.get('MediaTagList') is not None:
            for k in m.get('MediaTagList'):
                temp_model = ListAllPublicMediaTagsResponseBodyMediaTagList()
                self.media_tag_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAllPublicMediaTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllPublicMediaTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllPublicMediaTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAvatarTrainingJobsRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        status: str = None,
    ):
        # *   The page number.
        # *   Default value: 1.
        self.page_no = page_no
        # *   The number of entries per page.
        # *   Default value: 10.
        # *   Valid values: 1 to 100.
        self.page_size = page_size
        # *   The job state.
        # *   Valid values: Init, Queuing, Training, Success, and Fail.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_id: str = None,
        avatar_name: str = None,
        avatar_type: str = None,
        create_time: str = None,
        first_training_time: str = None,
        job_id: str = None,
        last_training_time: str = None,
        message: str = None,
        portrait: str = None,
        status: str = None,
    ):
        # The description of the digital human.
        self.avatar_description = avatar_description
        # The ID of the digital human.
        self.avatar_id = avatar_id
        # The name of the digital human.
        self.avatar_name = avatar_name
        # The type of the digital human.
        self.avatar_type = avatar_type
        # *   The time when the job was created.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # *   The time when the first training was initiated.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.first_training_time = first_training_time
        # The ID of the digital human training job.
        self.job_id = job_id
        # *   The time when the last training was initiated.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.last_training_time = last_training_time
        # The status description.
        self.message = message
        # The media asset ID of the portrait image.
        self.portrait = portrait
        # The state of the digital human training job.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.first_training_time is not None:
            result['FirstTrainingTime'] = self.first_training_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.last_training_time is not None:
            result['LastTrainingTime'] = self.last_training_time
        if self.message is not None:
            result['Message'] = self.message
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FirstTrainingTime') is not None:
            self.first_training_time = m.get('FirstTrainingTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LastTrainingTime') is not None:
            self.last_training_time = m.get('LastTrainingTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListAvatarTrainingJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar_training_job_list: List[ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList] = None,
        total_count: int = None,
    ):
        # The list of digital human training jobs.
        self.avatar_training_job_list = avatar_training_job_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.avatar_training_job_list:
            for k in self.avatar_training_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvatarTrainingJobList'] = []
        if self.avatar_training_job_list is not None:
            for k in self.avatar_training_job_list:
                result['AvatarTrainingJobList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.avatar_training_job_list = []
        if m.get('AvatarTrainingJobList') is not None:
            for k in m.get('AvatarTrainingJobList'):
                temp_model = ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList()
                self.avatar_training_job_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAvatarTrainingJobsResponseBody(TeaModel):
    def __init__(
        self,
        data: ListAvatarTrainingJobsResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListAvatarTrainingJobsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAvatarTrainingJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAvatarTrainingJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAvatarTrainingJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAvatarsRequest(TeaModel):
    def __init__(
        self,
        avatar_type: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # *   The type of the digital human.
        # *   2DAvatar
        self.avatar_type = avatar_type
        # *   The page number.
        # *   Default value: 1.
        self.page_no = page_no
        # *   The number of entries per page.
        # *   Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListAvatarsResponseBodyDataAvatarList(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_id: str = None,
        avatar_name: str = None,
        avatar_type: str = None,
        portrait: str = None,
        thumbnail: str = None,
        transparent: bool = None,
    ):
        # The description of the digital human.
        self.avatar_description = avatar_description
        # The ID of the digital human.
        self.avatar_id = avatar_id
        # The name of the digital human.
        self.avatar_name = avatar_name
        # The type of the digital human.
        self.avatar_type = avatar_type
        # The media asset ID of the portrait image.
        self.portrait = portrait
        # The thumbnail URL.
        self.thumbnail = thumbnail
        # Indicates whether the digital human image supports the alpha channels.
        self.transparent = transparent

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.avatar_type is not None:
            result['AvatarType'] = self.avatar_type
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        if self.transparent is not None:
            result['Transparent'] = self.transparent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('AvatarType') is not None:
            self.avatar_type = m.get('AvatarType')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        if m.get('Transparent') is not None:
            self.transparent = m.get('Transparent')
        return self


class ListAvatarsResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar_list: List[ListAvatarsResponseBodyDataAvatarList] = None,
        total_count: int = None,
    ):
        # The queried digital humans.
        self.avatar_list = avatar_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.avatar_list:
            for k in self.avatar_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvatarList'] = []
        if self.avatar_list is not None:
            for k in self.avatar_list:
                result['AvatarList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.avatar_list = []
        if m.get('AvatarList') is not None:
            for k in m.get('AvatarList'):
                temp_model = ListAvatarsResponseBodyDataAvatarList()
                self.avatar_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAvatarsResponseBody(TeaModel):
    def __init__(
        self,
        data: ListAvatarsResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListAvatarsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAvatarsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAvatarsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAvatarsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBatchMediaProducingJobsRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        job_id: str = None,
        job_type: str = None,
        max_results: int = None,
        next_token: str = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the quick video production job.
        self.job_id = job_id
        # The job type.
        # 
        # Valid values:
        # 
        # *   Script: script-based editing job that mixes media assets.
        # *   Smart_Mix: intelligent editing job that mixes media assets.
        self.job_type = job_type
        # The maximum number of entries to return.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The sorting parameter. Valid values:
        # 
        # *   desc (default): sorted by creation time in descending order.
        # *   asc: sorted by creation time in ascending order.
        # 
        # <!---->
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The job state.
        # 
        # Valid values:
        # 
        # *   Finished
        # *   Init
        # *   Failed
        # *   Processing
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListBatchMediaProducingJobsResponseBodyEditingBatchJobList(TeaModel):
    def __init__(
        self,
        complete_time: str = None,
        create_time: str = None,
        editing_config: str = None,
        extend: str = None,
        input_config: str = None,
        job_id: str = None,
        job_type: str = None,
        modified_time: str = None,
        output_config: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The time when the job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The editing configurations. For more information, see [EditingConfig](~~2692547#1be9bba03b7qu~~).
        self.editing_config = editing_config
        # The extended information of the job.
        self.extend = extend
        # The input configurations.
        self.input_config = input_config
        # The ID of the quick video production job.
        self.job_id = job_id
        # The job type.
        # 
        # Valid values:
        # 
        # *   Script: script-based editing job that mixes media assets.
        # *   Smart_Mix: intelligent editing job that mixes media assets.
        self.job_type = job_type
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The output configurations. For more information, see [OutputConfig](~~2692547#447b928fcbuoa~~).
        self.output_config = output_config
        # The job state.
        # 
        # Valid values:
        # 
        # *   Finished
        # *   Init
        # *   Failed
        # *   Processing
        self.status = status
        # The user-defined data in the JSON format, which can be up to 512 bytes in length. You can specify a custom callback URL. For more information, see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListBatchMediaProducingJobsResponseBody(TeaModel):
    def __init__(
        self,
        editing_batch_job_list: List[ListBatchMediaProducingJobsResponseBodyEditingBatchJobList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        # The queried quick video production jobs.
        self.editing_batch_job_list = editing_batch_job_list
        # The number of entries per page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.editing_batch_job_list:
            for k in self.editing_batch_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EditingBatchJobList'] = []
        if self.editing_batch_job_list is not None:
            for k in self.editing_batch_job_list:
                result['EditingBatchJobList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.editing_batch_job_list = []
        if m.get('EditingBatchJobList') is not None:
            for k in m.get('EditingBatchJobList'):
                temp_model = ListBatchMediaProducingJobsResponseBodyEditingBatchJobList()
                self.editing_batch_job_list.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListBatchMediaProducingJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBatchMediaProducingJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBatchMediaProducingJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChannelAlertsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        gmt_end: str = None,
        gmt_start: str = None,
        page_no: int = None,
        page_size: int = None,
        resource_arn: str = None,
        sort_by_modified_time: str = None,
    ):
        # The alert type.
        self.category = category
        # The end of the time range to query.
        self.gmt_end = gmt_end
        # The beginning of the time range to query.
        self.gmt_start = gmt_start
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The ARN of the channel.
        # 
        # This parameter is required.
        self.resource_arn = resource_arn
        # The sorting order by modification time. Valid values: asc and desc.
        self.sort_by_modified_time = sort_by_modified_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.gmt_end is not None:
            result['GmtEnd'] = self.gmt_end
        if self.gmt_start is not None:
            result['GmtStart'] = self.gmt_start
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_arn is not None:
            result['ResourceArn'] = self.resource_arn
        if self.sort_by_modified_time is not None:
            result['SortByModifiedTime'] = self.sort_by_modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GmtEnd') is not None:
            self.gmt_end = m.get('GmtEnd')
        if m.get('GmtStart') is not None:
            self.gmt_start = m.get('GmtStart')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceArn') is not None:
            self.resource_arn = m.get('ResourceArn')
        if m.get('SortByModifiedTime') is not None:
            self.sort_by_modified_time = m.get('SortByModifiedTime')
        return self


class ListChannelAlertsResponseBodyProgramAlerts(TeaModel):
    def __init__(
        self,
        arn: str = None,
        category: str = None,
        count: int = None,
        gmt_modified: str = None,
        program_name: str = None,
    ):
        # The ARN of the program.
        self.arn = arn
        # The alert type.
        self.category = category
        # The number of alerts.
        self.count = count
        # The time when the alert was last modified in UTC.
        self.gmt_modified = gmt_modified
        # The name of the program.
        self.program_name = program_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        return self


class ListChannelAlertsResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        program_alerts: List[ListChannelAlertsResponseBodyProgramAlerts] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The alerts.
        self.program_alerts = program_alerts
        # **Request ID**\
        self.request_id = request_id
        # The total number of alerts returned.
        self.total_count = total_count

    def validate(self):
        if self.program_alerts:
            for k in self.program_alerts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProgramAlerts'] = []
        if self.program_alerts is not None:
            for k in self.program_alerts:
                result['ProgramAlerts'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.program_alerts = []
        if m.get('ProgramAlerts') is not None:
            for k in m.get('ProgramAlerts'):
                temp_model = ListChannelAlertsResponseBodyProgramAlerts()
                self.program_alerts.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListChannelAlertsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChannelAlertsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChannelAlertsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChannelsRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        channel_tier: str = None,
        page_no: int = None,
        page_size: int = None,
        playback_mode: str = None,
        sort_by: str = None,
        sort_by_modified_time: str = None,
        state: int = None,
    ):
        # The name of the channel.
        self.channel_name = channel_name
        # The tier of the channel. Valid values: basic and standard.
        self.channel_tier = channel_tier
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The playback mode. Valid values: loop and linear.
        self.playback_mode = playback_mode
        # The sorting order by creation time. Valid values: asc and desc.
        self.sort_by = sort_by
        # The sorting order by modification time. Valid values: asc and desc.
        self.sort_by_modified_time = sort_by_modified_time
        # The channel status. A value of 0 specifies stopped. A value of 1 specifies started.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.channel_tier is not None:
            result['ChannelTier'] = self.channel_tier
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.playback_mode is not None:
            result['PlaybackMode'] = self.playback_mode
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.sort_by_modified_time is not None:
            result['SortByModifiedTime'] = self.sort_by_modified_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ChannelTier') is not None:
            self.channel_tier = m.get('ChannelTier')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PlaybackMode') is not None:
            self.playback_mode = m.get('PlaybackMode')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SortByModifiedTime') is not None:
            self.sort_by_modified_time = m.get('SortByModifiedTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListChannelsResponseBody(TeaModel):
    def __init__(
        self,
        channel_list: List[ChannelAssemblyChannel] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The channels.
        self.channel_list = channel_list
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # **Request ID**\
        self.request_id = request_id
        # The total number of channels returned.
        self.total_count = total_count

    def validate(self):
        if self.channel_list:
            for k in self.channel_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChannelList'] = []
        if self.channel_list is not None:
            for k in self.channel_list:
                result['ChannelList'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel_list = []
        if m.get('ChannelList') is not None:
            for k in m.get('ChannelList'):
                temp_model = ChannelAssemblyChannel()
                self.channel_list.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListChannelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChannelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChannelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomTemplatesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        subtype: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The template name.
        self.name = name
        # The order in which the entries are sorted. Valid values:
        # 
        # *   CreateTimeDesc: sorted by creation time in descending order.
        # *   CreateTimeAsc: sorted by creation time in ascending order.
        self.order_by = order_by
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The subtype ID of the template.
        # 
        # *   Valid values for transcoding templates:
        # 
        #     *   1 (Normal): regular template.
        #     *   2 (AudioTranscode): audio transcoding template.
        #     *   3 (Remux): container format conversion template.
        #     *   4 (NarrowBandV1): Narrowband HD 1.0 template.
        #     *   5 (NarrowBandV2): Narrowband HD 2.0 template.
        # 
        # *   Valid values for snapshot templates:
        # 
        #     *   1 (Normal): regular template.
        #     *   2 (Sprite): sprite template.
        #     *   3 (WebVtt): WebVTT template.
        # 
        # *   Valid values for AI-assisted content moderation templates:
        # 
        #     *   1 (Video): video moderation template.
        #     *   2 (Audio): audio moderation template.
        #     *   3 (Image): image moderation template.
        # 
        # *   Valid values for AI-assisted intelligent erasure templates:
        # 
        #     *   1 (VideoDelogo): logo erasure template.
        #     *   2 (VideoDetext): subtitle erasure template.
        self.subtype = subtype
        # The template ID.
        self.template_id = template_id
        # The template type. Valid values:
        # 
        # *   1: transcoding template.
        # *   2: snapshot template.
        # *   3: animated image template.
        # *   4\\. image watermark template.
        # *   5: text watermark template.
        # *   6: subtitle template.
        # *   7: AI-assisted content moderation template.
        # *   8: AI-assisted intelligent thumbnail template.
        # *   9: AI-assisted intelligent erasure template.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint(TeaModel):
    def __init__(
        self,
        bitrate_control_type: str = None,
    ):
        self.bitrate_control_type = bitrate_control_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate_control_type is not None:
            result['BitrateControlType'] = self.bitrate_control_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BitrateControlType') is not None:
            self.bitrate_control_type = m.get('BitrateControlType')
        return self


class ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint(TeaModel):
    def __init__(
        self,
        transcode_template_hint: ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint = None,
    ):
        self.transcode_template_hint = transcode_template_hint

    def validate(self):
        if self.transcode_template_hint:
            self.transcode_template_hint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.transcode_template_hint is not None:
            result['TranscodeTemplateHint'] = self.transcode_template_hint.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TranscodeTemplateHint') is not None:
            temp_model = ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint()
            self.transcode_template_hint = temp_model.from_map(m['TranscodeTemplateHint'])
        return self


class ListCustomTemplatesResponseBodyCustomTemplateList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        frontend_hint: ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint = None,
        is_default: bool = None,
        modified_time: str = None,
        status: str = None,
        subtype: int = None,
        subtype_name: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
        type: int = None,
        type_name: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        self.frontend_hint = frontend_hint
        # Indicates whether the template is the default template.
        # 
        # Valid values:
        # 
        # *   true
        # *   false
        self.is_default = is_default
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The template state.
        # 
        # Valid values:
        # 
        # *   Normal
        self.status = status
        # The subtype ID of the template.
        self.subtype = subtype
        # The subtype name of the template.
        self.subtype_name = subtype_name
        # The template parameters.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type ID of the template.
        self.type = type
        # The type name of the template.
        self.type_name = type_name

    def validate(self):
        if self.frontend_hint:
            self.frontend_hint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.frontend_hint is not None:
            result['FrontendHint'] = self.frontend_hint.to_map()
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FrontendHint') is not None:
            temp_model = ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint()
            self.frontend_hint = temp_model.from_map(m['FrontendHint'])
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class ListCustomTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        custom_template_list: List[ListCustomTemplatesResponseBodyCustomTemplateList] = None,
        request_id: str = None,
        total: int = None,
    ):
        # The queried templates.
        self.custom_template_list = custom_template_list
        # The request ID.
        self.request_id = request_id
        # The total number of templates.
        self.total = total

    def validate(self):
        if self.custom_template_list:
            for k in self.custom_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomTemplateList'] = []
        if self.custom_template_list is not None:
            for k in self.custom_template_list:
                result['CustomTemplateList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_template_list = []
        if m.get('CustomTemplateList') is not None:
            for k in m.get('CustomTemplateList'):
                temp_model = ListCustomTemplatesResponseBodyCustomTemplateList()
                self.custom_template_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListCustomTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomizedVoiceJobsRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        type: str = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        # The type of the human voice cloning job. Valid values:
        # 
        # *   Basic
        # *   Standard
        # 
        # > : If you do not specify this parameter, the default value Basic is used.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        gender: str = None,
        gmt_create: str = None,
        job_id: str = None,
        message: str = None,
        scenario: str = None,
        status: str = None,
        type: str = None,
        voice_desc: str = None,
        voice_id: str = None,
        voice_name: str = None,
    ):
        # *   The time when the job was created.
        # *   The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        self.gender = gender
        # The time when the job was created.
        self.gmt_create = gmt_create
        # The ID of the human voice cloning job.
        self.job_id = job_id
        # The returned message.
        self.message = message
        # The scenario. Valid values:
        # 
        # *   story
        # *   interaction
        # *   navigation
        self.scenario = scenario
        # The job state. Valid values:
        # 
        # *   Initialization
        # *   AudioDetecting
        # *   PreTraining
        # *   Training
        # *   Success
        # *   Fail
        self.status = status
        # *   The voice type. Valid values:
        # 
        #     *   Basic
        #     *   Standard
        self.type = type
        # The voice description.
        # 
        # *   The description can be up to 256 characters in length.
        self.voice_desc = voice_desc
        # The voice ID.
        self.voice_id = voice_id
        # The voice name.
        # 
        # *   The name can be up to 32 characters in length.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.voice_desc is not None:
            result['VoiceDesc'] = self.voice_desc
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VoiceDesc') is not None:
            self.voice_desc = m.get('VoiceDesc')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class ListCustomizedVoiceJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        customized_voice_job_list: List[ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList] = None,
        total_count: int = None,
    ):
        # The queried human voice cloning jobs.
        self.customized_voice_job_list = customized_voice_job_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.customized_voice_job_list:
            for k in self.customized_voice_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomizedVoiceJobList'] = []
        if self.customized_voice_job_list is not None:
            for k in self.customized_voice_job_list:
                result['CustomizedVoiceJobList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.customized_voice_job_list = []
        if m.get('CustomizedVoiceJobList') is not None:
            for k in m.get('CustomizedVoiceJobList'):
                temp_model = ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList()
                self.customized_voice_job_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomizedVoiceJobsResponseBody(TeaModel):
    def __init__(
        self,
        data: ListCustomizedVoiceJobsResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListCustomizedVoiceJobsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCustomizedVoiceJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomizedVoiceJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomizedVoiceJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomizedVoicesRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        type: str = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        # *   The voice type. Valid values:
        # 
        #     *   Basic
        #     *   Standard
        # 
        # *   If you do not specify this parameter, the default value Basic is used.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCustomizedVoicesResponseBodyDataCustomizedVoiceList(TeaModel):
    def __init__(
        self,
        demo_audio_media_id: str = None,
        gender: str = None,
        scenario: str = None,
        type: str = None,
        voice_desc: str = None,
        voice_id: str = None,
        voice_name: str = None,
    ):
        # The media asset ID of the sample audio file.
        self.demo_audio_media_id = demo_audio_media_id
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        self.gender = gender
        # The scenario. Valid values:
        # 
        # *   story
        # *   interaction
        # *   navigation
        self.scenario = scenario
        # *   The voice type. Valid values:
        # 
        #     *   Basic
        #     *   Standard
        self.type = type
        # The voice description.
        self.voice_desc = voice_desc
        # The voice ID.
        self.voice_id = voice_id
        # The voice name.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_audio_media_id is not None:
            result['DemoAudioMediaId'] = self.demo_audio_media_id
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.type is not None:
            result['Type'] = self.type
        if self.voice_desc is not None:
            result['VoiceDesc'] = self.voice_desc
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoAudioMediaId') is not None:
            self.demo_audio_media_id = m.get('DemoAudioMediaId')
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VoiceDesc') is not None:
            self.voice_desc = m.get('VoiceDesc')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class ListCustomizedVoicesResponseBodyData(TeaModel):
    def __init__(
        self,
        customized_voice_list: List[ListCustomizedVoicesResponseBodyDataCustomizedVoiceList] = None,
        total_count: int = None,
    ):
        # The queried personalized human voices.
        self.customized_voice_list = customized_voice_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.customized_voice_list:
            for k in self.customized_voice_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomizedVoiceList'] = []
        if self.customized_voice_list is not None:
            for k in self.customized_voice_list:
                result['CustomizedVoiceList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.customized_voice_list = []
        if m.get('CustomizedVoiceList') is not None:
            for k in m.get('CustomizedVoiceList'):
                temp_model = ListCustomizedVoicesResponseBodyDataCustomizedVoiceList()
                self.customized_voice_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomizedVoicesResponseBody(TeaModel):
    def __init__(
        self,
        data: ListCustomizedVoicesResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListCustomizedVoicesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCustomizedVoicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomizedVoicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomizedVoicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDNADBRequest(TeaModel):
    def __init__(
        self,
        dbids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the media fingerprint libraries. We recommend that you query at most 10 libraries at a time. Separate multiple library IDs with commas (,).
        self.dbids = dbids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbids is not None:
            result['DBIds'] = self.dbids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBIds') is not None:
            self.dbids = m.get('DBIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListDNADBResponseBodyDBList(TeaModel):
    def __init__(
        self,
        dbid: str = None,
        description: str = None,
        model: str = None,
        name: str = None,
        status: str = None,
    ):
        # The ID of the media fingerprint library.
        self.dbid = dbid
        # The description of the media fingerprint library.
        self.description = description
        # The model of the media fingerprint library. Valid values:
        # 
        # *   **Video**\
        # *   **Audio**\
        # *   **Image**\
        # *   **Text** (supported only in the China (Shanghai) region)
        self.model = model
        # The name of the media fingerprint library.
        self.name = name
        # The state of the media fingerprint library. Default value: **offline**. ****Valid values:
        # 
        # *   **offline**: The media fingerprint library is offline.
        # *   **active**: The media fingerprint library is online.
        # *   **deleted**: The media fingerprint library is deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.description is not None:
            result['Description'] = self.description
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDNADBResponseBody(TeaModel):
    def __init__(
        self,
        dblist: List[ListDNADBResponseBodyDBList] = None,
        request_id: str = None,
    ):
        # The queried media fingerprint libraries.
        self.dblist = dblist
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dblist:
            for k in self.dblist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBList'] = []
        if self.dblist is not None:
            for k in self.dblist:
                result['DBList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dblist = []
        if m.get('DBList') is not None:
            for k in m.get('DBList'):
                temp_model = ListDNADBResponseBodyDBList()
                self.dblist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDNADBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDNADBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDNADBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDNAFilesRequest(TeaModel):
    def __init__(
        self,
        dbid: str = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media fingerprint library.
        # 
        # This parameter is required.
        self.dbid = dbid
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListDNAFilesResponseBodyFileListInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListDNAFilesResponseBodyFileList(TeaModel):
    def __init__(
        self,
        input_file: ListDNAFilesResponseBodyFileListInputFile = None,
        primary_key: str = None,
    ):
        # The Object Storage Service (OSS) information about the input file.
        self.input_file = input_file
        # The primary key of the file.
        self.primary_key = primary_key

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = ListDNAFilesResponseBodyFileListInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        return self


class ListDNAFilesResponseBody(TeaModel):
    def __init__(
        self,
        file_list: List[ListDNAFilesResponseBodyFileList] = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The queried files.
        self.file_list = file_list
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.file_list:
            for k in self.file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileList'] = []
        if self.file_list is not None:
            for k in self.file_list:
                result['FileList'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_list = []
        if m.get('FileList') is not None:
            for k in m.get('FileList'):
                temp_model = ListDNAFilesResponseBodyFileList()
                self.file_list.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDNAFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDNAFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDNAFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDynamicImageJobsRequest(TeaModel):
    def __init__(
        self,
        end_of_create_time: str = None,
        job_id: str = None,
        next_page_token: str = None,
        order_by: str = None,
        page_size: int = None,
        start_of_create_time: str = None,
        status: str = None,
    ):
        # The end of the time range during which the jobs to be queried were created.
        self.end_of_create_time = end_of_create_time
        # The job ID.
        self.job_id = job_id
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The order that you use to sort the query results. Valid values:
        # 
        # 1.  CreateTimeAsc: sorts the jobs by creation time in ascending order.
        # 2.  CreateTimeDesc: sorts the jobs by creation time in descending order.
        self.order_by = order_by
        # The number of entries per page. Default value: 20. Maximum value: 100.
        self.page_size = page_size
        # The beginning of the time range during which the jobs to be queried were created.
        self.start_of_create_time = start_of_create_time
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDynamicImageJobsResponseBodyJobsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. The file can be an OSS object or a media asset. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  OSS://bucket/object
        # 2.  http(s)://bucket.oss-[regionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        # 
        # *\
        # *\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDynamicImageJobsResponseBodyJobsOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  OSS://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The type of the output file. Valid values:
        # 
        # 1.  OSS: an OSS object.
        # 2.  Media: a media asset.
        # 
        # *\
        # *\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDynamicImageJobsResponseBodyJobs(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input: ListDynamicImageJobsResponseBodyJobsInput = None,
        job_id: str = None,
        modified_time: str = None,
        name: str = None,
        output: ListDynamicImageJobsResponseBodyJobsOutput = None,
        pipeline_id: str = None,
        status: str = None,
        submit_time: str = None,
        template_id: str = None,
        trigger_source: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The state of the job.
        # 
        # *   **Success**: The job is successful.
        # *   **Fail**: The job failed.
        # *   **Init**: The job is submitted.
        self.status = status
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The template ID.
        self.template_id = template_id
        # The request trigger source.
        # 
        # Valid values:
        # 
        # *   Console
        # *   Workflow
        # *   API
        self.trigger_source = trigger_source

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListDynamicImageJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = ListDynamicImageJobsResponseBodyJobsOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        return self


class ListDynamicImageJobsResponseBody(TeaModel):
    def __init__(
        self,
        jobs: List[ListDynamicImageJobsResponseBodyJobs] = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The list of jobs.
        self.jobs = jobs
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListDynamicImageJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDynamicImageJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDynamicImageJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDynamicImageJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEditingProjectsRequest(TeaModel):
    def __init__(
        self,
        create_source: str = None,
        end_time: str = None,
        keyword: str = None,
        max_results: str = None,
        next_token: str = None,
        project_type: str = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
        template_type: str = None,
    ):
        # The method for creating the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        self.create_source = create_source
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The search keyword. You can search by job ID.
        self.keyword = keyword
        # The number of entries per page. A maximum of 100 entries can be returned on each page.
        # 
        # Default value: 10.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The type of the editing project. Valid values:
        # 
        # *   EditingProject: a regular editing project.
        # *   LiveEditingProject: a live stream editing project.
        self.project_type = project_type
        # The order of sorting of the results. Valid values:
        # 
        # *   CreationTime:Desc (default): sorts the results in reverse chronological order.
        # *   CreationTime:Asc: sorts the results in chronological order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The status of the online editing project. By default, online editing projects in all states are queried.
        self.status = status
        # The template type. This parameter is required if you create a template-based online editing project. Default value: Timeline.
        # 
        # *\
        # *\
        # 
        # Valid values:
        # 
        # *   Timeline: a regular template.
        # *   VETemplate: an advanced template.
        # *   None: general editing.
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListEditingProjectsResponseBodyProjectList(TeaModel):
    def __init__(
        self,
        business_config: str = None,
        business_status: str = None,
        cover_url: str = None,
        create_source: str = None,
        create_time: str = None,
        description: str = None,
        error_code: str = None,
        error_message: str = None,
        modified_source: str = None,
        modified_time: str = None,
        project_id: str = None,
        project_type: str = None,
        status: str = None,
        template_type: str = None,
        title: str = None,
    ):
        # The business configuration of the project. This parameter can be ignored for general editing projects.
        self.business_config = business_config
        # The business status of the project. This parameter can be ignored for general editing projects.
        self.business_status = business_status
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The method for editing the online editing project. Valid values:
        # 
        # \\- OpenAPI
        # 
        # \\- AliyunConsole
        # 
        # \\- WebSDK
        self.create_source = create_source
        # The time when the online editing project was created.
        self.create_time = create_time
        # The description of the online editing project.
        self.description = description
        # The error code returned if the production of the online editing project failed.
        self.error_code = error_code
        # The error message returned if the production of the online editing project failed.
        self.error_message = error_message
        # The method for modifying the online editing project last time.
        self.modified_source = modified_source
        # The time when the online editing project was last modified.
        self.modified_time = modified_time
        # The ID of the online editing project.
        self.project_id = project_id
        # The type of the editing project. Valid values:
        # 
        # *   EditingProject: a regular editing project.
        # *   LiveEditingProject: a live stream editing project.
        self.project_type = project_type
        # The status of the online editing project. Valid values:
        # 
        # \\- Draft
        # 
        # \\- Editing
        # 
        # \\- Producing
        # 
        # \\- Produced
        # 
        # \\- ProduceFailed
        self.status = status
        # The template type. Valid values:
        # 
        # *   Timeline: a regular template.
        # *   VETemplate: an advanced template.
        self.template_type = template_type
        # The title of the online editing project.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListEditingProjectsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        project_list: List[ListEditingProjectsResponseBodyProjectList] = None,
        request_id: str = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        # 
        # This parameter is required.
        self.next_token = next_token
        # The queried online editing projects.
        self.project_list = project_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.project_list:
            for k in self.project_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['ProjectList'] = []
        if self.project_list is not None:
            for k in self.project_list:
                result['ProjectList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.project_list = []
        if m.get('ProjectList') is not None:
            for k in m.get('ProjectList'):
                temp_model = ListEditingProjectsResponseBodyProjectList()
                self.project_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEditingProjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEditingProjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEditingProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHotwordLibrariesRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        start_time: str = None,
        usage_scenario: str = None,
    ):
        self.end_time = end_time
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_no = page_no
        self.page_size = page_size
        self.sort_by = sort_by
        self.start_time = start_time
        self.usage_scenario = usage_scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.name is not None:
            result['Name'] = self.name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.usage_scenario is not None:
            result['UsageScenario'] = self.usage_scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UsageScenario') is not None:
            self.usage_scenario = m.get('UsageScenario')
        return self


class ListHotwordLibrariesResponseBodyHotwordLibraryList(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        hotword_library_id: str = None,
        modified_time: str = None,
        name: str = None,
        usage_scenario: str = None,
    ):
        self.creation_time = creation_time
        self.description = description
        self.hotword_library_id = hotword_library_id
        self.modified_time = modified_time
        self.name = name
        self.usage_scenario = usage_scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.usage_scenario is not None:
            result['UsageScenario'] = self.usage_scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UsageScenario') is not None:
            self.usage_scenario = m.get('UsageScenario')
        return self


class ListHotwordLibrariesResponseBody(TeaModel):
    def __init__(
        self,
        hotword_library_list: List[ListHotwordLibrariesResponseBodyHotwordLibraryList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.hotword_library_list = hotword_library_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.hotword_library_list:
            for k in self.hotword_library_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HotwordLibraryList'] = []
        if self.hotword_library_list is not None:
            for k in self.hotword_library_list:
                result['HotwordLibraryList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hotword_library_list = []
        if m.get('HotwordLibraryList') is not None:
            for k in m.get('HotwordLibraryList'):
                temp_model = ListHotwordLibrariesResponseBodyHotwordLibraryList()
                self.hotword_library_list.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHotwordLibrariesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHotwordLibrariesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHotwordLibrariesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLivePackageChannelGroupsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The channel group name or description. Fuzzy match is supported.
        self.keyword = keyword
        # The page number. Pages start from page 1. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The sort order by creation time. Default value: desc.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        last_modified: str = None,
        origin_domain: str = None,
    ):
        # The time when the channel group was created. It is in the `yyyy-MM-ddTHH:mm:ssZ` format and displayed in UTC.
        self.create_time = create_time
        # The channel group description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The time when the channel group was last modified. It is in the `yyyy-MM-ddTHH:mm:ssZ` format and displayed in UTC.
        self.last_modified = last_modified
        # The origin domain.
        self.origin_domain = origin_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.origin_domain is not None:
            result['OriginDomain'] = self.origin_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OriginDomain') is not None:
            self.origin_domain = m.get('OriginDomain')
        return self


class ListLivePackageChannelGroupsResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel_groups: List[ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The channel groups returned.
        self.live_package_channel_groups = live_package_channel_groups
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sort order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.live_package_channel_groups:
            for k in self.live_package_channel_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LivePackageChannelGroups'] = []
        if self.live_package_channel_groups is not None:
            for k in self.live_package_channel_groups:
                result['LivePackageChannelGroups'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_package_channel_groups = []
        if m.get('LivePackageChannelGroups') is not None:
            for k in m.get('LivePackageChannelGroups'):
                temp_model = ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups()
                self.live_package_channel_groups.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLivePackageChannelGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLivePackageChannelGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLivePackageChannelGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLivePackageChannelsRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The channel name or description. Fuzzy match is supported.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sort order by creation time. Default value: desc.
        # 
        # Valid values:
        # 
        # *   asc
        # *   desc
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints(TeaModel):
    def __init__(
        self,
        id: str = None,
        password: str = None,
        url: str = None,
        username: str = None,
    ):
        # The ingest endpoint ID.
        self.id = id
        # The password.
        self.password = password
        # The ingest endpoint URL.
        self.url = url
        # The username.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.password is not None:
            result['Password'] = self.password
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class ListLivePackageChannelsResponseBodyLivePackageChannels(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        ingest_endpoints: List[ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints] = None,
        last_modified: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name.
        self.channel_name = channel_name
        # The time when the channel was created.
        self.create_time = create_time
        # The channel description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The ingest endpoints.
        self.ingest_endpoints = ingest_endpoints
        # The time when the channel was last modified.
        self.last_modified = last_modified
        # The ingest protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of M3U8 segments.
        self.segment_count = segment_count
        # The segment duration.
        self.segment_duration = segment_duration

    def validate(self):
        if self.ingest_endpoints:
            for k in self.ingest_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        result['IngestEndpoints'] = []
        if self.ingest_endpoints is not None:
            for k in self.ingest_endpoints:
                result['IngestEndpoints'].append(k.to_map() if k else None)
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        self.ingest_endpoints = []
        if m.get('IngestEndpoints') is not None:
            for k in m.get('IngestEndpoints'):
                temp_model = ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints()
                self.ingest_endpoints.append(temp_model.from_map(k))
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class ListLivePackageChannelsResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channels: List[ListLivePackageChannelsResponseBodyLivePackageChannels] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The live package channels.
        self.live_package_channels = live_package_channels
        # The page number.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sort order. Valid values: asc and desc (default).
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.live_package_channels:
            for k in self.live_package_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LivePackageChannels'] = []
        if self.live_package_channels is not None:
            for k in self.live_package_channels:
                result['LivePackageChannels'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_package_channels = []
        if m.get('LivePackageChannels') is not None:
            for k in m.get('LivePackageChannels'):
                temp_model = ListLivePackageChannelsResponseBodyLivePackageChannels()
                self.live_package_channels.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLivePackageChannelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLivePackageChannelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLivePackageChannelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLivePackageOriginEndpointsRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The endpoint name or description. Fuzzy match is supported.
        self.keyword = keyword
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The sort order by creation time. Valid values: asc and desc (default).
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        endpoint_name: str = None,
        endpoint_url: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        last_modified: str = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code.
        self.authorization_code = authorization_code
        # The channel name.
        self.channel_name = channel_name
        # The time when the endpoint was created.
        self.create_time = create_time
        # The endpoint description.
        self.description = description
        # The endpoint name.
        self.endpoint_name = endpoint_name
        # The endpoint URL.
        self.endpoint_url = endpoint_url
        # The channel group name.
        self.group_name = group_name
        # The IP address blacklist.
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist.
        self.ip_whitelist = ip_whitelist
        # The time when the endpoint was last modified.
        self.last_modified = last_modified
        # The playlist name.
        self.manifest_name = manifest_name
        # The distribution protocol.
        self.protocol = protocol
        # The number of days that time-shifted content is available.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_url is not None:
            result['EndpointUrl'] = self.endpoint_url
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointUrl') is not None:
            self.endpoint_url = m.get('EndpointUrl')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class ListLivePackageOriginEndpointsResponseBody(TeaModel):
    def __init__(
        self,
        live_package_origin_endpoints: List[ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The origin endpoints returned.
        self.live_package_origin_endpoints = live_package_origin_endpoints
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sort order. Valid values: `asc` and `desc` (default).
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.live_package_origin_endpoints:
            for k in self.live_package_origin_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LivePackageOriginEndpoints'] = []
        if self.live_package_origin_endpoints is not None:
            for k in self.live_package_origin_endpoints:
                result['LivePackageOriginEndpoints'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_package_origin_endpoints = []
        if m.get('LivePackageOriginEndpoints') is not None:
            for k in m.get('LivePackageOriginEndpoints'):
                temp_model = ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints()
                self.live_package_origin_endpoints.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLivePackageOriginEndpointsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLivePackageOriginEndpointsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLivePackageOriginEndpointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRecordFilesRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        job_ids: List[str] = None,
        page_no: int = None,
        page_size: int = None,
        record_format: str = None,
        sort_by: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The maximum time range to query is four days. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The list of job IDs.
        self.job_ids = job_ids
        # The page number of the page to return. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 5 to 30. Default value: 10.
        self.page_size = page_size
        # The format of the recording file. Valid values:
        # 
        # M3U8, FLV, and MP4
        self.record_format = record_format
        # The sorting order of the index files by creation time. Valid values:
        # 
        # asc: The query results are displayed in ascending order. This is the default value.
        # 
        # desc: The query results are displayed in descending order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.record_format is not None:
            result['RecordFormat'] = self.record_format
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RecordFormat') is not None:
            self.record_format = m.get('RecordFormat')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLiveRecordFilesResponseBodyFiles(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        duration: float = None,
        end_time: str = None,
        format: str = None,
        height: int = None,
        job_id: str = None,
        job_name: str = None,
        record_id: str = None,
        record_output: str = None,
        record_url: str = None,
        start_time: str = None,
        stream_url: str = None,
        width: int = None,
    ):
        # The time when the file was created in UTC.
        self.create_time = create_time
        # The recording length. Unit: seconds.
        self.duration = duration
        # The end of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time
        # The format of the recording file.
        self.format = format
        # The height of the video.
        self.height = height
        # The ID of the recording job.
        self.job_id = job_id
        # The name of the recording job.
        self.job_name = job_name
        # The ID of the index file.
        self.record_id = record_id
        # The storage information about the recording file.
        self.record_output = record_output
        # The URL of the index file.
        self.record_url = record_url
        # The beginning of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_url = stream_url
        # The width of the video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.format is not None:
            result['Format'] = self.format
        if self.height is not None:
            result['Height'] = self.height
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.record_output is not None:
            result['RecordOutput'] = self.record_output
        if self.record_url is not None:
            result['RecordUrl'] = self.record_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RecordOutput') is not None:
            self.record_output = m.get('RecordOutput')
        if m.get('RecordUrl') is not None:
            self.record_url = m.get('RecordUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListLiveRecordFilesResponseBody(TeaModel):
    def __init__(
        self,
        files: List[ListLiveRecordFilesResponseBodyFiles] = None,
        page_no: int = None,
        page_size: str = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: str = None,
    ):
        # The list of index files.
        self.files = files
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sorting order of the index files by creation time.
        self.sort_by = sort_by
        # The total number of files that meet the specified conditions.
        self.total_count = total_count

    def validate(self):
        if self.files:
            for k in self.files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Files'] = []
        if self.files is not None:
            for k in self.files:
                result['Files'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.files = []
        if m.get('Files') is not None:
            for k in m.get('Files'):
                temp_model = ListLiveRecordFilesResponseBodyFiles()
                self.files.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveRecordFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRecordFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRecordFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRecordJobsRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The end of the time range to query. The maximum time range between EndTime and StartTime cannot exceed 30 days. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.end_time = end_time
        # The search keyword. You can use the job ID or name as the keyword to search for jobs.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results in ascending order.
        # *   desc: sorts the query results in descending order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.start_time = start_time
        # The state of the job. By default, the state is not filtered.
        # 
        # Valid values:
        # 
        # *   paused: The job is paused.
        # *   initial: The job is not started.
        # *   started: The job is in progress.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        type: str = None,
    ):
        # The bucket name.
        self.bucket = bucket
        # The endpoint of the storage service.
        self.endpoint = endpoint
        # The type of the storage address.
        # 
        # Valid values:
        # 
        # *   vod
        # *   oss
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput(TeaModel):
    def __init__(
        self,
        type: str = None,
        url: str = None,
    ):
        # The type of the live stream URL.
        self.type = type
        # The URL of the live stream.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListLiveRecordJobsResponseBodyLiveRecordJobs(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        name: str = None,
        notify_url: str = None,
        record_output: ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput = None,
        status: str = None,
        stream_input: ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The time when the job was created.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.create_time = create_time
        # The ID of the recording job.
        self.job_id = job_id
        # The name of the recording job.
        self.name = name
        # The callback URL.
        self.notify_url = notify_url
        # The storage address of the recording.
        self.record_output = record_output
        # The state of the recording job.
        self.status = status
        # The URL of the live stream.
        self.stream_input = stream_input
        # The ID of the recording template.
        self.template_id = template_id
        # The name of the recording template.
        self.template_name = template_name

    def validate(self):
        if self.record_output:
            self.record_output.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_output is not None:
            result['RecordOutput'] = self.record_output.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordOutput') is not None:
            temp_model = ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput()
            self.record_output = temp_model.from_map(m['RecordOutput'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListLiveRecordJobsResponseBody(TeaModel):
    def __init__(
        self,
        live_record_jobs: List[ListLiveRecordJobsResponseBodyLiveRecordJobs] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The list of live stream recording jobs.
        self.live_record_jobs = live_record_jobs
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.live_record_jobs:
            for k in self.live_record_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveRecordJobs'] = []
        if self.live_record_jobs is not None:
            for k in self.live_record_jobs:
                result['LiveRecordJobs'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_record_jobs = []
        if m.get('LiveRecordJobs') is not None:
            for k in m.get('LiveRecordJobs'):
                temp_model = ListLiveRecordJobsResponseBodyLiveRecordJobs()
                self.live_record_jobs.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveRecordJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRecordJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRecordJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRecordTemplatesRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        template_ids: List[str] = None,
        type: str = None,
    ):
        # The search keyword. You can use the template ID or name as the keyword to search for templates. If you search for templates by name, fuzzy match is supported.
        self.keyword = keyword
        # The page number. Minimum value: 1. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results in ascending order.
        # *   desc: sorts the query results in descending order.
        self.sort_by = sort_by
        self.template_ids = template_ids
        # The type of the template.
        # 
        # Valid values:
        # 
        # *   system
        # *   custom
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of the recording cycle. Unit: seconds.
        self.cycle_duration = cycle_duration
        # The output file format.
        self.format = format
        # The name of the recording file that is stored in Object Storage Service (OSS).
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment. Unit: seconds.
        self.slice_duration = slice_duration
        # The name of the TS segment.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class ListLiveRecordTemplatesResponseBodyRecordTemplateList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        last_modified: str = None,
        name: str = None,
        record_format_list: List[ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList] = None,
        template_id: str = None,
        type: str = None,
    ):
        # The time when the job was created.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.create_time = create_time
        # The time when the template was last modified.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.last_modified = last_modified
        # The template name.
        self.name = name
        # The list of recording formats.
        self.record_format_list = record_format_list
        # The template ID.
        self.template_id = template_id
        # The type of the template.
        self.type = type

    def validate(self):
        if self.record_format_list:
            for k in self.record_format_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormatList'] = []
        if self.record_format_list is not None:
            for k in self.record_format_list:
                result['RecordFormatList'].append(k.to_map() if k else None)
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format_list = []
        if m.get('RecordFormatList') is not None:
            for k in m.get('RecordFormatList'):
                temp_model = ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList()
                self.record_format_list.append(temp_model.from_map(k))
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveRecordTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        record_template_list: List[ListLiveRecordTemplatesResponseBodyRecordTemplateList] = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The list of recording templates.
        self.record_template_list = record_template_list
        # The request ID.
        self.request_id = request_id
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results in ascending order.
        # *   desc: sorts the query results in descending order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.record_template_list:
            for k in self.record_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RecordTemplateList'] = []
        if self.record_template_list is not None:
            for k in self.record_template_list:
                result['RecordTemplateList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.record_template_list = []
        if m.get('RecordTemplateList') is not None:
            for k in m.get('RecordTemplateList'):
                temp_model = ListLiveRecordTemplatesResponseBodyRecordTemplateList()
                self.record_template_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveRecordTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRecordTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRecordTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveSnapshotFilesRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        job_id: str = None,
        limit: int = None,
        sort_by: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   The maximum time range that can be specified is one day.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the snapshot job.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The number of results to return each time. Valid values: 1 to 100. Default value: 10.
        self.limit = limit
        # The sorting order. Default value: asc.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results by creation time in ascending order.
        # *   desc: sorts the query results by creation time in descending order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLiveSnapshotFilesResponseBodyFileList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        is_overlay: bool = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # The creation timestamp that is used as an input parameter for a delete API operation.
        self.create_timestamp = create_timestamp
        # Specifies whether to overlay snapshots.
        self.is_overlay = is_overlay
        # The OSS bucket.
        self.oss_bucket = oss_bucket
        # The Object Storage Service (OSS) domain name.
        self.oss_endpoint = oss_endpoint
        # The location in which the OSS object is stored.
        self.oss_object = oss_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.is_overlay is not None:
            result['IsOverlay'] = self.is_overlay
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('IsOverlay') is not None:
            self.is_overlay = m.get('IsOverlay')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        return self


class ListLiveSnapshotFilesResponseBody(TeaModel):
    def __init__(
        self,
        file_list: List[ListLiveSnapshotFilesResponseBodyFileList] = None,
        next_start_time: str = None,
        request_id: str = None,
    ):
        # The list of files.
        self.file_list = file_list
        # The start time of the next page. If no value is returned, the pagination ends.
        self.next_start_time = next_start_time
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.file_list:
            for k in self.file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileList'] = []
        if self.file_list is not None:
            for k in self.file_list:
                result['FileList'].append(k.to_map() if k else None)
        if self.next_start_time is not None:
            result['NextStartTime'] = self.next_start_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_list = []
        if m.get('FileList') is not None:
            for k in m.get('FileList'):
                temp_model = ListLiveSnapshotFilesResponseBodyFileList()
                self.file_list.append(temp_model.from_map(k))
        if m.get('NextStartTime') is not None:
            self.next_start_time = m.get('NextStartTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveSnapshotFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveSnapshotFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveSnapshotFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveSnapshotJobsRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        page_no: int = None,
        page_size: int = None,
        search_key_word: str = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   By default, EndTime is seven days later than StartTime.
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed 30 days.
        self.end_time = end_time
        # The page number. Valid values: [1,n). Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The search keyword. You can use the job ID or name as the keyword to search for jobs. If you search for jobs by name, fuzzy match is supported.
        # 
        # *   It cannot exceed 128 characters in length.
        self.search_key_word = search_key_word
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results by creation time in ascending order.
        # *   desc: sorts the query results by creation time in descending order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   The default value is seven days ago.
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed 30 days.
        self.start_time = start_time
        # The job state filter. By default, all jobs are queried.
        # 
        # Valid values:
        # 
        # *   init: The job is not started.
        # *   paused: The job is paused.
        # *   started: The job is in progress.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        storage_type: str = None,
    ):
        # The bucket of the output endpoint. If the storage type is set to oss, the OSS bucket is returned.
        self.bucket = bucket
        # The output endpoint. If the storage type is set to oss, the Object Storage Service (OSS) domain name is returned.
        self.endpoint = endpoint
        # The storage type. The value can only be oss.
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class ListLiveSnapshotJobsResponseBodyJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        job_name: str = None,
        snapshot_output: ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput = None,
        status: str = None,
        template_id: str = None,
        template_name: str = None,
        time_interval: int = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # The job ID.
        self.job_id = job_id
        # The name of the job.
        self.job_name = job_name
        # The output information.
        self.snapshot_output = snapshot_output
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   init: The job is not started.
        # *   paused: The job is paused.
        # *   started: The job is in progress.
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The interval between two adjacent snapshots. Unit: seconds.
        self.time_interval = time_interval

    def validate(self):
        if self.snapshot_output:
            self.snapshot_output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.snapshot_output is not None:
            result['SnapshotOutput'] = self.snapshot_output.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('SnapshotOutput') is not None:
            temp_model = ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput()
            self.snapshot_output = temp_model.from_map(m['SnapshotOutput'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class ListLiveSnapshotJobsResponseBody(TeaModel):
    def __init__(
        self,
        job_list: List[ListLiveSnapshotJobsResponseBodyJobList] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The list of jobs.
        self.job_list = job_list
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sorting order of the jobs by creation time.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.job_list:
            for k in self.job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobList'] = []
        if self.job_list is not None:
            for k in self.job_list:
                result['JobList'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_list = []
        if m.get('JobList') is not None:
            for k in m.get('JobList'):
                temp_model = ListLiveSnapshotJobsResponseBodyJobList()
                self.job_list.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveSnapshotJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveSnapshotJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveSnapshotJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveSnapshotTemplatesRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        search_key_word: str = None,
        sort_by: str = None,
        template_ids: List[str] = None,
        type: str = None,
    ):
        # The page number. Valid values: [1,n). Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The search keyword. You can use the template ID or name as the keyword to search for templates. If you search for templates by name, fuzzy match is supported.
        # 
        # *   It cannot exceed 128 characters in length.
        self.search_key_word = search_key_word
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   asc: sorts the query results by creation time in ascending order.
        # *   desc: sorts the query results by creation time in descending order.
        self.sort_by = sort_by
        # The template IDs.
        # 
        # *   If you specify the SearchKeyWord parameter, this condition does not take effect.
        # *   The maximum length of the array is 200.
        self.template_ids = template_ids
        # The type of the template. By default, all types are queried.
        # 
        # Valid values:
        # 
        # *   system
        # *   custom
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveSnapshotTemplatesResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        template_id: str = None,
        template_name: str = None,
        time_interval: int = None,
        type: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The interval between two adjacent snapshots. Unit: seconds.
        self.time_interval = time_interval
        # The type of the template.
        # 
        # Valid values:
        # 
        # *   system
        # *   custom
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveSnapshotTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        template_list: List[ListLiveSnapshotTemplatesResponseBodyTemplateList] = None,
        total_count: int = None,
    ):
        # The number of the returned page.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The sorting order of the results by creation time.
        self.sort_by = sort_by
        # The list of the templates.
        self.template_list = template_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        result['TemplateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['TemplateList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        self.template_list = []
        if m.get('TemplateList') is not None:
            for k in m.get('TemplateList'):
                temp_model = ListLiveSnapshotTemplatesResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveSnapshotTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveSnapshotTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveSnapshotTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveTranscodeJobsRequest(TeaModel):
    def __init__(
        self,
        key_word: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        start_mode: int = None,
        status: int = None,
        type: str = None,
    ):
        # The search keyword. You can use the job ID or name as the keyword to search for jobs. If you search for jobs by name, fuzzy match is supported.
        self.key_word = key_word
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order. Valid values:
        # 
        # *   asc
        # *   desc
        self.sort_by = sort_by
        # The start mode of the transcoding job.
        # 
        # *   0: The transcoding job immediately starts.
        # *   1: The transcoding job starts at the scheduled time.
        self.start_mode = start_mode
        # The state of the job.
        # 
        # 0: The job is not started. 1: The job is in progress. 2: The job is stopped.
        self.status = status
        # The type of the template used by the transcoding job.
        # 
        # *   normal
        # *   narrow-band
        # *   audio-only
        # *   origin
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos(TeaModel):
    def __init__(
        self,
        output_url: str = None,
        type: str = None,
    ):
        # The URL of the output stream.
        self.output_url = output_url
        # The type of the output stream protocol. Only the RTMP protocol is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobListOutputStream(TeaModel):
    def __init__(
        self,
        stream_infos: List[ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos] = None,
    ):
        # The list of stream URLs.
        self.stream_infos = stream_infos

    def validate(self):
        if self.stream_infos:
            for k in self.stream_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfos'] = []
        if self.stream_infos is not None:
            for k in self.stream_infos:
                result['StreamInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_infos = []
        if m.get('StreamInfos') is not None:
            for k in m.get('StreamInfos'):
                temp_model = ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos()
                self.stream_infos.append(temp_model.from_map(k))
        return self


class ListLiveTranscodeJobsResponseBodyJobListStreamInput(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        type: str = None,
    ):
        # The URL of the input stream.
        self.input_url = input_url
        # The type of the input stream.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        name: str = None,
        output_stream: ListLiveTranscodeJobsResponseBodyJobListOutputStream = None,
        start_mode: int = None,
        status: int = None,
        stream_input: ListLiveTranscodeJobsResponseBodyJobListStreamInput = None,
        template_id: str = None,
        template_name: str = None,
        template_type: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The job ID.
        self.job_id = job_id
        # The name of the transcoding job.
        self.name = name
        # The information about the output stream.
        self.output_stream = output_stream
        # The start mode of the job.
        self.start_mode = start_mode
        # The state of the job.
        self.status = status
        # The information about the input stream.
        self.stream_input = stream_input
        # The ID of the transcoding template used by the transcoding job.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type of the transcoding template used by the transcoding job.
        self.template_type = template_type

    def validate(self):
        if self.output_stream:
            self.output_stream.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output_stream is not None:
            result['OutputStream'] = self.output_stream.to_map()
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputStream') is not None:
            temp_model = ListLiveTranscodeJobsResponseBodyJobListOutputStream()
            self.output_stream = temp_model.from_map(m['OutputStream'])
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = ListLiveTranscodeJobsResponseBodyJobListStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListLiveTranscodeJobsResponseBody(TeaModel):
    def __init__(
        self,
        job_list: List[ListLiveTranscodeJobsResponseBodyJobList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The list of transcoding jobs.
        self.job_list = job_list
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.job_list:
            for k in self.job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobList'] = []
        if self.job_list is not None:
            for k in self.job_list:
                result['JobList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_list = []
        if m.get('JobList') is not None:
            for k in m.get('JobList'):
                temp_model = ListLiveTranscodeJobsResponseBodyJobList()
                self.job_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveTranscodeJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveTranscodeJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveTranscodeJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveTranscodeTemplatesRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        key_word: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        type: str = None,
        video_codec: str = None,
    ):
        # The category of the template. Valid values:
        # 
        # *   system
        # *   customized
        self.category = category
        # The search keyword. You can use the template ID or name as the keyword to search for templates. If you search for templates by name, fuzzy match is supported.
        self.key_word = key_word
        # The page number of the page to return. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order. Valid values:
        # 
        # *   asc
        # *   desc
        self.sort_by = sort_by
        # The type of the template. Valid values:
        # 
        # *   normal
        # *   narrow-band
        # *   audio-only
        # *   origin
        self.type = type
        # The video codec. Valid values:
        # 
        # *   H.264
        # *   H.265
        self.video_codec = video_codec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        samplerate: str = None,
    ):
        # The audio bitrate.
        self.bitrate = bitrate
        # The number of sound channels.
        self.channels = channels
        # The audio codec.
        self.codec = codec
        # The encoding profile.
        self.profile = profile
        # The audio sampling rate.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        profile: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The encoding format.
        self.codec = codec
        # The video frame rate.
        self.fps = fps
        # The group of pictures (GOP) of the output video. Unit: frame.
        self.gop = gop
        # The vertical resolution of the video.
        self.height = height
        # The encoding profile.
        self.profile = profile
        # The horizontal resolution of the video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig(TeaModel):
    def __init__(
        self,
        audio_params: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams = None,
        video_params: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams = None,
    ):
        # The audio parameters.
        self.audio_params = audio_params
        # The video parameters.
        self.video_params = video_params

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentList(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        name: str = None,
        template_config: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig = None,
        template_id: str = None,
        type: str = None,
    ):
        # The category of the template. Valid values:
        self.category = category
        # The time when the job was created.
        self.create_time = create_time
        # The template name.
        self.name = name
        # The configuration of the template.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The type of the template.
        self.type = type

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_content_list: List[ListLiveTranscodeTemplatesResponseBodyTemplateContentList] = None,
        total_count: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The list of transcoding templates.
        self.template_content_list = template_content_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.template_content_list:
            for k in self.template_content_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TemplateContentList'] = []
        if self.template_content_list is not None:
            for k in self.template_content_list:
                result['TemplateContentList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.template_content_list = []
        if m.get('TemplateContentList') is not None:
            for k in m.get('TemplateContentList'):
                temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentList()
                self.template_content_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveTranscodeTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveTranscodeTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaBasicInfosRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        end_time: str = None,
        include_file_basic_info: bool = None,
        max_results: int = None,
        media_id: str = None,
        media_type: str = None,
        next_token: str = None,
        sort_by: str = None,
        source: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The business type of the media asset. Valid values:
        # 
        # \\- subtitles
        # 
        # \\- watermark
        # 
        # \\- opening
        # 
        # \\- ending
        # 
        # \\- general
        self.business_type = business_type
        # The end time of utcCreated.
        # 
        # \\- The value is the end of the left-open right-closed interval.
        # 
        # \\- Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. For example, 2017-01-11T12:00:00Z indicates 20:00:00 on January 11, 2017 (UTC +8).
        self.end_time = end_time
        # Specifies whether to return the basic information of the source file.
        self.include_file_basic_info = include_file_basic_info
        # The maximum number of entries to return.
        # 
        # Maximum value: 100. Default value: 10.
        self.max_results = max_results
        # The ID of the media asset.
        self.media_id = media_id
        # The type of the media asset. Valid values:
        # 
        # \\- image
        # 
        # \\- video
        # 
        # \\- audio
        # 
        # \\- text
        self.media_type = media_type
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_token = next_token
        # The order of sorting by utcCreated. Default value: desc. Valid values:
        # 
        # \\- desc
        # 
        # \\- asc
        self.sort_by = sort_by
        # The source of the media asset. Valid values:
        # 
        # \\- oss: Object Storage Service (OSS).
        # 
        # \\- vod: ApsaraVideo VOD.
        # 
        # \\- live: ApsaraVideo Live.
        # 
        # \\- general: other sources. This is the default value.
        self.source = source
        # The start time of utcCreated.
        # 
        # \\- The value is the beginning of a left-open right-closed interval.
        # 
        # \\- Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. For example, 2017-01-11T12:00:00Z indicates 20:00:00 on January 11, 2017 (UTC +8).
        self.start_time = start_time
        # The status of the media asset. Valid values:
        # 
        # \\- Init: the initial state, which indicates that the source file is not ready.
        # 
        # \\- Preparing: The source file is being prepared. For example, the file is being uploaded or edited.
        # 
        # \\- PrepareFail: The source file failed to be prepared. For example, the information of the source file failed to be obtained.
        # 
        # \\- Normal: The source file is ready.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.include_file_basic_info is not None:
            result['IncludeFileBasicInfo'] = self.include_file_basic_info
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IncludeFileBasicInfo') is not None:
            self.include_file_basic_info = m.get('IncludeFileBasicInfo')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        create_time: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        modified_time: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The time when the file was created.
        self.create_time = create_time
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The OSS URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The time when the file was last modified.
        self.modified_time = modified_time
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaBasicInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo = None,
    ):
        # The basic information of the file, including the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(
        self,
        biz: str = None,
        business_type: str = None,
        cate_id: int = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        reference_id: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        upload_source: str = None,
        user_data: str = None,
    ):
        # The service to which the media asset belongs.
        self.biz = biz
        # The business type of the media asset.
        self.business_type = business_type
        # The category ID.
        self.cate_id = cate_id
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The URL of the media asset in another service.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The custom ID of the media asset. The ID is a string that contains 6 to 64 characters. Only letters, digits, hyphens (-), and underscores (_) are supported. The ID is unique among users.
        self.reference_id = reference_id
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset.
        self.source = source
        # The sprite.
        self.sprite_images = sprite_images
        # The status of the media asset.
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        self.transcode_status = transcode_status
        # The upload source of the media asset.
        self.upload_source = upload_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaBasicInfosResponseBodyMediaInfos(TeaModel):
    def __init__(
        self,
        file_info_list: List[ListMediaBasicInfosResponseBodyMediaInfosFileInfoList] = None,
        media_basic_info: ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo = None,
        media_id: str = None,
    ):
        # FileInfos
        self.file_info_list = file_info_list
        # BasicInfo
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = ListMediaBasicInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class ListMediaBasicInfosResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        media_infos: List[ListMediaBasicInfosResponseBodyMediaInfos] = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned in the query.
        self.max_results = max_results
        # The media assets that meet the specified conditions.
        self.media_infos = media_infos
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = ListMediaBasicInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMediaBasicInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaBasicInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaBasicInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaInfoJobsRequest(TeaModel):
    def __init__(
        self,
        end_of_create_time: str = None,
        job_id: str = None,
        next_page_token: str = None,
        order_by: str = None,
        page_size: int = None,
        start_of_create_time: str = None,
        status: str = None,
    ):
        # The end of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_of_create_time = end_of_create_time
        # The job ID.
        self.job_id = job_id
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_page_token = next_page_token
        # The order that you use to sort the query results. Valid values:
        # 
        # *   CreateTimeDesc: sorts the query results by creation time in descending order.
        # *   CreateTimeAsc: sorts the query results by creation time in ascending order.
        self.order_by = order_by
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The beginning of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_of_create_time = start_of_create_time
        # The state of the job. Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMediaInfoJobsResponseBodyJobsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video. Unit: seconds.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The state of the file.
        self.file_status = file_status
        # The file type. Valid values: source_file and transcode_file.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image.
        # 
        # *   Valid values: 0, 90, 180, and 270.
        # *   Default value: 0.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoProperty(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList] = None,
        file_basic_info: ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo = None,
        video_stream_info_list: List[ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class ListMediaInfoJobsResponseBodyJobsScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class ListMediaInfoJobsResponseBodyJobs(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        finish_time: str = None,
        input: ListMediaInfoJobsResponseBodyJobsInput = None,
        job_id: str = None,
        media_info_property: ListMediaInfoJobsResponseBodyJobsMediaInfoProperty = None,
        name: str = None,
        request_id: str = None,
        schedule_config: ListMediaInfoJobsResponseBodyJobsScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # Indicates whether asynchronous processing was performed.
        self.async_ = async_
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The details of the media information.
        self.media_info_property = media_info_property
        # The job name.
        self.name = name
        # The request ID.
        self.request_id = request_id
        # The scheduling information.
        self.schedule_config = schedule_config
        # The state of the job. Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status
        # The job submission information.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The source of the job. Valid values:
        # 
        # *   API
        # *   WorkFlow
        # *   Console
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaInfoJobsResponseBody(TeaModel):
    def __init__(
        self,
        jobs: List[ListMediaInfoJobsResponseBodyJobs] = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The list of media information analysis jobs.
        self.jobs = jobs
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The token of the next page is returned after you call this operation for the first time.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListMediaInfoJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaInfoJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaInfoJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaInfoJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaLiveChannelsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        max_results: int = None,
        next_token: str = None,
        skip: int = None,
        sort_order: str = None,
        states: str = None,
    ):
        # The keyword of the query. You can perform a fuzzy search on channel ID or name.
        self.keyword = keyword
        # The number of entries per page. Valid values: 1 to 100. Default value:
        # 
        # *   If you do not specify this parameter or if you set a value smaller than 10, the default value is 10.
        # *   If you set a value greater than 100, the default value is 100.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_token = next_token
        # The number of entries to be skipped in the query. If the number of entries you attempt to skip exceeds the number of entries that meet the condition, an empty list is returned.
        self.skip = skip
        # The sorting order of the channels by creation time. Default value: asc. Valid values: desc and asc. asc indicates the ascending order, and desc indicates the descending order.
        self.sort_order = sort_order
        # The state of channels you want to query. You can separate multiple states with commas (,) in a JSON array.
        self.states = states

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.states is not None:
            result['States'] = self.states
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('States') is not None:
            self.states = m.get('States')
        return self


class ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        profile: str = None,
        sample_rate: int = None,
    ):
        # The audio bitrate. Unit: bit/s.
        self.bitrate = bitrate
        # The audio codec profile.
        self.profile = profile
        # The audio sample rate. Unit: Hz.
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        return self


class ListMediaLiveChannelsResponseBodyChannelsAudioSettings(TeaModel):
    def __init__(
        self,
        audio_codec: str = None,
        audio_codec_setting: ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting = None,
        audio_selector_name: str = None,
        language_code: str = None,
        language_name: str = None,
        name: str = None,
    ):
        # The audio codec.
        self.audio_codec = audio_codec
        # The audio encoding settings.
        self.audio_codec_setting = audio_codec_setting
        # The name of the audio selector.
        self.audio_selector_name = audio_selector_name
        # A three-letter ISO 639-2 language code.
        self.language_code = language_code
        # The name of the language.
        self.language_name = language_name
        # The name of the audio settings.
        self.name = name

    def validate(self):
        if self.audio_codec_setting:
            self.audio_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_codec_setting is not None:
            result['AudioCodecSetting'] = self.audio_codec_setting.to_map()
        if self.audio_selector_name is not None:
            result['AudioSelectorName'] = self.audio_selector_name
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioCodecSetting') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting()
            self.audio_codec_setting = temp_model.from_map(m['AudioCodecSetting'])
        if m.get('AudioSelectorName') is not None:
            self.audio_selector_name = m.get('AudioSelectorName')
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection(TeaModel):
    def __init__(
        self,
        language_code: str = None,
    ):
        # A three-letter ISO 639-2 language code from within an audio source.
        # 
        # This parameter is required.
        self.language_code = language_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        return self


class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection(TeaModel):
    def __init__(
        self,
        pid: int = None,
    ):
        # A PID from within a source.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection(TeaModel):
    def __init__(
        self,
        track_id: int = None,
    ):
        # The track ID from within a source.
        # 
        # This parameter is required.
        self.track_id = track_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.track_id is not None:
            result['TrackId'] = self.track_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TrackId') is not None:
            self.track_id = m.get('TrackId')
        return self


class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors(TeaModel):
    def __init__(
        self,
        audio_language_selection: ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection = None,
        audio_pid_selection: ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection = None,
        audio_track_selection: List[ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection] = None,
        name: str = None,
    ):
        # The audio language selection.
        self.audio_language_selection = audio_language_selection
        # The audio PID selection.
        self.audio_pid_selection = audio_pid_selection
        # The audio track selection.
        self.audio_track_selection = audio_track_selection
        # The name of the audio selector.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_language_selection:
            self.audio_language_selection.validate()
        if self.audio_pid_selection:
            self.audio_pid_selection.validate()
        if self.audio_track_selection:
            for k in self.audio_track_selection:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_language_selection is not None:
            result['AudioLanguageSelection'] = self.audio_language_selection.to_map()
        if self.audio_pid_selection is not None:
            result['AudioPidSelection'] = self.audio_pid_selection.to_map()
        result['AudioTrackSelection'] = []
        if self.audio_track_selection is not None:
            for k in self.audio_track_selection:
                result['AudioTrackSelection'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLanguageSelection') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection()
            self.audio_language_selection = temp_model.from_map(m['AudioLanguageSelection'])
        if m.get('AudioPidSelection') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection()
            self.audio_pid_selection = temp_model.from_map(m['AudioPidSelection'])
        self.audio_track_selection = []
        if m.get('AudioTrackSelection') is not None:
            for k in m.get('AudioTrackSelection'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection()
                self.audio_track_selection.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListMediaLiveChannelsResponseBodyChannelsInputAttachments(TeaModel):
    def __init__(
        self,
        audio_selectors: List[ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors] = None,
        input_id: str = None,
        input_name: str = None,
        language_name: str = None,
    ):
        # The audio selectors.
        self.audio_selectors = audio_selectors
        # The ID of the input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The name of the input.
        self.input_name = input_name
        # The name of the language.
        self.language_name = language_name

    def validate(self):
        if self.audio_selectors:
            for k in self.audio_selectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSelectors'] = []
        if self.audio_selectors is not None:
            for k in self.audio_selectors:
                result['AudioSelectors'].append(k.to_map() if k else None)
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.input_name is not None:
            result['InputName'] = self.input_name
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_selectors = []
        if m.get('AudioSelectors') is not None:
            for k in m.get('AudioSelectors'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors()
                self.audio_selectors.append(temp_model.from_map(k))
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        return self


class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # ChannelName in MediaPackage.
        self.channel_name = channel_name
        # GroupName in MediaPackage.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting(TeaModel):
    def __init__(
        self,
        audio_group_id: str = None,
        name_modifier: str = None,
    ):
        # The manifest audio group ID.
        self.audio_group_id = audio_group_id
        # The manifest name modifier. The child manifests include this modifier in their M3U8 file names.
        self.name_modifier = name_modifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_group_id is not None:
            result['AudioGroupId'] = self.audio_group_id
        if self.name_modifier is not None:
            result['NameModifier'] = self.name_modifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioGroupId') is not None:
            self.audio_group_id = m.get('AudioGroupId')
        if m.get('NameModifier') is not None:
            self.name_modifier = m.get('NameModifier')
        return self


class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs(TeaModel):
    def __init__(
        self,
        audio_setting_names: List[str] = None,
        media_package_output_setting: ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting = None,
        media_type: int = None,
        name: str = None,
        video_setting_name: str = None,
    ):
        # The referenced AudioSettings.
        self.audio_setting_names = audio_setting_names
        # The settings of the output delivered to MediaPackage.
        self.media_package_output_setting = media_package_output_setting
        # The media type of the output.
        self.media_type = media_type
        # The name of the output.
        self.name = name
        # The name of the referenced VideoSettings.
        self.video_setting_name = video_setting_name

    def validate(self):
        if self.media_package_output_setting:
            self.media_package_output_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_setting_names is not None:
            result['AudioSettingNames'] = self.audio_setting_names
        if self.media_package_output_setting is not None:
            result['MediaPackageOutputSetting'] = self.media_package_output_setting.to_map()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.video_setting_name is not None:
            result['VideoSettingName'] = self.video_setting_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettingNames') is not None:
            self.audio_setting_names = m.get('AudioSettingNames')
        if m.get('MediaPackageOutputSetting') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting()
            self.media_package_output_setting = temp_model.from_map(m['MediaPackageOutputSetting'])
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoSettingName') is not None:
            self.video_setting_name = m.get('VideoSettingName')
        return self


class ListMediaLiveChannelsResponseBodyChannelsOutputGroups(TeaModel):
    def __init__(
        self,
        media_package_group_setting: ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting = None,
        monitor_url: str = None,
        name: str = None,
        outputs: List[ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs] = None,
        type: str = None,
    ):
        # The MediaPackage destination.
        self.media_package_group_setting = media_package_group_setting
        # The URL for monitoring the output group. The parameter is returned only when the output gourp type is MediaPackage.
        self.monitor_url = monitor_url
        # The name of the output group.
        self.name = name
        # The outputs in the output group.
        self.outputs = outputs
        # The output group type.
        self.type = type

    def validate(self):
        if self.media_package_group_setting:
            self.media_package_group_setting.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_package_group_setting is not None:
            result['MediaPackageGroupSetting'] = self.media_package_group_setting.to_map()
        if self.monitor_url is not None:
            result['MonitorUrl'] = self.monitor_url
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaPackageGroupSetting') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting()
            self.media_package_group_setting = temp_model.from_map(m['MediaPackageGroupSetting'])
        if m.get('MonitorUrl') is not None:
            self.monitor_url = m.get('MonitorUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs()
                self.outputs.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail(TeaModel):
    def __init__(
        self,
        level: str = None,
        profile: str = None,
    ):
        # The video encoding level. It is not supported yet.
        self.level = level
        # The H.264 profile.
        self.profile = profile

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.profile is not None:
            result['Profile'] = self.profile
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate(TeaModel):
    def __init__(
        self,
        framerate_control: str = None,
        framerate_denominator: int = None,
        framerate_numerator: int = None,
    ):
        # The frame rate mode.
        self.framerate_control = framerate_control
        # The denominator of the fixed frame rate.
        self.framerate_denominator = framerate_denominator
        # The numerator of the fixed frame rate.
        self.framerate_numerator = framerate_numerator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.framerate_control is not None:
            result['FramerateControl'] = self.framerate_control
        if self.framerate_denominator is not None:
            result['FramerateDenominator'] = self.framerate_denominator
        if self.framerate_numerator is not None:
            result['FramerateNumerator'] = self.framerate_numerator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FramerateControl') is not None:
            self.framerate_control = m.get('FramerateControl')
        if m.get('FramerateDenominator') is not None:
            self.framerate_denominator = m.get('FramerateDenominator')
        if m.get('FramerateNumerator') is not None:
            self.framerate_numerator = m.get('FramerateNumerator')
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop(TeaModel):
    def __init__(
        self,
        bframes_num: int = None,
        gop_size: int = None,
        gop_size_units: str = None,
    ):
        # The number of B frames.
        self.bframes_num = bframes_num
        # The GOP size.
        self.gop_size = gop_size
        # The GOP size unit.
        self.gop_size_units = gop_size_units

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bframes_num is not None:
            result['BframesNum'] = self.bframes_num
        if self.gop_size is not None:
            result['GopSize'] = self.gop_size
        if self.gop_size_units is not None:
            result['GopSizeUnits'] = self.gop_size_units
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BframesNum') is not None:
            self.bframes_num = m.get('BframesNum')
        if m.get('GopSize') is not None:
            self.gop_size = m.get('GopSize')
        if m.get('GopSizeUnits') is not None:
            self.gop_size_units = m.get('GopSizeUnits')
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        buffer_size: int = None,
        max_bitrate: int = None,
        rate_control_mode: str = None,
    ):
        # The video bitrate. Unit: bit/s.
        self.bitrate = bitrate
        # The video buffer size. Unit: bit/s.
        self.buffer_size = buffer_size
        # The maximum bitrate. Unit: bit/s.
        self.max_bitrate = max_bitrate
        # The bitrate control mode.
        self.rate_control_mode = rate_control_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.buffer_size is not None:
            result['BufferSize'] = self.buffer_size
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.rate_control_mode is not None:
            result['RateControlMode'] = self.rate_control_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BufferSize') is not None:
            self.buffer_size = m.get('BufferSize')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('RateControlMode') is not None:
            self.rate_control_mode = m.get('RateControlMode')
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting(TeaModel):
    def __init__(
        self,
        codec_detail: ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail = None,
        framerate: ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate = None,
        gop: ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop = None,
        rate: ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate = None,
    ):
        # The video encoding settings.
        self.codec_detail = codec_detail
        # The frame rate.
        self.framerate = framerate
        # The GOP setting.
        self.gop = gop
        # The video encoding rate.
        self.rate = rate

    def validate(self):
        if self.codec_detail:
            self.codec_detail.validate()
        if self.framerate:
            self.framerate.validate()
        if self.gop:
            self.gop.validate()
        if self.rate:
            self.rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_detail is not None:
            result['CodecDetail'] = self.codec_detail.to_map()
        if self.framerate is not None:
            result['Framerate'] = self.framerate.to_map()
        if self.gop is not None:
            result['Gop'] = self.gop.to_map()
        if self.rate is not None:
            result['Rate'] = self.rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecDetail') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail()
            self.codec_detail = temp_model.from_map(m['CodecDetail'])
        if m.get('Framerate') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate()
            self.framerate = temp_model.from_map(m['Framerate'])
        if m.get('Gop') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop()
            self.gop = temp_model.from_map(m['Gop'])
        if m.get('Rate') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate()
            self.rate = temp_model.from_map(m['Rate'])
        return self


class ListMediaLiveChannelsResponseBodyChannelsVideoSettings(TeaModel):
    def __init__(
        self,
        height: int = None,
        name: str = None,
        video_codec: str = None,
        video_codec_setting: ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting = None,
        video_codec_type: str = None,
        width: int = None,
    ):
        # The height of the video in pixels.
        self.height = height
        # The name of the video settings.
        self.name = name
        # The video codec.
        self.video_codec = video_codec
        # The video encoding settings.
        self.video_codec_setting = video_codec_setting
        # 
        self.video_codec_type = video_codec_type
        # The width of the video in pixels.
        self.width = width

    def validate(self):
        if self.video_codec_setting:
            self.video_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_codec_setting is not None:
            result['VideoCodecSetting'] = self.video_codec_setting.to_map()
        if self.video_codec_type is not None:
            result['VideoCodecType'] = self.video_codec_type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoCodecSetting') is not None:
            temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting()
            self.video_codec_setting = temp_model.from_map(m['VideoCodecSetting'])
        if m.get('VideoCodecType') is not None:
            self.video_codec_type = m.get('VideoCodecType')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaLiveChannelsResponseBodyChannels(TeaModel):
    def __init__(
        self,
        audio_settings: List[ListMediaLiveChannelsResponseBodyChannelsAudioSettings] = None,
        channel_id: str = None,
        create_time: str = None,
        input_attachments: List[ListMediaLiveChannelsResponseBodyChannelsInputAttachments] = None,
        last_start_time: str = None,
        last_stop_time: str = None,
        name: str = None,
        output_groups: List[ListMediaLiveChannelsResponseBodyChannelsOutputGroups] = None,
        state: str = None,
        video_settings: List[ListMediaLiveChannelsResponseBodyChannelsVideoSettings] = None,
    ):
        # The audio settings.
        self.audio_settings = audio_settings
        # The ID of the channel.
        self.channel_id = channel_id
        # The time when the channel was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The inputs associated with the channel.
        self.input_attachments = input_attachments
        # The time when the channel was last started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. If the channel has never been started since it was created, an empty string is returned.
        self.last_start_time = last_start_time
        # The time when the channel was last stopped. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. If the channel has never stopped since it was created, an empty string is returned.
        self.last_stop_time = last_stop_time
        # The name of the channel.
        self.name = name
        # The output groups.
        self.output_groups = output_groups
        # The state of the channel. Valid values: IDLE, STARTING, RUNNING, RECOVERING, and STOPPING.
        self.state = state
        # The video settings.
        self.video_settings = video_settings

    def validate(self):
        if self.audio_settings:
            for k in self.audio_settings:
                if k:
                    k.validate()
        if self.input_attachments:
            for k in self.input_attachments:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.video_settings:
            for k in self.video_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSettings'] = []
        if self.audio_settings is not None:
            for k in self.audio_settings:
                result['AudioSettings'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['InputAttachments'] = []
        if self.input_attachments is not None:
            for k in self.input_attachments:
                result['InputAttachments'].append(k.to_map() if k else None)
        if self.last_start_time is not None:
            result['LastStartTime'] = self.last_start_time
        if self.last_stop_time is not None:
            result['LastStopTime'] = self.last_stop_time
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        if self.state is not None:
            result['State'] = self.state
        result['VideoSettings'] = []
        if self.video_settings is not None:
            for k in self.video_settings:
                result['VideoSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_settings = []
        if m.get('AudioSettings') is not None:
            for k in m.get('AudioSettings'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsAudioSettings()
                self.audio_settings.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.input_attachments = []
        if m.get('InputAttachments') is not None:
            for k in m.get('InputAttachments'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsInputAttachments()
                self.input_attachments.append(temp_model.from_map(k))
        if m.get('LastStartTime') is not None:
            self.last_start_time = m.get('LastStartTime')
        if m.get('LastStopTime') is not None:
            self.last_stop_time = m.get('LastStopTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsOutputGroups()
                self.output_groups.append(temp_model.from_map(k))
        if m.get('State') is not None:
            self.state = m.get('State')
        self.video_settings = []
        if m.get('VideoSettings') is not None:
            for k in m.get('VideoSettings'):
                temp_model = ListMediaLiveChannelsResponseBodyChannelsVideoSettings()
                self.video_settings.append(temp_model.from_map(k))
        return self


class ListMediaLiveChannelsResponseBody(TeaModel):
    def __init__(
        self,
        channels: List[ListMediaLiveChannelsResponseBodyChannels] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The channels.
        self.channels = channels
        # The number of entries returned per page.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.channels:
            for k in self.channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Channels'] = []
        if self.channels is not None:
            for k in self.channels:
                result['Channels'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channels = []
        if m.get('Channels') is not None:
            for k in m.get('Channels'):
                temp_model = ListMediaLiveChannelsResponseBodyChannels()
                self.channels.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMediaLiveChannelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaLiveChannelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaLiveChannelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaLiveInputSecurityGroupsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        max_results: int = None,
        next_token: str = None,
        skip: int = None,
        sort_order: str = None,
    ):
        # The keyword of the query. You can perform a fuzzy search on security group ID or name.
        self.keyword = keyword
        # The number of entries per page. Valid values: 1 to 100. Default value: If you do not specify this parameter or if you set a value smaller than 10, the default value is 10. If you set a value greater than 100, the default value is 100.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_token = next_token
        # The number of entries to be skipped in the query. If the number of entries you attempt to skip exceeds the number of entries that meet the condition, an empty list is returned.
        self.skip = skip
        # The sorting order of the security groups by creation time. Default value: asc. Valid values: desc and asc. asc indicates the ascending order, and desc indicates the descending order.
        self.sort_order = sort_order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        return self


class ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        input_ids: List[str] = None,
        name: str = None,
        security_group_id: str = None,
        whitelist_rules: List[str] = None,
    ):
        # The time when the security group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The IDs of the inputs associated with the security group.
        self.input_ids = input_ids
        # The security group name.
        self.name = name
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The security group rules.
        self.whitelist_rules = whitelist_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.input_ids is not None:
            result['InputIds'] = self.input_ids
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.whitelist_rules is not None:
            result['WhitelistRules'] = self.whitelist_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InputIds') is not None:
            self.input_ids = m.get('InputIds')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules = m.get('WhitelistRules')
        return self


class ListMediaLiveInputSecurityGroupsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        security_groups: List[ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups] = None,
        total_count: int = None,
    ):
        # The number of entries returned per page.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The security groups.
        self.security_groups = security_groups
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.security_groups:
            for k in self.security_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityGroups'] = []
        if self.security_groups is not None:
            for k in self.security_groups:
                result['SecurityGroups'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_groups = []
        if m.get('SecurityGroups') is not None:
            for k in m.get('SecurityGroups'):
                temp_model = ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups()
                self.security_groups.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMediaLiveInputSecurityGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaLiveInputSecurityGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaLiveInputSecurityGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaLiveInputsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        max_results: int = None,
        next_token: str = None,
        skip: int = None,
        sort_order: str = None,
        types: str = None,
    ):
        # The keyword of the query. You can perform a fuzzy search on input ID or name.
        self.keyword = keyword
        # The number of entries per page. Valid values: 1 to 100. Default value: If you do not specify this parameter or if you set a value smaller than 10, the default value is 10. If you set a value greater than 100, the default value is 100.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_token = next_token
        # The number of entries to be skipped in the query. If the number of entries you attempt to skip exceeds the number of entries that meet the condition, an empty list is returned.
        self.skip = skip
        # The sorting order of the inputs by creation time. Default value: asc. Valid values: desc and asc. asc indicates the ascending order, and desc indicates the descending order.
        self.sort_order = sort_order
        # The type of inputs you want to query. You can separate multiple input types with commas (,) in a JSON array.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListMediaLiveInputsResponseBodyInputsInputInfos(TeaModel):
    def __init__(
        self,
        dest_host: str = None,
        flow_id: str = None,
        flow_output_name: str = None,
        monitor_url: str = None,
        source_url: str = None,
        stream_name: str = None,
    ):
        # The endpoint that the stream is pushed to. This parameter is returned for PUSH inputs.
        self.dest_host = dest_host
        self.flow_id = flow_id
        self.flow_output_name = flow_output_name
        # The URL for input monitoring.
        self.monitor_url = monitor_url
        # The source URL where the stream is pulled from. This parameter is returned for PULL inputs.
        self.source_url = source_url
        # The name of the pushed stream. This parameter is returned for PUSH inputs.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_host is not None:
            result['DestHost'] = self.dest_host
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_output_name is not None:
            result['FlowOutputName'] = self.flow_output_name
        if self.monitor_url is not None:
            result['MonitorUrl'] = self.monitor_url
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestHost') is not None:
            self.dest_host = m.get('DestHost')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowOutputName') is not None:
            self.flow_output_name = m.get('FlowOutputName')
        if m.get('MonitorUrl') is not None:
            self.monitor_url = m.get('MonitorUrl')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class ListMediaLiveInputsResponseBodyInputs(TeaModel):
    def __init__(
        self,
        channel_ids: List[str] = None,
        create_time: str = None,
        input_id: str = None,
        input_infos: List[ListMediaLiveInputsResponseBodyInputsInputInfos] = None,
        name: str = None,
        security_group_ids: List[str] = None,
        type: str = None,
    ):
        # The IDs of the channels associated with the input.
        self.channel_ids = channel_ids
        # The time when the input was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the input.
        self.input_id = input_id
        # The input configurations.
        self.input_infos = input_infos
        # The name of the input.
        self.name = name
        # The IDs of the security groups associated with the input.
        self.security_group_ids = security_group_ids
        # The input type.
        self.type = type

    def validate(self):
        if self.input_infos:
            for k in self.input_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.input_id is not None:
            result['InputId'] = self.input_id
        result['InputInfos'] = []
        if self.input_infos is not None:
            for k in self.input_infos:
                result['InputInfos'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        self.input_infos = []
        if m.get('InputInfos') is not None:
            for k in m.get('InputInfos'):
                temp_model = ListMediaLiveInputsResponseBodyInputsInputInfos()
                self.input_infos.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaLiveInputsResponseBody(TeaModel):
    def __init__(
        self,
        inputs: List[ListMediaLiveInputsResponseBodyInputs] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The inputs.
        self.inputs = inputs
        # The number of entries returned per page.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = ListMediaLiveInputsResponseBodyInputs()
                self.inputs.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMediaLiveInputsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaLiveInputsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaLiveInputsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaMarksRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The mark ID. You can specify multiple IDs separated with commas (,). This parameter is discontinued.
        self.media_mark_ids = media_mark_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        return self


class ListMediaMarksResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_marks: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The marks of the media asset, in the JSONArray format.
        self.media_marks = media_marks
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_marks is not None:
            result['MediaMarks'] = self.media_marks
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarks') is not None:
            self.media_marks = m.get('MediaMarks')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaMarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaMarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaMarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaProducingJobsRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        job_type: str = None,
        keyword: str = None,
        master_job_id: str = None,
        max_results: int = None,
        next_token: str = None,
        project_id: str = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The end of the time range to query. The maximum time range between EndTime and StartTime cannot exceed 30 days. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The job type.
        # 
        # Valid values:
        # 
        # *   LiveEditingJob: live editing job.
        # *   EditingJob: regular template-based editing job
        # *   VETemplateJob: advanced template-based editing job.
        self.job_type = job_type
        # The search keyword. For example, you can use a job ID as the keyword to search for jobs.
        self.keyword = keyword
        # The ID of the quick video production job. If this parameter is specified, the subjobs of the quick video production job are queried.
        self.master_job_id = master_job_id
        # The maximum number of entries to return.
        # 
        # Default value: 10. Valid values: 1 to 100.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the online editing project.
        self.project_id = project_id
        # The sorting parameter. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   CreationTime:Asc: sorted by creation time in ascending order.
        # *   CreationTime:Desc: sorted by creation time in descending order.
        self.sort_by = sort_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The job state.
        # 
        # Valid values:
        # 
        # *   Init: The job is initialized.
        # *   Failed: The job failed.
        # *   Success: The job is successful.
        # *   Processing: The job is in progress.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.master_job_id is not None:
            result['MasterJobId'] = self.master_job_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('MasterJobId') is not None:
            self.master_job_id = m.get('MasterJobId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMediaProducingJobsResponseBodyMediaProducingJobList(TeaModel):
    def __init__(
        self,
        clips_param: str = None,
        code: str = None,
        complete_time: str = None,
        create_time: str = None,
        duration: float = None,
        job_id: str = None,
        media_id: str = None,
        media_url: str = None,
        message: str = None,
        modified_time: str = None,
        project_id: str = None,
        status: str = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The template material parameters.
        self.clips_param = clips_param
        # The response code.
        self.code = code
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.complete_time = complete_time
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The duration of the output file. Unit: seconds.
        self.duration = duration
        # The ID of the online editing job.
        self.job_id = job_id
        # The media asset ID of the output file.
        self.media_id = media_id
        # The URL of the output file.
        self.media_url = media_url
        # The returned message. Note: Pay attention to this parameter if the job failed.
        self.message = message
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The ID of the online editing project.
        self.project_id = project_id
        # The job state.
        self.status = status
        # The ID of the online editing template.
        self.template_id = template_id
        # The user-defined data in the JSON format.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.code is not None:
            result['Code'] = self.code
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaProducingJobsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: str = None,
        media_producing_job_list: List[ListMediaProducingJobsResponseBodyMediaProducingJobList] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        # The maximum number of entries returned.
        # 
        # Default value: 10. Valid values: 1 to 100.
        self.max_results = max_results
        # The queried media editing and production jobs.
        self.media_producing_job_list = media_producing_job_list
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_producing_job_list:
            for k in self.media_producing_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        result['MediaProducingJobList'] = []
        if self.media_producing_job_list is not None:
            for k in self.media_producing_job_list:
                result['MediaProducingJobList'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        self.media_producing_job_list = []
        if m.get('MediaProducingJobList') is not None:
            for k in m.get('MediaProducingJobList'):
                temp_model = ListMediaProducingJobsResponseBodyMediaProducingJobList()
                self.media_producing_job_list.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaProducingJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaProducingJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaProducingJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPackageJobsRequest(TeaModel):
    def __init__(
        self,
        end_of_create_time: str = None,
        job_id: str = None,
        next_page_token: str = None,
        order_by: str = None,
        page_size: int = None,
        start_of_create_time: str = None,
        status: str = None,
    ):
        # The end of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_of_create_time = end_of_create_time
        # The job ID.
        self.job_id = job_id
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_page_token = next_page_token
        # The order that you use to sort the query results. Valid values:
        # 
        # *   CreateTimeDesc: sorts the jobs by creation time in descending order.
        # *   CreateTimeAsc: sorts the jobs by creation time in ascending order.
        self.order_by = order_by
        # The number of entries per page. Valid values: 0 to 100. Default value: 20.
        self.page_size = page_size
        # The beginning of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_of_create_time = start_of_create_time
        # The state of the job.
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPackageJobsResponseBodyPackageJobListPackageJobsInputs(TeaModel):
    def __init__(
        self,
        input: ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput = None,
    ):
        # The information about the input stream file.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class ListPackageJobsResponseBodyPackageJobListPackageJobsOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPackageJobsResponseBodyPackageJobListPackageJobs(TeaModel):
    def __init__(
        self,
        code: str = None,
        create_time: str = None,
        finish_time: str = None,
        inputs: List[ListPackageJobsResponseBodyPackageJobListPackageJobsInputs] = None,
        job_id: str = None,
        message: str = None,
        modified_time: str = None,
        name: str = None,
        output: ListPackageJobsResponseBodyPackageJobListPackageJobsOutput = None,
        pipeline_id: str = None,
        priority: int = None,
        status: str = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input of the job.
        self.inputs = inputs
        # The job ID.
        self.job_id = job_id
        # The error message that is returned.
        self.message = message
        # The time when the job was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority. Default value: 6.
        self.priority = priority
        # The state of the job.
        self.status = status
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The source of the job. Valid values:
        # 
        # *   API
        # *   WorkFlow
        # *   Console
        self.trigger_source = trigger_source
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = ListPackageJobsResponseBodyPackageJobListPackageJobsInputs()
                self.inputs.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = ListPackageJobsResponseBodyPackageJobListPackageJobsOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListPackageJobsResponseBodyPackageJobList(TeaModel):
    def __init__(
        self,
        next_page_token: str = None,
        package_jobs: List[ListPackageJobsResponseBodyPackageJobListPackageJobs] = None,
    ):
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The token of the next page is returned after you call this operation for the first time.
        self.next_page_token = next_page_token
        # The list of packaging jobs.
        self.package_jobs = package_jobs

    def validate(self):
        if self.package_jobs:
            for k in self.package_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        result['PackageJobs'] = []
        if self.package_jobs is not None:
            for k in self.package_jobs:
                result['PackageJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        self.package_jobs = []
        if m.get('PackageJobs') is not None:
            for k in m.get('PackageJobs'):
                temp_model = ListPackageJobsResponseBodyPackageJobListPackageJobs()
                self.package_jobs.append(temp_model.from_map(k))
        return self


class ListPackageJobsResponseBody(TeaModel):
    def __init__(
        self,
        package_job_list: ListPackageJobsResponseBodyPackageJobList = None,
        request_id: str = None,
    ):
        # The list of packaging jobs.
        self.package_job_list = package_job_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.package_job_list:
            self.package_job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_job_list is not None:
            result['PackageJobList'] = self.package_job_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackageJobList') is not None:
            temp_model = ListPackageJobsResponseBodyPackageJobList()
            self.package_job_list = temp_model.from_map(m['PackageJobList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPackageJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPackageJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPackageJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelinesRequest(TeaModel):
    def __init__(
        self,
        speed: str = None,
    ):
        # The type of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Boost: MPS queue with transcoding speed boosted.
        # *   Standard: standard MPS queue.
        # *   NarrowBandHDV2: MPS queue that supports Narrowband HD 2.0.
        self.speed = speed

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.speed is not None:
            result['Speed'] = self.speed
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        return self


class ListPipelinesResponseBodyPipelineList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modified_time: str = None,
        name: str = None,
        pipeline_id: str = None,
        priority: int = None,
        speed: str = None,
        status: str = None,
    ):
        # The time when the template was created.
        self.create_time = create_time
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The name of the MPS queue.
        self.name = name
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The priority of the MPS queue.
        self.priority = priority
        # The type of the MPS queue.
        self.speed = speed
        # The state of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Active
        # *   Paused
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPipelinesResponseBody(TeaModel):
    def __init__(
        self,
        pipeline_list: List[ListPipelinesResponseBodyPipelineList] = None,
        request_id: str = None,
    ):
        # The queried MPS queues.
        self.pipeline_list = pipeline_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pipeline_list:
            for k in self.pipeline_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PipelineList'] = []
        if self.pipeline_list is not None:
            for k in self.pipeline_list:
                result['PipelineList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline_list = []
        if m.get('PipelineList') is not None:
            for k in m.get('PipelineList'):
                temp_model = ListPipelinesResponseBodyPipelineList()
                self.pipeline_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPipelinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProgramsRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        page_no: str = None,
        page_size: str = None,
        program_name: str = None,
        sort_by: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The name of the program.
        self.program_name = program_name
        # The sorting order. By default, the query results are sorted by creation time in descending order. Valid values:
        # 
        # *   asc: ascending order.
        # *   desc: descending order.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListProgramsResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        programs: List[ChannelAssemblyProgram] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The programs.
        self.programs = programs
        # **Request ID**\
        self.request_id = request_id
        # The total number of programs returned.
        self.total_count = total_count

    def validate(self):
        if self.programs:
            for k in self.programs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Programs'] = []
        if self.programs is not None:
            for k in self.programs:
                result['Programs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.programs = []
        if m.get('Programs') is not None:
            for k in m.get('Programs'):
                temp_model = ChannelAssemblyProgram()
                self.programs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProgramsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProgramsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProgramsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPublicMediaBasicInfosRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        include_file_basic_info: bool = None,
        max_results: int = None,
        media_tag_id: str = None,
        next_token: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # The business type of the media asset. Valid values:
        # 
        # *   sticker
        # *   bgm
        # *   bgi
        self.business_type = business_type
        # Specifies whether to return the basic information of the media asset.
        self.include_file_basic_info = include_file_basic_info
        # The maximum number of entries to return.
        # 
        # Maximum value: 100. Default value: 10.
        self.max_results = max_results
        # The media tag. All media assets that contain the specified media tag are returned. Valid values:
        # 
        # *   Sticker tags:
        # 
        #     *   sticker-atmosphere
        #     *   sticker-bubble
        #     *   sticker-cute
        #     *   sticker-daily
        #     *   sticker-expression
        #     *   sticker-gif
        # 
        # *   Background music (BGM) tags:
        # 
        #     *   bgm-romantic
        #     *   bgm-cuisine
        #     *   bgm-chinese-style
        #     *   bgm-upbeat
        #     *   bgm-dynamic
        #     *   bgm-relaxing
        #     *   bgm-quirky
        #     *   bgm-beauty
        # 
        # *   Background image (BGI) tags:
        # 
        #     *   bgi-grad
        #     *   bgi-solid
        #     *   bgi-pic
        self.media_tag_id = media_tag_id
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_token = next_token
        # The page number. Default value: 1
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.include_file_basic_info is not None:
            result['IncludeFileBasicInfo'] = self.include_file_basic_info
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.media_tag_id is not None:
            result['MediaTagId'] = self.media_tag_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('IncludeFileBasicInfo') is not None:
            self.include_file_basic_info = m.get('IncludeFileBasicInfo')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MediaTagId') is not None:
            self.media_tag_id = m.get('MediaTagId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The file status.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The Object Storage Service (OSS) URL of the file.
        self.file_url = file_url
        # The container format.
        self.format_name = format_name
        # The height.
        self.height = height
        # The region in which the file resides.
        self.region = region
        # The width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo = None,
    ):
        # The basic information of the file, such as the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        snapshots: str = None,
        source: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        user_data: str = None,
    ):
        # The business type of the media asset.
        self.business_type = business_type
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The URL of the media asset in another service.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was last modified.
        self.modified_time = modified_time
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset.
        self.source = source
        # The status of the media asset.
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        self.transcode_status = transcode_status
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfos(TeaModel):
    def __init__(
        self,
        file_info_list: List[ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList] = None,
        media_basic_info: ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo = None,
        media_id: str = None,
    ):
        # The file information of the media asset.
        self.file_info_list = file_info_list
        # The basic information of the media asset.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class ListPublicMediaBasicInfosResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        media_infos: List[ListPublicMediaBasicInfosResponseBodyMediaInfos] = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # The media assets that meet the specified conditions.
        self.media_infos = media_infos
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of media assets that meet the specified conditions.
        self.total_count = total_count

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPublicMediaBasicInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPublicMediaBasicInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecognitionEntitiesRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListRecognitionEntitiesResponseBodyEntitiesEntity(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        entity_info: str = None,
        entity_name: str = None,
    ):
        self.entity_id = entity_id
        self.entity_info = entity_info
        self.entity_name = entity_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.entity_info is not None:
            result['EntityInfo'] = self.entity_info
        if self.entity_name is not None:
            result['EntityName'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('EntityInfo') is not None:
            self.entity_info = m.get('EntityInfo')
        if m.get('EntityName') is not None:
            self.entity_name = m.get('EntityName')
        return self


class ListRecognitionEntitiesResponseBodyEntities(TeaModel):
    def __init__(
        self,
        entity: List[ListRecognitionEntitiesResponseBodyEntitiesEntity] = None,
    ):
        self.entity = entity

    def validate(self):
        if self.entity:
            for k in self.entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Entity'] = []
        if self.entity is not None:
            for k in self.entity:
                result['Entity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.entity = []
        if m.get('Entity') is not None:
            for k in m.get('Entity'):
                temp_model = ListRecognitionEntitiesResponseBodyEntitiesEntity()
                self.entity.append(temp_model.from_map(k))
        return self


class ListRecognitionEntitiesResponseBody(TeaModel):
    def __init__(
        self,
        entities: ListRecognitionEntitiesResponseBodyEntities = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.entities = entities
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.entities:
            self.entities.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entities is not None:
            result['Entities'] = self.entities.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Entities') is not None:
            temp_model = ListRecognitionEntitiesResponseBodyEntities()
            self.entities = temp_model.from_map(m['Entities'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRecognitionEntitiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRecognitionEntitiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRecognitionEntitiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecognitionLibsRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListRecognitionLibsResponseBodyLibsLib(TeaModel):
    def __init__(
        self,
        lib_description: str = None,
        lib_id: str = None,
        lib_name: str = None,
    ):
        self.lib_description = lib_description
        self.lib_id = lib_id
        self.lib_name = lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lib_description is not None:
            result['LibDescription'] = self.lib_description
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.lib_name is not None:
            result['LibName'] = self.lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LibDescription') is not None:
            self.lib_description = m.get('LibDescription')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('LibName') is not None:
            self.lib_name = m.get('LibName')
        return self


class ListRecognitionLibsResponseBodyLibs(TeaModel):
    def __init__(
        self,
        lib: List[ListRecognitionLibsResponseBodyLibsLib] = None,
    ):
        self.lib = lib

    def validate(self):
        if self.lib:
            for k in self.lib:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Lib'] = []
        if self.lib is not None:
            for k in self.lib:
                result['Lib'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.lib = []
        if m.get('Lib') is not None:
            for k in m.get('Lib'):
                temp_model = ListRecognitionLibsResponseBodyLibsLib()
                self.lib.append(temp_model.from_map(k))
        return self


class ListRecognitionLibsResponseBody(TeaModel):
    def __init__(
        self,
        libs: ListRecognitionLibsResponseBodyLibs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.libs = libs
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.libs:
            self.libs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.libs is not None:
            result['Libs'] = self.libs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Libs') is not None:
            temp_model = ListRecognitionLibsResponseBodyLibs()
            self.libs = temp_model.from_map(m['Libs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRecognitionLibsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRecognitionLibsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRecognitionLibsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecognitionSamplesRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        entity_id: str = None,
        lib_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.entity_id = entity_id
        # This parameter is required.
        self.lib_id = lib_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.lib_id is not None:
            result['LibId'] = self.lib_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('LibId') is not None:
            self.lib_id = m.get('LibId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListRecognitionSamplesResponseBodySamplesSample(TeaModel):
    def __init__(
        self,
        image_url: str = None,
        sample_id: str = None,
    ):
        self.image_url = image_url
        self.sample_id = sample_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.sample_id is not None:
            result['SampleId'] = self.sample_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('SampleId') is not None:
            self.sample_id = m.get('SampleId')
        return self


class ListRecognitionSamplesResponseBodySamples(TeaModel):
    def __init__(
        self,
        sample: List[ListRecognitionSamplesResponseBodySamplesSample] = None,
    ):
        self.sample = sample

    def validate(self):
        if self.sample:
            for k in self.sample:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Sample'] = []
        if self.sample is not None:
            for k in self.sample:
                result['Sample'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sample = []
        if m.get('Sample') is not None:
            for k in m.get('Sample'):
                temp_model = ListRecognitionSamplesResponseBodySamplesSample()
                self.sample.append(temp_model.from_map(k))
        return self


class ListRecognitionSamplesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        samples: ListRecognitionSamplesResponseBodySamples = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.samples = samples
        self.total_count = total_count

    def validate(self):
        if self.samples:
            self.samples.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.samples is not None:
            result['Samples'] = self.samples.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Samples') is not None:
            temp_model = ListRecognitionSamplesResponseBodySamples()
            self.samples = temp_model.from_map(m['Samples'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRecognitionSamplesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRecognitionSamplesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRecognitionSamplesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSchedulesRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        page_no: int = None,
        page_size: int = None,
        window_duration_seconds: int = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The time window of the program schedule.
        # 
        # This parameter is required.
        self.window_duration_seconds = window_duration_seconds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.window_duration_seconds is not None:
            result['WindowDurationSeconds'] = self.window_duration_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('WindowDurationSeconds') is not None:
            self.window_duration_seconds = m.get('WindowDurationSeconds')
        return self


class ListSchedulesResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        programs: List[ChannelAssemblyScheduleData] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The program schedule.
        self.programs = programs
        # **Request ID**\
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.programs:
            for k in self.programs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Programs'] = []
        if self.programs is not None:
            for k in self.programs:
                result['Programs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.programs = []
        if m.get('Programs') is not None:
            for k in m.get('Programs'):
                temp_model = ChannelAssemblyScheduleData()
                self.programs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSchedulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSchedulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSchedulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchLibRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListSearchLibResponseBodySearchLibInfoListIndexInfo(TeaModel):
    def __init__(
        self,
        index_readiness: str = None,
        index_status: str = None,
        index_type: str = None,
    ):
        self.index_readiness = index_readiness
        self.index_status = index_status
        self.index_type = index_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_readiness is not None:
            result['IndexReadiness'] = self.index_readiness
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexReadiness') is not None:
            self.index_readiness = m.get('IndexReadiness')
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        return self


class ListSearchLibResponseBodySearchLibInfoList(TeaModel):
    def __init__(
        self,
        index_info: List[ListSearchLibResponseBodySearchLibInfoListIndexInfo] = None,
        search_lib_name: str = None,
        status: str = None,
    ):
        self.index_info = index_info
        # The search library.
        self.search_lib_name = search_lib_name
        # The status of the search library.
        # 
        # *   normal
        # *   deleting
        # *   deleteFail
        self.status = status

    def validate(self):
        if self.index_info:
            for k in self.index_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IndexInfo'] = []
        if self.index_info is not None:
            for k in self.index_info:
                result['IndexInfo'].append(k.to_map() if k else None)
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.index_info = []
        if m.get('IndexInfo') is not None:
            for k in m.get('IndexInfo'):
                temp_model = ListSearchLibResponseBodySearchLibInfoListIndexInfo()
                self.index_info.append(temp_model.from_map(k))
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        search_lib_info_list: List[ListSearchLibResponseBodySearchLibInfoList] = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The request ID.
        self.request_id = request_id
        # Information about search libraries.
        self.search_lib_info_list = search_lib_info_list
        # Indicates whether the request was successful.
        self.success = success
        # 
        self.total = total

    def validate(self):
        if self.search_lib_info_list:
            for k in self.search_lib_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SearchLibInfoList'] = []
        if self.search_lib_info_list is not None:
            for k in self.search_lib_info_list:
                result['SearchLibInfoList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.search_lib_info_list = []
        if m.get('SearchLibInfoList') is not None:
            for k in m.get('SearchLibInfoList'):
                temp_model = ListSearchLibResponseBodySearchLibInfoList()
                self.search_lib_info_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSmartJobsRequest(TeaModel):
    def __init__(
        self,
        job_state: str = None,
        job_type: str = None,
        max_results: int = None,
        next_token: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The job state.
        # 
        # Valid values:
        # 
        # *   Finished: The job is complete.
        # *   Failed: The job failed.
        # *   Executing: The job is in progress.
        # *   Created: The job is created.
        self.job_state = job_state
        # The job type.
        # 
        # Valid values:
        # 
        # *   ASR: automatic speech recognition(job) job.
        # *   DynamicChart: dynamic chart job.
        # *   VideoTranslation: video translation job.
        # *   TextToSpeech: intelligent audio production job.
        self.job_type = job_type
        # The maximum number of entries to return.
        # 
        # Default value: 10. Valid values: 1 to 100.
        self.max_results = max_results
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        # The sorting parameter. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   CreationTime:Asc: sorted by creation time in ascending order.
        # *   CreationTime:Desc: sorted by creation time in descending order.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_state is not None:
            result['JobState'] = self.job_state
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobState') is not None:
            self.job_state = m.get('JobState')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListSmartJobsResponseBodySmartJobListInputConfig(TeaModel):
    def __init__(
        self,
        input_file: str = None,
        keyword: str = None,
    ):
        # The information about the input file.
        self.input_file = input_file
        # The keyword information.
        self.keyword = keyword

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        return self


class ListSmartJobsResponseBodySmartJobListOutputConfig(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        object: str = None,
    ):
        # The Object Storage Service (OSS) bucket.
        self.bucket = bucket
        # The OSS object.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListSmartJobsResponseBodySmartJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        editing_config: str = None,
        input_config: ListSmartJobsResponseBodySmartJobListInputConfig = None,
        job_id: str = None,
        job_state: str = None,
        job_type: str = None,
        modified_time: str = None,
        output_config: ListSmartJobsResponseBodySmartJobListOutputConfig = None,
        title: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The job description.
        self.description = description
        # The editing configurations.
        self.editing_config = editing_config
        # The input configurations.
        self.input_config = input_config
        # The job ID.
        self.job_id = job_id
        # The job state.
        # 
        # Valid values:
        # 
        # *   Finished: The job is complete.
        # *   Failed: The job failed.
        # *   Executing: The job is in progress.
        # *   Created: The job is created.
        self.job_state = job_state
        # The job type.
        # 
        # Valid values:
        # 
        # *   ASR: ASR job.
        # *   DynamicChart: dynamic chart job.
        # *   TextToSpeech: intelligent audio production job.
        self.job_type = job_type
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The output configurations.
        self.output_config = output_config
        # The job title.
        self.title = title
        # The user-defined data.
        self.user_data = user_data
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.output_config:
            self.output_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_state is not None:
            result['JobState'] = self.job_state
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            temp_model = ListSmartJobsResponseBodySmartJobListInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobState') is not None:
            self.job_state = m.get('JobState')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            temp_model = ListSmartJobsResponseBodySmartJobListOutputConfig()
            self.output_config = temp_model.from_map(m['OutputConfig'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListSmartJobsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: str = None,
        next_token: str = None,
        request_id: str = None,
        smart_job_list: List[ListSmartJobsResponseBodySmartJobList] = None,
        total_count: str = None,
    ):
        # The maximum number of entries returned on a single page. The value is set to the maximum number of entries returned on each page except for the last page. Valid example: 10,10,5. Invalid example: 10,5,10.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The queried intelligent jobs.
        self.smart_job_list = smart_job_list
        # Optional. The total number of entries returned. By default, this parameter is not returned.
        self.total_count = total_count

    def validate(self):
        if self.smart_job_list:
            for k in self.smart_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SmartJobList'] = []
        if self.smart_job_list is not None:
            for k in self.smart_job_list:
                result['SmartJobList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.smart_job_list = []
        if m.get('SmartJobList') is not None:
            for k in m.get('SmartJobList'):
                temp_model = ListSmartJobsResponseBodySmartJobList()
                self.smart_job_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSmartJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSmartJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSmartJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSmartSysAvatarModelsRequest(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        sdk_version: str = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        self.sdk_version = sdk_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        return self


class ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList(TeaModel):
    def __init__(
        self,
        avatar_id: str = None,
        avatar_name: str = None,
        bitrate: int = None,
        cover_url: str = None,
        height: int = None,
        output_mask: bool = None,
        video_url: str = None,
        width: int = None,
    ):
        # The ID of the digital human. The ID is required to submit a separate digital human rendering job or use the digital human image in an intelligent timeline.
        self.avatar_id = avatar_id
        # The name of the digital human.
        self.avatar_name = avatar_name
        # The video bitrate.
        self.bitrate = bitrate
        # The sample thumbnail URL of the digital human.
        self.cover_url = cover_url
        # The video height.
        self.height = height
        # Indicates whether portrait mask rendering is supported.
        self.output_mask = output_mask
        # The sample video URL of the digital human.
        self.video_url = video_url
        # The video width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_id is not None:
            result['AvatarId'] = self.avatar_id
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.height is not None:
            result['Height'] = self.height
        if self.output_mask is not None:
            result['OutputMask'] = self.output_mask
        if self.video_url is not None:
            result['VideoUrl'] = self.video_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarId') is not None:
            self.avatar_id = m.get('AvatarId')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('OutputMask') is not None:
            self.output_mask = m.get('OutputMask')
        if m.get('VideoUrl') is not None:
            self.video_url = m.get('VideoUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListSmartSysAvatarModelsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        smart_sys_avatar_model_list: List[ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList] = None,
        total_count: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The queried digital humans.
        self.smart_sys_avatar_model_list = smart_sys_avatar_model_list
        # The total number of system digital human images returned.
        self.total_count = total_count

    def validate(self):
        if self.smart_sys_avatar_model_list:
            for k in self.smart_sys_avatar_model_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SmartSysAvatarModelList'] = []
        if self.smart_sys_avatar_model_list is not None:
            for k in self.smart_sys_avatar_model_list:
                result['SmartSysAvatarModelList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.smart_sys_avatar_model_list = []
        if m.get('SmartSysAvatarModelList') is not None:
            for k in m.get('SmartSysAvatarModelList'):
                temp_model = ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList()
                self.smart_sys_avatar_model_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSmartSysAvatarModelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSmartSysAvatarModelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSmartSysAvatarModelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSmartVoiceGroupsRequest(TeaModel):
    def __init__(
        self,
        voice_type: str = None,
    ):
        self.voice_type = voice_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.voice_type is not None:
            result['VoiceType'] = self.voice_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VoiceType') is not None:
            self.voice_type = m.get('VoiceType')
        return self


class ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList(TeaModel):
    def __init__(
        self,
        desc: str = None,
        name: str = None,
        remark: str = None,
        support_sample_rate: str = None,
        tag: str = None,
        voice: str = None,
        voice_type: str = None,
        voice_url: str = None,
    ):
        # The speaker description.
        self.desc = desc
        # The speaker name.
        self.name = name
        # The remarks of the speaker.
        self.remark = remark
        self.support_sample_rate = support_sample_rate
        # The tag of the speaker type.
        self.tag = tag
        # The speaker ID.
        self.voice = voice
        # The speaker type.
        # 
        # Valid values:
        # 
        # *   Male
        # *   Female
        # *   Boy
        # *   Girl
        self.voice_type = voice_type
        # The URL of the sample audio file.
        self.voice_url = voice_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.support_sample_rate is not None:
            result['SupportSampleRate'] = self.support_sample_rate
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.voice_type is not None:
            result['VoiceType'] = self.voice_type
        if self.voice_url is not None:
            result['VoiceUrl'] = self.voice_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SupportSampleRate') is not None:
            self.support_sample_rate = m.get('SupportSampleRate')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('VoiceType') is not None:
            self.voice_type = m.get('VoiceType')
        if m.get('VoiceUrl') is not None:
            self.voice_url = m.get('VoiceUrl')
        return self


class ListSmartVoiceGroupsResponseBodyVoiceGroups(TeaModel):
    def __init__(
        self,
        type: str = None,
        voice_list: List[ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList] = None,
    ):
        # The name of the speaker group.
        self.type = type
        # The speakers.
        self.voice_list = voice_list

    def validate(self):
        if self.voice_list:
            for k in self.voice_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        result['VoiceList'] = []
        if self.voice_list is not None:
            for k in self.voice_list:
                result['VoiceList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.voice_list = []
        if m.get('VoiceList') is not None:
            for k in m.get('VoiceList'):
                temp_model = ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList()
                self.voice_list.append(temp_model.from_map(k))
        return self


class ListSmartVoiceGroupsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        voice_groups: List[ListSmartVoiceGroupsResponseBodyVoiceGroups] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The queried speaker groups.
        self.voice_groups = voice_groups

    def validate(self):
        if self.voice_groups:
            for k in self.voice_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VoiceGroups'] = []
        if self.voice_groups is not None:
            for k in self.voice_groups:
                result['VoiceGroups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.voice_groups = []
        if m.get('VoiceGroups') is not None:
            for k in m.get('VoiceGroups'):
                temp_model = ListSmartVoiceGroupsResponseBodyVoiceGroups()
                self.voice_groups.append(temp_model.from_map(k))
        return self


class ListSmartVoiceGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSmartVoiceGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSmartVoiceGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSnapshotJobsRequest(TeaModel):
    def __init__(
        self,
        end_of_create_time: str = None,
        job_id: str = None,
        next_page_token: str = None,
        order_by: str = None,
        page_size: int = None,
        start_of_create_time: str = None,
        status: str = None,
    ):
        # The end of the time range during which the jobs to be queried were created.
        self.end_of_create_time = end_of_create_time
        # The job ID.
        self.job_id = job_id
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The order that you use to sort the query results.
        # 
        # 1.  CreateTimeDesc
        # 2.  CreateTimeAsc
        # 
        # Valid values:
        # 
        # *   CreateTimeDesc: sorts the jobs by creation time in descending order
        # *   CreateTimeAsc: sorts the jobs by creation time in ascending order.
        self.order_by = order_by
        # The number of entries per page. Default value: 20. Maximum value: 100.
        self.page_size = page_size
        # The beginning of the time range during which the jobs to be queried were created.
        self.start_of_create_time = start_of_create_time
        # The state of the job.
        # 
        # Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListSnapshotJobsResponseBodyJobsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats: 1. OSS://bucket/object 2. http(s)://bucket.oss-[RegionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBodyJobsOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The output file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  OSS://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS. If multiple static snapshots were captured, the object must contain the "{Count}" placeholder. In the case of a sprite, the object must contain the "{TileCount}" placeholder. The suffix of the WebVTT snapshot objects must be ".vtt".
        self.media = media
        # The type of the output file. Valid values:
        # 
        # 1.  OSS: an OSS object.
        # 2.  Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBodyJobs(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        count: int = None,
        create_time: str = None,
        finish_time: str = None,
        input: ListSnapshotJobsResponseBodyJobsInput = None,
        job_id: str = None,
        modified_time: str = None,
        name: str = None,
        output: ListSnapshotJobsResponseBodyJobsOutput = None,
        pipeline_id: str = None,
        status: str = None,
        submit_time: str = None,
        template_id: str = None,
        trigger_source: str = None,
        type: str = None,
    ):
        # Indicates whether the snapshots were captured in asynchronous mode.
        self.async_ = async_
        # The number of snapshots.
        self.count = count
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The time when the job was last modified.
        self.modified_time = modified_time
        # The name of the job.
        self.name = name
        # The output of the job.
        self.output = output
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The state of the job.
        # 
        # *   **Success**: The job is successful.
        # *   **Fail**: The job failed.
        # *   **Init**: The job is submitted.
        self.status = status
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The template ID.
        self.template_id = template_id
        # The request trigger source.
        # 
        # Valid values:
        # 
        # *   Console
        # *   Workflow
        # *   API
        self.trigger_source = trigger_source
        # The type of the job.
        # 
        # Valid values:
        # 
        # *   WebVtt
        # *   Sprite
        # *   Normal
        self.type = type

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.count is not None:
            result['Count'] = self.count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListSnapshotJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = ListSnapshotJobsResponseBodyJobsOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBody(TeaModel):
    def __init__(
        self,
        jobs: List[ListSnapshotJobsResponseBodyJobs] = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The list of jobs.
        self.jobs = jobs
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListSnapshotJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSnapshotJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSnapshotJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSnapshotJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSourceLocationsRequest(TeaModel):
    def __init__(
        self,
        filter_state: bool = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
        sort_by_modified_time: str = None,
        source_location_name: str = None,
    ):
        # Specifies whether to ignore source locations marked as deleted. A value of true means ignoring source locations marked as deleted.
        self.filter_state = filter_state
        # *   The page number.
        # *   Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order.
        self.sort_by = sort_by
        # The sorting order of the source locations based on the time when they were last modified.
        self.sort_by_modified_time = sort_by_modified_time
        # The name of the source location.
        self.source_location_name = source_location_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_state is not None:
            result['FilterState'] = self.filter_state
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.sort_by_modified_time is not None:
            result['SortByModifiedTime'] = self.sort_by_modified_time
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilterState') is not None:
            self.filter_state = m.get('FilterState')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SortByModifiedTime') is not None:
            self.sort_by_modified_time = m.get('SortByModifiedTime')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        return self


class ListSourceLocationsResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        source_location_list: List[ChannelAssemblySourceLocation] = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # **Request ID**\
        self.request_id = request_id
        # The source locations.
        self.source_location_list = source_location_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.source_location_list:
            for k in self.source_location_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SourceLocationList'] = []
        if self.source_location_list is not None:
            for k in self.source_location_list:
                result['SourceLocationList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.source_location_list = []
        if m.get('SourceLocationList') is not None:
            for k in m.get('SourceLocationList'):
                temp_model = ChannelAssemblySourceLocation()
                self.source_location_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSourceLocationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSourceLocationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSourceLocationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSourcesRequest(TeaModel):
    def __init__(
        self,
        filter_state: bool = None,
        page_no: str = None,
        page_size: str = None,
        sort_by: str = None,
        sort_by_modified_time: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        # Specifies whether to ignore sources marked as deleted.
        self.filter_state = filter_state
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The sorting order. By default, the query results are sorted by creation time in descending order. Valid values: asc and desc.
        self.sort_by = sort_by
        # The sorting order by modification time. Valid values: asc and desc.
        self.sort_by_modified_time = sort_by_modified_time
        # The name of the source location.
        self.source_location_name = source_location_name
        # The name of the source.
        self.source_name = source_name
        # The source type. Valid values: vodSource and liveSource.
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_state is not None:
            result['FilterState'] = self.filter_state
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.sort_by_modified_time is not None:
            result['SortByModifiedTime'] = self.sort_by_modified_time
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilterState') is not None:
            self.filter_state = m.get('FilterState')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SortByModifiedTime') is not None:
            self.sort_by_modified_time = m.get('SortByModifiedTime')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class ListSourcesResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        source_list: List[ChannelAssemblySource] = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # **Request ID**\
        self.request_id = request_id
        # The sources.
        self.source_list = source_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.source_list:
            for k in self.source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SourceList'] = []
        if self.source_list is not None:
            for k in self.source_list:
                result['SourceList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.source_list = []
        if m.get('SourceList') is not None:
            for k in m.get('SourceList'):
                temp_model = ChannelAssemblySource()
                self.source_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemTemplatesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        status: str = None,
        subtype: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The template name.
        self.name = name
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 20 Valid values: 1 to 100.
        self.page_size = page_size
        # The template state. Valid values: Normal, Invisible, and All.
        self.status = status
        # The subtype ID of the template.
        self.subtype = subtype
        # The template ID.
        self.template_id = template_id
        # The template type. Separate multiple types with commas (,).
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSystemTemplatesResponseBodySystemTemplateList(TeaModel):
    def __init__(
        self,
        status: str = None,
        subtype: int = None,
        subtype_name: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
        type: int = None,
        type_name: str = None,
    ):
        # The template state.
        self.status = status
        # The subtype ID of the template.
        self.subtype = subtype
        # The subtype name of the template.
        self.subtype_name = subtype_name
        # The template parameters.
        self.template_config = template_config
        # The template ID.
        self.template_id = template_id
        # The template name.
        self.template_name = template_name
        # The type ID of the template.
        self.type = type
        # The type name of the template.
        self.type_name = type_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class ListSystemTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        system_template_list: List[ListSystemTemplatesResponseBodySystemTemplateList] = None,
        total: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The queried templates.
        self.system_template_list = system_template_list
        # The total number of templates.
        self.total = total

    def validate(self):
        if self.system_template_list:
            for k in self.system_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SystemTemplateList'] = []
        if self.system_template_list is not None:
            for k in self.system_template_list:
                result['SystemTemplateList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.system_template_list = []
        if m.get('SystemTemplateList') is not None:
            for k in m.get('SystemTemplateList'):
                temp_model = ListSystemTemplatesResponseBodySystemTemplateList()
                self.system_template_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListSystemTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSystemTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTemplatesRequest(TeaModel):
    def __init__(
        self,
        create_source: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_type: str = None,
        status: str = None,
        type: str = None,
    ):
        # The source from which the template was created.
        # 
        # Valid values:
        # 
        # *   AliyunConsole
        # *   WebSDK
        # *   OpenAPI
        self.create_source = create_source
        # The search keyword. You can use the template ID or title as the keyword to search for templates.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The sorting parameter. By default, the query results are sorted by creation time in descending order.
        # 
        # Valid values:
        # 
        # *   CreationTime:Asc: sorted by creation time in ascending order.
        # *   CreationTime:Desc: sorted by creation time in descending order.
        self.sort_type = sort_type
        # The template state.
        # 
        # Valid values:
        # 
        # *   UploadFailed: Failed to upload the video.
        # *   ProcessFailed: Failed to process the advanced template.
        # *   Available: The template is available.
        # *   Uploading: The video is being uploaded.
        # *   Created: The template is created but not ready for use.
        # *   Processing: The advanced template is being processed.
        self.status = status
        # The template type.
        # 
        # Valid values:
        # 
        # *   Timeline
        # *   VETemplate
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        clips_param: str = None,
        config: str = None,
        cover_url: str = None,
        create_source: str = None,
        creation_time: str = None,
        modified_source: str = None,
        modified_time: str = None,
        name: str = None,
        preview_media: str = None,
        preview_media_status: str = None,
        status: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The clip parameters.
        self.clips_param = clips_param
        # The template configurations.
        self.config = config
        # The thumbnail URL.
        self.cover_url = cover_url
        # The source from which the template was created.
        # 
        # Valid values:
        # 
        # *   AliyunConsole
        # *   WebSDK
        # *   OpenAPI
        self.create_source = create_source
        # The time when the template was created.
        self.creation_time = creation_time
        # The source from which the template was modified.
        # 
        # Valid values:
        # 
        # *   AliyunConsole
        # *   WebSDK
        # *   OpenAPI
        self.modified_source = modified_source
        # The time when the template was last modified.
        self.modified_time = modified_time
        # The template name.
        self.name = name
        # The preview media asset.
        self.preview_media = preview_media
        # The state of the preview media asset.
        # 
        # Valid values:
        # 
        # *   PrepareFail
        # *   Init
        # *   Normal
        # *   Preparing
        self.preview_media_status = preview_media_status
        # The template state.
        # 
        # Valid values:
        # 
        # *   UploadFailed: Failed to upload the video.
        # *   ProcessFailed: Failed to process the advanced template.
        # *   Available: The template is available.
        # *   Uploading: The video is being uploaded.
        # *   Created: The template is created but not ready for use.
        # *   Processing: The advanced template is being processed.
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The template type.
        # 
        # Valid values:
        # 
        # *   Timeline: regular template.
        # *   VETemplate: advanced template.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.preview_media_status is not None:
            result['PreviewMediaStatus'] = self.preview_media_status
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('PreviewMediaStatus') is not None:
            self.preview_media_status = m.get('PreviewMediaStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: List[ListTemplatesResponseBodyTemplates] = None,
        total_count: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The queried templates.
        self.templates = templates
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = ListTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTranscodeJobsRequest(TeaModel):
    def __init__(
        self,
        end_of_create_time: str = None,
        next_page_token: str = None,
        order_by: str = None,
        page_size: int = None,
        parent_job_id: str = None,
        start_of_create_time: str = None,
        status: str = None,
    ):
        # The end of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_of_create_time = end_of_create_time
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_page_token = next_page_token
        # The order that you use to sort the query results. Valid values:
        # 
        # *   CreateTimeDesc: sorts the query results by creation time in descending order.
        # *   CreateTimeAsc: sorts the query results by creation time in ascending order.
        self.order_by = order_by
        # The number of entries per page. Valid values: 0 to 100. Default value: 20.
        self.page_size = page_size
        # The job ID.
        self.parent_job_id = parent_job_id
        # The beginning of the time range during which the jobs to be queried were created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_of_create_time = start_of_create_time
        # The state of the job.
        # 
        # *   Init: The job is submitted.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTranscodeJobsResponseBodyJobsInputGroup(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media asset. This parameter is specified only when the media asset is transcoded.
        self.input_url = input_url
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported. If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The URL of the transcoded output stream. This parameter is required only when the output is a media asset.
        self.output_url = output_url
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
    ):
        # The ciphertext of HTTP Live Streaming (HLS) encryption.
        self.cipher_text = cipher_text
        # The endpoint of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # The encryption type.
        self.encrypt_type = encrypt_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported. If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the stream. Valid values: the number of seconds or "ToEND".
        self.duration = duration
        # The beginning of the time range for which data was queried.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The position of the watermark on the x-axis.
        self.dx = dx
        # The position of the watermark on the y-axis.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the output video.
        self.height = height
        # The reference position of the watermark. Valid values: TopLeft, TopRight, BottomLeft, and BottomRight. Default value: TopLeft.
        self.refer_pos = refer_pos
        # The timeline settings.
        self.timeline = timeline
        # The width of the output video.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, the ID of a media asset is returned.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Indicates whether the text size was adjusted based on the output video dimensions. true / false, default: false
        self.adaptive = adaptive
        # The border color.
        self.border_color = border_color
        # The border width.
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the watermark.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text.
        self.font_name = font_name
        # The size of the text.
        self.font_size = font_size
        # The distance of the watermark from the left edge.
        self.left = left
        # The distance of the watermark from the top edge.
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: [8,1000].
        # *   Unit: Kbit/s.
        # *   Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Indicates whether the audio stream is deleted.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Default value: 44100.
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum adaptive bitrate (ABR). This parameter takes effect only for Narrowband HD 1.0. Valid values: [10,50000]. Unit: Kbit/s.
        self.abr_max = abr_max
        # The average bitrate of the video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size.
        # 
        # *   Valid values: [1000,128000].
        # *   Default value: 6000.
        # *   Unit: KB.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Valid values: [0,51].
        # *   Default value: 23 if the encoding format is H.264, or 26 if the encoding format is H.265.
        # 
        # If this parameter is set, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   border: automatically detects and removes black bars.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The frame rate.
        # 
        # *   Valid values: (0,60].
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes.
        # 
        # *   Valid values: [1,1080000].
        # *   Default value: 250.
        self.gop = gop
        # The height of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the height of the input video.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the output video. Valid values: [10,50000]. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Indicates whether the video was removed.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio = None,
        container: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        tags: Dict[str, str] = None,
        video: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        self.tags = tags
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Video') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs] = None,
        encryption: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption = None,
        image_watermarks: List[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks] = None,
        is_inherit_tags: bool = None,
        subtitles: List[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles] = None,
        text_watermarks: List[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks] = None,
        transcode: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration for an image.
        self.image_watermarks = image_watermarks
        # Indicates whether the tags of the input stream are inherited in the output stream. This parameter does not take effect when the input is not a media asset. Default value: false.
        self.is_inherit_tags = is_inherit_tags
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermarks.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        if self.is_inherit_tags is not None:
            result['IsInheritTags'] = self.is_inherit_tags
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        if m.get('IsInheritTags') is not None:
            self.is_inherit_tags = m.get('IsInheritTags')
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroup(TeaModel):
    def __init__(
        self,
        output: ListTranscodeJobsResponseBodyJobsOutputGroupOutput = None,
        process_config: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig = None,
    ):
        # The output file configuration.
        self.output = output
        # The job processing configuration.
        self.process_config = process_config

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class ListTranscodeJobsResponseBodyJobsScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class ListTranscodeJobsResponseBodyJobs(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input_group: List[ListTranscodeJobsResponseBodyJobsInputGroup] = None,
        job_count: int = None,
        name: str = None,
        output_group: List[ListTranscodeJobsResponseBodyJobsOutputGroup] = None,
        parent_job_id: str = None,
        percent: int = None,
        request_id: str = None,
        schedule_config: ListTranscodeJobsResponseBodyJobsScheduleConfig = None,
        status: str = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        self.input_group = input_group
        # The number of subjobs.
        self.job_count = job_count
        # The job name.
        self.name = name
        # The output group of the job.
        self.output_group = output_group
        # The main job ID.
        self.parent_job_id = parent_job_id
        # The completion percentage of the job.
        self.percent = percent
        # The ID of the request that submitted the job.
        self.request_id = request_id
        # The scheduling configuration of the job.
        self.schedule_config = schedule_config
        # The state of the job.
        # 
        # *   Success: At least one of the subjobs is successful.
        # *   Fail: All subjobs failed.
        self.status = status
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The source of the job. Valid values:
        # 
        # *   API
        # *   WorkFlow
        # *   Console
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = ListTranscodeJobsResponseBodyJobsInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListTranscodeJobsResponseBody(TeaModel):
    def __init__(
        self,
        jobs: List[ListTranscodeJobsResponseBodyJobs] = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The list of jobs.
        self.jobs = jobs
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The token of the next page is returned after you call this operation for the first time.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListTranscodeJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTranscodeJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTranscodeJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTranscodeJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVodPackagingAssetsRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The name of the packaging group.
        self.group_name = group_name
        # The search keyword. The names of the returned assets are prefixed with this keyword.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sorting order of the assets based on the time when they were ingested. Valid values:
        # 
        # *   desc (default): descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListVodPackagingAssetsResponseBodyAssetsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The URL of the media file. Only M3U8 files stored in OSS are supported.
        self.media = media
        # The input type. Only Object Storage Service (OSS) is supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListVodPackagingAssetsResponseBodyAssets(TeaModel):
    def __init__(
        self,
        asset_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        input: ListVodPackagingAssetsResponseBodyAssetsInput = None,
    ):
        # The name of the VOD packaging asset.
        self.asset_name = asset_name
        # The time when the asset was ingested. It follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The asset description.
        self.description = description
        # The name of the packaging group.
        self.group_name = group_name
        # The asset input configurations.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_name is not None:
            result['AssetName'] = self.asset_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetName') is not None:
            self.asset_name = m.get('AssetName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Input') is not None:
            temp_model = ListVodPackagingAssetsResponseBodyAssetsInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class ListVodPackagingAssetsResponseBody(TeaModel):
    def __init__(
        self,
        assets: List[ListVodPackagingAssetsResponseBodyAssets] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The VOD packaging assets.
        self.assets = assets
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The sorting order of the assets based on the time when they were ingested. Valid values:
        # 
        # *   desc: descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.assets:
            for k in self.assets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Assets'] = []
        if self.assets is not None:
            for k in self.assets:
                result['Assets'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.assets = []
        if m.get('Assets') is not None:
            for k in m.get('Assets'):
                temp_model = ListVodPackagingAssetsResponseBodyAssets()
                self.assets.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVodPackagingAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVodPackagingAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVodPackagingAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVodPackagingConfigurationsRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The name of the packaging group.
        self.group_name = group_name
        # The search keyword. The names of the returned packaging configurations contain the keyword.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sorting order of the packaging configurations based on the time when they were created. Valid values:
        # 
        # *   desc (default): descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListVodPackagingConfigurationsResponseBody(TeaModel):
    def __init__(
        self,
        packaging_configurations: List[VodPackagingConfiguration] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The packaging configurations.
        self.packaging_configurations = packaging_configurations
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The sorting order of the packaging configurations based on the time when they were created. Valid values:
        # 
        # *   desc: descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.packaging_configurations:
            for k in self.packaging_configurations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PackagingConfigurations'] = []
        if self.packaging_configurations is not None:
            for k in self.packaging_configurations:
                result['PackagingConfigurations'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.packaging_configurations = []
        if m.get('PackagingConfigurations') is not None:
            for k in m.get('PackagingConfigurations'):
                temp_model = VodPackagingConfiguration()
                self.packaging_configurations.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVodPackagingConfigurationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVodPackagingConfigurationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVodPackagingConfigurationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVodPackagingGroupsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        # The search keyword. The names of the returned packaging groups contain the keyword.
        self.keyword = keyword
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The sorting order of the packaging groups based on the time when they were created. Valid values:
        # 
        # *   desc (default): descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListVodPackagingGroupsResponseBody(TeaModel):
    def __init__(
        self,
        packaging_groups: List[VodPackagingGroup] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        sort_by: str = None,
        total_count: int = None,
    ):
        # The packaging groups.
        self.packaging_groups = packaging_groups
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The sorting order of the packaging groups based on the time when they were created. Valid values:
        # 
        # *   desc: descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.packaging_groups:
            for k in self.packaging_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PackagingGroups'] = []
        if self.packaging_groups is not None:
            for k in self.packaging_groups:
                result['PackagingGroups'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.packaging_groups = []
        if m.get('PackagingGroups') is not None:
            for k in m.get('PackagingGroups'):
                temp_model = VodPackagingGroup()
                self.packaging_groups.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVodPackagingGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVodPackagingGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVodPackagingGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCopyrightExtractJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryCopyrightExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
    ):
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class QueryCopyrightExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: QueryCopyrightExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = QueryCopyrightExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryCopyrightExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCopyrightExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCopyrightExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCopyrightJobListRequest(TeaModel):
    def __init__(
        self,
        create_time_end: int = None,
        create_time_start: int = None,
        job_id: str = None,
        level: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.job_id = job_id
        self.level = level
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryCopyrightJobListResponseBodyDataInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryCopyrightJobListResponseBodyDataOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryCopyrightJobListResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        input: QueryCopyrightJobListResponseBodyDataInput = None,
        job_id: str = None,
        level: int = None,
        message: str = None,
        output: QueryCopyrightJobListResponseBodyDataOutput = None,
        result: str = None,
        status: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.input = input
        self.job_id = job_id
        self.level = level
        self.message = message
        self.output = output
        self.result = result
        self.status = status
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Input') is not None:
            temp_model = QueryCopyrightJobListResponseBodyDataInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = QueryCopyrightJobListResponseBodyDataOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryCopyrightJobListResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryCopyrightJobListResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryCopyrightJobListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryCopyrightJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCopyrightJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCopyrightJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDNAJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the media fingerprint analysis jobs that you want to query. We recommend that you query at most 10 jobs at a time. Separate multiple job IDs with commas (,).
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryDNAJobListResponseBodyJobListInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. The file can be an OSS object or a media asset. The path of an OSS object can be in one of the following formats:
        # 
        # 1\\. oss://bucket/object
        # 
        # 2\\. http(s)://bucket.oss-[regionId].aliyuncs.com/object
        # 
        # In the preceding paths, bucket indicates an OSS bucket that resides in the same region as the current project, and object indicates the path of the object in the bucket.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: Object Storage Service (OSS) object.
        # 2.  Media: media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryDNAJobListResponseBodyJobList(TeaModel):
    def __init__(
        self,
        code: str = None,
        config: str = None,
        creation_time: str = None,
        dbid: str = None,
        dnaresult: str = None,
        finish_time: str = None,
        id: str = None,
        input: QueryDNAJobListResponseBodyJobListInput = None,
        message: str = None,
        primary_key: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The response code.
        self.code = code
        # The configurations of the media fingerprint analysis job.
        self.config = config
        # The time when the job was created.
        self.creation_time = creation_time
        # The ID of the media fingerprint library.
        self.dbid = dbid
        # The URL of the media fingerprint analysis result.
        self.dnaresult = dnaresult
        # The time when the job was complete.
        self.finish_time = finish_time
        # The job ID.
        self.id = id
        # The details of the input file.
        self.input = input
        # The returned message.
        self.message = message
        # The primary key of the video. You must make sure that each primary key is unique.
        self.primary_key = primary_key
        # The job state. Valid values:
        # 
        # *   **Queuing**: The job is waiting in the queue.
        # *   **Analysing**: The job is in progress.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job failed.
        self.status = status
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.config is not None:
            result['Config'] = self.config
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.dnaresult is not None:
            result['DNAResult'] = self.dnaresult
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('DNAResult') is not None:
            self.dnaresult = m.get('DNAResult')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            temp_model = QueryDNAJobListResponseBodyJobListInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryDNAJobListResponseBody(TeaModel):
    def __init__(
        self,
        job_list: List[QueryDNAJobListResponseBodyJobList] = None,
        request_id: str = None,
    ):
        # The queried media fingerprint analysis jobs.
        self.job_list = job_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            for k in self.job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobList'] = []
        if self.job_list is not None:
            for k in self.job_list:
                result['JobList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_list = []
        if m.get('JobList') is not None:
            for k in m.get('JobList'):
                temp_model = QueryDNAJobListResponseBodyJobList()
                self.job_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryDNAJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDNAJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDNAJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryIProductionJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        job_id: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The ID of the intelligent production job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryIProductionJobResponseBodyInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, set this parameter to the path of an OSS object. If Type is set to Media, set this parameter to the ID of a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object bucket in the path specifies an OSS bucket that resides in the same region as the intelligent production job. object in the path specifies the object path in OSS.
        self.media = media
        # The media type. Valid values:
        # 
        # 1.  OSS: Object Storage Service (OSS) object
        # 2.  Media: media asset
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryIProductionJobResponseBodyOutput(TeaModel):
    def __init__(
        self,
        biz: str = None,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        self.biz = biz
        # The output file. If Type is set to OSS, set this parameter to the path of an OSS object. If Type is set to Media, set this parameter to the ID of a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object bucket in the path specifies an OSS bucket that resides in the same region as the intelligent production job. object in the path specifies the object path in OSS.
        self.media = media
        self.output_url = output_url
        # The media type. Valid values:
        # 
        # *   OSS: OSS object
        # *   Media: media asset
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryIProductionJobResponseBodyScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue.
        self.pipeline_id = pipeline_id
        # The priority of the job in the MPS queue to which the job is added.
        # 
        # *   A value of 10 indicates the highest priority.
        # *   Default value: **6**.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class QueryIProductionJobResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        function_name: str = None,
        input: QueryIProductionJobResponseBodyInput = None,
        job_id: str = None,
        job_params: str = None,
        name: str = None,
        output: QueryIProductionJobResponseBodyOutput = None,
        output_files: List[str] = None,
        output_media_ids: List[str] = None,
        output_urls: List[str] = None,
        request_id: str = None,
        result: str = None,
        schedule_config: QueryIProductionJobResponseBodyScheduleConfig = None,
        status: str = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The name of the algorithm that you want to use for the job. Valid values:
        # 
        # *   **Cover**: This algorithm intelligently generates a thumbnail image for a video.
        # *   **VideoClip**: This algorithm intelligently generates a summary for a video.
        # *   **VideoDelogo**: This algorithm removes logos from a video.
        # *   **VideoDetext**: This algorithm removes captions from a video.
        self.function_name = function_name
        # The input file.
        self.input = input
        # The ID of the intelligent production job.
        self.job_id = job_id
        # The algorithm-specific parameters. The parameters are specified as JSON objects and vary based on the algorithm.
        self.job_params = job_params
        # The name of the intelligent production job.
        self.name = name
        # The output file.
        self.output = output
        # The output files.
        self.output_files = output_files
        self.output_media_ids = output_media_ids
        # The URLs of the output files.
        self.output_urls = output_urls
        # The ID of the request.
        self.request_id = request_id
        # The output of the algorithm. The output is in JSON format and varies based on the algorithm. For more information, see the "Parameters of Result" section of this topic.
        self.result = result
        # The scheduling configuration.
        self.schedule_config = schedule_config
        # The status of the job. Valid values:
        # 
        # *   Queuing: The job is waiting in the queue.
        # *   Analysing: The job is in progress.
        # *   Fail: The job failed.
        # *   Success: The job was successful.
        self.status = status
        # The template ID.
        self.template_id = template_id
        # The user-defined data that is returned in the response.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.output_files is not None:
            result['OutputFiles'] = self.output_files
        if self.output_media_ids is not None:
            result['OutputMediaIds'] = self.output_media_ids
        if self.output_urls is not None:
            result['OutputUrls'] = self.output_urls
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            temp_model = QueryIProductionJobResponseBodyInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = QueryIProductionJobResponseBodyOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('OutputFiles') is not None:
            self.output_files = m.get('OutputFiles')
        if m.get('OutputMediaIds') is not None:
            self.output_media_ids = m.get('OutputMediaIds')
        if m.get('OutputUrls') is not None:
            self.output_urls = m.get('OutputUrls')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('ScheduleConfig') is not None:
            temp_model = QueryIProductionJobResponseBodyScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryIProductionJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryIProductionJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaCensorJobDetailRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the content moderation job. You can obtain the job ID from the response parameters of the [SubmitMediaCensorJob](https://help.aliyun.com/document_detail/444848.html) operation.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The number of entries per page.
        # 
        # *   Default value: **30**.
        # *   Valid values: **1 to 300**.
        self.maximum_page_size = maximum_page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result.
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live broadcasting in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(TeaModel):
    def __init__(
        self,
        result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults = None,
    ):
        # The OSS bucket in which the thumbnail is stored.
        self.bucket = bucket
        # The OSS region in which the thumbnail resides.
        self.location = location
        # The Object Storage Service (OSS) object that is used as the thumbnail.
        self.object = object
        # The moderation results.
        self.results = results

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Results') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(TeaModel):
    def __init__(
        self,
        cover_image_censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult] = None,
    ):
        self.cover_image_censor_result = cover_image_censor_result

    def validate(self):
        if self.cover_image_censor_result:
            for k in self.cover_image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoverImageCensorResult'] = []
        if self.cover_image_censor_result is not None:
            for k in self.cover_image_censor_result:
                result['CoverImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cover_image_censor_result = []
        if m.get('CoverImageCensorResult') is not None:
            for k in m.get('CoverImageCensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult()
                self.cover_image_censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result.
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live broadcasting in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result.
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live broadcasting in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults = None,
        object: str = None,
        timestamp: str = None,
    ):
        # The moderation results that include information such as labels and scores.
        self.censor_results = censor_results
        # The OSS object that is generated as the output snapshot.
        # 
        # >  In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg`, `output00002-****.jpg`, and so on.
        self.object = object
        # The position in the video. Format: `hh:mm:ss[.SSS]`.
        self.timestamp = timestamp

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.object is not None:
            result['Object'] = self.object
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(TeaModel):
    def __init__(
        self,
        video_timeline: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline] = None,
    ):
        self.video_timeline = video_timeline

    def validate(self):
        if self.video_timeline:
            for k in self.video_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoTimeline'] = []
        if self.video_timeline is not None:
            for k in self.video_timeline:
                result['VideoTimeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_timeline = []
        if m.get('VideoTimeline') is not None:
            for k in m.get('VideoTimeline'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline()
                self.video_timeline.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults = None,
        next_page_token: str = None,
        video_timelines: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines = None,
    ):
        # A collection of moderation results. The information includes the summary about various scenarios such as pornographic content moderation and terrorist content moderation.
        self.censor_results = censor_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The moderation results that are sorted in ascending order by time.
        self.video_timelines = video_timelines

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()
        if self.video_timelines:
            self.video_timelines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.video_timelines is not None:
            result['VideoTimelines'] = self.video_timelines.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('VideoTimelines') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines()
            self.video_timelines = temp_model.from_map(m['VideoTimelines'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket in which the output snapshot is stored.
        self.bucket = bucket
        # The OSS region in which the output snapshot resides.
        self.location = location
        # The OSS object that is generated as the output snapshot.
        # 
        # >  In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg`, `output00002-****.jpg`, and so on.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        output_file: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile = None,
        video_censor: str = None,
    ):
        # The custom business type. Default value: common.
        self.biz_type = biz_type
        # The information about output snapshots.
        self.output_file = output_file
        # Indicates whether the video content needs to be moderated. Default value: **true**. Valid values:
        # 
        # *   **true**: The video content needs to be moderated.
        # *   **false**: The video content does not need to be moderated.
        self.video_censor = video_censor

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.video_censor is not None:
            result['VideoCensor'] = self.video_censor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('OutputFile') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('VideoCensor') is not None:
            self.video_censor = m.get('VideoCensor')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(TeaModel):
    def __init__(
        self,
        barrage_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult = None,
        code: str = None,
        cover_image_censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults = None,
        creation_time: str = None,
        desc_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult = None,
        finish_time: str = None,
        input: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput = None,
        job_id: str = None,
        message: str = None,
        pipeline_id: str = None,
        state: str = None,
        suggestion: str = None,
        title_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult = None,
        user_data: str = None,
        vensor_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult = None,
        video_censor_config: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig = None,
    ):
        # The moderation results of live comments.
        self.barrage_censor_result = barrage_censor_result
        # The error code returned if the job failed. This parameter is not returned if the job is successful.
        self.code = code
        # The moderation results of thumbnails.
        self.cover_image_censor_results = cover_image_censor_results
        # The time when the content moderation job was created.
        self.creation_time = creation_time
        # The moderation results of descriptions.
        self.desc_censor_result = desc_censor_result
        # The time when the content moderation job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The ID of the content moderation job.
        self.job_id = job_id
        # The error message returned if the job failed. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The job state.
        self.state = state
        # The overall result of the content moderation job. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        # 
        # >  If the moderation result of any type of content is review, the overall result is review. If the moderation result of any type of content is block, the overall result is block.
        self.suggestion = suggestion
        # The moderation results of titles.
        self.title_censor_result = title_censor_result
        # The user-defined data.
        self.user_data = user_data
        # The moderation results of videos.
        self.vensor_censor_result = vensor_censor_result
        # The video moderation configurations.
        self.video_censor_config = video_censor_config

    def validate(self):
        if self.barrage_censor_result:
            self.barrage_censor_result.validate()
        if self.cover_image_censor_results:
            self.cover_image_censor_results.validate()
        if self.desc_censor_result:
            self.desc_censor_result.validate()
        if self.input:
            self.input.validate()
        if self.title_censor_result:
            self.title_censor_result.validate()
        if self.vensor_censor_result:
            self.vensor_censor_result.validate()
        if self.video_censor_config:
            self.video_censor_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.cover_image_censor_results is not None:
            result['CoverImageCensorResults'] = self.cover_image_censor_results.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vensor_censor_result is not None:
            result['VensorCensorResult'] = self.vensor_censor_result.to_map()
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BarrageCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult()
            self.barrage_censor_result = temp_model.from_map(m['BarrageCensorResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CoverImageCensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults()
            self.cover_image_censor_results = temp_model.from_map(m['CoverImageCensorResults'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult()
            self.desc_censor_result = temp_model.from_map(m['DescCensorResult'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TitleCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult()
            self.title_censor_result = temp_model.from_map(m['TitleCensorResult'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VensorCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult()
            self.vensor_censor_result = temp_model.from_map(m['VensorCensorResult'])
        if m.get('VideoCensorConfig') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig()
            self.video_censor_config = temp_model.from_map(m['VideoCensorConfig'])
        return self


class QueryMediaCensorJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        media_censor_job_detail: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail = None,
        request_id: str = None,
    ):
        # The results of the content moderation job.
        self.media_censor_job_detail = media_censor_job_detail
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_censor_job_detail:
            self.media_censor_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_censor_job_detail is not None:
            result['MediaCensorJobDetail'] = self.media_censor_job_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaCensorJobDetail') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail()
            self.media_censor_job_detail = temp_model.from_map(m['MediaCensorJobDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaCensorJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaCensorJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaCensorJobListRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        job_ids: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        # The end of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard. The time must be in UTC.
        # *   Format: yyyy-MM-ddTHH:mm:ssZ.
        self.end_of_job_created_time_range = end_of_job_created_time_range
        # The IDs of the content moderation jobs. You can obtain the ID of a content moderation job from the response parameters of the SubmitMediaCensorJob operation. Separate multiple IDs with commas (,).
        self.job_ids = job_ids
        # The number of entries per page.
        # 
        # *   Default value: **30**.
        # *   Valid values: **1 to 300**.
        self.maximum_page_size = maximum_page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the jobs were submitted.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard. The time must be in UTC.
        # *   Format: yyyy-MM-ddTHH:mm:ssZ.
        self.start_of_job_created_time_range = start_of_job_created_time_range
        # The state of the jobs that you want to query. Valid values:
        # 
        # *   **All**: all jobs.
        # *   **Queuing**: the jobs that are waiting in the queue.
        # *   **Analysing**: the jobs that are in progress.
        # *   **Fail**: failed jobs.
        # *   **Success**: successful jobs.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live streaming in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The overall result of the moderation job. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        # 
        # >  If the moderation result of any type of content is review, the overall result is review. If the moderation result of any type of content is block, the overall result is block.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults(TeaModel):
    def __init__(
        self,
        result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults = None,
    ):
        # The OSS bucket in which the thumbnail is stored.
        self.bucket = bucket
        # The OSS region in which the thumbnail resides.
        self.location = location
        # The Object Storage Service (OSS) object that is used as the thumbnail.
        self.object = object
        # The moderation results.
        self.results = results

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Results') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults(TeaModel):
    def __init__(
        self,
        cover_image_censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult] = None,
    ):
        self.cover_image_censor_result = cover_image_censor_result

    def validate(self):
        if self.cover_image_censor_result:
            for k in self.cover_image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoverImageCensorResult'] = []
        if self.cover_image_censor_result is not None:
            for k in self.cover_image_censor_result:
                result['CoverImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cover_image_censor_result = []
        if m.get('CoverImageCensorResult') is not None:
            for k in m.get('CoverImageCensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult()
                self.cover_image_censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   **normal**: normal content.
        # *   **spam**: spam.
        # *   **ad**: ads.
        # *   **abuse**: abuse content.
        # *   **flood**: excessive junk content.
        # *   **contraband**: prohibited content.
        # *   **meaningless**: meaningless content.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live streaming in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The label of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **sexy**: sexy content.
        #     *   **porn**: pornographic content.
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **bloody**: bloody content.
        #     *   **explosion**: explosion and smoke.
        #     *   **outfit**: special costume.
        #     *   **logo**: special logo.
        #     *   **weapon**: weapon.
        #     *   **politics**: political content.
        #     *   **violence**: violence.
        #     *   **crowd**: crowd.
        #     *   **parade**: parade.
        #     *   **carcrash**: car accident.
        #     *   **flag**: flag.
        #     *   **location**: landmark.
        #     *   **others**: other content.
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **ad**: other ads.
        #     *   **politics**: political content in text.
        #     *   **porn**: pornographic content in text.
        #     *   **abuse**: abuse in text.
        #     *   **terrorism**: terrorist content in text.
        #     *   **contraband**: prohibited content in text.
        #     *   **spam**: spam in text.
        #     *   **npx**: illegal ad.
        #     *   **qrcode**: QR code.
        #     *   **programCode**: mini program code.
        # 
        # *   Valid values in the undesirable scene moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **meaningless**: meaningless content, such as a black or white screen.
        #     *   **PIP**: picture-in-picture.
        #     *   **smoking**: smoking.
        #     *   **drivelive**: live streaming in a running vehicle.
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content.
        #     *   **TV**: controlled logo.
        #     *   **trademark**: trademark.
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation.
        # *   **terrorism**: terrorist content moderation.
        # *   **ad**: ad moderation.
        # *   **live**: undesirable scene moderation.
        # *   **logo**: logo moderation.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults = None,
        object: str = None,
        timestamp: str = None,
    ):
        # The moderation results that include information such as labels and scores.
        self.censor_results = censor_results
        # The OSS object that is generated as the output snapshot.
        # 
        # >  In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg`, `output00002-****.jpg`, and so on.
        self.object = object
        # The position in the video. Format: `hh:mm:ss[.SSS]`.
        self.timestamp = timestamp

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.object is not None:
            result['Object'] = self.object
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines(TeaModel):
    def __init__(
        self,
        video_timeline: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline] = None,
    ):
        self.video_timeline = video_timeline

    def validate(self):
        if self.video_timeline:
            for k in self.video_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoTimeline'] = []
        if self.video_timeline is not None:
            for k in self.video_timeline:
                result['VideoTimeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_timeline = []
        if m.get('VideoTimeline') is not None:
            for k in m.get('VideoTimeline'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline()
                self.video_timeline.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults = None,
        next_page_token: str = None,
        video_timelines: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines = None,
    ):
        # A collection of moderation results. The information includes the summary about various scenarios such as pornographic content moderation and terrorist content moderation.
        self.censor_results = censor_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The moderation results that are sorted in ascending order by time.
        self.video_timelines = video_timelines

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()
        if self.video_timelines:
            self.video_timelines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.video_timelines is not None:
            result['VideoTimelines'] = self.video_timelines.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('VideoTimelines') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines()
            self.video_timelines = temp_model.from_map(m['VideoTimelines'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket in which the output snapshot is stored.
        self.bucket = bucket
        # The ID of the region in which the output snapshot resides.
        self.location = location
        # The OSS object that is generated as the output snapshot.
        # 
        # >  In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg, output00002-****.jpg`, and so on.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        output_file: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile = None,
        video_censor: str = None,
    ):
        # The moderation template. Default value: common. The default value indicates that the default template is used.
        # 
        # >  If the moderation template is not specified, the default value common is returned. If a custom moderation template that is created by submitting a ticket is specified, the UID of the template is returned.
        self.biz_type = biz_type
        # The information about output snapshots.
        self.output_file = output_file
        # Indicates whether the video content needs to be moderated. Default value: **true**. Valid values:
        # 
        # *   **true**: The video content needs to be moderated.
        # *   **false**: The video content does not need to be moderated.
        self.video_censor = video_censor

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.video_censor is not None:
            result['VideoCensor'] = self.video_censor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('OutputFile') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('VideoCensor') is not None:
            self.video_censor = m.get('VideoCensor')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob(TeaModel):
    def __init__(
        self,
        barrage_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult = None,
        code: str = None,
        cover_image_censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults = None,
        creation_time: str = None,
        desc_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult = None,
        finish_time: str = None,
        input: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput = None,
        job_id: str = None,
        message: str = None,
        pipeline_id: str = None,
        state: str = None,
        suggestion: str = None,
        title_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult = None,
        user_data: str = None,
        vensor_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult = None,
        video_censor_config: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig = None,
    ):
        # The moderation results of live comments.
        self.barrage_censor_result = barrage_censor_result
        # The error code returned if the job failed. This parameter is not returned if the job is successful.
        self.code = code
        # The moderation results of thumbnails.
        self.cover_image_censor_results = cover_image_censor_results
        # The time when the content moderation job was created.
        self.creation_time = creation_time
        # The moderation results of descriptions.
        self.desc_censor_result = desc_censor_result
        # The time when the content moderation job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The ID of the content moderation job.
        self.job_id = job_id
        # The error message returned if the job failed. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The job state.
        self.state = state
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion
        # The moderation results of titles.
        self.title_censor_result = title_censor_result
        # The user-defined data.
        self.user_data = user_data
        # The moderation results of videos.
        self.vensor_censor_result = vensor_censor_result
        # The video moderation configurations.
        self.video_censor_config = video_censor_config

    def validate(self):
        if self.barrage_censor_result:
            self.barrage_censor_result.validate()
        if self.cover_image_censor_results:
            self.cover_image_censor_results.validate()
        if self.desc_censor_result:
            self.desc_censor_result.validate()
        if self.input:
            self.input.validate()
        if self.title_censor_result:
            self.title_censor_result.validate()
        if self.vensor_censor_result:
            self.vensor_censor_result.validate()
        if self.video_censor_config:
            self.video_censor_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.cover_image_censor_results is not None:
            result['CoverImageCensorResults'] = self.cover_image_censor_results.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vensor_censor_result is not None:
            result['VensorCensorResult'] = self.vensor_censor_result.to_map()
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BarrageCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult()
            self.barrage_censor_result = temp_model.from_map(m['BarrageCensorResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CoverImageCensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults()
            self.cover_image_censor_results = temp_model.from_map(m['CoverImageCensorResults'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult()
            self.desc_censor_result = temp_model.from_map(m['DescCensorResult'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TitleCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult()
            self.title_censor_result = temp_model.from_map(m['TitleCensorResult'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VensorCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult()
            self.vensor_censor_result = temp_model.from_map(m['VensorCensorResult'])
        if m.get('VideoCensorConfig') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig()
            self.video_censor_config = temp_model.from_map(m['VideoCensorConfig'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobList(TeaModel):
    def __init__(
        self,
        media_censor_job: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob] = None,
    ):
        self.media_censor_job = media_censor_job

    def validate(self):
        if self.media_censor_job:
            for k in self.media_censor_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaCensorJob'] = []
        if self.media_censor_job is not None:
            for k in self.media_censor_job:
                result['MediaCensorJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_censor_job = []
        if m.get('MediaCensorJob') is not None:
            for k in m.get('MediaCensorJob'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob()
                self.media_censor_job.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryMediaCensorJobListResponseBody(TeaModel):
    def __init__(
        self,
        media_censor_job_list: QueryMediaCensorJobListResponseBodyMediaCensorJobList = None,
        next_page_token: str = None,
        non_exist_ids: QueryMediaCensorJobListResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The queried content moderation jobs.
        self.media_censor_job_list = media_censor_job_list
        # A pagination token. It can be used in the next request to retrieve a new page of results. The value is 32-character UUID. If the returned query results cannot be displayed within one page, this parameter is returned. The value of this parameter is updated for each query.
        self.next_page_token = next_page_token
        # The IDs of the jobs that do not exist. This parameter is not returned if all the specified jobs are found.
        self.non_exist_ids = non_exist_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_censor_job_list:
            self.media_censor_job_list.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_censor_job_list is not None:
            result['MediaCensorJobList'] = self.media_censor_job_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaCensorJobList') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobList()
            self.media_censor_job_list = temp_model.from_map(m['MediaCensorJobList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NonExistIds') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaCensorJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaCensorJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaCensorJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaIndexJobRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        search_lib_name: str = None,
    ):
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The name of the search library. Default value: ims-default-search-lib.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class QueryMediaIndexJobResponseBodyIndexJobInfoList(TeaModel):
    def __init__(
        self,
        gmt_finish: str = None,
        gmt_submit: str = None,
        index_type: str = None,
        status: str = None,
    ):
        # The end time of the indexing job.
        self.gmt_finish = gmt_finish
        # The time when the index job was submitted.
        self.gmt_submit = gmt_submit
        # The index type. Valid values:
        # 
        # *   mm: large visual model.
        # *   face: face recognition.
        # *   aiLabel: smart tagging.
        self.index_type = index_type
        # The job status. Valid values:
        # 
        # *   Running
        # *   Success
        # *   Fail
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_finish is not None:
            result['GmtFinish'] = self.gmt_finish
        if self.gmt_submit is not None:
            result['GmtSubmit'] = self.gmt_submit
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtFinish') is not None:
            self.gmt_finish = m.get('GmtFinish')
        if m.get('GmtSubmit') is not None:
            self.gmt_submit = m.get('GmtSubmit')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryMediaIndexJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        index_job_info_list: List[QueryMediaIndexJobResponseBodyIndexJobInfoList] = None,
        request_id: str = None,
        success: str = None,
    ):
        # The response code.
        self.code = code
        # The indexing jobs enabled for the media asset.
        self.index_job_info_list = index_job_info_list
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.index_job_info_list:
            for k in self.index_job_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['IndexJobInfoList'] = []
        if self.index_job_info_list is not None:
            for k in self.index_job_info_list:
                result['IndexJobInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.index_job_info_list = []
        if m.get('IndexJobInfoList') is not None:
            for k in m.get('IndexJobInfoList'):
                temp_model = QueryMediaIndexJobResponseBodyIndexJobInfoList()
                self.index_job_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryMediaIndexJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaIndexJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaIndexJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySearchIndexRequest(TeaModel):
    def __init__(
        self,
        index_type: str = None,
        search_lib_name: str = None,
    ):
        # The category of the index. Valid values:
        # 
        # *   mm: large visual model.
        # *   face: face recognition.
        # *   aiLabel: smart tagging.
        # 
        # This parameter is required.
        self.index_type = index_type
        # The name of the search library.
        # 
        # *   If you leave this parameter empty, the search index is created in the default search library of Intelligent Media Service (IMS). Default value: ims-default-search-lib.
        # *   To query information about an existing search library, call the [QuerySearchLib](https://help.aliyun.com/document_detail/2584455.html) API operation.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class QuerySearchIndexResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        index_status: str = None,
        index_type: str = None,
        media_total: str = None,
        request_id: str = None,
        search_lib_name: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The state of the index. Valid values:
        # 
        # *   active: the index is enabled.
        # *   Deactive: the index is not enabled.
        self.index_status = index_status
        # The category of the index. Valid values:
        # 
        # *   mm: large visual model.
        # *   face: face recognition.
        # *   aiLabel: smart tagging.
        self.index_type = index_type
        # The total number of media assets.
        self.media_total = media_total
        # The ID of the request.
        self.request_id = request_id
        # The name of the search library.
        self.search_lib_name = search_lib_name
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.media_total is not None:
            result['MediaTotal'] = self.media_total
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('MediaTotal') is not None:
            self.media_total = m.get('MediaTotal')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySearchIndexResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySearchIndexResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySearchIndexResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySearchLibRequest(TeaModel):
    def __init__(
        self,
        search_lib_name: str = None,
    ):
        # The name of the search library.
        # 
        # This parameter is required.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class QuerySearchLibResponseBodyIndexInfo(TeaModel):
    def __init__(
        self,
        index_readiness: str = None,
        index_status: str = None,
        index_type: str = None,
    ):
        self.index_readiness = index_readiness
        self.index_status = index_status
        self.index_type = index_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_readiness is not None:
            result['IndexReadiness'] = self.index_readiness
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexReadiness') is not None:
            self.index_readiness = m.get('IndexReadiness')
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        return self


class QuerySearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        index_info: List[QuerySearchLibResponseBodyIndexInfo] = None,
        request_id: str = None,
        search_lib_name: str = None,
        status: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        self.index_info = index_info
        # The ID of the request.
        self.request_id = request_id
        # The name of the search library.
        self.search_lib_name = search_lib_name
        # The status of the search library.
        # 
        # Valid values:
        # 
        # *   normal
        # *   deleting
        # *   deleteFail
        self.status = status
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.index_info:
            for k in self.index_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['IndexInfo'] = []
        if self.index_info is not None:
            for k in self.index_info:
                result['IndexInfo'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.status is not None:
            result['Status'] = self.status
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.index_info = []
        if m.get('IndexInfo') is not None:
            for k in m.get('IndexInfo'):
                temp_model = QuerySearchLibResponseBodyIndexInfo()
                self.index_info.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySmarttagJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        params: str = None,
    ):
        # The ID of the smart tagging job that you want to query. You can obtain the job ID from the response parameters of the SubmitSmarttagJob operation.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The extra parameters that you want to query in the request. The value is a JSON string. Example: {"labelResultType":"auto"}. The value of labelResultType is of the STRING type. Valid values:
        # 
        # *   auto: machine tagging
        # *   hmi: tagging by human and machine
        self.params = params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.params is not None:
            result['Params'] = self.params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        return self


class QuerySmarttagJobResponseBodyResultsResult(TeaModel):
    def __init__(
        self,
        data: str = None,
        type: str = None,
    ):
        # The details of the analysis result. The value is a JSON string. For more information about the parameters of different result types, see the "Parameters of different result types" section of this topic.
        self.data = data
        # The type of the analysis result.
        # 
        # *   The type of the analysis result based on Smart tagging V1.0. Valid values:
        # 
        # 1.  TextLabel: the text tag.
        # 2.  VideoLabel: the video tag.
        # 3.  ASR: the original result of automatic speech recognition (ASR). By default, this type of result is not returned.
        # 4.  OCR: the original result of optical character recognition (OCR). By default, this type of result is not returned.
        # 5.  NLP: the natural language processing (NLP)-based result. By default, this type of result is not returned.
        # 
        # *   The type of the analysis result based on Smart tagging V2.0. Valid values:
        # 
        # 1.  CPVLabel
        # 2.  Meta: the information about the video file, such as the title of the video. By default, this type of information is not returned.
        # 
        # *   The type of the analysis result based on Smart tagging V2.0-custom. Valid values:
        # 
        # 1.  CPVLabel
        # 2.  Meta: the information about the video file, such as the title of the video. By default, this type of information is not returned.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QuerySmarttagJobResponseBodyResults(TeaModel):
    def __init__(
        self,
        result: List[QuerySmarttagJobResponseBodyResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QuerySmarttagJobResponseBodyResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QuerySmarttagJobResponseBody(TeaModel):
    def __init__(
        self,
        job_status: str = None,
        request_id: str = None,
        results: QuerySmarttagJobResponseBodyResults = None,
        user_data: str = None,
    ):
        # The status of the job. Valid values:
        # 
        # *   **Success**: The job was successful.
        # *   **Fail**: The job failed.
        # *   **Processing**: The job is in progress.
        # *   **Submitted**: The job is submitted and waiting to be processed.
        self.job_status = job_status
        # The request ID.
        self.request_id = request_id
        # The analysis results of the smart tagging job. The value is an array.
        self.results = results
        # The content of callback messages that are sent to Simple Message Queue (SMQ) when the information of the smart tagging job changes. For more information about the parameters contained in the callback message, see the "Callback parameters" section of this topic.
        self.user_data = user_data

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.results is not None:
            result['Results'] = self.results.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Results') is not None:
            temp_model = QuerySmarttagJobResponseBodyResults()
            self.results = temp_model.from_map(m['Results'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QuerySmarttagJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySmarttagJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySmarttagJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceAbJobListRequest(TeaModel):
    def __init__(
        self,
        create_time_end: int = None,
        create_time_start: int = None,
        job_id: str = None,
        page_number: int = None,
        page_size: int = None,
        trace_media_id: str = None,
    ):
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.job_id = job_id
        self.page_number = page_number
        self.page_size = page_size
        self.trace_media_id = trace_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        return self


class QueryTraceAbJobListResponseBodyDataInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryTraceAbJobListResponseBodyDataOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryTraceAbJobListResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        input: QueryTraceAbJobListResponseBodyDataInput = None,
        job_id: str = None,
        level: int = None,
        output: QueryTraceAbJobListResponseBodyDataOutput = None,
        result: str = None,
        status: str = None,
        trace_media_id: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.input = input
        self.job_id = job_id
        self.level = level
        self.output = output
        self.result = result
        self.status = status
        self.trace_media_id = trace_media_id
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Input') is not None:
            temp_model = QueryTraceAbJobListResponseBodyDataInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Output') is not None:
            temp_model = QueryTraceAbJobListResponseBodyDataOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryTraceAbJobListResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryTraceAbJobListResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryTraceAbJobListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceAbJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceAbJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceAbJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceExtractJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryTraceExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        trace: str = None,
    ):
        self.trace = trace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trace is not None:
            result['Trace'] = self.trace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        return self


class QueryTraceExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: QueryTraceExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = QueryTraceExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceM3u8JobListRequest(TeaModel):
    def __init__(
        self,
        create_time_end: int = None,
        create_time_start: int = None,
        job_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.job_id = job_id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryTraceM3u8JobListResponseBodyDataOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryTraceM3u8JobListResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        job_id: str = None,
        output: QueryTraceM3u8JobListResponseBodyDataOutput = None,
        status: str = None,
        trace: str = None,
        trace_media_id: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.job_id = job_id
        self.output = output
        self.status = status
        self.trace = trace
        self.trace_media_id = trace_media_id
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.trace is not None:
            result['Trace'] = self.trace
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Output') is not None:
            temp_model = QueryTraceM3u8JobListResponseBodyDataOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryTraceM3u8JobListResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryTraceM3u8JobListResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryTraceM3u8JobListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceM3u8JobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceM3u8JobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceM3u8JobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshUploadMediaRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RefreshUploadMediaResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
        upload_address: str = None,
        upload_auth: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id
        # The upload URL.
        # 
        # >  The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAddress only if you use Object Storage Service (OSS) SDK or call an OSS API operation to upload media files.
        self.upload_address = upload_address
        # The upload credential.
        # 
        # >  The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded upload credential before you use an SDK or call an API operation to upload media files. You need to parse UploadAuth only if you use OSS SDK or call an OSS API operation to upload media files.
        self.upload_auth = upload_auth

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class RefreshUploadMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefreshUploadMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshUploadMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterMediaInfoRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        cate_id: int = None,
        client_token: str = None,
        cover_url: str = None,
        description: str = None,
        input_url: str = None,
        media_tags: str = None,
        media_type: str = None,
        overwrite: bool = None,
        reference_id: str = None,
        register_config: str = None,
        smart_tag_template_id: str = None,
        title: str = None,
        user_data: str = None,
        workflow_id: str = None,
    ):
        # The business type of the media asset. Valid values:
        # 
        # *   subtitles
        # *   watermark
        # *   opening
        # *   ending
        # *   general
        self.business_type = business_type
        # The category ID.
        self.cate_id = cate_id
        # The client token that is used to ensure the idempotence of the request. The value must be a UUID that contains 32 characters.
        self.client_token = client_token
        # The thumbnail URL of the media asset.
        # 
        # *   The value can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.cover_url = cover_url
        # The description of the media asset.
        # 
        # *   The value can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.description = description
        # The URL of the media asset in another service. The URL is associated with the ID of the media asset in IMS. The URL cannot be modified once registered. The following types of URLs are supported:
        # 
        # *   OSS URL in one of the following formats:
        # 
        # http(s)://example-bucket.oss-cn-shanghai.aliyuncs.com/example.mp4
        # 
        # oss://example-bucket/example.mp4: In this format, it is considered by default that the region of the OSS bucket in which the media asset resides is the same as the region in which IMS is activated.
        # 
        # *   URL of an ApsaraVideo VOD media asset
        # 
        # vod://\\*\\*\\*20b48fb04483915d4f2cd8ac\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.input_url = input_url
        # The tags of the media asset.
        # 
        # *   Up to 16 tags are supported.
        # *   Separate multiple tags with commas (,).
        # *   Each tag can be up to 32 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.media_tags = media_tags
        # The type of the media asset. Valid values:
        # 
        # *   image
        # *   video
        # *   audio
        # *   text
        # 
        # We recommend that you specify this parameter based on your business requirements. If you set InputURL to an OSS URL, the media asset type can be automatically determined based on the file name extension. For more information
        # <props="china">, see [File formats](https://help.aliyun.com/document_detail/466207.html).
        self.media_type = media_type
        # Specifies whether to overwrite the media asset that has been registered by using the same URL. Default value: false. Valid values:
        # 
        # \\- true: If a media asset has been registered by using the same URL, the original media asset is deleted and the new media asset is registered.
        # 
        # \\- false: If a media asset has been registered by using the same URL, the new media asset is not registered. A URL cannot be used to register multiple media assets.
        self.overwrite = overwrite
        # The custom ID. The ID can be 6 to 64 characters in length and can contain only letters, digits, hyphens (-), and underscores (_). Make sure that the ID is unique among users.
        self.reference_id = reference_id
        # The registration configurations.
        # 
        # By default, a sprite is generated for the media asset. You can set NeedSprite to false to disable automatic sprite generation.
        # 
        # By default, a snapshot is generated for the media asset. You can set NeedSnapshot to false to disable automatic snapshot generation.
        self.register_config = register_config
        # The ID of the smart tagging template. Valid values:
        # 
        # *   S00000101-300080: the system template that supports natural language processing (NLP) for content recognition.
        # *   S00000103-000001: the system template that supports NLP for content recognition and all tagging capabilities.
        # *   S00000103-000002: the system template that supports all tagging capabilities but does not support NLP for content recognition.
        # 
        # After you configure this parameter, a smart tag analysis task is automatically initiated after the media asset is registered. For more information about the billable items<props="china">, see [Smart tagging](https://help.aliyun.com/zh/ims/media-ai-billing?spm=a2c4g.11186623.0.0.3147392dWwlSjL#p-k38-3rb-dug).
        self.smart_tag_template_id = smart_tag_template_id
        # The title. If you do not specify this parameter, a default title is automatically generated based on the date.
        # 
        # *   The value can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.title = title
        # The user data. You can specify a custom callback URL. For more information<props="china"> ,see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        # 
        # *   The value can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        # *   The value must be in the JSON format.
        self.user_data = user_data
        # The workflow ID.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        if self.register_config is not None:
            result['RegisterConfig'] = self.register_config
        if self.smart_tag_template_id is not None:
            result['SmartTagTemplateId'] = self.smart_tag_template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        if m.get('RegisterConfig') is not None:
            self.register_config = m.get('RegisterConfig')
        if m.get('SmartTagTemplateId') is not None:
            self.smart_tag_template_id = m.get('SmartTagTemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class RegisterMediaInfoResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset in IMS.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterMediaInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterMediaInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterMediaStreamRequest(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media_id: str = None,
        user_data: str = None,
    ):
        # The URL of the media asset in another service. The URL is associated with the ID of the media asset in IMS. The URL cannot be modified once registered.
        # 
        # Set this parameter to the OSS URL of the media asset. The following formats are supported:
        # 
        # http(s)://example-bucket.oss-cn-shanghai.aliyuncs.com/example.mp4
        # 
        # oss://example-bucket/example.mp4: In this format, it is considered by default that the region of the OSS bucket in which the media asset resides is the same as the region in which IMS is activated.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class RegisterMediaStreamResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterMediaStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterMediaStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterMediaStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchEditingProjectRequest(TeaModel):
    def __init__(
        self,
        create_source: str = None,
        end_time: str = None,
        page_no: int = None,
        page_size: int = None,
        project_type: str = None,
        sort_by: str = None,
        start_time: str = None,
        status: str = None,
        template_type: str = None,
    ):
        # The source of the project.
        # 
        # \\-OpenAPI
        # 
        # \\-AliyunConsole
        # 
        # \\-WebSDK
        # 
        # Valid values:
        # 
        # *   AliyunConsole: The project is created in the Alibaba Cloud console.
        # *   WebSDK: The project is created by using the SDK for Web.
        # *   OpenAPI: The project is created by calling API operations.
        self.create_source = create_source
        # The end of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 100.
        self.page_size = page_size
        # The type of the editing project. Default value: EditingProject. Valid values:
        # 
        # *   EditingProject: a regular editing project.
        # *   LiveEditingProject: a live stream editing project.
        self.project_type = project_type
        # The sorting rule of results. Valid values:
        # 
        # \\- CreationTime:Desc (default): The results are sorted in reverse chronological order based on the creation time.
        # 
        # \\- CreationTime:Asc: The results are sorted in chronological order based on the creation time.
        self.sort_by = sort_by
        # The beginning of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time
        # The status of the online editing project. Separate multiple values with commas (,). By default, all online editing projects are queried.
        # 
        # Valid values:
        # 
        # \\-Draft
        # 
        # \\-Producing
        # 
        # \\-Produced
        # 
        # \\-ProduceFailed
        self.status = status
        # The template type. Valid values:
        # 
        # \\-Timeline
        # 
        # \\-VETemplate
        # 
        # Valid values:
        # 
        # *   Timeline: regular template.
        # *   VETemplate: advanced template.
        # *   None: No template is used.
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class SearchEditingProjectResponseBodyProjectList(TeaModel):
    def __init__(
        self,
        business_config: str = None,
        business_status: str = None,
        cover_url: str = None,
        create_source: str = None,
        create_time: str = None,
        description: str = None,
        duration: int = None,
        error_code: str = None,
        error_message: str = None,
        modified_source: str = None,
        modified_time: str = None,
        project_id: str = None,
        project_type: str = None,
        status: str = None,
        template_type: str = None,
        timeline: str = None,
        title: str = None,
    ):
        # The business configuration of the project. This parameter can be ignored for general editing projects.
        self.business_config = business_config
        # The business status of the project. This parameter can be ignored for general editing projects. Valid values:
        # 
        # Valid values:
        # 
        # *   BroadCasting:
        # *   ReservationCanceled
        # *   LiveFinished
        # *   LoadingFailed
        # *   Reserving
        self.business_status = business_status
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The method for editing the online editing project.
        # 
        # \\-OpenAPI
        # 
        # \\-AliyunConsole
        # 
        # \\-WebSDK
        # 
        # Valid values:
        # 
        # *   AliyunConsole: The project is created in the Alibaba Cloud console.
        # *   WebSDK: The project is created by using the SDK for Web.
        # *   OpenAPI: The project is created by calling API operations.
        self.create_source = create_source
        # The time when the online editing project was created.
        self.create_time = create_time
        # The description of the online editing project.
        self.description = description
        # The total length of the online editing project. Unit: seconds.
        self.duration = duration
        # The error code returned if the production of the online editing project failed.
        self.error_code = error_code
        # The error message returned if the production of the online editing project failed.
        self.error_message = error_message
        # The method used when the online editing project was last modified.
        self.modified_source = modified_source
        # The time when the online editing project was last modified.
        self.modified_time = modified_time
        # The ID of the online editing project.
        self.project_id = project_id
        # The type of the editing project.
        # 
        # Valid values:
        # 
        # *   LiveEditingProject: a live stream editing project.
        # *   EditingProject: a regular editing project.
        self.project_type = project_type
        # The status of the online editing project. Valid values:
        # 
        # \\-Draft
        # 
        # \\-Editing
        # 
        # \\-Producing
        # 
        # \\-Produced
        # 
        # \\-ProduceFailed
        # 
        # Valid values:
        # 
        # *   Draft
        # *   Produced
        # *   Editing
        # *   Producing
        # *   ProduceFailed
        self.status = status
        # The type of the template.
        self.template_type = template_type
        # The timeline of the online editing project.
        self.timeline = timeline
        # The title of the online editing project.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SearchEditingProjectResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        project_list: List[SearchEditingProjectResponseBodyProjectList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned on a single page. The value is set to the maximum number of entries returned on each page except for the last page.
        # 
        # Examples:
        # 
        # Valid example: 10,10,5. Invalid example: 10,5,10.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The queried online editing projects.
        self.project_list = project_list
        # The request ID.
        self.request_id = request_id
        # Optional. The total number of entries returned. By default, this parameter is not returned.
        self.total_count = total_count

    def validate(self):
        if self.project_list:
            for k in self.project_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['ProjectList'] = []
        if self.project_list is not None:
            for k in self.project_list:
                result['ProjectList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.project_list = []
        if m.get('ProjectList') is not None:
            for k in m.get('ProjectList'):
                temp_model = SearchEditingProjectResponseBodyProjectList()
                self.project_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchEditingProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchEditingProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchIndexJobRerunRequest(TeaModel):
    def __init__(
        self,
        media_ids: str = None,
        search_lib_name: str = None,
        task: str = None,
    ):
        # The ID of the media asset. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.media_ids = media_ids
        # The search library.
        self.search_lib_name = search_lib_name
        # The type of the job. Separate multiple types with commas (,).
        # 
        # *   aiLabel: smart tagging.
        # *   face: face recognition.
        # *   mm: large visual model.
        self.task = task

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.task is not None:
            result['Task'] = self.task
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Task') is not None:
            self.task = m.get('Task')
        return self


class SearchIndexJobRerunResponseBodyData(TeaModel):
    def __init__(
        self,
        media_ids_no_exist: List[str] = None,
    ):
        # The media asset IDs that do not exist.
        self.media_ids_no_exist = media_ids_no_exist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids_no_exist is not None:
            result['MediaIdsNoExist'] = self.media_ids_no_exist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIdsNoExist') is not None:
            self.media_ids_no_exist = m.get('MediaIdsNoExist')
        return self


class SearchIndexJobRerunResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SearchIndexJobRerunResponseBodyData = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The response data.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SearchIndexJobRerunResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SearchIndexJobRerunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchIndexJobRerunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchIndexJobRerunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaRequest(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        match: str = None,
        page_no: int = None,
        page_size: int = None,
        scroll_token: str = None,
        search_lib_name: str = None,
        sort_by: str = None,
    ):
        # The ID of the entity.
        self.entity_id = entity_id
        # The filter conditions. For more information about the parameter syntax
        # <props="china">, see [Media asset search protocols](https://help.aliyun.com/document_detail/2584256.html).
        self.match = match
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The pagination identifier. The value can be up to 32 characters in length. The first time you call this operation for each new search, you do not need to specify this parameter. The value of this parameter is returned each time data records that meet the specified filter condition are found. The value is used to record the current position of queried data. Record the returned parameter value and set this parameter according to the following requirements during the next search: If you need to traverse all data that meets the filter criteria, you must set the ScrollToken parameter. If the value of the PageNo parameter exceeds 200, we recommend that you set this parameter to optimize search performance. You can only page backward. You can page a maximum of 1,000 entries in an operation.
        self.scroll_token = scroll_token
        # The search library.
        self.search_lib_name = search_lib_name
        # The sort field and order. Separate multiple parameters with commas (,).
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.match is not None:
            result['Match'] = self.match
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scroll_token is not None:
            result['ScrollToken'] = self.scroll_token
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('Match') is not None:
            self.match = m.get('Match')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScrollToken') is not None:
            self.scroll_token = m.get('ScrollToken')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks(TeaModel):
    def __init__(
        self,
        position: str = None,
        size: float = None,
        timestamp: float = None,
    ):
        # The coordinates of the bounding box.
        self.position = position
        # The size of the bounding box.
        self.size = size
        # The timestamp of the track.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.position is not None:
            result['Position'] = self.position
        if self.size is not None:
            result['Size'] = self.size
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences(TeaModel):
    def __init__(
        self,
        content: str = None,
        finegrain_id: str = None,
        finegrain_name: str = None,
        from_: float = None,
        image: str = None,
        score: float = None,
        table_batch_seq_id: str = None,
        to: float = None,
        tracks: List[SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks] = None,
        clip_id: str = None,
    ):
        # The text content.
        self.content = content
        # The fine-grained ID of the entity.
        self.finegrain_id = finegrain_id
        # The fine-grained name of the entity.
        self.finegrain_name = finegrain_name
        # The start time of the clip.
        self.from_ = from_
        # The optimal face image encoded in Base64.
        self.image = image
        # The score.
        self.score = score
        # The sequence ID of the vector table.
        self.table_batch_seq_id = table_batch_seq_id
        # The end time of the clip.
        self.to = to
        # The track sequence.
        self.tracks = tracks
        # The ID of the clip.
        self.clip_id = clip_id

    def validate(self):
        if self.tracks:
            for k in self.tracks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.finegrain_id is not None:
            result['FinegrainId'] = self.finegrain_id
        if self.finegrain_name is not None:
            result['FinegrainName'] = self.finegrain_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.image is not None:
            result['Image'] = self.image
        if self.score is not None:
            result['Score'] = self.score
        if self.table_batch_seq_id is not None:
            result['TableBatchSeqId'] = self.table_batch_seq_id
        if self.to is not None:
            result['To'] = self.to
        result['Tracks'] = []
        if self.tracks is not None:
            for k in self.tracks:
                result['Tracks'].append(k.to_map() if k else None)
        if self.clip_id is not None:
            result['clipId'] = self.clip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FinegrainId') is not None:
            self.finegrain_id = m.get('FinegrainId')
        if m.get('FinegrainName') is not None:
            self.finegrain_name = m.get('FinegrainName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('TableBatchSeqId') is not None:
            self.table_batch_seq_id = m.get('TableBatchSeqId')
        if m.get('To') is not None:
            self.to = m.get('To')
        self.tracks = []
        if m.get('Tracks') is not None:
            for k in m.get('Tracks'):
                temp_model = SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks()
                self.tracks.append(temp_model.from_map(k))
        if m.get('clipId') is not None:
            self.clip_id = m.get('clipId')
        return self


class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo(TeaModel):
    def __init__(
        self,
        category: str = None,
        face_id: str = None,
        label_id: str = None,
        label_name: str = None,
        label_type: str = None,
        occurrences: List[SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences] = None,
        source: str = None,
    ):
        # The category.
        self.category = category
        # The face ID.
        self.face_id = face_id
        # The ID of the entity.
        self.label_id = label_id
        # The name of the entity.
        self.label_name = label_name
        # The type of the tag.
        self.label_type = label_type
        # The clips.
        self.occurrences = occurrences
        # The source.
        self.source = source

    def validate(self):
        if self.occurrences:
            for k in self.occurrences:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.face_id is not None:
            result['FaceId'] = self.face_id
        if self.label_id is not None:
            result['LabelId'] = self.label_id
        if self.label_name is not None:
            result['LabelName'] = self.label_name
        if self.label_type is not None:
            result['LabelType'] = self.label_type
        result['Occurrences'] = []
        if self.occurrences is not None:
            for k in self.occurrences:
                result['Occurrences'].append(k.to_map() if k else None)
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('FaceId') is not None:
            self.face_id = m.get('FaceId')
        if m.get('LabelId') is not None:
            self.label_id = m.get('LabelId')
        if m.get('LabelName') is not None:
            self.label_name = m.get('LabelName')
        if m.get('LabelType') is not None:
            self.label_type = m.get('LabelType')
        self.occurrences = []
        if m.get('Occurrences') is not None:
            for k in m.get('Occurrences'):
                temp_model = SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences()
                self.occurrences.append(temp_model.from_map(k))
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class SearchMediaResponseBodyMediaInfoListAiDataAsrInfo(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content: str = None,
        from_: float = None,
        timestamp: float = None,
        to: float = None,
    ):
        # The ID of the clip.
        self.clip_id = clip_id
        # The text content.
        self.content = content
        # The start time of the clip.
        self.from_ = from_
        # The timestamp of the clip.
        self.timestamp = timestamp
        # The end time of the clip.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content is not None:
            result['Content'] = self.content
        if self.from_ is not None:
            result['From'] = self.from_
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaResponseBodyMediaInfoListAiDataOcrInfo(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content: str = None,
        from_: float = None,
        timestamp: float = None,
        to: float = None,
    ):
        # The ID of the clip.
        self.clip_id = clip_id
        # The text content.
        self.content = content
        # The start time of the clip.
        self.from_ = from_
        # The timestamp of the clip.
        self.timestamp = timestamp
        # The end time of the clip.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content is not None:
            result['Content'] = self.content
        if self.from_ is not None:
            result['From'] = self.from_
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaResponseBodyMediaInfoListAiData(TeaModel):
    def __init__(
        self,
        ai_label_info: List[SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo] = None,
        asr_info: List[SearchMediaResponseBodyMediaInfoListAiDataAsrInfo] = None,
        ocr_info: List[SearchMediaResponseBodyMediaInfoListAiDataOcrInfo] = None,
    ):
        # The tags of the intelligent AI job.
        self.ai_label_info = ai_label_info
        # The information about audio files.
        self.asr_info = asr_info
        # The subtitles.
        self.ocr_info = ocr_info

    def validate(self):
        if self.ai_label_info:
            for k in self.ai_label_info:
                if k:
                    k.validate()
        if self.asr_info:
            for k in self.asr_info:
                if k:
                    k.validate()
        if self.ocr_info:
            for k in self.ocr_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AiLabelInfo'] = []
        if self.ai_label_info is not None:
            for k in self.ai_label_info:
                result['AiLabelInfo'].append(k.to_map() if k else None)
        result['AsrInfo'] = []
        if self.asr_info is not None:
            for k in self.asr_info:
                result['AsrInfo'].append(k.to_map() if k else None)
        result['OcrInfo'] = []
        if self.ocr_info is not None:
            for k in self.ocr_info:
                result['OcrInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ai_label_info = []
        if m.get('AiLabelInfo') is not None:
            for k in m.get('AiLabelInfo'):
                temp_model = SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo()
                self.ai_label_info.append(temp_model.from_map(k))
        self.asr_info = []
        if m.get('AsrInfo') is not None:
            for k in m.get('AsrInfo'):
                temp_model = SearchMediaResponseBodyMediaInfoListAiDataAsrInfo()
                self.asr_info.append(temp_model.from_map(k))
        self.ocr_info = []
        if m.get('OcrInfo') is not None:
            for k in m.get('OcrInfo'):
                temp_model = SearchMediaResponseBodyMediaInfoListAiDataOcrInfo()
                self.ocr_info.append(temp_model.from_map(k))
        return self


class SearchMediaResponseBodyMediaInfoListAiRoughData(TeaModel):
    def __init__(
        self,
        ai_category: str = None,
        ai_job_id: str = None,
        result: str = None,
        save_type: str = None,
        status: str = None,
    ):
        # TV Series
        self.ai_category = ai_category
        # The ID of the AI job.
        self.ai_job_id = ai_job_id
        # The results of the AI job.
        self.result = result
        # The save type.
        self.save_type = save_type
        # The data status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_category is not None:
            result['AiCategory'] = self.ai_category
        if self.ai_job_id is not None:
            result['AiJobId'] = self.ai_job_id
        if self.result is not None:
            result['Result'] = self.result
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiCategory') is not None:
            self.ai_category = m.get('AiCategory')
        if m.get('AiJobId') is not None:
            self.ai_job_id = m.get('AiJobId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        create_time: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        images_input: str = None,
        modified_time: str = None,
        region: str = None,
        width: str = None,
    ):
        # The bitrate of the file.
        self.bitrate = bitrate
        # The time when the file was created.
        self.create_time = create_time
        # The duration of the file.
        self.duration = duration
        # The name of the file.
        self.file_name = file_name
        # The size of the file in bytes.
        self.file_size = file_size
        # The status of the file.
        self.file_status = file_status
        # The type of the file.
        self.file_type = file_type
        # The Object Storage Service (OSS) URL of the file.
        self.file_url = file_url
        # The encapsulation format of the file.
        self.format_name = format_name
        # The height of the file.
        self.height = height
        self.images_input = images_input
        # The time when the file was last modified.
        self.modified_time = modified_time
        # The region in which the file is stored.
        self.region = region
        # The width of the file.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.images_input is not None:
            result['ImagesInput'] = self.images_input
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImagesInput') is not None:
            self.images_input = m.get('ImagesInput')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchMediaResponseBodyMediaInfoListFileInfoList(TeaModel):
    def __init__(
        self,
        file_basic_info: SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo = None,
    ):
        # The basic information about the file, such as the duration and size.
        self.file_basic_info = file_basic_info

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class SearchMediaResponseBodyMediaInfoListIndexStatusList(TeaModel):
    def __init__(
        self,
        index_status: str = None,
        index_type: str = None,
    ):
        self.index_status = index_status
        self.index_type = index_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_status is not None:
            result['IndexStatus'] = self.index_status
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexStatus') is not None:
            self.index_status = m.get('IndexStatus')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        return self


class SearchMediaResponseBodyMediaInfoListMediaBasicInfo(TeaModel):
    def __init__(
        self,
        biz: str = None,
        business_type: str = None,
        cate_id: int = None,
        cate_name: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        namespace: str = None,
        reference_id: str = None,
        snapshots: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        transcode_status: str = None,
        upload_source: str = None,
        user_data: str = None,
        vision_description: str = None,
    ):
        # The business to which the media asset belongs.
        self.biz = biz
        # The business type of the media asset.
        self.business_type = business_type
        # The ID of the category.
        self.cate_id = cate_id
        # The name of the category.
        self.cate_name = cate_name
        # The category of the media asset.
        self.category = category
        # The thumbnail URL of the media asset.
        self.cover_url = cover_url
        # The time when the media asset was created.
        self.create_time = create_time
        # The time when the media asset was deleted.
        self.deleted_time = deleted_time
        # The description of the media asset.
        self.description = description
        # The address of the media asset that is waiting to be registered.
        self.input_url = input_url
        # The ID of the media asset.
        self.media_id = media_id
        # The tags of the media asset.
        self.media_tags = media_tags
        # The type of the media asset.
        self.media_type = media_type
        # The time when the media asset was modified.
        self.modified_time = modified_time
        self.namespace = namespace
        # The custom ID of the media asset. The ID is a string that contains 6 to 64 characters. Only letters, digits, hyphens (-), and underscores (_) are supported. Each custom ID is unique.
        self.reference_id = reference_id
        # The snapshots of the media asset.
        self.snapshots = snapshots
        # The source of the media asset.
        self.source = source
        # The image sprite of the media asset
        self.sprite_images = sprite_images
        # The state of the media asset.
        self.status = status
        # The title of the media asset.
        self.title = title
        # The transcoding status of the media asset.
        self.transcode_status = transcode_status
        # The upload source of the media asset.
        self.upload_source = upload_source
        # The user data.
        self.user_data = user_data
        self.vision_description = vision_description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vision_description is not None:
            result['VisionDescription'] = self.vision_description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VisionDescription') is not None:
            self.vision_description = m.get('VisionDescription')
        return self


class SearchMediaResponseBodyMediaInfoList(TeaModel):
    def __init__(
        self,
        ai_data: SearchMediaResponseBodyMediaInfoListAiData = None,
        ai_rough_data: SearchMediaResponseBodyMediaInfoListAiRoughData = None,
        file_info_list: List[SearchMediaResponseBodyMediaInfoListFileInfoList] = None,
        index_status_list: List[SearchMediaResponseBodyMediaInfoListIndexStatusList] = None,
        media_basic_info: SearchMediaResponseBodyMediaInfoListMediaBasicInfo = None,
        media_id: str = None,
    ):
        # The details of the intelligent AI job.
        self.ai_data = ai_data
        # The description of the AI job.
        self.ai_rough_data = ai_rough_data
        # The information about the files.
        self.file_info_list = file_info_list
        self.index_status_list = index_status_list
        # The basic information about the media asset.
        self.media_basic_info = media_basic_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.ai_data:
            self.ai_data.validate()
        if self.ai_rough_data:
            self.ai_rough_data.validate()
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.index_status_list:
            for k in self.index_status_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_data is not None:
            result['AiData'] = self.ai_data.to_map()
        if self.ai_rough_data is not None:
            result['AiRoughData'] = self.ai_rough_data.to_map()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        result['IndexStatusList'] = []
        if self.index_status_list is not None:
            for k in self.index_status_list:
                result['IndexStatusList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiData') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListAiData()
            self.ai_data = temp_model.from_map(m['AiData'])
        if m.get('AiRoughData') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListAiRoughData()
            self.ai_rough_data = temp_model.from_map(m['AiRoughData'])
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = SearchMediaResponseBodyMediaInfoListFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        self.index_status_list = []
        if m.get('IndexStatusList') is not None:
            for k in m.get('IndexStatusList'):
                temp_model = SearchMediaResponseBodyMediaInfoListIndexStatusList()
                self.index_status_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchMediaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_info_list: List[SearchMediaResponseBodyMediaInfoList] = None,
        request_id: str = None,
        scroll_token: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The media assets that meet the requirements.
        self.media_info_list = media_info_list
        # The ID of the request.
        self.request_id = request_id
        # The pagination identifier.
        self.scroll_token = scroll_token
        # Indicates whether the request was successful.
        self.success = success
        # The total number of media assets that meet the conditions.
        self.total = total

    def validate(self):
        if self.media_info_list:
            for k in self.media_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaInfoList'] = []
        if self.media_info_list is not None:
            for k in self.media_info_list:
                result['MediaInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scroll_token is not None:
            result['ScrollToken'] = self.scroll_token
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_info_list = []
        if m.get('MediaInfoList') is not None:
            for k in m.get('MediaInfoList'):
                temp_model = SearchMediaResponseBodyMediaInfoList()
                self.media_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScrollToken') is not None:
            self.scroll_token = m.get('ScrollToken')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaByAILabelRequest(TeaModel):
    def __init__(
        self,
        matching_mode: str = None,
        media_id: str = None,
        media_type: str = None,
        multimodal_search_type: str = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        search_lib_name: str = None,
        sort_by: str = None,
        specific_search: bool = None,
        text: str = None,
    ):
        self.matching_mode = matching_mode
        # The ID of the media asset. This parameter is required if you want to query media asset clips.
        self.media_id = media_id
        # The type of the media assets. Valid values:
        # 
        # *   image
        # *   video
        # *   audio
        self.media_type = media_type
        # The type of query. Valid values:
        # 
        # *   PersonName: queries media assets based on character names.
        # *   Ocr: queries media assets based on subtitles.
        # *   AiCategory: queries media assets based on AI categories.
        # *   FullSearch (default): queries all media assets.
        self.multimodal_search_type = multimodal_search_type
        self.namespace = namespace
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The name of the search library.
        self.search_lib_name = search_lib_name
        # The sorting method of the results. Valid values:
        # 
        # *   CreationTime:Desc (default): sorts results in reverse chronological order.
        # *   CreationTime:Asc: sorts results in chronological order.
        self.sort_by = sort_by
        # Specifies whether to query media asset clips. Valid values:
        # 
        # *   true
        # *   false
        self.specific_search = specific_search
        # The content that you want to query.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.matching_mode is not None:
            result['MatchingMode'] = self.matching_mode
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.multimodal_search_type is not None:
            result['MultimodalSearchType'] = self.multimodal_search_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.specific_search is not None:
            result['SpecificSearch'] = self.specific_search
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchingMode') is not None:
            self.matching_mode = m.get('MatchingMode')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('MultimodalSearchType') is not None:
            self.multimodal_search_type = m.get('MultimodalSearchType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SpecificSearch') is not None:
            self.specific_search = m.get('SpecificSearch')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks(TeaModel):
    def __init__(
        self,
        position: str = None,
        size: float = None,
        timestamp: float = None,
    ):
        # The coordinates of the bounding box.
        self.position = position
        # The size of the bounding box.
        self.size = size
        # The timestamp of the track.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.position is not None:
            result['Position'] = self.position
        if self.size is not None:
            result['Size'] = self.size
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content: str = None,
        finegrain_id: str = None,
        finegrain_name: str = None,
        from_: float = None,
        image: str = None,
        score: float = None,
        table_batch_seq_id: str = None,
        to: float = None,
        tracks: List[SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks] = None,
    ):
        # The ID of the clip.
        self.clip_id = clip_id
        # The content of the text.
        self.content = content
        # The fine-grained ID of the entity.
        self.finegrain_id = finegrain_id
        # The fine-grained name of the entity.
        self.finegrain_name = finegrain_name
        # The start time of the clip.
        self.from_ = from_
        # The image that contains the most face information.
        self.image = image
        # The score.
        self.score = score
        # The sequence ID of the vector table.
        self.table_batch_seq_id = table_batch_seq_id
        # The end time of the clip.
        self.to = to
        # The tracks.
        self.tracks = tracks

    def validate(self):
        if self.tracks:
            for k in self.tracks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content is not None:
            result['Content'] = self.content
        if self.finegrain_id is not None:
            result['FinegrainId'] = self.finegrain_id
        if self.finegrain_name is not None:
            result['FinegrainName'] = self.finegrain_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.image is not None:
            result['Image'] = self.image
        if self.score is not None:
            result['Score'] = self.score
        if self.table_batch_seq_id is not None:
            result['TableBatchSeqId'] = self.table_batch_seq_id
        if self.to is not None:
            result['To'] = self.to
        result['Tracks'] = []
        if self.tracks is not None:
            for k in self.tracks:
                result['Tracks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FinegrainId') is not None:
            self.finegrain_id = m.get('FinegrainId')
        if m.get('FinegrainName') is not None:
            self.finegrain_name = m.get('FinegrainName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('TableBatchSeqId') is not None:
            self.table_batch_seq_id = m.get('TableBatchSeqId')
        if m.get('To') is not None:
            self.to = m.get('To')
        self.tracks = []
        if m.get('Tracks') is not None:
            for k in m.get('Tracks'):
                temp_model = SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks()
                self.tracks.append(temp_model.from_map(k))
        return self


class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo(TeaModel):
    def __init__(
        self,
        category: str = None,
        face_id: str = None,
        label_id: str = None,
        label_name: str = None,
        label_type: str = None,
        occurrences: List[SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences] = None,
        source: str = None,
    ):
        # The category.
        self.category = category
        # The ID of the face.
        self.face_id = face_id
        # The ID of the entity.
        self.label_id = label_id
        # The name of the entity.
        self.label_name = label_name
        # The type of the tag.
        self.label_type = label_type
        # The information about the clips.
        self.occurrences = occurrences
        # The source.
        self.source = source

    def validate(self):
        if self.occurrences:
            for k in self.occurrences:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.face_id is not None:
            result['FaceId'] = self.face_id
        if self.label_id is not None:
            result['LabelId'] = self.label_id
        if self.label_name is not None:
            result['LabelName'] = self.label_name
        if self.label_type is not None:
            result['LabelType'] = self.label_type
        result['Occurrences'] = []
        if self.occurrences is not None:
            for k in self.occurrences:
                result['Occurrences'].append(k.to_map() if k else None)
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('FaceId') is not None:
            self.face_id = m.get('FaceId')
        if m.get('LabelId') is not None:
            self.label_id = m.get('LabelId')
        if m.get('LabelName') is not None:
            self.label_name = m.get('LabelName')
        if m.get('LabelType') is not None:
            self.label_type = m.get('LabelType')
        self.occurrences = []
        if m.get('Occurrences') is not None:
            for k in m.get('Occurrences'):
                temp_model = SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences()
                self.occurrences.append(temp_model.from_map(k))
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content: str = None,
        from_: float = None,
        timestamp: float = None,
        to: float = None,
    ):
        # The ID of the clip.
        self.clip_id = clip_id
        # The content of the audio.
        self.content = content
        # The start time of the clip.
        self.from_ = from_
        # The timestamp of the clip.
        self.timestamp = timestamp
        # The end time of the clip.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content is not None:
            result['Content'] = self.content
        if self.from_ is not None:
            result['From'] = self.from_
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content: str = None,
        from_: float = None,
        timestamp: float = None,
        to: float = None,
    ):
        # The ID of the clip.
        self.clip_id = clip_id
        # The content of the text.
        self.content = content
        # The start time of the clip.
        self.from_ = from_
        # The timestamp of the clip.
        self.timestamp = timestamp
        # The end time of the clip.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content is not None:
            result['Content'] = self.content
        if self.from_ is not None:
            result['From'] = self.from_
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaByAILabelResponseBodyMediaListAiData(TeaModel):
    def __init__(
        self,
        ai_label_info: List[SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo] = None,
        asr_info: List[SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo] = None,
        ocr_info: List[SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo] = None,
    ):
        # The tags of the AI job.
        self.ai_label_info = ai_label_info
        # The information about audio files.
        self.asr_info = asr_info
        # The information about subtitle files.
        self.ocr_info = ocr_info

    def validate(self):
        if self.ai_label_info:
            for k in self.ai_label_info:
                if k:
                    k.validate()
        if self.asr_info:
            for k in self.asr_info:
                if k:
                    k.validate()
        if self.ocr_info:
            for k in self.ocr_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AiLabelInfo'] = []
        if self.ai_label_info is not None:
            for k in self.ai_label_info:
                result['AiLabelInfo'].append(k.to_map() if k else None)
        result['AsrInfo'] = []
        if self.asr_info is not None:
            for k in self.asr_info:
                result['AsrInfo'].append(k.to_map() if k else None)
        result['OcrInfo'] = []
        if self.ocr_info is not None:
            for k in self.ocr_info:
                result['OcrInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ai_label_info = []
        if m.get('AiLabelInfo') is not None:
            for k in m.get('AiLabelInfo'):
                temp_model = SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo()
                self.ai_label_info.append(temp_model.from_map(k))
        self.asr_info = []
        if m.get('AsrInfo') is not None:
            for k in m.get('AsrInfo'):
                temp_model = SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo()
                self.asr_info.append(temp_model.from_map(k))
        self.ocr_info = []
        if m.get('OcrInfo') is not None:
            for k in m.get('OcrInfo'):
                temp_model = SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo()
                self.ocr_info.append(temp_model.from_map(k))
        return self


class SearchMediaByAILabelResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        ai_data: SearchMediaByAILabelResponseBodyMediaListAiData = None,
        app_id: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: float = None,
        media_id: str = None,
        modification_time: str = None,
        size: int = None,
        snapshots: List[str] = None,
        status: str = None,
        storage_location: str = None,
        tags: str = None,
        title: str = None,
    ):
        # The details of the AI job.
        self.ai_data = ai_data
        # The ID of the application. Default value: app-1000000.
        self.app_id = app_id
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media asset was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the media asset.
        self.description = description
        # The duration. Unit: seconds.
        self.duration = duration
        # The ID of the media asset.
        self.media_id = media_id
        # The time when the media asset was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modification_time = modification_time
        # The size of the source file. Unit: bytes.
        self.size = size
        # The array of video snapshot URLs.
        self.snapshots = snapshots
        # The status of the video.
        # 
        # Valid values:
        # 
        # *   PrepareFail
        # *   UploadFail
        # *   Init
        # *   UploadSucc
        # *   Transcoding
        # *   TranscodeFail
        # *   Deleted
        # *   Normal
        # *   Uploading
        # *   Preparing
        # *   Blocked
        # *   Checking
        self.status = status
        # The storage address.
        self.storage_location = storage_location
        # The tags of the media asset.
        self.tags = tags
        # The title of the media asset.
        self.title = title

    def validate(self):
        if self.ai_data:
            self.ai_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ai_data is not None:
            result['AiData'] = self.ai_data.to_map()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AiData') is not None:
            temp_model = SearchMediaByAILabelResponseBodyMediaListAiData()
            self.ai_data = temp_model.from_map(m['AiData'])
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SearchMediaByAILabelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_list: List[SearchMediaByAILabelResponseBodyMediaList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The media assets that contain the specified content.
        self.media_list = media_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success
        # The total number of audio and video files that meet the conditions.
        self.total = total

    def validate(self):
        if self.media_list:
            for k in self.media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaList'] = []
        if self.media_list is not None:
            for k in self.media_list:
                result['MediaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_list = []
        if m.get('MediaList') is not None:
            for k in m.get('MediaList'):
                temp_model = SearchMediaByAILabelResponseBodyMediaList()
                self.media_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaByAILabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaByAILabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaByAILabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaByFaceRequest(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        face_search_token: str = None,
        media_type: str = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        person_image_url: str = None,
        search_lib_name: str = None,
    ):
        # The ID of the entity.
        self.entity_id = entity_id
        # The token that is used to identify the query. You can use this parameter in the SearchMediaClipByFace operation to specify the same query conditions.
        # 
        # This parameter is required.
        self.face_search_token = face_search_token
        # The type of the media asset. Valid values:
        # 
        # *   image
        # *   video
        self.media_type = media_type
        self.namespace = namespace
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The URL of the face image.
        # 
        # This parameter is required.
        self.person_image_url = person_image_url
        # The name of the search library.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.face_search_token is not None:
            result['FaceSearchToken'] = self.face_search_token
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.person_image_url is not None:
            result['PersonImageUrl'] = self.person_image_url
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('FaceSearchToken') is not None:
            self.face_search_token = m.get('FaceSearchToken')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PersonImageUrl') is not None:
            self.person_image_url = m.get('PersonImageUrl')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class SearchMediaByFaceResponseBodyMediaInfoList(TeaModel):
    def __init__(
        self,
        media_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchMediaByFaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_info_list: List[SearchMediaByFaceResponseBodyMediaInfoList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The media assets that meet the conditions.
        self.media_info_list = media_info_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success
        # The total number of data records that meet the specified filter condition.
        self.total = total

    def validate(self):
        if self.media_info_list:
            for k in self.media_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaInfoList'] = []
        if self.media_info_list is not None:
            for k in self.media_info_list:
                result['MediaInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_info_list = []
        if m.get('MediaInfoList') is not None:
            for k in m.get('MediaInfoList'):
                temp_model = SearchMediaByFaceResponseBodyMediaInfoList()
                self.media_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaByFaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaByFaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaByFaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaByHybridRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_type: str = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        search_lib_name: str = None,
        text: str = None,
    ):
        # The ID of the media asset. The details of the media asset are returned.
        self.media_id = media_id
        self.media_type = media_type
        self.namespace = namespace
        self.page_no = page_no
        self.page_size = page_size
        self.search_lib_name = search_lib_name
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SearchMediaByHybridResponseBodyMediaListClipInfo(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        to: float = None,
    ):
        self.from_ = from_
        self.score = score
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaByHybridResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        clip_info: List[SearchMediaByHybridResponseBodyMediaListClipInfo] = None,
        media_id: str = None,
    ):
        self.clip_info = clip_info
        self.media_id = media_id

    def validate(self):
        if self.clip_info:
            for k in self.clip_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClipInfo'] = []
        if self.clip_info is not None:
            for k in self.clip_info:
                result['ClipInfo'].append(k.to_map() if k else None)
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip_info = []
        if m.get('ClipInfo') is not None:
            for k in m.get('ClipInfo'):
                temp_model = SearchMediaByHybridResponseBodyMediaListClipInfo()
                self.clip_info.append(temp_model.from_map(k))
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchMediaByHybridResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_list: List[SearchMediaByHybridResponseBodyMediaList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        self.code = code
        self.media_list = media_list
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.media_list:
            for k in self.media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaList'] = []
        if self.media_list is not None:
            for k in self.media_list:
                result['MediaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_list = []
        if m.get('MediaList') is not None:
            for k in m.get('MediaList'):
                temp_model = SearchMediaByHybridResponseBodyMediaList()
                self.media_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaByHybridResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaByHybridResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaByHybridResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaByMultimodalRequest(TeaModel):
    def __init__(
        self,
        media_type: str = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        search_lib_name: str = None,
        text: str = None,
    ):
        # The type of the media assets.
        # 
        # Valid values:
        # 
        # *   image
        # *   video (default)
        self.media_type = media_type
        self.namespace = namespace
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The search library.
        self.search_lib_name = search_lib_name
        # The content that you want to query. You can describe the content in natural language.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SearchMediaByMultimodalResponseBodyMediaListClipInfo(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        to: float = None,
    ):
        # The start time of the clip.
        self.from_ = from_
        # The score.
        self.score = score
        # The end time of the clip.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class SearchMediaByMultimodalResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        clip_info: List[SearchMediaByMultimodalResponseBodyMediaListClipInfo] = None,
        media_id: str = None,
    ):
        # The information about the clip.
        self.clip_info = clip_info
        # The ID of the media asset.
        self.media_id = media_id

    def validate(self):
        if self.clip_info:
            for k in self.clip_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClipInfo'] = []
        if self.clip_info is not None:
            for k in self.clip_info:
                result['ClipInfo'].append(k.to_map() if k else None)
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip_info = []
        if m.get('ClipInfo') is not None:
            for k in m.get('ClipInfo'):
                temp_model = SearchMediaByMultimodalResponseBodyMediaListClipInfo()
                self.clip_info.append(temp_model.from_map(k))
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchMediaByMultimodalResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_list: List[SearchMediaByMultimodalResponseBodyMediaList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The media assets that contain the specified content.
        self.media_list = media_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success
        # The total number of data records that meet the specified filter condition.
        self.total = total

    def validate(self):
        if self.media_list:
            for k in self.media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaList'] = []
        if self.media_list is not None:
            for k in self.media_list:
                result['MediaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_list = []
        if m.get('MediaList') is not None:
            for k in m.get('MediaList'):
                temp_model = SearchMediaByMultimodalResponseBodyMediaList()
                self.media_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaByMultimodalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaByMultimodalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaByMultimodalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaClipByFaceRequest(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        face_search_token: str = None,
        media_id: str = None,
        page_no: int = None,
        page_size: int = None,
        search_lib_name: str = None,
    ):
        # The ID of the entity.
        self.entity_id = entity_id
        # The value of this parameter is the same as that of the FaceSearchToken parameter in the SearchMediaByFace request. This specifies to return media asset clips that meet the same query conditions.
        # 
        # This parameter is required.
        self.face_search_token = face_search_token
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 50.
        self.page_size = page_size
        # The name of the search library.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.face_search_token is not None:
            result['FaceSearchToken'] = self.face_search_token
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('FaceSearchToken') is not None:
            self.face_search_token = m.get('FaceSearchToken')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition(TeaModel):
    def __init__(
        self,
        h: int = None,
        w: int = None,
        x: int = None,
        y: int = None,
    ):
        # The height of the rectangle frame. Unit: pixels.
        self.h = h
        # The width of the rectangle frame. Unit: pixels.
        self.w = w
        # The x-axis coordinate of the upper-left corner. Unit: pixels.
        self.x = x
        # The y-axis coordinate of the upper-left corner. Unit: pixels.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.h is not None:
            result['H'] = self.h
        if self.w is not None:
            result['W'] = self.w
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('H') is not None:
            self.h = m.get('H')
        if m.get('W') is not None:
            self.w = m.get('W')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData(TeaModel):
    def __init__(
        self,
        box_position: SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition = None,
        timestamp: float = None,
    ):
        # The coordinates of the face.
        self.box_position = box_position
        # The timestamp when the face appears in the clip. Unit: seconds. The value is of the Float type.
        self.timestamp = timestamp

    def validate(self):
        if self.box_position:
            self.box_position.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.box_position is not None:
            result['BoxPosition'] = self.box_position.to_map()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BoxPosition') is not None:
            temp_model = SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition()
            self.box_position = temp_model.from_map(m['BoxPosition'])
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos(TeaModel):
    def __init__(
        self,
        end_time: float = None,
        expression: str = None,
        start_time: float = None,
        track_data: List[SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData] = None,
    ):
        # The end time of the clip. Unit: seconds. The value is of the Float type.
        self.end_time = end_time
        self.expression = expression
        # The start time of the clip. Unit: seconds. The value is of the Float type.
        self.start_time = start_time
        # The information about the face in the clip.
        self.track_data = track_data

    def validate(self):
        if self.track_data:
            for k in self.track_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['TrackData'] = []
        if self.track_data is not None:
            for k in self.track_data:
                result['TrackData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.track_data = []
        if m.get('TrackData') is not None:
            for k in m.get('TrackData'):
                temp_model = SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData()
                self.track_data.append(temp_model.from_map(k))
        return self


class SearchMediaClipByFaceResponseBodyMediaClipList(TeaModel):
    def __init__(
        self,
        category: str = None,
        entity_id: str = None,
        label_name: str = None,
        occurrences_infos: List[SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos] = None,
        score: float = None,
    ):
        # The type of the character. Valid values: celebrity sensitive politician custom unknown
        self.category = category
        # The ID of the entity, which is the same as the entity ID returned in tag analysis.
        self.entity_id = entity_id
        # The name of the entity.
        self.label_name = label_name
        # The information about clips related to the face.
        self.occurrences_infos = occurrences_infos
        # The score of the clip. The value is of the Float type. The value is in the range of [0,1].
        self.score = score

    def validate(self):
        if self.occurrences_infos:
            for k in self.occurrences_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.label_name is not None:
            result['LabelName'] = self.label_name
        result['OccurrencesInfos'] = []
        if self.occurrences_infos is not None:
            for k in self.occurrences_infos:
                result['OccurrencesInfos'].append(k.to_map() if k else None)
        if self.score is not None:
            result['Score'] = self.score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('LabelName') is not None:
            self.label_name = m.get('LabelName')
        self.occurrences_infos = []
        if m.get('OccurrencesInfos') is not None:
            for k in m.get('OccurrencesInfos'):
                temp_model = SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos()
                self.occurrences_infos.append(temp_model.from_map(k))
        if m.get('Score') is not None:
            self.score = m.get('Score')
        return self


class SearchMediaClipByFaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_clip_list: List[SearchMediaClipByFaceResponseBodyMediaClipList] = None,
        request_id: str = None,
        success: str = None,
        total: int = None,
    ):
        # The status code returned.
        self.code = code
        # The media asset clips that meet the requirements.
        self.media_clip_list = media_clip_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success
        # The total number of media asset clips that meet the conditions.
        self.total = total

    def validate(self):
        if self.media_clip_list:
            for k in self.media_clip_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaClipList'] = []
        if self.media_clip_list is not None:
            for k in self.media_clip_list:
                result['MediaClipList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_clip_list = []
        if m.get('MediaClipList') is not None:
            for k in m.get('MediaClipList'):
                temp_model = SearchMediaClipByFaceResponseBodyMediaClipList()
                self.media_clip_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaClipByFaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaClipByFaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaClipByFaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchPublicMediaInfoRequest(TeaModel):
    def __init__(
        self,
        authorized: bool = None,
        dynamic_meta_data_match_fields: str = None,
        entity_id: str = None,
        favorite: bool = None,
        media_ids: str = None,
        page_no: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        self.authorized = authorized
        self.dynamic_meta_data_match_fields = dynamic_meta_data_match_fields
        self.entity_id = entity_id
        self.favorite = favorite
        self.media_ids = media_ids
        self.page_no = page_no
        self.page_size = page_size
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.dynamic_meta_data_match_fields is not None:
            result['DynamicMetaDataMatchFields'] = self.dynamic_meta_data_match_fields
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.favorite is not None:
            result['Favorite'] = self.favorite
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('DynamicMetaDataMatchFields') is not None:
            self.dynamic_meta_data_match_fields = m.get('DynamicMetaDataMatchFields')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('Favorite') is not None:
            self.favorite = m.get('Favorite')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData(TeaModel):
    def __init__(
        self,
        data: str = None,
        type: str = None,
    ):
        self.data = data
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        category: str = None,
        cover_url: str = None,
        create_time: str = None,
        deleted_time: str = None,
        description: str = None,
        media_id: str = None,
        media_tags: str = None,
        media_type: str = None,
        modified_time: str = None,
        source: str = None,
        sprite_images: str = None,
        status: str = None,
        title: str = None,
        user_data: str = None,
    ):
        self.business_type = business_type
        self.category = category
        self.cover_url = cover_url
        self.create_time = create_time
        self.deleted_time = deleted_time
        self.description = description
        # MediaId
        self.media_id = media_id
        self.media_tags = media_tags
        self.media_type = media_type
        self.modified_time = modified_time
        self.source = source
        self.sprite_images = sprite_images
        self.status = status
        self.title = title
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo(TeaModel):
    def __init__(
        self,
        dynamic_meta_data: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData = None,
        media_basic_info: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo = None,
        media_id: str = None,
    ):
        self.dynamic_meta_data = dynamic_meta_data
        # BasicInfo
        self.media_basic_info = media_basic_info
        self.media_id = media_id

    def validate(self):
        if self.dynamic_meta_data:
            self.dynamic_meta_data.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_meta_data is not None:
            result['DynamicMetaData'] = self.dynamic_meta_data.to_map()
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DynamicMetaData') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData()
            self.dynamic_meta_data = temp_model.from_map(m['DynamicMetaData'])
        if m.get('MediaBasicInfo') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfos(TeaModel):
    def __init__(
        self,
        authorized: bool = None,
        favorite: bool = None,
        media_info: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo = None,
        remaining_auth_time: str = None,
    ):
        self.authorized = authorized
        self.favorite = favorite
        self.media_info = media_info
        self.remaining_auth_time = remaining_auth_time

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.favorite is not None:
            result['Favorite'] = self.favorite
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.remaining_auth_time is not None:
            result['RemainingAuthTime'] = self.remaining_auth_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('Favorite') is not None:
            self.favorite = m.get('Favorite')
        if m.get('MediaInfo') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RemainingAuthTime') is not None:
            self.remaining_auth_time = m.get('RemainingAuthTime')
        return self


class SearchPublicMediaInfoResponseBody(TeaModel):
    def __init__(
        self,
        public_media_infos: List[SearchPublicMediaInfoResponseBodyPublicMediaInfos] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.public_media_infos = public_media_infos
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.public_media_infos:
            for k in self.public_media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PublicMediaInfos'] = []
        if self.public_media_infos is not None:
            for k in self.public_media_infos:
                result['PublicMediaInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.public_media_infos = []
        if m.get('PublicMediaInfos') is not None:
            for k in m.get('PublicMediaInfos'):
                temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfos()
                self.public_media_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchPublicMediaInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchPublicMediaInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchPublicMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendAIAgentDataChannelMessageRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        message: str = None,
    ):
        # The ID of the AI agent in the conversation.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The DataChannel message you want to send. You must specify a JSON string. The value can be up to 8,192 characters in length.
        # 
        # This parameter is required.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class SendAIAgentDataChannelMessageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendAIAgentDataChannelMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendAIAgentDataChannelMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendAIAgentDataChannelMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendAIAgentSpeechRequest(TeaModel):
    def __init__(
        self,
        enable_interrupt: bool = None,
        instance_id: str = None,
        text: str = None,
    ):
        # Specifies whether the broadcast can interrupt the ongoing speech. Default value: true
        self.enable_interrupt = enable_interrupt
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_interrupt is not None:
            result['EnableInterrupt'] = self.enable_interrupt
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableInterrupt') is not None:
            self.enable_interrupt = m.get('EnableInterrupt')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SendAIAgentSpeechResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendAIAgentSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendAIAgentSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendAIAgentSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendAIAgentTextRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        text: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SendAIAgentTextResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendAIAgentTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendAIAgentTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendAIAgentTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLiveSnapshotJobCommandRequest(TeaModel):
    def __init__(
        self,
        command: str = None,
        job_id: str = None,
    ):
        # The operation command.
        # 
        # Valid values:
        # 
        # *   stop
        # *   restart
        # *   start
        # 
        # This parameter is required.
        self.command = command
        # The ID of the snapshot job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SendLiveSnapshotJobCommandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendLiveSnapshotJobCommandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendLiveSnapshotJobCommandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLiveSnapshotJobCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLiveTranscodeJobCommandRequest(TeaModel):
    def __init__(
        self,
        command: str = None,
        job_id: str = None,
    ):
        # The operation command. Only the stop command is supported. This command is used to stop a transcoding job.
        # 
        # This parameter is required.
        self.command = command
        # The ID of the transcoding job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SendLiveTranscodeJobCommandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendLiveTranscodeJobCommandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendLiveTranscodeJobCommandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLiveTranscodeJobCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendMessageChatTextRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        mode: str = None,
        need_archiving: bool = None,
        receiver_id: str = None,
        session_id: str = None,
        text: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.mode = mode
        self.need_archiving = need_archiving
        # This parameter is required.
        self.receiver_id = receiver_id
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.need_archiving is not None:
            result['NeedArchiving'] = self.need_archiving
        if self.receiver_id is not None:
            result['ReceiverId'] = self.receiver_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.text is not None:
            result['Text'] = self.text
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('NeedArchiving') is not None:
            self.need_archiving = m.get('NeedArchiving')
        if m.get('ReceiverId') is not None:
            self.receiver_id = m.get('ReceiverId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SendMessageChatTextResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendMessageChatTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendMessageChatTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendMessageChatTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetContentAnalyzeConfigRequest(TeaModel):
    def __init__(
        self,
        auto: bool = None,
        save_type: str = None,
        template_id: str = None,
    ):
        self.auto = auto
        self.save_type = save_type
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto is not None:
            result['Auto'] = self.auto
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Auto') is not None:
            self.auto = m.get('Auto')
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SetContentAnalyzeConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetContentAnalyzeConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetContentAnalyzeConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetContentAnalyzeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDefaultCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SetDefaultCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDefaultCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDefaultCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDefaultCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDefaultStorageLocationRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        path: str = None,
        storage_type: str = None,
    ):
        self.bucket = bucket
        self.path = path
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.path is not None:
            result['Path'] = self.path
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class SetDefaultStorageLocationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDefaultStorageLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDefaultStorageLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDefaultStorageLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetEventCallbackRequest(TeaModel):
    def __init__(
        self,
        auth_key: str = None,
        auth_switch: str = None,
        callback_queue_name: str = None,
        callback_type: str = None,
        callback_url: str = None,
        event_type_list: str = None,
    ):
        # The authentication key. The key can be up to 32 characters in length and must contain uppercase letters, lowercase letters, and digits. This parameter takes effect only if you set CallbackType to **HTTP**.
        self.auth_key = auth_key
        # Specifies whether to enable callback authentication. This parameter takes effect only if you set CallbackType to **HTTP**. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.auth_switch = auth_switch
        # The name of the Simple Message Queue (SMQ) queue in the region. The name must start with ice-callback-.
        self.callback_queue_name = callback_queue_name
        # The callback method. Valid values:
        # 
        # *   **HTTP**\
        # *   **MNS**\
        self.callback_type = callback_type
        # The callback URL. This parameter is required if you set CallbackType to **HTTP**. The callback URL cannot exceed 256 bytes in length. You can specify only one callback URL.
        self.callback_url = callback_url
        # The type of the callback event. You can specify multiple values separated with commas (,). ProduceMediaComplete: indicates that the editing and production task is complete.
        self.event_type_list = event_type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.auth_switch is not None:
            result['AuthSwitch'] = self.auth_switch
        if self.callback_queue_name is not None:
            result['CallbackQueueName'] = self.callback_queue_name
        if self.callback_type is not None:
            result['CallbackType'] = self.callback_type
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('AuthSwitch') is not None:
            self.auth_switch = m.get('AuthSwitch')
        if m.get('CallbackQueueName') is not None:
            self.callback_queue_name = m.get('CallbackQueueName')
        if m.get('CallbackType') is not None:
            self.callback_type = m.get('CallbackType')
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        return self


class SetEventCallbackResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the configuration was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetEventCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetEventCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetEventCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        audio_oss_path: str = None,
        callback_url: str = None,
        enable_audio_recording: bool = None,
        enable_notify: bool = None,
        event_types: str = None,
        token: str = None,
    ):
        # The ID of the AI agent.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.audio_oss_path = audio_oss_path
        # The URL for receiving callback notifications. By default, this parameter is left empty.
        self.callback_url = callback_url
        self.enable_audio_recording = enable_audio_recording
        # Specifies whether to enable event notifications.
        # 
        # This parameter is required.
        self.enable_notify = enable_notify
        # The event types. If you do not specify this parameter, all event types are selected.
        # 
        # *   agent_start
        # *   agent_stop
        # *   error
        self.event_types = event_types
        # The authentication token for callback. The token is carried in the Authorization header of a callback request. By default, this parameter is left empty.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.audio_oss_path is not None:
            result['AudioOssPath'] = self.audio_oss_path
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.enable_audio_recording is not None:
            result['EnableAudioRecording'] = self.enable_audio_recording
        if self.enable_notify is not None:
            result['EnableNotify'] = self.enable_notify
        if self.event_types is not None:
            result['EventTypes'] = self.event_types
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AudioOssPath') is not None:
            self.audio_oss_path = m.get('AudioOssPath')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('EnableAudioRecording') is not None:
            self.enable_audio_recording = m.get('EnableAudioRecording')
        if m.get('EnableNotify') is not None:
            self.enable_notify = m.get('EnableNotify')
        if m.get('EventTypes') is not None:
            self.event_types = m.get('EventTypes')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class SetNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartAIAgentInstanceRequestChatSyncConfig(TeaModel):
    def __init__(
        self,
        imaiagent_id: str = None,
        receiver_id: str = None,
    ):
        # IMId
        self.imaiagent_id = imaiagent_id
        # Id
        self.receiver_id = receiver_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.imaiagent_id is not None:
            result['IMAIAgentId'] = self.imaiagent_id
        if self.receiver_id is not None:
            result['ReceiverId'] = self.receiver_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IMAIAgentId') is not None:
            self.imaiagent_id = m.get('IMAIAgentId')
        if m.get('ReceiverId') is not None:
            self.receiver_id = m.get('ReceiverId')
        return self


class StartAIAgentInstanceRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        agent_config: AIAgentConfig = None,
        chat_sync_config: StartAIAgentInstanceRequestChatSyncConfig = None,
        runtime_config: AIAgentRuntimeConfig = None,
        session_id: str = None,
        template_config: AIAgentTemplateConfig = None,
        user_data: str = None,
    ):
        # The ID of the AI agent created in the [IMS](https://ims.console.aliyun.com/ai/robot/list) console.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.agent_config = agent_config
        # 
        self.chat_sync_config = chat_sync_config
        # This parameter is required.
        self.runtime_config = runtime_config
        self.session_id = session_id
        self.template_config = template_config
        self.user_data = user_data

    def validate(self):
        if self.agent_config:
            self.agent_config.validate()
        if self.chat_sync_config:
            self.chat_sync_config.validate()
        if self.runtime_config:
            self.runtime_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.agent_config is not None:
            result['AgentConfig'] = self.agent_config.to_map()
        if self.chat_sync_config is not None:
            result['ChatSyncConfig'] = self.chat_sync_config.to_map()
        if self.runtime_config is not None:
            result['RuntimeConfig'] = self.runtime_config.to_map()
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AgentConfig') is not None:
            temp_model = AIAgentConfig()
            self.agent_config = temp_model.from_map(m['AgentConfig'])
        if m.get('ChatSyncConfig') is not None:
            temp_model = StartAIAgentInstanceRequestChatSyncConfig()
            self.chat_sync_config = temp_model.from_map(m['ChatSyncConfig'])
        if m.get('RuntimeConfig') is not None:
            temp_model = AIAgentRuntimeConfig()
            self.runtime_config = temp_model.from_map(m['RuntimeConfig'])
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TemplateConfig') is not None:
            temp_model = AIAgentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class StartAIAgentInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        agent_config_shrink: str = None,
        chat_sync_config_shrink: str = None,
        runtime_config_shrink: str = None,
        session_id: str = None,
        template_config_shrink: str = None,
        user_data: str = None,
    ):
        # The ID of the AI agent created in the [IMS](https://ims.console.aliyun.com/ai/robot/list) console.
        # 
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.agent_config_shrink = agent_config_shrink
        # 
        self.chat_sync_config_shrink = chat_sync_config_shrink
        # This parameter is required.
        self.runtime_config_shrink = runtime_config_shrink
        self.session_id = session_id
        self.template_config_shrink = template_config_shrink
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.agent_config_shrink is not None:
            result['AgentConfig'] = self.agent_config_shrink
        if self.chat_sync_config_shrink is not None:
            result['ChatSyncConfig'] = self.chat_sync_config_shrink
        if self.runtime_config_shrink is not None:
            result['RuntimeConfig'] = self.runtime_config_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AgentConfig') is not None:
            self.agent_config_shrink = m.get('AgentConfig')
        if m.get('ChatSyncConfig') is not None:
            self.chat_sync_config_shrink = m.get('ChatSyncConfig')
        if m.get('RuntimeConfig') is not None:
            self.runtime_config_shrink = m.get('RuntimeConfig')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class StartAIAgentInstanceResponseBody(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        request_id: str = None,
    ):
        self.instance_id = instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartAIAgentInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartAIAgentInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartAIAgentInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartAIAgentOutboundCallRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        called_number: str = None,
        caller_number: str = None,
        config: AIAgentOutboundCallConfig = None,
        session_id: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        # This parameter is required.
        self.called_number = called_number
        # This parameter is required.
        self.caller_number = caller_number
        self.config = config
        self.session_id = session_id
        self.user_data = user_data

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.caller_number is not None:
            result['CallerNumber'] = self.caller_number
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CallerNumber') is not None:
            self.caller_number = m.get('CallerNumber')
        if m.get('Config') is not None:
            temp_model = AIAgentOutboundCallConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class StartAIAgentOutboundCallShrinkRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        called_number: str = None,
        caller_number: str = None,
        config_shrink: str = None,
        session_id: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        # This parameter is required.
        self.called_number = called_number
        # This parameter is required.
        self.caller_number = caller_number
        self.config_shrink = config_shrink
        self.session_id = session_id
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.caller_number is not None:
            result['CallerNumber'] = self.caller_number
        if self.config_shrink is not None:
            result['Config'] = self.config_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CallerNumber') is not None:
            self.caller_number = m.get('CallerNumber')
        if m.get('Config') is not None:
            self.config_shrink = m.get('Config')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class StartAIAgentOutboundCallResponseBody(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        request_id: str = None,
    ):
        self.instance_id = instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartAIAgentOutboundCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartAIAgentOutboundCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartAIAgentOutboundCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        return self


class StartChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
    ):
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class StartMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartRtcRobotInstanceRequestConfig(TeaModel):
    def __init__(
        self,
        asr_max_silence: int = None,
        enable_voice_interrupt: bool = None,
        greeting: str = None,
        use_voiceprint: bool = None,
        user_offline_timeout: int = None,
        user_online_timeout: int = None,
        voice_id: str = None,
        voiceprint_id: str = None,
        volume: int = None,
    ):
        self.asr_max_silence = asr_max_silence
        self.enable_voice_interrupt = enable_voice_interrupt
        self.greeting = greeting
        self.use_voiceprint = use_voiceprint
        self.user_offline_timeout = user_offline_timeout
        self.user_online_timeout = user_online_timeout
        self.voice_id = voice_id
        self.voiceprint_id = voiceprint_id
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_max_silence is not None:
            result['AsrMaxSilence'] = self.asr_max_silence
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.use_voiceprint is not None:
            result['UseVoiceprint'] = self.use_voiceprint
        if self.user_offline_timeout is not None:
            result['UserOfflineTimeout'] = self.user_offline_timeout
        if self.user_online_timeout is not None:
            result['UserOnlineTimeout'] = self.user_online_timeout
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        if self.voiceprint_id is not None:
            result['VoiceprintId'] = self.voiceprint_id
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrMaxSilence') is not None:
            self.asr_max_silence = m.get('AsrMaxSilence')
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('UseVoiceprint') is not None:
            self.use_voiceprint = m.get('UseVoiceprint')
        if m.get('UserOfflineTimeout') is not None:
            self.user_offline_timeout = m.get('UserOfflineTimeout')
        if m.get('UserOnlineTimeout') is not None:
            self.user_online_timeout = m.get('UserOnlineTimeout')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        if m.get('VoiceprintId') is not None:
            self.voiceprint_id = m.get('VoiceprintId')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class StartRtcRobotInstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        channel_id: str = None,
        config: StartRtcRobotInstanceRequestConfig = None,
        robot_id: str = None,
        user_data: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.auth_token = auth_token
        # This parameter is required.
        self.channel_id = channel_id
        self.config = config
        # This parameter is required.
        self.robot_id = robot_id
        self.user_data = user_data
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Config') is not None:
            temp_model = StartRtcRobotInstanceRequestConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartRtcRobotInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        channel_id: str = None,
        config_shrink: str = None,
        robot_id: str = None,
        user_data: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.auth_token = auth_token
        # This parameter is required.
        self.channel_id = channel_id
        self.config_shrink = config_shrink
        # This parameter is required.
        self.robot_id = robot_id
        self.user_data = user_data
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.config_shrink is not None:
            result['Config'] = self.config_shrink
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Config') is not None:
            self.config_shrink = m.get('Config')
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartRtcRobotInstanceResponseBody(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        request_id: str = None,
    ):
        self.instance_id = instance_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartRtcRobotInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartRtcRobotInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartRtcRobotInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartWorkflowRequest(TeaModel):
    def __init__(
        self,
        task_input: str = None,
        user_data: str = None,
        workflow_id: str = None,
    ):
        # The workflow input. Only media assets are supported.
        self.task_input = task_input
        # The user-defined data in the JSON format, which cannot be up to 512 bytes in length. You can specify a custom callback URL. For more information, see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data
        # The ID of the workflow template. To view the template ID, log on to the [IMS console](https://ims.console.aliyun.com/settings/workflow/list) and choose Configurations > Workflow Template.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_input is not None:
            result['TaskInput'] = self.task_input
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskInput') is not None:
            self.task_input = m.get('TaskInput')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class StartWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the workflow task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StartWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopAIAgentInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StopAIAgentInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopAIAgentInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopAIAgentInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopAIAgentInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
    ):
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        return self


class StopChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
    ):
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class StopMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopRtcRobotInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StopRtcRobotInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopRtcRobotInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopRtcRobotInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopRtcRobotInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAIAgentVideoAuditTaskRequestCallbackConfig(TeaModel):
    def __init__(
        self,
        token: str = None,
        url: str = None,
    ):
        self.token = token
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.token is not None:
            result['Token'] = self.token
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitAIAgentVideoAuditTaskRequestCapturePolicies(TeaModel):
    def __init__(
        self,
        duration: int = None,
        frame_count: int = None,
        prompt: str = None,
        start_time: int = None,
    ):
        self.duration = duration
        self.frame_count = frame_count
        self.prompt = prompt
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.frame_count is not None:
            result['FrameCount'] = self.frame_count
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FrameCount') is not None:
            self.frame_count = m.get('FrameCount')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitAIAgentVideoAuditTaskRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        self.media = media
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitAIAgentVideoAuditTaskRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        audit_interval: int = None,
        callback_config: SubmitAIAgentVideoAuditTaskRequestCallbackConfig = None,
        capture_policies: List[SubmitAIAgentVideoAuditTaskRequestCapturePolicies] = None,
        input: SubmitAIAgentVideoAuditTaskRequestInput = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.audit_interval = audit_interval
        self.callback_config = callback_config
        # This parameter is required.
        self.capture_policies = capture_policies
        # This parameter is required.
        self.input = input
        self.user_data = user_data

    def validate(self):
        if self.callback_config:
            self.callback_config.validate()
        if self.capture_policies:
            for k in self.capture_policies:
                if k:
                    k.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.audit_interval is not None:
            result['AuditInterval'] = self.audit_interval
        if self.callback_config is not None:
            result['CallbackConfig'] = self.callback_config.to_map()
        result['CapturePolicies'] = []
        if self.capture_policies is not None:
            for k in self.capture_policies:
                result['CapturePolicies'].append(k.to_map() if k else None)
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AuditInterval') is not None:
            self.audit_interval = m.get('AuditInterval')
        if m.get('CallbackConfig') is not None:
            temp_model = SubmitAIAgentVideoAuditTaskRequestCallbackConfig()
            self.callback_config = temp_model.from_map(m['CallbackConfig'])
        self.capture_policies = []
        if m.get('CapturePolicies') is not None:
            for k in m.get('CapturePolicies'):
                temp_model = SubmitAIAgentVideoAuditTaskRequestCapturePolicies()
                self.capture_policies.append(temp_model.from_map(k))
        if m.get('Input') is not None:
            temp_model = SubmitAIAgentVideoAuditTaskRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAIAgentVideoAuditTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        aiagent_id: str = None,
        audit_interval: int = None,
        callback_config_shrink: str = None,
        capture_policies_shrink: str = None,
        input_shrink: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.aiagent_id = aiagent_id
        self.audit_interval = audit_interval
        self.callback_config_shrink = callback_config_shrink
        # This parameter is required.
        self.capture_policies_shrink = capture_policies_shrink
        # This parameter is required.
        self.input_shrink = input_shrink
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aiagent_id is not None:
            result['AIAgentId'] = self.aiagent_id
        if self.audit_interval is not None:
            result['AuditInterval'] = self.audit_interval
        if self.callback_config_shrink is not None:
            result['CallbackConfig'] = self.callback_config_shrink
        if self.capture_policies_shrink is not None:
            result['CapturePolicies'] = self.capture_policies_shrink
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AIAgentId') is not None:
            self.aiagent_id = m.get('AIAgentId')
        if m.get('AuditInterval') is not None:
            self.audit_interval = m.get('AuditInterval')
        if m.get('CallbackConfig') is not None:
            self.callback_config_shrink = m.get('CallbackConfig')
        if m.get('CapturePolicies') is not None:
            self.capture_policies_shrink = m.get('CapturePolicies')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAIAgentVideoAuditTaskResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitAIAgentVideoAuditTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAIAgentVideoAuditTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAIAgentVideoAuditTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitASRJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        duration: str = None,
        editing_config: str = None,
        input_file: str = None,
        start_time: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # The job description, which can up to 128 bytes in length.
        self.description = description
        # The speech duration.
        self.duration = duration
        self.editing_config = editing_config
        # The input file. You can specify an Object Storage Service (OSS) URL or the ID of a media asset in the media asset library.
        self.input_file = input_file
        # The start time of the speech to recognize.
        self.start_time = start_time
        # The job title, which can be up to 128 bytes in length.
        self.title = title
        # The user-defined data in the JSON format. You can specify your business information, such as the business environment and job information.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitASRJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
        state: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id
        # The job state. Valid values:
        # 
        # *   Created
        # *   Executing
        # *   Finished
        # *   Failed
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitASRJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitASRJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitASRJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAudioProduceJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        editing_config: str = None,
        input_config: str = None,
        output_config: str = None,
        overwrite: bool = None,
        title: str = None,
        user_data: str = None,
    ):
        # The job description.
        # 
        # *   The job description can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.description = description
        # The audio editing configurations.
        # 
        # *   voice: the [voice type](https://help.aliyun.com/document_detail/449563.html).
        # *   customizedVoice: the ID of the personalized human voice.
        # *   format: the format of the output file. Valid values: PCM, WAV, and MP3.
        # *   volume: the volume. Default value: 50. Valid values: 0 to 100.
        # *   speech_rate: the speech tempo. Default value: 0. Value range: -500 to 500.
        # *   pitch_rate: the intonation. Default value: 0. Value range: -500 to 500.
        # 
        # >  If you specify both voice and customizedVoice, customizedVoice takes precedence over voice.
        # 
        # This parameter is required.
        self.editing_config = editing_config
        # The text content. A maximum of 2,000 characters are supported. The [Speech Synthesis Markup Language (SSML)](https://help.aliyun.com/document_detail/2672807.html) is supported.
        # 
        # This parameter is required.
        self.input_config = input_config
        # The output audio configurations.
        # 
        # This parameter is required.
        self.output_config = output_config
        # Specifies whether to overwrite the existing Object Storage Service (OSS) object.
        self.overwrite = overwrite
        # The job title. If you do not specify this parameter, the system generates a title based on the current date.
        # 
        # *   The job title can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.title = title
        # The user-defined data in the JSON format, which can be up to 512 bytes in length. You can specify a custom callback URL. For more information, see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAudioProduceJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
        request_id: str = None,
        state: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id
        # The job state. Valid values:
        # 
        # *   Created
        # *   Executing
        # *   Finished
        # *   Failed
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitAudioProduceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAudioProduceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAudioProduceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAvatarTrainingJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitAvatarTrainingJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitAvatarTrainingJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitAvatarTrainingJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitAvatarTrainingJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitAvatarTrainingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAvatarTrainingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAvatarTrainingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAvatarVideoJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        editing_config: str = None,
        input_config: str = None,
        output_config: str = None,
        title: str = None,
        user_data: str = None,
    ):
        self.description = description
        self.editing_config = editing_config
        # The input configurations of the video rendering job for an avatar. You can specify text, the Object Storage Service (OSS) URL of an audio file, or the ID of a media asset. The audio file must be in the MP3 or WAV format.
        # 
        # >  The text must be at least five words in length.
        self.input_config = input_config
        self.output_config = output_config
        self.title = title
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAvatarVideoJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.media_id = media_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitAvatarVideoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAvatarVideoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAvatarVideoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitBatchMediaProducingJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        editing_config: str = None,
        input_config: str = None,
        output_config: str = None,
        template_config: str = None,
        user_data: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The editing configurations. For more information, see [EditingConfig](~~2692547#1be9bba03b7qu~~).
        self.editing_config = editing_config
        # The input configurations. For more information, see [InputConfig](~~2692547#2faed1559549n~~).
        self.input_config = input_config
        # The output configurations. For more information, see [OutputConfig](~~2692547#447b928fcbuoa~~).
        self.output_config = output_config
        self.template_config = template_config
        # The user-defined data, including the business and callback configurations. For more information, see [UserData](https://help.aliyun.com/document_detail/357745.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitBatchMediaProducingJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the quick video production job.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitBatchMediaProducingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitBatchMediaProducingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitBatchMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCopyrightExtractJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitCopyrightExtractJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitCopyrightExtractJobRequestInput = None,
        params: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.input = input
        self.params = params
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.params is not None:
            result['Params'] = self.params
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitCopyrightExtractJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightExtractJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        params: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.input_shrink = input_shrink
        self.params = params
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.params is not None:
            result['Params'] = self.params
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitCopyrightExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCopyrightExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCopyrightExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitCopyrightExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCopyrightExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCopyrightExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCopyrightJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitCopyrightJobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitCopyrightJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        input: SubmitCopyrightJobRequestInput = None,
        level: int = None,
        message: str = None,
        output: SubmitCopyrightJobRequestOutput = None,
        params: str = None,
        start_time: int = None,
        total_time: int = None,
        user_data: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.input = input
        self.level = level
        # This parameter is required.
        self.message = message
        # This parameter is required.
        self.output = output
        self.params = params
        self.start_time = start_time
        self.total_time = total_time
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.params is not None:
            result['Params'] = self.params
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            temp_model = SubmitCopyrightJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = SubmitCopyrightJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightJobShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        input_shrink: str = None,
        level: int = None,
        message: str = None,
        output_shrink: str = None,
        params: str = None,
        start_time: int = None,
        total_time: int = None,
        user_data: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.input_shrink = input_shrink
        self.level = level
        # This parameter is required.
        self.message = message
        # This parameter is required.
        self.output_shrink = output_shrink
        self.params = params
        self.start_time = start_time
        self.total_time = total_time
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.params is not None:
            result['Params'] = self.params
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitCopyrightJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCopyrightJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCopyrightJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitCopyrightJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCopyrightJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCopyrightJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        demo_audio_media_url: str = None,
        voice_id: str = None,
    ):
        # The URL of the sample audio file.
        # 
        # *   If this parameter is specified, a sample audio file is generated at the specified Object Storage Service (OSS) URL after the training is complete.
        # 
        # *   If this parameter is not specified, no sample audio file is generated.
        # 
        #     **\
        # 
        #     **Note**: The URL must be a valid public OSS URL within your Alibaba Cloud account.
        self.demo_audio_media_url = demo_audio_media_url
        # The voice ID.
        # 
        # This parameter is required.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_audio_media_url is not None:
            result['DemoAudioMediaURL'] = self.demo_audio_media_url
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoAudioMediaURL') is not None:
            self.demo_audio_media_url = m.get('DemoAudioMediaURL')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class SubmitCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        voice_id: str = None,
    ):
        # The ID of the human voice cloning job.
        self.job_id = job_id
        # The voice ID.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class SubmitCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDNAJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. The file can be an OSS object or a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1\\. oss://bucket/object
        # 
        # 2\\. http(s)://bucket.oss-[regionId].aliyuncs.com/object
        # 
        # In the preceding paths, bucket indicates an OSS bucket that resides in the same region as the current project, and object indicates the path of the object in the bucket.
        # 
        # This parameter is required.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: Object Storage Service (OSS) object.
        # 2.  Media: media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitDNAJobRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        dbid: str = None,
        input: SubmitDNAJobRequestInput = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        primary_key: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The configurations of the media fingerprint analysis job. The value is a JSON object. If you specify this parameter, the template parameters are overwritten.
        self.config = config
        # The ID of the media fingerprint library. If you do not specify this parameter, the default media fingerprint library is used. For more information about how to create a media fingerprint library, see [CreateDNADB](https://help.aliyun.com/document_detail/479275.html).
        # 
        # This parameter is required.
        self.dbid = dbid
        # The input file for media fingerprint analysis.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the media fingerprint analysis job is submitted.
        self.pipeline_id = pipeline_id
        # The primary key of the video. You must make sure that each primary key is unique.
        # 
        # This parameter is required.
        self.primary_key = primary_key
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The template ID.
        self.template_id = template_id
        # The user-defined data. The data can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('Input') is not None:
            temp_model = SubmitDNAJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDNAJobShrinkRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        dbid: str = None,
        input_shrink: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        primary_key: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The configurations of the media fingerprint analysis job. The value is a JSON object. If you specify this parameter, the template parameters are overwritten.
        self.config = config
        # The ID of the media fingerprint library. If you do not specify this parameter, the default media fingerprint library is used. For more information about how to create a media fingerprint library, see [CreateDNADB](https://help.aliyun.com/document_detail/479275.html).
        # 
        # This parameter is required.
        self.dbid = dbid
        # The input file for media fingerprint analysis.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the media fingerprint analysis job is submitted.
        self.pipeline_id = pipeline_id
        # The primary key of the video. You must make sure that each primary key is unique.
        # 
        # This parameter is required.
        self.primary_key = primary_key
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The template ID.
        self.template_id = template_id
        # The user-defined data. The data can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.dbid is not None:
            result['DBId'] = self.dbid
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('DBId') is not None:
            self.dbid = m.get('DBId')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDNAJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media fingerprint analysis job. We recommend that you save this ID for subsequent calls of other operations.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitDNAJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitDNAJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDNAJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDynamicChartJobRequest(TeaModel):
    def __init__(
        self,
        axis_params: str = None,
        background: str = None,
        chart_config: str = None,
        chart_title: str = None,
        chart_type: str = None,
        data_source: str = None,
        description: str = None,
        input: str = None,
        output_config: str = None,
        subtitle: str = None,
        title: str = None,
        unit: str = None,
        user_data: str = None,
    ):
        # The axis configurations. If XAxisFontInterval is set to 0 or left empty, the system automatically determines an optimal interval.
        self.axis_params = axis_params
        # The chart background.
        self.background = background
        # The chart configurations.
        self.chart_config = chart_config
        # The chart title.
        self.chart_title = chart_title
        # The chart type.
        # 
        # Valid values:
        # 
        # *   Line: line chart
        # *   Histogram: bar chart
        # *   Pie: pie chart
        # 
        # This parameter is required.
        self.chart_type = chart_type
        # The data source.
        self.data_source = data_source
        # The job description.
        self.description = description
        # The input data for the chart.
        # 
        # This parameter is required.
        self.input = input
        # The output configurations.
        # 
        # This parameter is required.
        self.output_config = output_config
        # The subtitle.
        self.subtitle = subtitle
        # The job title.
        self.title = title
        # Unit
        self.unit = unit
        # The custom data in JSON format.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.axis_params is not None:
            result['AxisParams'] = self.axis_params
        if self.background is not None:
            result['Background'] = self.background
        if self.chart_config is not None:
            result['ChartConfig'] = self.chart_config
        if self.chart_title is not None:
            result['ChartTitle'] = self.chart_title
        if self.chart_type is not None:
            result['ChartType'] = self.chart_type
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.subtitle is not None:
            result['Subtitle'] = self.subtitle
        if self.title is not None:
            result['Title'] = self.title
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AxisParams') is not None:
            self.axis_params = m.get('AxisParams')
        if m.get('Background') is not None:
            self.background = m.get('Background')
        if m.get('ChartConfig') is not None:
            self.chart_config = m.get('ChartConfig')
        if m.get('ChartTitle') is not None:
            self.chart_title = m.get('ChartTitle')
        if m.get('ChartType') is not None:
            self.chart_type = m.get('ChartType')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Subtitle') is not None:
            self.subtitle = m.get('Subtitle')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicChartJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitDynamicChartJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitDynamicChartJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDynamicChartJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDynamicImageJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, set this parameter to the URL of an OSS object. If Type is set to Media, set this parameter to the ID of a media asset. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the Intelligent Media Services (IMS) console.
        # 
        # This parameter is required.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitDynamicImageJobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The output file. The file can be an OSS object or a media asset. The URL of an OSS object can be in one of the following formats:
        # 
        # *   oss://bucket/object
        # *   http(s)://bucket.oss-[regionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the IMS console.
        # 
        # This parameter is required.
        self.media = media
        # The type of the output file. Valid values:
        # 
        # 1.  OSS: an OSS object.
        # 2.  Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitDynamicImageJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority. Valid values: 1 to 10. Default value: 6. A greater value specifies a higher priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        end: str = None,
        seek: str = None,
    ):
        # The length of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        self.duration = duration
        # The length of the ending part of the original clip to be cropped out. If you specify this parameter, the Duration parameter becomes invalid.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        self.end = end
        # The start point of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end is not None:
            result['End'] = self.end
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class SubmitDynamicImageJobRequestTemplateConfigOverwriteParams(TeaModel):
    def __init__(
        self,
        format: str = None,
        fps: int = None,
        height: int = None,
        long_short_mode: bool = None,
        scan_mode: str = None,
        time_span: SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan = None,
        width: int = None,
    ):
        # The format of the animated image. Valid values:
        # 
        # *   **gif**\
        # *   **webp**\
        self.format = format
        # The frame rate. Valid values: [1,60].
        self.fps = fps
        # The height of the animated image. Valid values: [128,4096].
        self.height = height
        # Specifies whether to enable the auto-rotate screen feature. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # Default value: **true**.
        # 
        # >  If this feature is enabled, the width of the output video corresponds to the long side of the input video, which is the height of the input video in portrait mode. The height of the output video corresponds to the short side of the input video, which is the width of the input video in portrait mode.
        self.long_short_mode = long_short_mode
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive** This is the default value.
        self.scan_mode = scan_mode
        # The timeline parameters.
        self.time_span = time_span
        # The width of the animated image. Valid values: [128,4096].
        self.width = width

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('TimeSpan') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitDynamicImageJobRequestTemplateConfig(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitDynamicImageJobRequestTemplateConfigOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfigOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitDynamicImageJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitDynamicImageJobRequestInput = None,
        name: str = None,
        output: SubmitDynamicImageJobRequestOutput = None,
        schedule_config: SubmitDynamicImageJobRequestScheduleConfig = None,
        template_config: SubmitDynamicImageJobRequestTemplateConfig = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input = input
        # The name of the job.
        self.name = name
        # The output of the job.
        # 
        # This parameter is required.
        self.output = output
        # The scheduling settings.
        self.schedule_config = schedule_config
        # The snapshot template configuration.
        # 
        # This parameter is required.
        self.template_config = template_config
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitDynamicImageJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitDynamicImageJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitDynamicImageJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateConfig') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicImageJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        name: str = None,
        output_shrink: str = None,
        schedule_config_shrink: str = None,
        template_config_shrink: str = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        # The name of the job.
        self.name = name
        # The output of the job.
        # 
        # This parameter is required.
        self.output_shrink = output_shrink
        # The scheduling settings.
        self.schedule_config_shrink = schedule_config_shrink
        # The snapshot template configuration.
        # 
        # This parameter is required.
        self.template_config_shrink = template_config_shrink
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicImageJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitDynamicImageJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitDynamicImageJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDynamicImageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitHighlightExtractionJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        input_config: str = None,
        output_config: str = None,
        user_data: str = None,
    ):
        self.client_token = client_token
        self.input_config = input_config
        self.output_config = output_config
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitHighlightExtractionJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitHighlightExtractionJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitHighlightExtractionJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitHighlightExtractionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitIProductionJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. The file can be an OSS object or a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[regionId].aliyuncs.com/object bucket in the path specifies an OSS bucket that resides in the same region as the intelligent production job. object in the path specifies the object path in OSS.
        # 
        # This parameter is required.
        self.media = media
        # The media type. Valid values:
        # 
        # *   OSS: OSS object
        # *   Media: media asset
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitIProductionJobRequestOutput(TeaModel):
    def __init__(
        self,
        biz: str = None,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        self.biz = biz
        # The output file. If Type is set to OSS, set this parameter to the path of an OSS object. If Type is set to Media, set this parameter to the ID of a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object bucket in the path specifies an OSS bucket that resides in the same region as the intelligent production job. object in the path specifies the object path in OSS.
        # 
        # This parameter is required.
        self.media = media
        self.output_url = output_url
        # The media type. Valid values:
        # 
        # *   OSS: OSS object
        # *   Media: media asset
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitIProductionJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. A smaller value indicates a higher priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitIProductionJobRequest(TeaModel):
    def __init__(
        self,
        function_name: str = None,
        input: SubmitIProductionJobRequestInput = None,
        job_params: str = None,
        model_id: str = None,
        name: str = None,
        output: SubmitIProductionJobRequestOutput = None,
        schedule_config: SubmitIProductionJobRequestScheduleConfig = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The name of the algorithm that you want to use for the job. Valid values:
        # 
        # *   **Cover**: This algorithm intelligently generates a thumbnail image for a video.
        # *   **VideoClip**: This algorithm intelligently generates a summary for a video.
        # *   **VideoDelogo**: This algorithm removes logos from a video.
        # *   **VideoDetext**: This algorithm removes captions from a video.
        # *   **CaptionExtraction**: This algorithm extracts captions from a video and generates the caption file.
        # *   **VideoGreenScreenMatting**: This algorithm performs green-screen image matting on a video and generates a new video.
        # *   **FaceBeauty**: This algorithm performs video retouching.
        # *   **VideoH2V**: This algorithm transforms a video from the landscape mode to the portrait mode.
        # *   **MusicSegmentDetect**: This algorithm detects the chorus of a song.
        # *   **AudioBeatDetection**: This algorithm detects rhythms.
        # *   **AudioQualityAssessment**: This algorithm assesses the audio quality.
        # *   **SpeechDenoise**: This algorithm performs noise reduction.
        # *   **AudioMixing**: This algorithm mixes audio streams.
        # 
        # This parameter is required.
        self.function_name = function_name
        # The input file. The file can be an Object Storage Service (OSS) object or a media asset.
        # 
        # This parameter is required.
        self.input = input
        # The algorithm-specific parameters. The parameters are specified as JSON objects and vary based on the algorithm. For more information, see the "Parameters of JobParams" section of this topic.
        self.job_params = job_params
        self.model_id = model_id
        # The name of the intelligent production job. The name can be up to 100 characters in length.
        self.name = name
        # The output file. The file can be an OSS object or a media asset.
        # 
        # This parameter is required.
        self.output = output
        # The scheduling configuration.
        self.schedule_config = schedule_config
        # The template ID.
        self.template_id = template_id
        # The user-defined data that is returned in the response. The value can be up to 1,024 bytes in length.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            temp_model = SubmitIProductionJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitIProductionJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitIProductionJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitIProductionJobShrinkRequest(TeaModel):
    def __init__(
        self,
        function_name: str = None,
        input_shrink: str = None,
        job_params: str = None,
        model_id: str = None,
        name: str = None,
        output_shrink: str = None,
        schedule_config_shrink: str = None,
        template_id: str = None,
        user_data: str = None,
    ):
        # The name of the algorithm that you want to use for the job. Valid values:
        # 
        # *   **Cover**: This algorithm intelligently generates a thumbnail image for a video.
        # *   **VideoClip**: This algorithm intelligently generates a summary for a video.
        # *   **VideoDelogo**: This algorithm removes logos from a video.
        # *   **VideoDetext**: This algorithm removes captions from a video.
        # *   **CaptionExtraction**: This algorithm extracts captions from a video and generates the caption file.
        # *   **VideoGreenScreenMatting**: This algorithm performs green-screen image matting on a video and generates a new video.
        # *   **FaceBeauty**: This algorithm performs video retouching.
        # *   **VideoH2V**: This algorithm transforms a video from the landscape mode to the portrait mode.
        # *   **MusicSegmentDetect**: This algorithm detects the chorus of a song.
        # *   **AudioBeatDetection**: This algorithm detects rhythms.
        # *   **AudioQualityAssessment**: This algorithm assesses the audio quality.
        # *   **SpeechDenoise**: This algorithm performs noise reduction.
        # *   **AudioMixing**: This algorithm mixes audio streams.
        # 
        # This parameter is required.
        self.function_name = function_name
        # The input file. The file can be an Object Storage Service (OSS) object or a media asset.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        # The algorithm-specific parameters. The parameters are specified as JSON objects and vary based on the algorithm. For more information, see the "Parameters of JobParams" section of this topic.
        self.job_params = job_params
        self.model_id = model_id
        # The name of the intelligent production job. The name can be up to 100 characters in length.
        self.name = name
        # The output file. The file can be an OSS object or a media asset.
        # 
        # This parameter is required.
        self.output_shrink = output_shrink
        # The scheduling configuration.
        self.schedule_config_shrink = schedule_config_shrink
        # The template ID.
        self.template_id = template_id
        # The user-defined data that is returned in the response. The value can be up to 1,024 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitIProductionJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the intelligent production job.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitIProductionJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitIProductionJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitLiveEditingJobRequest(TeaModel):
    def __init__(
        self,
        clips: str = None,
        live_stream_config: str = None,
        media_produce_config: str = None,
        output_media_config: str = None,
        output_media_target: str = None,
        project_id: str = None,
        user_data: str = None,
    ):
        # The clips in the JSON array format. The output video is created by merging these clips sequentially.
        # 
        # Each clip has a start time and an end time. If no live stream parameters are specified, the outer live stream configurations apply. The start and end timestamps are in UTC. For more information about the parameters, see the "Clip" section of this topic.
        # 
        # This parameter is required.
        self.clips = clips
        # The live stream configurations, in the JSON format. The configurations must include the following parameters:
        # 
        # *   AppName: the name of the application to which the live stream belongs.
        # *   DomainName: the domain name of the application.
        # *   StreamName: the name of the live stream.
        self.live_stream_config = live_stream_config
        # The production configurations, in the JSON format. Mode specifies the editing mode. Valid values:
        # 
        # *   **AccurateFast** (default): fast editing. It is faster than the Accurate mode. The resolution of the output file is the same as that of the source stream. You cannot specify the width and height of the output file.
        # *   **Accurate**: accurate editing. In this mode, you can specify the width and height of the output file.
        # *   **Rough**: rough editing. The minimum precision is one TS segment. The output file comprises all segments within the specified time range. You can specify the width and height of the output file.
        # *   **RoughFast**: fast rough editing. It is faster than the Accurate mode. The minimum precision is one TS segment. The output file comprises all segments within the specified time range. The resolution of the output file is the same as that of the source stream. You cannot specify the width and height of the output file.
        self.media_produce_config = media_produce_config
        # The configurations of the output file, in the JSON format. You can specify an OSS URL or a storage location in a storage bucket of ApsaraVideo VOD.
        # 
        # *   To store the output file in OSS, you must specify MediaURL.
        # *   To store the output file in ApsaraVideo VOD, you must specify StorageLocation and FileName.
        self.output_media_config = output_media_config
        # The type of the output file. Valid values:
        # 
        # *   oss-object: OSS object in an OSS bucket.
        # *   vod-media: media asset in Alibaba Cloud VOD.
        self.output_media_target = output_media_target
        # The ID of the live editing project. If this parameter is specified, the system reads the storage configurations of the project. If this parameter is not specified, the specified storage configurations take precedence.
        self.project_id = project_id
        # The user-defined data in the JSON format, which can be up to 512 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips
        if self.live_stream_config is not None:
            result['LiveStreamConfig'] = self.live_stream_config
        if self.media_produce_config is not None:
            result['MediaProduceConfig'] = self.media_produce_config
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.output_media_target is not None:
            result['OutputMediaTarget'] = self.output_media_target
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clips') is not None:
            self.clips = m.get('Clips')
        if m.get('LiveStreamConfig') is not None:
            self.live_stream_config = m.get('LiveStreamConfig')
        if m.get('MediaProduceConfig') is not None:
            self.media_produce_config = m.get('MediaProduceConfig')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('OutputMediaTarget') is not None:
            self.output_media_target = m.get('OutputMediaTarget')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitLiveEditingJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
        media_url: str = None,
        project_id: str = None,
        request_id: str = None,
        vod_media_id: str = None,
    ):
        # The ID of the live editing job.
        self.job_id = job_id
        # The media asset ID of the output file.
        self.media_id = media_id
        # The URL of the output file.
        self.media_url = media_url
        # The ID of the live editing project.
        self.project_id = project_id
        # The request ID.
        self.request_id = request_id
        # The media asset ID of the output file in ApsaraVideo VOD if the output file is stored in ApsaraVideo VOD.
        self.vod_media_id = vod_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vod_media_id is not None:
            result['VodMediaId'] = self.vod_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VodMediaId') is not None:
            self.vod_media_id = m.get('VodMediaId')
        return self


class SubmitLiveEditingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitLiveEditingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitLiveEditingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitLiveRecordJobRequestRecordOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        type: str = None,
    ):
        # The bucket name.
        self.bucket = bucket
        # The endpoint of the storage service.
        self.endpoint = endpoint
        # The type of the storage address.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitLiveRecordJobRequestStreamInput(TeaModel):
    def __init__(
        self,
        type: str = None,
        url: str = None,
    ):
        # The type of the live stream URL. The value can only be rtmp.
        # 
        # This parameter is required.
        self.type = type
        # The URL of the live stream.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitLiveRecordJobRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_url: str = None,
        record_output: SubmitLiveRecordJobRequestRecordOutput = None,
        stream_input: SubmitLiveRecordJobRequestStreamInput = None,
        template_id: str = None,
    ):
        # The name of the recording job.
        # 
        # This parameter is required.
        self.name = name
        # The callback URL.
        self.notify_url = notify_url
        # The storage address of the recording.
        # 
        # This parameter is required.
        self.record_output = record_output
        # The URL of the live stream.
        # 
        # This parameter is required.
        self.stream_input = stream_input
        # The ID of the recording template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.record_output:
            self.record_output.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_output is not None:
            result['RecordOutput'] = self.record_output.to_map()
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordOutput') is not None:
            temp_model = SubmitLiveRecordJobRequestRecordOutput()
            self.record_output = temp_model.from_map(m['RecordOutput'])
        if m.get('StreamInput') is not None:
            temp_model = SubmitLiveRecordJobRequestStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitLiveRecordJobShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_url: str = None,
        record_output_shrink: str = None,
        stream_input_shrink: str = None,
        template_id: str = None,
    ):
        # The name of the recording job.
        # 
        # This parameter is required.
        self.name = name
        # The callback URL.
        self.notify_url = notify_url
        # The storage address of the recording.
        # 
        # This parameter is required.
        self.record_output_shrink = record_output_shrink
        # The URL of the live stream.
        # 
        # This parameter is required.
        self.stream_input_shrink = stream_input_shrink
        # The ID of the recording template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_output_shrink is not None:
            result['RecordOutput'] = self.record_output_shrink
        if self.stream_input_shrink is not None:
            result['StreamInput'] = self.stream_input_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordOutput') is not None:
            self.record_output_shrink = m.get('RecordOutput')
        if m.get('StreamInput') is not None:
            self.stream_input_shrink = m.get('StreamInput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitLiveRecordJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the recording job.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitLiveRecordJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitLiveRecordJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitLiveRecordJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitLiveSnapshotJobRequestSnapshotOutput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        endpoint: str = None,
        storage_type: str = None,
    ):
        # The bucket of the snapshot output endpoint.
        # 
        # This parameter is required.
        self.bucket = bucket
        # The output endpoint of the snapshot.
        # 
        # This parameter is required.
        self.endpoint = endpoint
        # The storage type of the snapshot. The value can only be oss.
        # 
        # This parameter is required.
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class SubmitLiveSnapshotJobRequestStreamInput(TeaModel):
    def __init__(
        self,
        type: str = None,
        url: str = None,
    ):
        # The type of the input stream. The value can only be rtmp.
        # 
        # This parameter is required.
        self.type = type
        # The URL of the input stream.
        # 
        # *   It cannot exceed 255 characters in length.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitLiveSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        job_name: str = None,
        snapshot_output: SubmitLiveSnapshotJobRequestSnapshotOutput = None,
        stream_input: SubmitLiveSnapshotJobRequestStreamInput = None,
        template_id: str = None,
    ):
        # The snapshot callback URL.
        # 
        # *   It cannot exceed 255 characters in length.
        # *   Both HTTP and HTTPS URLs are supported.
        self.callback_url = callback_url
        # The name of the job.
        # 
        # *   It cannot exceed 128 characters in length.
        # 
        # This parameter is required.
        self.job_name = job_name
        # The information about the output snapshot.
        # 
        # This parameter is required.
        self.snapshot_output = snapshot_output
        # The information about the input stream.
        # 
        # This parameter is required.
        self.stream_input = stream_input
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.snapshot_output:
            self.snapshot_output.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.snapshot_output is not None:
            result['SnapshotOutput'] = self.snapshot_output.to_map()
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('SnapshotOutput') is not None:
            temp_model = SubmitLiveSnapshotJobRequestSnapshotOutput()
            self.snapshot_output = temp_model.from_map(m['SnapshotOutput'])
        if m.get('StreamInput') is not None:
            temp_model = SubmitLiveSnapshotJobRequestStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitLiveSnapshotJobShrinkRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        job_name: str = None,
        snapshot_output_shrink: str = None,
        stream_input_shrink: str = None,
        template_id: str = None,
    ):
        # The snapshot callback URL.
        # 
        # *   It cannot exceed 255 characters in length.
        # *   Both HTTP and HTTPS URLs are supported.
        self.callback_url = callback_url
        # The name of the job.
        # 
        # *   It cannot exceed 128 characters in length.
        # 
        # This parameter is required.
        self.job_name = job_name
        # The information about the output snapshot.
        # 
        # This parameter is required.
        self.snapshot_output_shrink = snapshot_output_shrink
        # The information about the input stream.
        # 
        # This parameter is required.
        self.stream_input_shrink = stream_input_shrink
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.snapshot_output_shrink is not None:
            result['SnapshotOutput'] = self.snapshot_output_shrink
        if self.stream_input_shrink is not None:
            result['StreamInput'] = self.stream_input_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('SnapshotOutput') is not None:
            self.snapshot_output_shrink = m.get('SnapshotOutput')
        if m.get('StreamInput') is not None:
            self.stream_input_shrink = m.get('StreamInput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitLiveSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitLiveSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitLiveSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitLiveSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitLiveTranscodeJobRequestStreamInput(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        type: str = None,
    ):
        # The URL of the input stream.
        # 
        # This parameter is required.
        self.input_url = input_url
        # The type of the input stream. The value can only be rtmp.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitLiveTranscodeJobRequestTimedConfig(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
    ):
        # The stop time of the transcoding job. Note: The time span between the stop time and the current time cannot exceed seven days.
        self.end_time = end_time
        # The start time of the transcoding job. Note: The time span between the start time and the current time cannot exceed seven days.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitLiveTranscodeJobRequestTranscodeOutput(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        type: str = None,
    ):
        # The streaming domain name of ApsaraVideo Live.
        self.domain_name = domain_name
        # The type of the output stream. A value of LiveCenter indicates that the URL of the output stream is generated based on the domain name of ApsaraVideo Live. The value can only be LiveCenter.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitLiveTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        start_mode: int = None,
        stream_input: SubmitLiveTranscodeJobRequestStreamInput = None,
        template_id: str = None,
        timed_config: SubmitLiveTranscodeJobRequestTimedConfig = None,
        transcode_output: SubmitLiveTranscodeJobRequestTranscodeOutput = None,
    ):
        # The name of the transcoding job.
        # 
        # This parameter is required.
        self.name = name
        # The start mode of the transcoding job.
        # 
        # *   0: The transcoding job immediately starts.
        # *   1: The transcoding job starts at the scheduled time.
        # 
        # This parameter is required.
        self.start_mode = start_mode
        # The information about the input stream.
        # 
        # This parameter is required.
        self.stream_input = stream_input
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The configuration of a timed transcoding job. This parameter is required if you set StartMode to 1.
        self.timed_config = timed_config
        # The information about the transcoding output.
        # 
        # This parameter is required.
        self.transcode_output = transcode_output

    def validate(self):
        if self.stream_input:
            self.stream_input.validate()
        if self.timed_config:
            self.timed_config.validate()
        if self.transcode_output:
            self.transcode_output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timed_config is not None:
            result['TimedConfig'] = self.timed_config.to_map()
        if self.transcode_output is not None:
            result['TranscodeOutput'] = self.transcode_output.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('StreamInput') is not None:
            temp_model = SubmitLiveTranscodeJobRequestStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TimedConfig') is not None:
            temp_model = SubmitLiveTranscodeJobRequestTimedConfig()
            self.timed_config = temp_model.from_map(m['TimedConfig'])
        if m.get('TranscodeOutput') is not None:
            temp_model = SubmitLiveTranscodeJobRequestTranscodeOutput()
            self.transcode_output = temp_model.from_map(m['TranscodeOutput'])
        return self


class SubmitLiveTranscodeJobShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        start_mode: int = None,
        stream_input_shrink: str = None,
        template_id: str = None,
        timed_config_shrink: str = None,
        transcode_output_shrink: str = None,
    ):
        # The name of the transcoding job.
        # 
        # This parameter is required.
        self.name = name
        # The start mode of the transcoding job.
        # 
        # *   0: The transcoding job immediately starts.
        # *   1: The transcoding job starts at the scheduled time.
        # 
        # This parameter is required.
        self.start_mode = start_mode
        # The information about the input stream.
        # 
        # This parameter is required.
        self.stream_input_shrink = stream_input_shrink
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The configuration of a timed transcoding job. This parameter is required if you set StartMode to 1.
        self.timed_config_shrink = timed_config_shrink
        # The information about the transcoding output.
        # 
        # This parameter is required.
        self.transcode_output_shrink = transcode_output_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.stream_input_shrink is not None:
            result['StreamInput'] = self.stream_input_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timed_config_shrink is not None:
            result['TimedConfig'] = self.timed_config_shrink
        if self.transcode_output_shrink is not None:
            result['TranscodeOutput'] = self.transcode_output_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('StreamInput') is not None:
            self.stream_input_shrink = m.get('StreamInput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TimedConfig') is not None:
            self.timed_config_shrink = m.get('TimedConfig')
        if m.get('TranscodeOutput') is not None:
            self.transcode_output_shrink = m.get('TranscodeOutput')
        return self


class SubmitLiveTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the transcoding job.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitLiveTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitLiveTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaAiAnalysisJobRequest(TeaModel):
    def __init__(
        self,
        analysis_params: str = None,
        input: str = None,
        user_data: str = None,
    ):
        # The analysis parameters.
        self.analysis_params = analysis_params
        # The media asset that you want to analyze. You can specify an Object Storage Service (OSS) URL, a media asset ID, or an external URL.
        self.input = input
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_params is not None:
            result['AnalysisParams'] = self.analysis_params
        if self.input is not None:
            result['Input'] = self.input
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisParams') is not None:
            self.analysis_params = m.get('AnalysisParams')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaAiAnalysisJobResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaAiAnalysisJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaAiAnalysisJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaAiAnalysisJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaCensorJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. The file can be an OSS object or a media asset. You can specify the path of an OSS object in one of the following formats:
        # 
        # 1\\. oss://bucket/object
        # 
        # 2\\. http(s)://bucket.oss-[regionId].aliyuncs.com/object
        # 
        # In the preceding paths, bucket indicates an OSS bucket that resides in the same region as the current project, and object indicates the path of the object in the bucket.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # OSS: OSS object.
        # 
        # Media: media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaCensorJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job is submitted.
        self.pipeline_id = pipeline_id
        # The job priority. A larger value indicates a higher priority. Valid values: 1 to 10.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaCensorJobRequest(TeaModel):
    def __init__(
        self,
        barrages: str = None,
        cover_images: str = None,
        description: str = None,
        input: SubmitMediaCensorJobRequestInput = None,
        notify_url: str = None,
        output: str = None,
        schedule_config: SubmitMediaCensorJobRequestScheduleConfig = None,
        template_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # The live comments of the video.
        # 
        # >  If this parameter is specified, the system checks the live comments specified by this parameter instead of the live comments of the input file specified by Media.
        self.barrages = barrages
        # The Object Storage Service (OSS) objects that are used as the thumbnails. Specify the thumbnails in a JSON array. A maximum of five thumbnails are supported.
        # 
        # >  If this parameter is specified, the system checks the thumbnails specified by this parameter instead of the thumbnails of the input file specified by **Media**.
        self.cover_images = cover_images
        # The video description, which can be up to 128 bytes in length.
        # 
        # >  If this parameter is specified, the system checks the description specified by this parameter instead of the description of the input file specified by Media.
        self.description = description
        # The information about the file to be moderated.
        self.input = input
        # The callback URL. Simple Message Queue (SMQ, formerly MNS) and HTTP callbacks are supported.
        self.notify_url = notify_url
        # The output snapshots. The moderation job generates output snapshots and the result JSON file in the path corresponding to the input file.
        # 
        # *   File name format of output snapshots: oss://bucket/snapshot-{Count}.jpg. In the path, bucket indicates an OSS bucket that resides in the same region as the current project, and {Count} is the sequence number of the snapshot.
        # *   The detailed moderation results are stored in the {jobId}.output file in the same OSS folder as the output snapshots. For more information about the parameters in the output file, see [Output parameters of media moderation jobs](https://help.aliyun.com/document_detail/609211.html).
        self.output = output
        # The scheduling configurations.
        self.schedule_config = schedule_config
        # The template ID. If this parameter is not specified, the default template is used for moderation.
        self.template_id = template_id
        # The video title, which can be up to 64 bytes in length.
        # 
        # >  If this parameter is specified, the system checks the title specified by this parameter instead of the title of the input file specified by Media.
        self.title = title
        # The user-defined data, which can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrages is not None:
            result['Barrages'] = self.barrages
        if self.cover_images is not None:
            result['CoverImages'] = self.cover_images
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.output is not None:
            result['Output'] = self.output
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Barrages') is not None:
            self.barrages = m.get('Barrages')
        if m.get('CoverImages') is not None:
            self.cover_images = m.get('CoverImages')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            temp_model = SubmitMediaCensorJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaCensorJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaCensorJobShrinkRequest(TeaModel):
    def __init__(
        self,
        barrages: str = None,
        cover_images: str = None,
        description: str = None,
        input_shrink: str = None,
        notify_url: str = None,
        output: str = None,
        schedule_config_shrink: str = None,
        template_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # The live comments of the video.
        # 
        # >  If this parameter is specified, the system checks the live comments specified by this parameter instead of the live comments of the input file specified by Media.
        self.barrages = barrages
        # The Object Storage Service (OSS) objects that are used as the thumbnails. Specify the thumbnails in a JSON array. A maximum of five thumbnails are supported.
        # 
        # >  If this parameter is specified, the system checks the thumbnails specified by this parameter instead of the thumbnails of the input file specified by **Media**.
        self.cover_images = cover_images
        # The video description, which can be up to 128 bytes in length.
        # 
        # >  If this parameter is specified, the system checks the description specified by this parameter instead of the description of the input file specified by Media.
        self.description = description
        # The information about the file to be moderated.
        self.input_shrink = input_shrink
        # The callback URL. Simple Message Queue (SMQ, formerly MNS) and HTTP callbacks are supported.
        self.notify_url = notify_url
        # The output snapshots. The moderation job generates output snapshots and the result JSON file in the path corresponding to the input file.
        # 
        # *   File name format of output snapshots: oss://bucket/snapshot-{Count}.jpg. In the path, bucket indicates an OSS bucket that resides in the same region as the current project, and {Count} is the sequence number of the snapshot.
        # *   The detailed moderation results are stored in the {jobId}.output file in the same OSS folder as the output snapshots. For more information about the parameters in the output file, see [Output parameters of media moderation jobs](https://help.aliyun.com/document_detail/609211.html).
        self.output = output
        # The scheduling configurations.
        self.schedule_config_shrink = schedule_config_shrink
        # The template ID. If this parameter is not specified, the default template is used for moderation.
        self.template_id = template_id
        # The video title, which can be up to 64 bytes in length.
        # 
        # >  If this parameter is specified, the system checks the title specified by this parameter instead of the title of the input file specified by Media.
        self.title = title
        # The user-defined data, which can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrages is not None:
            result['Barrages'] = self.barrages
        if self.cover_images is not None:
            result['CoverImages'] = self.cover_images
        if self.description is not None:
            result['Description'] = self.description
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.output is not None:
            result['Output'] = self.output
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Barrages') is not None:
            self.barrages = m.get('Barrages')
        if m.get('CoverImages') is not None:
            self.cover_images = m.get('CoverImages')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaCensorJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the content moderation job. We recommend that you save this ID for subsequent calls of other operations.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaCensorJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaCensorJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaCensorJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaConvertJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        config: str = None,
        pipeline_id: str = None,
        user_data: str = None,
    ):
        # The idempotency key that is used to ensure repeated requests have the same effect as a single request.
        self.client_token = client_token
        # The configurations of the transcoding task.
        # 
        # This parameter is required.
        self.config = config
        # The ID of the queue.
        self.pipeline_id = pipeline_id
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config is not None:
            result['Config'] = self.config
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaConvertJobResponseBodyJobConfig(TeaModel):
    def __init__(
        self,
        inputs: List[MediaConvertInput] = None,
        output_groups: List[MediaConvertOutputGroup] = None,
        outputs: List[MediaConvertOutput] = None,
    ):
        # The inputs of the transcoding task.
        self.inputs = inputs
        # The output group configurations.
        self.output_groups = output_groups
        # The output configurations.
        self.outputs = outputs

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = MediaConvertInput()
                self.inputs.append(temp_model.from_map(k))
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = MediaConvertOutputGroup()
                self.output_groups.append(temp_model.from_map(k))
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = MediaConvertOutput()
                self.outputs.append(temp_model.from_map(k))
        return self


class SubmitMediaConvertJobResponseBodyJob(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        code: str = None,
        config: SubmitMediaConvertJobResponseBodyJobConfig = None,
        job_id: str = None,
        message: str = None,
        output_details: List[MediaConvertOutputDetail] = None,
        output_group_details: List[MediaConvertOutputGroupDetail] = None,
        pipeline_id: str = None,
        request_id: str = None,
        state: str = None,
        user_data: str = None,
    ):
        # The idempotency key of the request for creating the transcoding task.
        self.client_token = client_token
        # The error code returned when the transcoding task failed.
        self.code = code
        # The configurations of the transcoding task.
        self.config = config
        # The ID of the transcoding task.
        self.job_id = job_id
        # The error message returned when the transcoding task failed.
        self.message = message
        # The details of the transcoded outputs.
        self.output_details = output_details
        # The details of the output groups.
        self.output_group_details = output_group_details
        # The ID of the queue.
        self.pipeline_id = pipeline_id
        # The ID of the request.
        self.request_id = request_id
        # The status of the transcoding task. Valid values:
        # 
        # *   Inited: The task is initialized.
        # *   Running
        # *   Success
        # *   Failed
        # *   Cancelled
        self.state = state
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.config:
            self.config.validate()
        if self.output_details:
            for k in self.output_details:
                if k:
                    k.validate()
        if self.output_group_details:
            for k in self.output_group_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.code is not None:
            result['Code'] = self.code
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        result['OutputDetails'] = []
        if self.output_details is not None:
            for k in self.output_details:
                result['OutputDetails'].append(k.to_map() if k else None)
        result['OutputGroupDetails'] = []
        if self.output_group_details is not None:
            for k in self.output_group_details:
                result['OutputGroupDetails'].append(k.to_map() if k else None)
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Config') is not None:
            temp_model = SubmitMediaConvertJobResponseBodyJobConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        self.output_details = []
        if m.get('OutputDetails') is not None:
            for k in m.get('OutputDetails'):
                temp_model = MediaConvertOutputDetail()
                self.output_details.append(temp_model.from_map(k))
        self.output_group_details = []
        if m.get('OutputGroupDetails') is not None:
            for k in m.get('OutputGroupDetails'):
                temp_model = MediaConvertOutputGroupDetail()
                self.output_group_details.append(temp_model.from_map(k))
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaConvertJobResponseBody(TeaModel):
    def __init__(
        self,
        job: SubmitMediaConvertJobResponseBodyJob = None,
        request_id: str = None,
    ):
        # The transcoding task.
        self.job = job
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Job') is not None:
            temp_model = SubmitMediaConvertJobResponseBodyJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaConvertJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaConvertJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaConvertJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaInfoJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the Intelligent Media Services (IMS) console.
        # 
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The type of the media object. Valid values: OSS and Media. A value of OSS indicates an Object Storage Service (OSS) object. A value of Media indicates a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaInfoJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaInfoJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitMediaInfoJobRequestInput = None,
        name: str = None,
        schedule_config: SubmitMediaInfoJobRequestScheduleConfig = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input = input
        # The job name.
        self.name = name
        # The scheduling parameters.
        self.schedule_config = schedule_config
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaInfoJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        name: str = None,
        schedule_config_shrink: str = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        # The job name.
        self.name = name
        # The scheduling parameters.
        self.schedule_config_shrink = schedule_config_shrink
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, the URL of an OSS object is returned. Both the OSS and HTTP protocols are supported. If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values: OSS and Media. A value of OSS indicates an OSS object. A value of Media indicates a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sample format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size.
        self.file_size = file_size
        # The state of the file.
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height of the output video.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the file.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height of the output video.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList] = None,
        file_basic_info: SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo = None,
        video_stream_info_list: List[SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        finish_time: str = None,
        input: SubmitMediaInfoJobResponseBodyMediaInfoJobInput = None,
        job_id: str = None,
        media_info_property: SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty = None,
        name: str = None,
        request_id: str = None,
        schedule_config: SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # Indicates whether asynchronous processing was performed.
        self.async_ = async_
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The details of the media information.
        self.media_info_property = media_info_property
        # The job name.
        self.name = name
        # The request ID.
        self.request_id = request_id
        # The scheduling information.
        self.schedule_config = schedule_config
        # The state of the job. Valid values: Init (the job is submitted), Success (the job is successful), and Fail (the job failed).
        self.status = status
        # The job submission information.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The source of the job. Valid values: API, WorkFlow, and Console.
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job: SubmitMediaInfoJobResponseBodyMediaInfoJob = None,
        request_id: str = None,
    ):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaInfoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaInfoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaProducingJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        clips_param: str = None,
        editing_produce_config: str = None,
        media_metadata: str = None,
        output_media_config: str = None,
        output_media_target: str = None,
        project_id: str = None,
        project_metadata: str = None,
        source: str = None,
        template_id: str = None,
        timeline: str = None,
        user_data: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The material parameters of the template, in the JSON format. If TemplateId is specified, ClipsParam must also be specified. For more information, see [Create and use a regular template](https://help.aliyun.com/document_detail/445399.html) and [Create and use advanced templates](https://help.aliyun.com/document_detail/445389.html).
        self.clips_param = clips_param
        # The parameters for editing and production. For more information, see [EditingProduceConfig](https://help.aliyun.com/document_detail/357745.html).
        # 
        # >  If no thumbnail is specified in EditingProduceConfig, the first frame of the video is used as the thumbnail.
        # 
        # *   AutoRegisterInputVodMedia: specifies whether to automatically register the ApsaraVideo VOD media assets in your timeline with IMS. Default value: true.
        # *   OutputWebmTransparentChannel: specifies whether the output video contains alpha channels. Default value: false.
        # *   CoverConfig: the custom thumbnail parameters.
        # *\
        self.editing_produce_config = editing_produce_config
        # The metadata of the produced video, in the JSON format. For more information about the parameters, see [MediaMetadata](https://help.aliyun.com/document_detail/357745.html).
        self.media_metadata = media_metadata
        # The configurations of the output file, in the JSON format. You can specify an OSS URL or a storage location in a storage bucket of ApsaraVideo VOD.
        # 
        # To store the output file in OSS, you must specify MediaURL. To store the output file in ApsaraVideo VOD, you must specify StorageLocation and FileName.
        # 
        # For more information, see [OutputMediaConfig](https://help.aliyun.com/document_detail/357745.html).
        # 
        # This parameter is required.
        self.output_media_config = output_media_config
        # The type of the output file. Valid values:
        # 
        # *   oss-object: OSS object in an OSS bucket.
        # *   vod-media: media asset in ApsaraVideo VOD.
        # *   S3: output file based on the Amazon Simple Storage Service (S3) protocol.
        self.output_media_target = output_media_target
        # The ID of the editing project.
        # 
        # > : You must specify one of ProgectId, Timeline, and TempalteId and leave the other two parameters empty.
        self.project_id = project_id
        # The metadata of the editing project, in the JSON format. For more information about the parameters, see [ProjectMetadata](https://help.aliyun.com/document_detail/357745.html).
        self.project_metadata = project_metadata
        # The source of the editing and production request. Valid values:
        # 
        # *   OpenAPI
        # *   AliyunConsole
        # *   WebSDK
        self.source = source
        # The template ID. The template is used to build a timeline with ease.
        # 
        # > : You must specify one of ProgectId, Timeline, and TempalteId and leave the other two parameters empty. If TemplateId is specified, ClipsParam must also be specified.
        self.template_id = template_id
        self.timeline = timeline
        # The user-defined data in the JSON format, which can be up to 512 bytes in length. You can specify a custom callback URL. For more information, see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.editing_produce_config is not None:
            result['EditingProduceConfig'] = self.editing_produce_config
        if self.media_metadata is not None:
            result['MediaMetadata'] = self.media_metadata
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.output_media_target is not None:
            result['OutputMediaTarget'] = self.output_media_target
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_metadata is not None:
            result['ProjectMetadata'] = self.project_metadata
        if self.source is not None:
            result['Source'] = self.source
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('EditingProduceConfig') is not None:
            self.editing_produce_config = m.get('EditingProduceConfig')
        if m.get('MediaMetadata') is not None:
            self.media_metadata = m.get('MediaMetadata')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('OutputMediaTarget') is not None:
            self.output_media_target = m.get('OutputMediaTarget')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMetadata') is not None:
            self.project_metadata = m.get('ProjectMetadata')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaProducingJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
        project_id: str = None,
        request_id: str = None,
        vod_media_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The media asset ID of the output file.
        self.media_id = media_id
        # The ID of the editing project.
        self.project_id = project_id
        # The request ID.
        self.request_id = request_id
        # The media asset ID of the output file in ApsaraVideo VOD if the output file is stored in ApsaraVideo VOD.
        self.vod_media_id = vod_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vod_media_id is not None:
            result['VodMediaId'] = self.vod_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VodMediaId') is not None:
            self.vod_media_id = m.get('VodMediaId')
        return self


class SubmitMediaProducingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaProducingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitPackageJobRequestInputsInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitPackageJobRequestInputs(TeaModel):
    def __init__(
        self,
        input: SubmitPackageJobRequestInputsInput = None,
    ):
        # The information about the input stream file.
        # 
        # This parameter is required.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitPackageJobRequestInputsInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class SubmitPackageJobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported. If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitPackageJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitPackageJobRequest(TeaModel):
    def __init__(
        self,
        inputs: List[SubmitPackageJobRequestInputs] = None,
        name: str = None,
        output: SubmitPackageJobRequestOutput = None,
        schedule_config: SubmitPackageJobRequestScheduleConfig = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.inputs = inputs
        # The name of the job.
        self.name = name
        # The output of the job.
        # 
        # This parameter is required.
        self.output = output
        # The scheduling settings.
        self.schedule_config = schedule_config
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.inputs:
            for k in self.inputs:
                if k:
                    k.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Inputs'] = []
        if self.inputs is not None:
            for k in self.inputs:
                result['Inputs'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.inputs = []
        if m.get('Inputs') is not None:
            for k in m.get('Inputs'):
                temp_model = SubmitPackageJobRequestInputs()
                self.inputs.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitPackageJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitPackageJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitPackageJobShrinkRequest(TeaModel):
    def __init__(
        self,
        inputs_shrink: str = None,
        name: str = None,
        output_shrink: str = None,
        schedule_config_shrink: str = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.inputs_shrink = inputs_shrink
        # The name of the job.
        self.name = name
        # The output of the job.
        # 
        # This parameter is required.
        self.output_shrink = output_shrink
        # The scheduling settings.
        self.schedule_config_shrink = schedule_config_shrink
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inputs_shrink is not None:
            result['Inputs'] = self.inputs_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Inputs') is not None:
            self.inputs_shrink = m.get('Inputs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitPackageJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitPackageJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitPackageJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitPackageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitProjectExportJobRequest(TeaModel):
    def __init__(
        self,
        export_type: str = None,
        output_media_config: str = None,
        project_id: str = None,
        timeline: str = None,
        user_data: str = None,
    ):
        self.export_type = export_type
        # This parameter is required.
        self.output_media_config = output_media_config
        self.project_id = project_id
        self.timeline = timeline
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitProjectExportJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitProjectExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitProjectExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitProjectExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitScreenMediaHighlightsJobRequest(TeaModel):
    def __init__(
        self,
        editing_config: str = None,
        input_config: str = None,
        output_config: str = None,
        user_data: str = None,
    ):
        self.editing_config = editing_config
        self.input_config = input_config
        self.output_config = output_config
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitScreenMediaHighlightsJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitScreenMediaHighlightsJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitScreenMediaHighlightsJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitScreenMediaHighlightsJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSegmentationJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        input_config: str = None,
        job_params: str = None,
        output_config: str = None,
        user_data: str = None,
    ):
        self.client_token = client_token
        self.input_config = input_config
        self.job_params = job_params
        self.output_config = output_config
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSegmentationJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSegmentationJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSegmentationJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSegmentationJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSmarttagJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # If Type is set to OSS, specify an OSS path. Example: OSS://test-bucket/video/202208/test.mp4.
        # 
        # If Type is set to Media, specify a media asset ID. Example: c5c62d8f0361337cab312dce8e77dc6d.
        # 
        # If Type is set to URL, specify an HTTP URL. Example: https://zc-test.oss-cn-shanghai.aliyuncs.com/test/unknowFace.mp4.
        self.media = media
        # The media type. Valid values:
        # 
        # *   OSS
        # *   Media
        # *   URL
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSmarttagJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: str = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which you want to submit the smart tagging job. The MPS queue is bound to an SMQ queue. This parameter specifies the default MPS queue. By default, an MPS queue can process a maximum of two concurrent smart tagging jobs. To increase the limit, submit a ticket.
        self.pipeline_id = pipeline_id
        # The job priority. This parameter is not implemented. You can leave this parameter empty or enter a random value.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitSmarttagJobRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_addr: str = None,
        content_type: str = None,
        input: SubmitSmarttagJobRequestInput = None,
        notify_url: str = None,
        params: str = None,
        schedule_config: SubmitSmarttagJobRequestScheduleConfig = None,
        template_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # The video description. The description can contain letters, digits, and hyphens (-) and cannot start with a special character. The description can be up to 1 KB in length.
        self.content = content
        # This parameter is discontinued.
        self.content_addr = content_addr
        # This parameter is discontinued.
        self.content_type = content_type
        # The job input.
        self.input = input
        # The URL for receiving callbacks. Set the value to an HTTP URL or an HTTPS URL.
        self.notify_url = notify_url
        # The additional request parameters. The value is a JSON string. Example: {"needAsrData":true, "needOcrData":false}. The following parameters are supported:
        # 
        # *   needAsrData: specifies whether to query the automatic speech recognition (ASR) data. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   needOcrData: specifies whether to query the optical character recognition (OCR) data. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   needMetaData: specifies whether to query the metadata. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   nlpParams: the input parameters of the natural language processing (NLP) operator. The value is a JSON object. This parameter is empty by default, which indicates that the NLP operator is not used. For more information, see the "nlpParams" section of this topic.
        self.params = params
        # The scheduling configurations.
        self.schedule_config = schedule_config
        # The ID of the template that specifies the analysis algorithms. For more information about template operations, see [Configure templates](https://help.aliyun.com/document_detail/445702.html).
        self.template_id = template_id
        # The video title. The title can contain letters, digits, and hyphens (-) and cannot start with a special character. The title can be up to 256 bytes in length.
        self.title = title
        # The data to be passed through Simple Message Queue (SMQ, formerly MNS) during callbacks. The data can be up to 1 KB in length. For more information about how to specify an SMQ queue for receiving callbacks, see UpdatePipeline.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_addr is not None:
            result['ContentAddr'] = self.content_addr
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.params is not None:
            result['Params'] = self.params
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentAddr') is not None:
            self.content_addr = m.get('ContentAddr')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Input') is not None:
            temp_model = SubmitSmarttagJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSmarttagJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSmarttagJobShrinkRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_addr: str = None,
        content_type: str = None,
        input_shrink: str = None,
        notify_url: str = None,
        params: str = None,
        schedule_config_shrink: str = None,
        template_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # The video description. The description can contain letters, digits, and hyphens (-) and cannot start with a special character. The description can be up to 1 KB in length.
        self.content = content
        # This parameter is discontinued.
        self.content_addr = content_addr
        # This parameter is discontinued.
        self.content_type = content_type
        # The job input.
        self.input_shrink = input_shrink
        # The URL for receiving callbacks. Set the value to an HTTP URL or an HTTPS URL.
        self.notify_url = notify_url
        # The additional request parameters. The value is a JSON string. Example: {"needAsrData":true, "needOcrData":false}. The following parameters are supported:
        # 
        # *   needAsrData: specifies whether to query the automatic speech recognition (ASR) data. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   needOcrData: specifies whether to query the optical character recognition (OCR) data. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   needMetaData: specifies whether to query the metadata. The value is of the BOOLEAN type. Default value: false. Valid values: true and false.
        # *   nlpParams: the input parameters of the natural language processing (NLP) operator. The value is a JSON object. This parameter is empty by default, which indicates that the NLP operator is not used. For more information, see the "nlpParams" section of this topic.
        self.params = params
        # The scheduling configurations.
        self.schedule_config_shrink = schedule_config_shrink
        # The ID of the template that specifies the analysis algorithms. For more information about template operations, see [Configure templates](https://help.aliyun.com/document_detail/445702.html).
        self.template_id = template_id
        # The video title. The title can contain letters, digits, and hyphens (-) and cannot start with a special character. The title can be up to 256 bytes in length.
        self.title = title
        # The data to be passed through Simple Message Queue (SMQ, formerly MNS) during callbacks. The data can be up to 1 KB in length. For more information about how to specify an SMQ queue for receiving callbacks, see UpdatePipeline.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_addr is not None:
            result['ContentAddr'] = self.content_addr
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.params is not None:
            result['Params'] = self.params
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentAddr') is not None:
            self.content_addr = m.get('ContentAddr')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSmarttagJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the smart tagging job. We recommend that you save this ID for subsequent calls of other operations.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSmarttagJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSmarttagJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSmarttagJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSnapshotJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The input file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the Intelligent Media Services (IMS) console.
        # 
        # This parameter is required.
        self.media = media
        # The type of the input file. Valid values:
        # 
        # 1.  OSS: an Object Storage Service (OSS) object.
        # 2.  Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSnapshotJobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The output file. If Type is set to OSS, the URL of an OSS object is returned. If Type is set to Media, the ID of a media asset is returned. The URL of an OSS object can be in one of the following formats:
        # 
        # 1.  oss://bucket/object
        # 2.  http(s)://bucket.oss-[RegionId].aliyuncs.com/object
        # 
        # In the URL, bucket specifies an OSS bucket that resides in the same region as the job, and object specifies the object URL in OSS. If multiple static snapshots were captured, the object must contain the "{Count}" placeholder. In the case of a sprite, the object must contain the "{TileCount}" placeholder. The suffix of the WebVTT snapshot objects must be ".vtt".
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the IMS console.
        # 
        # This parameter is required.
        self.media = media
        # The type of the output file. Valid values:
        # 
        # 1.  OSS: an OSS object.
        # 2.  Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSnapshotJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig(TeaModel):
    def __init__(
        self,
        cell_height: int = None,
        cell_width: int = None,
        color: str = None,
        columns: int = None,
        lines: int = None,
        margin: int = None,
        padding: int = None,
    ):
        # The height of a single snapshot before tiling. The default value is the height of the output snapshot.
        self.cell_height = cell_height
        # The width of a single snapshot before tiling. The default value is the width of the output snapshot.
        self.cell_width = cell_width
        # The background color.
        self.color = color
        # The number of columns that the image sprite contains.
        self.columns = columns
        # The number of rows that the image sprite contains.
        self.lines = lines
        # The width of the frame. Default value: 0. Unit: pixels.
        self.margin = margin
        # The spacing between two adjacent snapshots. Default value: 0. Unit: pixels.
        self.padding = padding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class SubmitSnapshotJobRequestTemplateConfigOverwriteParams(TeaModel):
    def __init__(
        self,
        black_level: int = None,
        count: int = None,
        frame_type: str = None,
        height: int = None,
        interval: int = None,
        is_spt_frag: bool = None,
        pixel_black_threshold: int = None,
        sprite_snapshot_config: SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig = None,
        time: int = None,
        type: str = None,
        width: int = None,
    ):
        # The threshold that is used to filter out black frames for the first snapshot to be captured. This feature is available if you request the system to capture multiple snapshots.
        self.black_level = black_level
        # The number of snapshots.
        self.count = count
        # The type of the frame.
        self.frame_type = frame_type
        # The height of a captured snapshot.
        self.height = height
        # The interval at which snapshots are captured.
        self.interval = interval
        # The WebVTT snapshot configuration that specifies whether to merge the output snapshots.
        self.is_spt_frag = is_spt_frag
        # The color value threshold that determines whether a pixel is black.
        self.pixel_black_threshold = pixel_black_threshold
        # The configuration of the sprite snapshot.
        self.sprite_snapshot_config = sprite_snapshot_config
        # The point in time at which the system starts to capture snapshots in the input video.
        self.time = time
        # The snapshot type. Valid values:
        self.type = type
        # The width of a captured snapshot.
        self.width = width

    def validate(self):
        if self.sprite_snapshot_config:
            self.sprite_snapshot_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_level is not None:
            result['BlackLevel'] = self.black_level
        if self.count is not None:
            result['Count'] = self.count
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_spt_frag is not None:
            result['IsSptFrag'] = self.is_spt_frag
        if self.pixel_black_threshold is not None:
            result['PixelBlackThreshold'] = self.pixel_black_threshold
        if self.sprite_snapshot_config is not None:
            result['SpriteSnapshotConfig'] = self.sprite_snapshot_config.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlackLevel') is not None:
            self.black_level = m.get('BlackLevel')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsSptFrag') is not None:
            self.is_spt_frag = m.get('IsSptFrag')
        if m.get('PixelBlackThreshold') is not None:
            self.pixel_black_threshold = m.get('PixelBlackThreshold')
        if m.get('SpriteSnapshotConfig') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig()
            self.sprite_snapshot_config = temp_model.from_map(m['SpriteSnapshotConfig'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSnapshotJobRequestTemplateConfig(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitSnapshotJobRequestTemplateConfigOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfigOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitSnapshotJobRequestInput = None,
        name: str = None,
        output: SubmitSnapshotJobRequestOutput = None,
        schedule_config: SubmitSnapshotJobRequestScheduleConfig = None,
        template_config: SubmitSnapshotJobRequestTemplateConfig = None,
        user_data: str = None,
    ):
        # The snapshot input.
        # 
        # This parameter is required.
        self.input = input
        # The name of the job.
        self.name = name
        # The snapshot output.
        # 
        # This parameter is required.
        self.output = output
        # The scheduling settings.
        self.schedule_config = schedule_config
        # The snapshot template configuration.
        # 
        # This parameter is required.
        self.template_config = template_config
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitSnapshotJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitSnapshotJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSnapshotJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateConfig') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        name: str = None,
        output_shrink: str = None,
        schedule_config_shrink: str = None,
        template_config_shrink: str = None,
        user_data: str = None,
    ):
        # The snapshot input.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        # The name of the job.
        self.name = name
        # The snapshot output.
        # 
        # This parameter is required.
        self.output_shrink = output_shrink
        # The scheduling settings.
        self.schedule_config_shrink = schedule_config_shrink
        # The snapshot template configuration.
        # 
        # This parameter is required.
        self.template_config_shrink = template_config_shrink
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSportsHighlightsJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        input_config: str = None,
        output_config: str = None,
        user_data: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The input configurations.
        self.input_config = input_config
        # The output configurations.
        self.output_config = output_config
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSportsHighlightsJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the sports highlights job.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSportsHighlightsJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSportsHighlightsJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSportsHighlightsJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitStandardCustomizedVoiceJobRequest(TeaModel):
    def __init__(
        self,
        audios: str = None,
        authentication: str = None,
        demo_audio_media_url: str = None,
        gender: str = None,
        voice_name: str = None,
    ):
        # *   The material assets IDs of the materials for training.
        # *   Separate multiple media IDs with commas (,).
        # 
        # > : The total duration of all materials must be within 15 to 30 minutes. The duration of each material must be greater than 1 minute.
        self.audios = audios
        # *   The media asset ID of the authentication audio.
        # 
        # *   Upload an audio file for identity authentication. If the voiceprint extracted from the uploaded file differs from that of the training file, the job fails.
        # 
        #     **\
        # 
        #     **Note**: Clearly read and record the following text: I confirm to customize human voice cloning and provide audio files that contain my voice for training. I promise that I am responsible for the customized content and that the content complies with laws and regulations.
        self.authentication = authentication
        # The URL of the sample audio file.
        # 
        # *   If this parameter is specified, a sample audio file is generated at the specified Object Storage Service (OSS) URL after the training is complete.
        # 
        # *   If this parameter is not specified, no sample audio file is generated.
        # 
        #     **\
        # 
        #     **Note**: The URL must be a valid public OSS URL within your Alibaba Cloud account.
        self.demo_audio_media_url = demo_audio_media_url
        # The gender. Valid values:
        # 
        # *   female
        # *   male
        self.gender = gender
        # The voice name.
        # 
        # *   The name can be up to 32 characters in length.
        self.voice_name = voice_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audios is not None:
            result['Audios'] = self.audios
        if self.authentication is not None:
            result['Authentication'] = self.authentication
        if self.demo_audio_media_url is not None:
            result['DemoAudioMediaURL'] = self.demo_audio_media_url
        if self.gender is not None:
            result['Gender'] = self.gender
        if self.voice_name is not None:
            result['VoiceName'] = self.voice_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audios') is not None:
            self.audios = m.get('Audios')
        if m.get('Authentication') is not None:
            self.authentication = m.get('Authentication')
        if m.get('DemoAudioMediaURL') is not None:
            self.demo_audio_media_url = m.get('DemoAudioMediaURL')
        if m.get('Gender') is not None:
            self.gender = m.get('Gender')
        if m.get('VoiceName') is not None:
            self.voice_name = m.get('VoiceName')
        return self


class SubmitStandardCustomizedVoiceJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the human voice cloning job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitStandardCustomizedVoiceJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitStandardCustomizedVoiceJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitStandardCustomizedVoiceJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitStandardCustomizedVoiceJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitStandardCustomizedVoiceJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitStandardCustomizedVoiceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSyncMediaInfoJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the Intelligent Media Services (IMS) console.
        # 
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The type of the media object.
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSyncMediaInfoJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitSyncMediaInfoJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitSyncMediaInfoJobRequestInput = None,
        name: str = None,
        schedule_config: SubmitSyncMediaInfoJobRequestScheduleConfig = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input = input
        # The job name.
        self.name = name
        # The scheduling parameters. This parameter is optional.
        self.schedule_config = schedule_config
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitSyncMediaInfoJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSyncMediaInfoJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        name: str = None,
        schedule_config_shrink: str = None,
        user_data: str = None,
    ):
        # The input of the job.
        # 
        # This parameter is required.
        self.input_shrink = input_shrink
        # The job name.
        self.name = name
        # The scheduling parameters. This parameter is optional.
        self.schedule_config_shrink = schedule_config_shrink
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported. If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the file.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sample format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video. Unit: seconds.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The state of the file. Valid values:
        # 
        # *   Normal
        self.file_status = file_status
        # The file type.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height of the output video.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the file.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height of the output video.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList] = None,
        file_basic_info: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo = None,
        video_stream_info_list: List[SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        finish_time: str = None,
        input: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput = None,
        job_id: str = None,
        media_info_property: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty = None,
        name: str = None,
        request_id: str = None,
        schedule_config: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # Indicates whether asynchronous processing was performed.
        self.async_ = async_
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input of the job.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The details of the media information.
        self.media_info_property = media_info_property
        # The job name.
        self.name = name
        # The request ID.
        self.request_id = request_id
        # The scheduling information.
        self.schedule_config = schedule_config
        # The state of the job. Valid values: Init (the job is submitted), Success (the job is successful), and Fail (the job failed).
        self.status = status
        # The job submission information.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The source of the job. Valid values: API, WorkFlow, and Console.
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job: SubmitSyncMediaInfoJobResponseBodyMediaInfoJob = None,
        request_id: str = None,
    ):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSyncMediaInfoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSyncMediaInfoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTextGenerateJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        generate_config: str = None,
        title: str = None,
        type: str = None,
        user_data: str = None,
    ):
        # The job description, which can be up to 1,024 bytes in length and must be encoded in UTF-8.
        self.description = description
        # The text generation configurations, including keywords and the requirements for the word count and number of output copies.
        self.generate_config = generate_config
        # The job title.
        # 
        # The job title can be up to 128 bytes in length.
        # 
        # The value must be encoded in UTF-8.
        self.title = title
        # The job type.
        # 
        # Valid values:
        # 
        # *   MarketingCopy: the marketing copy.
        # *   Title: the short video title.
        self.type = type
        # The user-defined data in the JSON format, which can be up to 512 bytes in length. You can specify a custom callback URL. For more information, see [Configure a callback upon editing completion](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.generate_config is not None:
            result['GenerateConfig'] = self.generate_config
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GenerateConfig') is not None:
            self.generate_config = m.get('GenerateConfig')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTextGenerateJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitTextGenerateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTextGenerateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTextGenerateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceAbJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTraceAbJobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTraceAbJobRequest(TeaModel):
    def __init__(
        self,
        cipher_base_64ed: str = None,
        input: SubmitTraceAbJobRequestInput = None,
        level: int = None,
        output: SubmitTraceAbJobRequestOutput = None,
        start_time: int = None,
        total_time: int = None,
        user_data: str = None,
    ):
        self.cipher_base_64ed = cipher_base_64ed
        # This parameter is required.
        self.input = input
        self.level = level
        # This parameter is required.
        self.output = output
        self.start_time = start_time
        self.total_time = total_time
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_base_64ed is not None:
            result['CipherBase64ed'] = self.cipher_base_64ed
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.level is not None:
            result['Level'] = self.level
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherBase64ed') is not None:
            self.cipher_base_64ed = m.get('CipherBase64ed')
        if m.get('Input') is not None:
            temp_model = SubmitTraceAbJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Output') is not None:
            temp_model = SubmitTraceAbJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceAbJobShrinkRequest(TeaModel):
    def __init__(
        self,
        cipher_base_64ed: str = None,
        input_shrink: str = None,
        level: int = None,
        output_shrink: str = None,
        start_time: int = None,
        total_time: int = None,
        user_data: str = None,
    ):
        self.cipher_base_64ed = cipher_base_64ed
        # This parameter is required.
        self.input_shrink = input_shrink
        self.level = level
        # This parameter is required.
        self.output_shrink = output_shrink
        self.start_time = start_time
        self.total_time = total_time
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_base_64ed is not None:
            result['CipherBase64ed'] = self.cipher_base_64ed
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.level is not None:
            result['Level'] = self.level
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherBase64ed') is not None:
            self.cipher_base_64ed = m.get('CipherBase64ed')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceAbJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        trace_media_id: str = None,
    ):
        self.job_id = job_id
        self.trace_media_id = trace_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        return self


class SubmitTraceAbJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceAbJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceAbJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitTraceAbJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceAbJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceAbJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceExtractJobRequestInput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTraceExtractJobRequest(TeaModel):
    def __init__(
        self,
        input: SubmitTraceExtractJobRequestInput = None,
        params: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.input = input
        self.params = params
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.params is not None:
            result['Params'] = self.params
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitTraceExtractJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceExtractJobShrinkRequest(TeaModel):
    def __init__(
        self,
        input_shrink: str = None,
        params: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.input_shrink = input_shrink
        self.params = params
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.params is not None:
            result['Params'] = self.params
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitTraceExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitTraceExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceM3u8JobRequestOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.media = media
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTraceM3u8JobRequest(TeaModel):
    def __init__(
        self,
        key_uri: str = None,
        output: SubmitTraceM3u8JobRequestOutput = None,
        params: str = None,
        trace: str = None,
        trace_media_id: str = None,
    ):
        self.key_uri = key_uri
        # This parameter is required.
        self.output = output
        self.params = params
        self.trace = trace
        self.trace_media_id = trace_media_id

    def validate(self):
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.params is not None:
            result['Params'] = self.params
        if self.trace is not None:
            result['Trace'] = self.trace
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('Output') is not None:
            temp_model = SubmitTraceM3u8JobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        return self


class SubmitTraceM3u8JobShrinkRequest(TeaModel):
    def __init__(
        self,
        key_uri: str = None,
        output_shrink: str = None,
        params: str = None,
        trace: str = None,
        trace_media_id: str = None,
    ):
        self.key_uri = key_uri
        # This parameter is required.
        self.output_shrink = output_shrink
        self.params = params
        self.trace = trace
        self.trace_media_id = trace_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.params is not None:
            result['Params'] = self.params
        if self.trace is not None:
            result['Trace'] = self.trace
        if self.trace_media_id is not None:
            result['TraceMediaId'] = self.trace_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        if m.get('TraceMediaId') is not None:
            self.trace_media_id = m.get('TraceMediaId')
        return self


class SubmitTraceM3u8JobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitTraceM3u8JobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceM3u8JobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceM3u8JobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitTraceM3u8JobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceM3u8JobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceM3u8JobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTranscodeJobRequestInputGroup(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media: str = None,
        type: str = None,
    ):
        # The URL of the input stream.
        # 
        # *   This parameter takes effect only when Type is set to Media. You can select a specific file within the media asset as an input.
        # *   The system checks whether the input URL exists within the media asset.
        self.input_url = input_url
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the Intelligent Media Services (IMS) console.
        # 
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an Object Storage Service (OSS) object.
        # *   Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # 
        # >  Before you use the OSS bucket in the URL, you must add the bucket on the [Storage Management](https://help.aliyun.com/document_detail/609918.html) page of the IMS console.
        # 
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        # 
        # This parameter is required.
        self.media = media
        # The URL of the output stream.\\
        # This parameter takes effect only when Type is set to Media. You can select a specific file within the media asset as an output.\\
        # Supported placeholders:
        # 
        # *   {MediaId}: the ID of the media asset.
        # *   {JobId}: the ID of the transcoding subjob.
        # *   {MediaBucket}: the bucket to which the media asset belongs.
        # *   {ExtName}: the file suffix, which uses the output format of the transcoding template.
        # *   {DestMd5}: the MD5 value of the transcoded output file.\\
        #     Notes:
        # 
        # 1.  This parameter must contain the {MediaId} and {JobId} placeholders.
        # 2.  The output bucket is the same as the bucket to which the media asset belongs.
        self.output_url = output_url
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
        key_service_type: str = None,
    ):
        # The ciphertext of HTTP Live Streaming (HLS) encryption.
        self.cipher_text = cipher_text
        # The address of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # Specifies the encryption type. Valid values:
        # 
        # *   PrivateEncryption: Alibaba Cloud proprietary cryptography
        # *   HLSEncryption: HTTP Live Streaming (HLS) encryption
        self.encrypt_type = encrypt_type
        # The key service type for HLS encryption. Valid values:
        # 
        # *   KMS
        # *   Base64
        self.key_service_type = key_service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.key_service_type is not None:
            result['KeyServiceType'] = self.key_service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KeyServiceType') is not None:
            self.key_service_type = m.get('KeyServiceType')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The time range in which the watermark is displayed.
        # 
        # *   Valid values: integers and ToEND.
        # *   Default value: ToEND.
        self.duration = duration
        # The beginning of the time range in which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Value values: integers.
        # *   Default value: 0.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the horizontal offset to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the vertical offset to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the watermark image in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark height.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark height to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.height = height
        # The position of the watermark.
        # 
        # *   Valid values: TopRight, TopLeft, BottomRight, and BottomLeft.
        # *   Default value: TopRight.
        self.refer_pos = refer_pos
        # The time settings of the dynamic watermark.
        self.timeline = timeline
        # The width of the watermark in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark width.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark width to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Specifies whether to the font size based on the output video dimensions. true / false, default: false
        self.adaptive = adaptive
        # The outline color of the text watermark. Default value: black. For more information, see BorderColor.
        self.border_color = border_color
        # The outline width of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: (0,4096].
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the text.
        # 
        # *   Valid values: (0,1].
        # *   Default value: 1.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text. Default value: SimSun.
        self.font_name = font_name
        # The size of the text.
        # 
        # *   Default value: 16.
        # *   Valid values: (4,120).
        self.font_size = font_size
        # The left margin of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.left = left
        # The top margin of the text.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file. Valid values: [8,1000]. Unit: Kbit/s. Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Specifies whether to delete the audio stream.
        self.remove = remove
        # The sampling rate. Valid values: 22050, 32000, 44100, 48000, and 96000. Default value: 44100. Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method that is used to adjust the resolution. This parameter takes effect only if both the Width and Height parameters are specified. You can use this parameter together with the LongShortMode parameter.
        # 
        # Valid values: rescale, crop, pad, and none.
        # 
        # Default value: none.
        self.adj_dar_method = adj_dar_method
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the bitrate of the input audio is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value:
        # 
        # *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        # *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the resolution of the input video is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_reso = is_check_reso
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_reso_fail = is_check_reso_fail
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the bitrate of the input video is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The video transcoding mode. Valid values:
        # 
        # *   onepass: You can set this parameter to onepass if the Bitrate parameter is set to ABR. The encoding speed of this mode is faster than that of the twopass mode.
        # *   twopass: You can set this parameter to twopass if the Bitrate parameter is set to VBR. The encoding speed of this mode is slower than that of the onepass mode.
        # *   CBR: the constant bitrate mode.
        # 
        # Default value: onepass.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum adaptive bitrate (ABR). This parameter takes effect only for Narrowband HD 1.0. Valid values: [10,50000]. Unit: Kbit/s.
        self.abr_max = abr_max
        # The average video bitrate. Valid values: [10,50000]. Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size. Valid values: [1000,128000]. Default value: 6000. Unit: KB.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor (CRF). Valid values: [0,51]. Default value: 23 if the encoding format is H.264, or 26 if the encoding format is H.265.
        # 
        # >  If this parameter is specified, the setting of the bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   border: automatically detects and removes black bars.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The frame rate. Valid values:(0,60]. Default value: the frame rate of the input file.
        # 
        # >  The value is 60 if the frame rate of the input file exceeds 60.
        self.fps = fps
        # The maximum number of frames between keyframes. Valid values: [1,1080000]. Default value: 250.
        self.gop = gop
        # The height of the video. Valid values: [128,4096]. Unit: pixels. Default value: the original height of the video.
        self.height = height
        # Specifies whether to enable the auto-rotate screen feature.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the video. Valid values: [10,50000]. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video. Format: width:height:left:top. Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Specifies whether to remove the video.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the video. Valid values: [128,4096]. Unit: pixels. Default value: the original width of the video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio = None,
        container: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        trans_config: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig = None,
        video: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        # The conditional transcoding configurations.
        self.trans_config = trans_config
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('TransConfig') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs] = None,
        encryption: SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption = None,
        image_watermarks: List[SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks] = None,
        subtitles: List[SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles] = None,
        text_watermarks: List[SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks] = None,
        transcode: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration of an image.
        self.image_watermarks = image_watermarks
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermark.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        # 
        # This parameter is required.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobRequestOutputGroup(TeaModel):
    def __init__(
        self,
        output: SubmitTranscodeJobRequestOutputGroupOutput = None,
        process_config: SubmitTranscodeJobRequestOutputGroupProcessConfig = None,
    ):
        # The output file configuration.
        # 
        # This parameter is required.
        self.output = output
        # The job processing configuration.
        # 
        # This parameter is required.
        self.process_config = process_config

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class SubmitTranscodeJobRequestScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        input_group: List[SubmitTranscodeJobRequestInputGroup] = None,
        name: str = None,
        output_group: List[SubmitTranscodeJobRequestOutputGroup] = None,
        schedule_config: SubmitTranscodeJobRequestScheduleConfig = None,
        user_data: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        # 
        # This parameter is required.
        self.input_group = input_group
        # The job name.
        self.name = name
        # The output group of the job.
        # 
        # This parameter is required.
        self.output_group = output_group
        # The scheduling information about the job.
        self.schedule_config = schedule_config
        # The custom settings. The value must be in the JSON format and can be up to 512 bytes in length. You can specify a [custom callback URL](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobRequestInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = SubmitTranscodeJobRequestOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobShrinkRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        input_group_shrink: str = None,
        name: str = None,
        output_group_shrink: str = None,
        schedule_config_shrink: str = None,
        user_data: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        # 
        # This parameter is required.
        self.input_group_shrink = input_group_shrink
        # The job name.
        self.name = name
        # The output group of the job.
        # 
        # This parameter is required.
        self.output_group_shrink = output_group_shrink
        # The scheduling information about the job.
        self.schedule_config_shrink = schedule_config_shrink
        # The custom settings. The value must be in the JSON format and can be up to 512 bytes in length. You can specify a [custom callback URL](https://help.aliyun.com/document_detail/451631.html).
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.input_group_shrink is not None:
            result['InputGroup'] = self.input_group_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_group_shrink is not None:
            result['OutputGroup'] = self.output_group_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InputGroup') is not None:
            self.input_group_shrink = m.get('InputGroup')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputGroup') is not None:
            self.output_group_shrink = m.get('OutputGroup')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
        key_service_type: str = None,
    ):
        # The ciphertext of HLS encryption.
        self.cipher_text = cipher_text
        # The address of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # Specifies the encryption type.
        self.encrypt_type = encrypt_type
        # The type of the key service. Valid values: KMS and Base64.
        self.key_service_type = key_service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.key_service_type is not None:
            result['KeyServiceType'] = self.key_service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KeyServiceType') is not None:
            self.key_service_type = m.get('KeyServiceType')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The time range in which the watermark is displayed.
        # 
        # *   Valid values: integers and ToEND.
        # *   Default value: ToEND.
        self.duration = duration
        # The beginning of the time range in which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Value values: integers.
        # *   Default value: 0.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the horizontal offset to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the vertical offset to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the watermark image in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark height.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark height to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.height = height
        # The position of the watermark.
        # 
        # *   Valid values: TopRight, TopLeft, BottomRight, and BottomLeft.
        # *   Default value: TopRight.
        self.refer_pos = refer_pos
        # The time settings of the dynamic watermark.
        self.timeline = timeline
        # The width of the watermark in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark width.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark width to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object. If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported. If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Specifies whether to the font size based on the output video dimensions.
        # 
        # *   true: false
        # *   default: false
        self.adaptive = adaptive
        # The outline color of the text watermark. Default value: black. For more information, see BorderColor.
        self.border_color = border_color
        # The outline width of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: (0,4096].
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the text.
        # 
        # *   Valid values: (0,1].
        # *   Default value: 1.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text. Default value: SimSun.
        self.font_name = font_name
        # The size of the text.
        # 
        # *   Default value: 16.
        # *   Valid values: (4,120).
        self.font_size = font_size
        # The left margin of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.left = left
        # The top margin of the text.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: [8,1000].
        # *   Unit: Kbit/s.
        # *   Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Specifies whether to delete the audio stream.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000. Default value: 44100.
        # *   Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method that is used to adjust the resolution. This parameter takes effect only if both the Width and Height parameters are specified. You can use this parameter together with the LongShortMode parameter.
        # 
        # Valid values: rescale, crop, pad, and none.
        # 
        # Default value: none.
        self.adj_dar_method = adj_dar_method
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the bitrate of the input audio is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value:
        # 
        # *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        # *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the resolution of the input video is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_reso = is_check_reso
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_reso_fail = is_check_reso_fail
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the bitrate of the input video is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution.
        # 
        # Default value: false.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The video transcoding mode. Valid values:
        # 
        # *   onepass: You can set this parameter to onepass if the Bitrate parameter is set to ABR. The encoding speed of this mode is faster than that of the twopass mode.
        # *   twopass: You can set this parameter to twopass if the Bitrate parameter is set to VBR. The encoding speed of this mode is slower than that of the onepass mode.
        # *   CBR: the constant bitrate mode.
        # 
        # Default value: onepass.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum ABR. This parameter takes effect only for Narrowband HD 1.0.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.abr_max = abr_max
        # The average bitrate of the video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size.
        # 
        # *   Valid values: [1000,128000].
        # *   Default value: 6000.
        # *   Unit: KB.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Valid values: [0,51].
        # *   Default value: 23 if the encoding format is H.264, or Default value when the Codec parameter is set to H.265: 26.
        # 
        # If this parameter is specified, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   border: automatically detects and removes black bars.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The frame rate.
        # 
        # *   Valid values: (0,60].
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes.
        # 
        # *   Valid values: [1,1080000].
        # *   Default value: 250.
        self.gop = gop
        # The height of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the height of the input video.
        self.height = height
        # Specifies whether to enable the auto-rotate screen feature.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the output video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Specifies whether to remove the video.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio = None,
        container: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        trans_config: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig = None,
        video: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        # The conditional transcoding configurations.
        self.trans_config = trans_config
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('TransConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs] = None,
        encryption: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption = None,
        image_watermarks: List[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks] = None,
        subtitles: List[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles] = None,
        text_watermarks: List[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks] = None,
        transcode: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration of an image.
        self.image_watermarks = image_watermarks
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermark.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup(TeaModel):
    def __init__(
        self,
        output: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput = None,
        process_config: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig = None,
    ):
        # The output file configuration.
        self.output = output
        # The job processing configuration.
        self.process_config = process_config

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        media: str = None,
        type: str = None,
    ):
        # The URL of the input stream:
        # 
        # *   This parameter takes effect only when Type is set to Media. You can select a specific file within the media asset as an input.
        # *   The system checks whether the input URL exists within the media asset.
        self.input_url = input_url
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        sample_fmt: str = None,
        sample_rate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The sound channel layout.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The encoder tag.
        self.codec_tag = codec_tag
        # The name of the encoder tag.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The sample format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.sample_rate = sample_rate
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_name: str = None,
        file_size: str = None,
        file_status: str = None,
        file_type: str = None,
        file_url: str = None,
        format_name: str = None,
        height: str = None,
        media_id: str = None,
        region: str = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The duration of the video. Unit: seconds.
        self.duration = duration
        # The file name.
        self.file_name = file_name
        # The file size. Unit: bytes.
        self.file_size = file_size
        # The state of the file.
        self.file_status = file_status
        # The file type. Valid values: source_file and transcode_file.
        self.file_type = file_type
        # The URL of the file.
        self.file_url = file_url
        # The name of the video format.
        self.format_name = format_name
        # The height of the output video.
        self.height = height
        # The ID of the media asset.
        self.media_id = media_id
        # The region in which the file resides.
        self.region = region
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bit_rate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        time_base: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bit_rate = bit_rate
        # The name of the encoding format.
        self.codec_long_name = codec_long_name
        # The encoding format.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The time base of the encoder.
        self.codec_time_base = codec_time_base
        # The display aspect ratio.
        self.dar = dar
        # The duration of the stream. Unit: seconds.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). Valid values:
        # 
        # *   0: The stream contains no B-frames.
        # *   1: The stream contains one B-frame.
        # *   2: The stream contains multiple consecutive B-frames.
        self.has_bframes = has_bframes
        # The height of the output video.
        self.height = height
        # The sequence number of the stream.
        self.index = index
        # The language of the stream.
        self.lang = lang
        # The codec level.
        self.level = level
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The encoder profile.
        self.profile = profile
        # The rotation angle of the video image. Valid values: 0, 90, 180, and 270. Default value: 0.
        self.rotate = rotate
        # The aspect ratio of the area from which the sampling points are collected.
        self.sar = sar
        # The start time of the stream.
        self.start_time = start_time
        # The time base.
        self.time_base = time_base
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(TeaModel):
    def __init__(
        self,
        audio_stream_info_list: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList] = None,
        file_basic_info: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo = None,
        video_stream_info_list: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList] = None,
    ):
        # The information about the audio stream.
        self.audio_stream_info_list = audio_stream_info_list
        # The basic file information.
        self.file_basic_info = file_basic_info
        # The information about the video stream.
        self.video_stream_info_list = video_stream_info_list

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(TeaModel):
    def __init__(
        self,
        media: str = None,
        output_url: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The URL of the output stream.\\
        # This parameter takes effect only when Type is set to Media. You can select a specific file within the media asset as an output.\\
        # Supported placeholders:
        # 
        # *   {MediaId}: the ID of the media asset.
        # *   {JobId}: the ID of the transcoding subjob.
        # *   {MediaBucket}: the bucket to which the media asset belongs.
        # *   {ExtName}: the file suffix, which uses the output format of the transcoding template.
        # *   {DestMd5}: the MD5 value of the transcoded output file.\\
        #     Notes:
        # 
        # 1.  This parameter must contain the {MediaId} and {JobId} placeholders.
        # 2.  The output bucket is the same as the bucket to which the media asset belongs.
        self.output_url = output_url
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs(TeaModel):
    def __init__(
        self,
        audio_index: str = None,
        duration: float = None,
        start: float = None,
        video_index: str = None,
    ):
        # The audio stream index.
        # 
        # This parameter is required.
        self.audio_index = audio_index
        # The duration of the input stream. The default value is the duration of the video.
        self.duration = duration
        # The start time of the input stream. Default value: 0.
        self.start = start
        # The video stream index.
        # 
        # This parameter is required.
        self.video_index = video_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_index is not None:
            result['AudioIndex'] = self.audio_index
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        if self.video_index is not None:
            result['VideoIndex'] = self.video_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioIndex') is not None:
            self.audio_index = m.get('AudioIndex')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('VideoIndex') is not None:
            self.video_index = m.get('VideoIndex')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption(TeaModel):
    def __init__(
        self,
        cipher_text: str = None,
        decrypt_key_uri: str = None,
        encrypt_type: str = None,
        key_service_type: str = None,
    ):
        # The ciphertext of HLS encryption.
        self.cipher_text = cipher_text
        # The address of the decryption service for HLS encryption.
        self.decrypt_key_uri = decrypt_key_uri
        # Specifies the encryption type.
        self.encrypt_type = encrypt_type
        # The type of the key service. Valid values: KMS and Base64.
        self.key_service_type = key_service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_text is not None:
            result['CipherText'] = self.cipher_text
        if self.decrypt_key_uri is not None:
            result['DecryptKeyUri'] = self.decrypt_key_uri
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.key_service_type is not None:
            result['KeyServiceType'] = self.key_service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherText') is not None:
            self.cipher_text = m.get('CipherText')
        if m.get('DecryptKeyUri') is not None:
            self.decrypt_key_uri = m.get('DecryptKeyUri')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KeyServiceType') is not None:
            self.key_service_type = m.get('KeyServiceType')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The time range in which the watermark is displayed.
        # 
        # *   Valid values: integers and ToEND.
        # *   Default value: ToEND.
        self.duration = duration
        # The beginning of the time range in which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Value values: integers.
        # *   Default value: 0.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        file: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile = None,
        height: str = None,
        refer_pos: str = None,
        timeline: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the horizontal offset to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video. Default value: 0.
        # 
        # The following value types are supported:
        # 
        # *   Integer: the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the vertical offset to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dy = dy
        # The watermark image file.
        self.file = file
        # The height of the watermark image in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark height.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark height to the height of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.height = height
        # The position of the watermark.
        # 
        # *   Valid values: TopRight, TopLeft, BottomRight, and BottomLeft.
        # *   Default value: TopRight.
        self.refer_pos = refer_pos
        # The time settings of the dynamic watermark.
        self.timeline = timeline
        # The width of the watermark in the output video. The following value types are supported:
        # 
        # *   Integer: the pixel value of the watermark width.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixels.
        # 
        # *   Decimal: the ratio of the watermark width to the width of the output video.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(
        self,
        media: str = None,
        type: str = None,
    ):
        # The media object.
        # 
        # *   If Type is set to OSS, set this parameter to the URL of an OSS object. Both the OSS and HTTP protocols are supported.
        # *   If Type is set to Media, set this parameter to the ID of a media asset.
        self.media = media
        # The type of the media object. Valid values:
        # 
        # *   OSS: an OSS object.
        # *   Media: a media asset.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        file: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile = None,
        format: str = None,
    ):
        # The file encoding format.
        self.char_enc = char_enc
        # The subtitle file.
        self.file = file
        # The format of the subtitle file.
        self.format = format

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(
        self,
        adaptive: str = None,
        border_color: str = None,
        border_width: int = None,
        content: str = None,
        font_alpha: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size: int = None,
        left: str = None,
        top: str = None,
    ):
        # Specifies whether to the font size based on the output video dimensions. true / false, default: false
        self.adaptive = adaptive
        # The outline color of the text watermark. Default value: black. For more information, see BorderColor.
        self.border_color = border_color
        # The outline width of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: (0,4096].
        self.border_width = border_width
        # The watermark text. Base64 encoding is not required. The string must be encoded in UTF-8.
        self.content = content
        # The transparency of the text.
        # 
        # *   Valid values: (0,1].
        # *   Default value: 1.
        self.font_alpha = font_alpha
        # The color of the text.
        self.font_color = font_color
        # The font of the text. Default value: SimSun.
        self.font_name = font_name
        # The size of the text.
        # 
        # *   Default value: 16.
        # *   Valid values: (4,120).
        self.font_size = font_size
        # The left margin of the text watermark.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.left = left
        # The top margin of the text.
        # 
        # *   Default value: 0.
        # *   Valid values: [0,4096].
        self.top = top

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        loudness_range_target: str = None,
        method: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume range.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        self.method = method
        # The peak volume.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: [8,1000].
        # *   Unit: Kbit/s.
        # *   Default value: 128.
        self.bitrate = bitrate
        # The number of sound channels. Default value: 2.
        self.channels = channels
        # The audio codec. Valid values: AAC, MP3, VORBIS, and FLAC. Default value: AAC.
        self.codec = codec
        # The audio codec profile. If the Codec parameter is set to AAC, the valid values are aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # Specifies whether to delete the audio stream.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Default value: 44100.
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        force_seg_time: str = None,
    ):
        # The segment length.
        self.duration = duration
        # The forced segmentation point in time.
        self.force_seg_time = force_seg_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(
        self,
        segment: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment = None,
    ):
        # The segment settings.
        self.segment = segment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method that is used to adjust the resolution. This parameter takes effect only if both the Width and Height parameters are specified. You can use this parameter together with the LongShortMode parameter.
        # 
        # Valid values: rescale, crop, pad, and none.
        # 
        # Default value: none.
        self.adj_dar_method = adj_dar_method
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the bitrate of the input audio is used for transcoding.
        # *   false: does not check the video resolution.
        # 
        # Default values:
        # 
        # *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        # *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Specifies whether to check the audio bitrate. You can specify only one of the IsCheckAudioBitrate and IsCheckAudioBitrateFail parameters. The priority of the IsCheckAudioBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input audio is less than that of the output audio, the transcoding job fails.
        # *   false: does not check the video resolution. This is the default value.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the resolution of the input video is used for transcoding.
        # *   false: does not check the video resolution. This is the default value.
        self.is_check_reso = is_check_reso
        # Specifies whether to check the video resolution. You can specify only one of the IsCheckReso and IsCheckResoFail parameters. The priority of the IsCheckResoFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the width or height of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution. This is the default value.
        self.is_check_reso_fail = is_check_reso_fail
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the bitrate of the input video is used for transcoding.
        # *   false: does not check the video resolution. This is the default value.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Specifies whether to check the video bitrate. You can specify only one of the IsCheckVideoBitrate and IsCheckVideoBitrateFail parameters. The priority of the IsCheckVideoBitrateFail parameter is higher. Valid values:
        # 
        # *   true: checks the video resolution. If the bitrate of the input video is less than that of the output video, the transcoding job fails.
        # *   false: does not check the video resolution. This is the default value.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The video transcoding mode. Valid values:
        # 
        # *   onepass: You can set this parameter to onepass if the Bitrate parameter is set to ABR. This is the default value. The encoding speed of this mode is faster than that of the twopass mode.
        # *   twopass: You can set this parameter to twopass if the Bitrate parameter is set to VBR. The encoding speed of this mode is slower than that of the onepass mode.
        # *   CBR: the constant bitrate mode.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(
        self,
        abr_max: str = None,
        bitrate: str = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        long_short_mode: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum ABR. This parameter takes effect only for Narrowband HD 1.0. Valid values: [10,50000]. Unit: Kbit/s.
        self.abr_max = abr_max
        # The average bitrate of the video.
        # 
        # *   Valid values: [10,50000].
        # *   Unit: Kbit/s.
        self.bitrate = bitrate
        # The buffer size.
        # 
        # *   Valid values: [1000,128000].
        # *   Default value: 6000.
        # *   Unit: KB.
        self.bufsize = bufsize
        # The encoding format.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Valid values: [0,51].
        # *   Default value: 23 if the encoding format is H.264, or Default value when the Codec parameter is set to H.265: 26.
        # 
        # If this parameter is specified, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   border: automatically detects and removes black bars.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The frame rate.
        # 
        # *   Valid values: (0,60].
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes.
        # 
        # *   Valid values: [1,1080000].
        # *   Default value: 250.
        self.gop = gop
        # The height of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the height of the input video.
        self.height = height
        # Specifies whether to enable the auto-rotate screen feature.
        self.long_short_mode = long_short_mode
        # The maximum bitrate of the output video. Valid values: [10,50000]. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. This parameter takes effect only if the encoding format is H.264. Valid values: veryfast, fast, medium, slow, and slower. Default value: medium.
        self.preset = preset
        # The encoding profile. Valid values: baseline, main, and high.
        # 
        # *   baseline: applicable to mobile devices.
        # *   main: applicable to standard-definition devices.
        # *   high: applicable to high-definition devices.
        # 
        # Default value: high.
        self.profile = profile
        # Specifies whether to remove the video.
        self.remove = remove
        # The scan mode. Valid values: interlaced and progressive.
        self.scan_mode = scan_mode
        # The width of the output video.
        # 
        # *   Valid values: [128,4096].
        # *   Unit: pixels.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(
        self,
        audio: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio = None,
        container: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer = None,
        mux_config: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig = None,
        trans_config: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig = None,
        video: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo = None,
    ):
        # The audio settings.
        self.audio = audio
        # The encapsulation format settings.
        self.container = container
        # The encapsulation settings.
        self.mux_config = mux_config
        # The conditional transcoding configurations.
        self.trans_config = trans_config
        # The video settings.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('TransConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(TeaModel):
    def __init__(
        self,
        overwrite_params: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams = None,
        template_id: str = None,
    ):
        # The parameters that are used to overwrite the corresponding parameters of the template.
        self.overwrite_params = overwrite_params
        # The template ID.
        self.template_id = template_id

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(TeaModel):
    def __init__(
        self,
        combine_configs: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs] = None,
        encryption: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption = None,
        image_watermarks: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks] = None,
        subtitles: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles] = None,
        text_watermarks: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks] = None,
        transcode: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode = None,
    ):
        # The multi-input stream merge configuration.
        self.combine_configs = combine_configs
        # The encryption settings.
        self.encryption = encryption
        # The watermark configuration of an image.
        self.image_watermarks = image_watermarks
        # The subtitle configuration.
        self.subtitles = subtitles
        # The configurations of the text watermark.
        self.text_watermarks = text_watermarks
        # The transcoding configuration.
        self.transcode = transcode

    def validate(self):
        if self.combine_configs:
            for k in self.combine_configs:
                if k:
                    k.validate()
        if self.encryption:
            self.encryption.validate()
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CombineConfigs'] = []
        if self.combine_configs is not None:
            for k in self.combine_configs:
                result['CombineConfigs'].append(k.to_map() if k else None)
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.combine_configs = []
        if m.get('CombineConfigs') is not None:
            for k in m.get('CombineConfigs'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs()
                self.combine_configs.append(temp_model.from_map(k))
        if m.get('Encryption') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        priority: int = None,
    ):
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job. Valid values: 1 to 10. The greater the value, the higher the priority.
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input_group: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup] = None,
        job_id: str = None,
        job_index: int = None,
        name: str = None,
        out_file_meta: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta = None,
        output: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput = None,
        parent_job_id: str = None,
        process_config: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig = None,
        request_id: str = None,
        schedule_config: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig = None,
        status: str = None,
        submit_result_json: Dict[str, Any] = None,
        submit_time: str = None,
        user_data: str = None,
    ):
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        self.input_group = input_group
        # The subjob ID.
        self.job_id = job_id
        # The index number of the subjob in the entire job.
        self.job_index = job_index
        # The job name.
        self.name = name
        # The media information about the video generated by the job.
        self.out_file_meta = out_file_meta
        # The output file configuration.
        self.output = output
        # The main job ID.
        self.parent_job_id = parent_job_id
        # The transcoding configuration.
        self.process_config = process_config
        # The ID of the request that submitted the job.
        self.request_id = request_id
        # The scheduling information about the job.
        self.schedule_config = schedule_config
        # The state of the transcoding job. Valid values:
        # 
        # *   Init: The job is submitted.
        # *   Processing: The job is in progress.
        # *   Success: The job is successful.
        # *   Fail: The job failed.
        # *   Deleted: The job is deleted.
        self.status = status
        # The job submission result.
        self.submit_result_json = submit_result_json
        # The time when the job was submitted.
        self.submit_time = submit_time
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.out_file_meta:
            self.out_file_meta.validate()
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_index is not None:
            result['JobIndex'] = self.job_index
        if self.name is not None:
            result['Name'] = self.name
        if self.out_file_meta is not None:
            result['OutFileMeta'] = self.out_file_meta.to_map()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobIndex') is not None:
            self.job_index = m.get('JobIndex')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutFileMeta') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta()
            self.out_file_meta = temp_model.from_map(m['OutFileMeta'])
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        finish_time: str = None,
        input_group: List[SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup] = None,
        job_count: int = None,
        name: str = None,
        output_group: List[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup] = None,
        parent_job_id: str = None,
        percent: int = None,
        request_id: str = None,
        schedule_config: SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig = None,
        status: str = None,
        submit_time: str = None,
        transcode_job_list: List[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList] = None,
        trigger_source: str = None,
        user_data: str = None,
    ):
        # The time when the job was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the job was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.finish_time = finish_time
        # The input group of the job. An input of a single file indicates a transcoding job. An input of multiple files indicates an audio and video stream merge job.
        self.input_group = input_group
        # The number of subjobs.
        self.job_count = job_count
        # The job name.
        self.name = name
        # The output group of the job.
        self.output_group = output_group
        # The main job ID.
        self.parent_job_id = parent_job_id
        # The completion percentage of the job.
        self.percent = percent
        # The ID of the request that submitted the job.
        self.request_id = request_id
        # The scheduling configuration of the job.
        self.schedule_config = schedule_config
        # The state of the job. Success: At least one of the subjobs is successful. Fail: All subjobs failed.
        self.status = status
        # The time when the job was submitted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.submit_time = submit_time
        # The list of subjobs.
        self.transcode_job_list = transcode_job_list
        # The source of the job. Valid values: API, WorkFlow, and Console.
        self.trigger_source = trigger_source
        # The user data.
        self.user_data = user_data

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.transcode_job_list:
            for k in self.transcode_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        result['TranscodeJobList'] = []
        if self.transcode_job_list is not None:
            for k in self.transcode_job_list:
                result['TranscodeJobList'].append(k.to_map() if k else None)
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        self.transcode_job_list = []
        if m.get('TranscodeJobList') is not None:
            for k in m.get('TranscodeJobList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList()
                self.transcode_job_list.append(temp_model.from_map(k))
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transcode_parent_job: SubmitTranscodeJobResponseBodyTranscodeParentJob = None,
    ):
        # The request ID.
        self.request_id = request_id
        # TranscodeParentJobWithSubJobDTO
        self.transcode_parent_job = transcode_parent_job

    def validate(self):
        if self.transcode_parent_job:
            self.transcode_parent_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.transcode_parent_job is not None:
            result['TranscodeParentJob'] = self.transcode_parent_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TranscodeParentJob') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJob()
            self.transcode_parent_job = temp_model.from_map(m['TranscodeParentJob'])
        return self


class SubmitTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitVideoTranslationJobRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        description: str = None,
        editing_config: str = None,
        input_config: str = None,
        output_config: str = None,
        signature: str = None,
        signature_mehtod: str = None,
        signature_nonce: str = None,
        signature_type: str = None,
        signature_version: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # *   The client token.
        self.client_token = client_token
        # *   The job description.
        self.description = description
        # *   The configuration parameters of the video translation job.
        # *   The value must be in the JSON format.
        self.editing_config = editing_config
        # *   The input parameters of the video translation job.
        # *   A video translation job takes a video or subtitle file as the input.
        # *   The value must be in the JSON format.
        self.input_config = input_config
        # *   The output parameters of the video translation job.
        # *   A video translation job can generate a video or subtitle file as the output.
        self.output_config = output_config
        self.signature = signature
        self.signature_mehtod = signature_mehtod
        self.signature_nonce = signature_nonce
        self.signature_type = signature_type
        self.signature_version = signature_version
        # *   The job title.
        self.title = title
        # *   The user-defined data.
        # *   The data must be in the JSON format, and can be up to 512 characters in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.signature_mehtod is not None:
            result['SignatureMehtod'] = self.signature_mehtod
        if self.signature_nonce is not None:
            result['SignatureNonce'] = self.signature_nonce
        if self.signature_type is not None:
            result['SignatureType'] = self.signature_type
        if self.signature_version is not None:
            result['SignatureVersion'] = self.signature_version
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('SignatureMehtod') is not None:
            self.signature_mehtod = m.get('SignatureMehtod')
        if m.get('SignatureNonce') is not None:
            self.signature_nonce = m.get('SignatureNonce')
        if m.get('SignatureType') is not None:
            self.signature_type = m.get('SignatureType')
        if m.get('SignatureVersion') is not None:
            self.signature_version = m.get('SignatureVersion')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitVideoTranslationJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the video translation job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitVideoTranslationJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitVideoTranslationJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitVideoTranslationJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitVideoTranslationJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitVideoTranslationJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitVideoTranslationJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TakeoverAIAgentCallRequest(TeaModel):
    def __init__(
        self,
        human_agent_user_id: str = None,
        instance_id: str = None,
        require_token: bool = None,
    ):
        # The ID of the human agent that will take over the AI agent (UserId in ARTC). If you do not specify this parameter, it is automatically generated and returned.
        self.human_agent_user_id = human_agent_user_id
        # The ID of the AI agent that will be taken over.
        self.instance_id = instance_id
        # Specifies whether to return the ARTC token. Default value: false.
        self.require_token = require_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.human_agent_user_id is not None:
            result['HumanAgentUserId'] = self.human_agent_user_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.require_token is not None:
            result['RequireToken'] = self.require_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HumanAgentUserId') is not None:
            self.human_agent_user_id = m.get('HumanAgentUserId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequireToken') is not None:
            self.require_token = m.get('RequireToken')
        return self


class TakeoverAIAgentCallResponseBody(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        human_agent_user_id: str = None,
        request_id: str = None,
        token: str = None,
    ):
        # The ID of the ARTC channel.
        self.channel_id = channel_id
        # The ID of the human agent.
        self.human_agent_user_id = human_agent_user_id
        # The ID of the request.
        self.request_id = request_id
        # The ARTC token.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.human_agent_user_id is not None:
            result['HumanAgentUserId'] = self.human_agent_user_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('HumanAgentUserId') is not None:
            self.human_agent_user_id = m.get('HumanAgentUserId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class TakeoverAIAgentCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TakeoverAIAgentCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TakeoverAIAgentCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAIAgentInstanceRequest(TeaModel):
    def __init__(
        self,
        agent_config: AIAgentConfig = None,
        instance_id: str = None,
        template_config: AIAgentTemplateConfig = None,
        user_data: str = None,
    ):
        self.agent_config = agent_config
        # The ID of the AI agent that you want to update.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The template configurations of the AI agent. The configurations are merged with the template configurations that are used to start the AI agent. For more information, see the definition of TemplateConfig.
        self.template_config = template_config
        self.user_data = user_data

    def validate(self):
        if self.agent_config:
            self.agent_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_config is not None:
            result['AgentConfig'] = self.agent_config.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentConfig') is not None:
            temp_model = AIAgentConfig()
            self.agent_config = temp_model.from_map(m['AgentConfig'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateConfig') is not None:
            temp_model = AIAgentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UpdateAIAgentInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_config_shrink: str = None,
        instance_id: str = None,
        template_config_shrink: str = None,
        user_data: str = None,
    ):
        self.agent_config_shrink = agent_config_shrink
        # The ID of the AI agent that you want to update.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The template configurations of the AI agent. The configurations are merged with the template configurations that are used to start the AI agent. For more information, see the definition of TemplateConfig.
        self.template_config_shrink = template_config_shrink
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_config_shrink is not None:
            result['AgentConfig'] = self.agent_config_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentConfig') is not None:
            self.agent_config_shrink = m.get('AgentConfig')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UpdateAIAgentInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAIAgentInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAIAgentInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAIAgentInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAdInsertionRequest(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_ad_segment_url_prefix: str = None,
        cdn_content_segment_url_prefix: str = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Specifies whether to enable ad marker passthrough. Default value: OFF.
        # 
        # Valid values:
        # 
        # *   OFF: Disable.
        # *   ON: Enable.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The request URL of the ad decision server (ADS). HTTP and HTTPS are supported. The maximum length is 2,048 characters.
        # 
        # This parameter is required.
        self.ads_url = ads_url
        # The CDN prefix for ad segments. HTTP and HTTPS are supported. The maximum length is 512 characters.
        self.cdn_ad_segment_url_prefix = cdn_ad_segment_url_prefix
        # The CDN prefix for content segments. HTTP and HTTPS are supported. The maximum length is 512 characters.
        self.cdn_content_segment_url_prefix = cdn_content_segment_url_prefix
        # A JSON string that specifies the player parameter variables and aliases. Format: { "player_params.{name}": { "{key}": "{value}" } }. You can add up to 20 player_params.{name} entries. The name field can be up to 150 characters in length. Each player parameter can include up to 50 key-value pairs. A key can be up to 150 characters long, and a value can be up to 500 characters.
        self.config_aliases = config_aliases
        # The URL prefix for the source content. HTTP and HTTPS are supported. The maximum length is 512 characters.
        # 
        # This parameter is required.
        self.content_url_prefix = content_url_prefix
        # The configuration name, which cannot be modified.
        # 
        # This parameter is required.
        self.name = name
        # Specifies the maximum duration of underfilled time allowed in an ad break. Unit: seconds. Default value: 8 seconds.
        self.personalization_threshold = personalization_threshold
        # The HTTP or HTTPS URL of the slate ad. Only MP4 format is supported. The maximum length is 2,048 characters.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_ad_segment_url_prefix is not None:
            result['CdnAdSegmentUrlPrefix'] = self.cdn_ad_segment_url_prefix
        if self.cdn_content_segment_url_prefix is not None:
            result['CdnContentSegmentUrlPrefix'] = self.cdn_content_segment_url_prefix
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnAdSegmentUrlPrefix') is not None:
            self.cdn_ad_segment_url_prefix = m.get('CdnAdSegmentUrlPrefix')
        if m.get('CdnContentSegmentUrlPrefix') is not None:
            self.cdn_content_segment_url_prefix = m.get('CdnContentSegmentUrlPrefix')
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class UpdateAdInsertionResponseBodyConfigCdnConfig(TeaModel):
    def __init__(
        self,
        ad_segment_url_prefix: str = None,
        content_segment_url_prefix: str = None,
    ):
        # The CDN prefix for ad segments.
        self.ad_segment_url_prefix = ad_segment_url_prefix
        # The CDN prefix for content segments.
        self.content_segment_url_prefix = content_segment_url_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_segment_url_prefix is not None:
            result['AdSegmentUrlPrefix'] = self.ad_segment_url_prefix
        if self.content_segment_url_prefix is not None:
            result['ContentSegmentUrlPrefix'] = self.content_segment_url_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdSegmentUrlPrefix') is not None:
            self.ad_segment_url_prefix = m.get('AdSegmentUrlPrefix')
        if m.get('ContentSegmentUrlPrefix') is not None:
            self.content_segment_url_prefix = m.get('ContentSegmentUrlPrefix')
        return self


class UpdateAdInsertionResponseBodyConfigManifestEndpointConfig(TeaModel):
    def __init__(
        self,
        dash_prefix: str = None,
        hls_prefix: str = None,
    ):
        # DASH
        self.dash_prefix = dash_prefix
        # The prefix of the playback endpoint for HLS manifests.
        self.hls_prefix = hls_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dash_prefix is not None:
            result['DashPrefix'] = self.dash_prefix
        if self.hls_prefix is not None:
            result['HlsPrefix'] = self.hls_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashPrefix') is not None:
            self.dash_prefix = m.get('DashPrefix')
        if m.get('HlsPrefix') is not None:
            self.hls_prefix = m.get('HlsPrefix')
        return self


class UpdateAdInsertionResponseBodyConfig(TeaModel):
    def __init__(
        self,
        ad_marker_passthrough: str = None,
        ads_url: str = None,
        cdn_config: UpdateAdInsertionResponseBodyConfigCdnConfig = None,
        config_aliases: str = None,
        content_url_prefix: str = None,
        create_time: str = None,
        last_modified: str = None,
        manifest_endpoint_config: UpdateAdInsertionResponseBodyConfigManifestEndpointConfig = None,
        name: str = None,
        personalization_threshold: int = None,
        slate_ad_url: str = None,
    ):
        # Indicates whether ad marker passthrough is enabled.
        self.ad_marker_passthrough = ad_marker_passthrough
        # The request URL of ADS.
        self.ads_url = ads_url
        # The CDN configurations.
        self.cdn_config = cdn_config
        # The player parameter variables and aliases.
        self.config_aliases = config_aliases
        # The URL prefix for the source content.
        self.content_url_prefix = content_url_prefix
        # The time when the configuration was created.
        self.create_time = create_time
        # The time when the configuration was last modified.
        self.last_modified = last_modified
        # The playback endpoint configuration.
        self.manifest_endpoint_config = manifest_endpoint_config
        # The name of the ad insertion configuration.
        self.name = name
        # The personalization threshold.
        self.personalization_threshold = personalization_threshold
        # The URL of the slate ad.
        self.slate_ad_url = slate_ad_url

    def validate(self):
        if self.cdn_config:
            self.cdn_config.validate()
        if self.manifest_endpoint_config:
            self.manifest_endpoint_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_marker_passthrough is not None:
            result['AdMarkerPassthrough'] = self.ad_marker_passthrough
        if self.ads_url is not None:
            result['AdsUrl'] = self.ads_url
        if self.cdn_config is not None:
            result['CdnConfig'] = self.cdn_config.to_map()
        if self.config_aliases is not None:
            result['ConfigAliases'] = self.config_aliases
        if self.content_url_prefix is not None:
            result['ContentUrlPrefix'] = self.content_url_prefix
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.manifest_endpoint_config is not None:
            result['ManifestEndpointConfig'] = self.manifest_endpoint_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.personalization_threshold is not None:
            result['PersonalizationThreshold'] = self.personalization_threshold
        if self.slate_ad_url is not None:
            result['SlateAdUrl'] = self.slate_ad_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdMarkerPassthrough') is not None:
            self.ad_marker_passthrough = m.get('AdMarkerPassthrough')
        if m.get('AdsUrl') is not None:
            self.ads_url = m.get('AdsUrl')
        if m.get('CdnConfig') is not None:
            temp_model = UpdateAdInsertionResponseBodyConfigCdnConfig()
            self.cdn_config = temp_model.from_map(m['CdnConfig'])
        if m.get('ConfigAliases') is not None:
            self.config_aliases = m.get('ConfigAliases')
        if m.get('ContentUrlPrefix') is not None:
            self.content_url_prefix = m.get('ContentUrlPrefix')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('ManifestEndpointConfig') is not None:
            temp_model = UpdateAdInsertionResponseBodyConfigManifestEndpointConfig()
            self.manifest_endpoint_config = temp_model.from_map(m['ManifestEndpointConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PersonalizationThreshold') is not None:
            self.personalization_threshold = m.get('PersonalizationThreshold')
        if m.get('SlateAdUrl') is not None:
            self.slate_ad_url = m.get('SlateAdUrl')
        return self


class UpdateAdInsertionResponseBody(TeaModel):
    def __init__(
        self,
        config: UpdateAdInsertionResponseBodyConfig = None,
        request_id: str = None,
    ):
        # The ad insertion configuration.
        self.config = config
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = UpdateAdInsertionResponseBodyConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAdInsertionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAdInsertionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAdInsertionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAvatarTrainingJobRequest(TeaModel):
    def __init__(
        self,
        avatar_description: str = None,
        avatar_name: str = None,
        job_id: str = None,
        portrait: str = None,
        thumbnail: str = None,
        transparent: bool = None,
        video: str = None,
    ):
        # *   The description of the digital human.
        # *   The description can be up to 1,000 characters in length.
        self.avatar_description = avatar_description
        # *   The name of the digital human.
        # *   The name can be up to seven characters in length.
        self.avatar_name = avatar_name
        # The ID of the digital human training job.
        # 
        # This parameter is required.
        self.job_id = job_id
        # *   The media asset ID of the portrait image.
        # *   The value must be 32 characters in length.
        self.portrait = portrait
        # *   The thumbnail URL.
        # *   After the digital human is trained, the thumbnail is uploaded to this URL.
        # *   The URL must be a valid public Object Storage Service (OSS) URL.
        # *   The URL can be up to 512 characters in length.
        # *   The URL cannot be updated after the digital human is trained.
        self.thumbnail = thumbnail
        # *   Indicates whether the input video supports alpha channels.
        # 
        # *   You can modify this parameter only if the job is in the Init or Fail state.
        # 
        #     **\
        # 
        #     **Note**: Make sure that the current settings are consistent with those of the submitted training video. Otherwise, the digital human may malfunction.
        self.transparent = transparent
        # *   The ID of the video used for training.
        # *   The value must be 32 characters in length.
        # *   Supported formats: MP4, MOV, and WebM.
        # *   The duration of the video must be 5 to 15 minutes.
        # *   The resolution of the video must be 19201080 or 10801920.
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_description is not None:
            result['AvatarDescription'] = self.avatar_description
        if self.avatar_name is not None:
            result['AvatarName'] = self.avatar_name
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.portrait is not None:
            result['Portrait'] = self.portrait
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        if self.transparent is not None:
            result['Transparent'] = self.transparent
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarDescription') is not None:
            self.avatar_description = m.get('AvatarDescription')
        if m.get('AvatarName') is not None:
            self.avatar_name = m.get('AvatarName')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Portrait') is not None:
            self.portrait = m.get('Portrait')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        if m.get('Transparent') is not None:
            self.transparent = m.get('Transparent')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class UpdateAvatarTrainingJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the digital human training job.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class UpdateAvatarTrainingJobResponseBody(TeaModel):
    def __init__(
        self,
        data: UpdateAvatarTrainingJobResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = UpdateAvatarTrainingJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateAvatarTrainingJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAvatarTrainingJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAvatarTrainingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cate_name: str = None,
    ):
        # The category ID. You can use one of the following methods to obtain the ID:
        # 
        # *   Log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com) and choose **Media Asset Management** > **Category Management** to view the category ID.
        # *   View the value of CateId returned by the AddCategory operation that you called to create a category.
        # *   View the value of CateId returned by the GetCategories operation that you called to query a category.
        # 
        # This parameter is required.
        self.cate_id = cate_id
        # The category name.
        # 
        # This parameter is required.
        self.cate_name = cate_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        return self


class UpdateCategoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateChannelRequest(TeaModel):
    def __init__(
        self,
        access_policy: bool = None,
        access_token: str = None,
        channel_name: str = None,
        filler_source_location_name: str = None,
        filler_source_name: str = None,
        out_put_config_list: str = None,
    ):
        # Specifies whether to enable access control.
        self.access_policy = access_policy
        # The token for accessing the channel.
        self.access_token = access_token
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The source location of the filler slate.
        self.filler_source_location_name = filler_source_location_name
        # The name of the filler slate.
        self.filler_source_name = filler_source_name
        # The channel output configurations.
        # 
        # This parameter is required.
        self.out_put_config_list = out_put_config_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_policy is not None:
            result['AccessPolicy'] = self.access_policy
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.filler_source_location_name is not None:
            result['FillerSourceLocationName'] = self.filler_source_location_name
        if self.filler_source_name is not None:
            result['FillerSourceName'] = self.filler_source_name
        if self.out_put_config_list is not None:
            result['OutPutConfigList'] = self.out_put_config_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessPolicy') is not None:
            self.access_policy = m.get('AccessPolicy')
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('FillerSourceLocationName') is not None:
            self.filler_source_location_name = m.get('FillerSourceLocationName')
        if m.get('FillerSourceName') is not None:
            self.filler_source_name = m.get('FillerSourceName')
        if m.get('OutPutConfigList') is not None:
            self.out_put_config_list = m.get('OutPutConfigList')
        return self


class UpdateChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel: ChannelAssemblyChannel = None,
        request_id: str = None,
    ):
        # The channel information.
        self.channel = channel
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.channel:
            self.channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channel') is not None:
            temp_model = ChannelAssemblyChannel()
            self.channel = temp_model.from_map(m['Channel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_config: str = None,
        template_id: str = None,
    ):
        # The template name.
        self.name = name
        # The [template parameters](https://help.aliyun.com/document_detail/448291.html).
        self.template_config = template_config
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomizedVoiceRequest(TeaModel):
    def __init__(
        self,
        demo_audio_media_id: str = None,
        voice_id: str = None,
    ):
        # The media asset ID of the sample audio file.
        self.demo_audio_media_id = demo_audio_media_id
        # The voice ID.
        # 
        # This parameter is required.
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_audio_media_id is not None:
            result['DemoAudioMediaId'] = self.demo_audio_media_id
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoAudioMediaId') is not None:
            self.demo_audio_media_id = m.get('DemoAudioMediaId')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class UpdateCustomizedVoiceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCustomizedVoiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCustomizedVoiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomizedVoiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEditingProjectRequest(TeaModel):
    def __init__(
        self,
        business_status: str = None,
        clips_param: str = None,
        cover_url: str = None,
        description: str = None,
        project_id: str = None,
        template_id: str = None,
        timeline: str = None,
        title: str = None,
    ):
        # The business status of the project. This parameter can be ignored for general editing projects. Valid values:
        # 
        # *   Reserving
        # *   ReservationCanceled
        self.business_status = business_status
        # The material parameter corresponding to the template, in the JSON format. If TemplateId is specified, ClipsParam must also be specified.
        self.clips_param = clips_param
        # The thumbnail URL of the online editing project.
        self.cover_url = cover_url
        # The description of the online editing project.
        self.description = description
        # The ID of the online editing project.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The template ID. This parameter is used to quickly build a timeline with ease. Note: Only one of ProjectId, Timeline, and TemplateId can be specified. If TemplateId is specified, ClipsParam must also be specified.
        self.template_id = template_id
        self.timeline = timeline
        # The title of the online editing project.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateEditingProjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEditingProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEditingProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHotwordLibraryRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        hotword_library_id: str = None,
        hotwords: List[Hotword] = None,
        name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.hotword_library_id = hotword_library_id
        self.hotwords = hotwords
        self.name = name

    def validate(self):
        if self.hotwords:
            for k in self.hotwords:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        result['Hotwords'] = []
        if self.hotwords is not None:
            for k in self.hotwords:
                result['Hotwords'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        self.hotwords = []
        if m.get('Hotwords') is not None:
            for k in m.get('Hotwords'):
                temp_model = Hotword()
                self.hotwords.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateHotwordLibraryShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        hotword_library_id: str = None,
        hotwords_shrink: str = None,
        name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.hotword_library_id = hotword_library_id
        self.hotwords_shrink = hotwords_shrink
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.hotword_library_id is not None:
            result['HotwordLibraryId'] = self.hotword_library_id
        if self.hotwords_shrink is not None:
            result['Hotwords'] = self.hotwords_shrink
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HotwordLibraryId') is not None:
            self.hotword_library_id = m.get('HotwordLibraryId')
        if m.get('Hotwords') is not None:
            self.hotwords_shrink = m.get('Hotwords')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateHotwordLibraryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHotwordLibraryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHotwordLibraryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHotwordLibraryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePackageChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        description: str = None,
        group_name: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The channel description. It can be up to 1,000 characters in length.
        self.description = description
        # The channel group name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.group_name = group_name
        # The ingest protocol. Only HLS is supported.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of M3U8 segments. Valid values: 2 to 100.
        # 
        # This parameter is required.
        self.segment_count = segment_count
        # The segment duration. Valid values: 1 to 30.
        # 
        # This parameter is required.
        self.segment_duration = segment_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(TeaModel):
    def __init__(
        self,
        id: str = None,
        password: str = None,
        url: str = None,
        username: str = None,
    ):
        # The ingest endpoint ID.
        self.id = id
        # The password.
        self.password = password
        # The ingest endpoint URL.
        self.url = url
        # The username.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.password is not None:
            result['Password'] = self.password
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class UpdateLivePackageChannelResponseBodyLivePackageChannel(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        ingest_endpoints: List[UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints] = None,
        last_modified: str = None,
        protocol: str = None,
        segment_count: int = None,
        segment_duration: int = None,
    ):
        # The channel name.
        self.channel_name = channel_name
        # The time when the channel was created.
        self.create_time = create_time
        # The channel description. It can be up to 1,000 characters in length.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The ingest endpoints.
        self.ingest_endpoints = ingest_endpoints
        # The time when the channel was last modified.
        self.last_modified = last_modified
        # The ingest protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of segments.
        self.segment_count = segment_count
        # The segment duration.
        self.segment_duration = segment_duration

    def validate(self):
        if self.ingest_endpoints:
            for k in self.ingest_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        result['IngestEndpoints'] = []
        if self.ingest_endpoints is not None:
            for k in self.ingest_endpoints:
                result['IngestEndpoints'].append(k.to_map() if k else None)
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_count is not None:
            result['SegmentCount'] = self.segment_count
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        self.ingest_endpoints = []
        if m.get('IngestEndpoints') is not None:
            for k in m.get('IngestEndpoints'):
                temp_model = UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints()
                self.ingest_endpoints.append(temp_model.from_map(k))
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentCount') is not None:
            self.segment_count = m.get('SegmentCount')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        return self


class UpdateLivePackageChannelResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel: UpdateLivePackageChannelResponseBodyLivePackageChannel = None,
        request_id: str = None,
    ):
        # The information about the live package channel.
        self.live_package_channel = live_package_channel
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel:
            self.live_package_channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel is not None:
            result['LivePackageChannel'] = self.live_package_channel.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannel') is not None:
            temp_model = UpdateLivePackageChannelResponseBodyLivePackageChannel()
            self.live_package_channel = temp_model.from_map(m['LivePackageChannel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePackageChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePackageChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePackageChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePackageChannelCredentialsRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
        rotate_credentials: int = None,
    ):
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # Specifies whether to update the credentials. 1: updates the credentials of endpoint 1. 2: updates the credentials of endpoint 2. 3: updates the credentials of endpoints 1 and 2.
        # 
        # This parameter is required.
        self.rotate_credentials = rotate_credentials

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.rotate_credentials is not None:
            result['RotateCredentials'] = self.rotate_credentials
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RotateCredentials') is not None:
            self.rotate_credentials = m.get('RotateCredentials')
        return self


class UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints(TeaModel):
    def __init__(
        self,
        id: str = None,
        password: str = None,
        url: str = None,
        username: str = None,
    ):
        # The ingest endpoint ID. `input1` indicates primary and `input2` indicates secondary.
        self.id = id
        # The password.
        self.password = password
        # The ingest endpoint URL.
        self.url = url
        # The username.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.password is not None:
            result['Password'] = self.password
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class UpdateLivePackageChannelCredentialsResponseBody(TeaModel):
    def __init__(
        self,
        ingest_endpoints: List[UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints] = None,
        request_id: str = None,
    ):
        # The information about the ingest endpoint.
        self.ingest_endpoints = ingest_endpoints
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ingest_endpoints:
            for k in self.ingest_endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IngestEndpoints'] = []
        if self.ingest_endpoints is not None:
            for k in self.ingest_endpoints:
                result['IngestEndpoints'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ingest_endpoints = []
        if m.get('IngestEndpoints') is not None:
            for k in m.get('IngestEndpoints'):
                temp_model = UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints()
                self.ingest_endpoints.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePackageChannelCredentialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePackageChannelCredentialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePackageChannelCredentialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePackageChannelGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        group_name: str = None,
    ):
        # The channel group description. It can be up to 1,000 characters in length.
        self.description = description
        # The channel group name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        group_name: str = None,
        last_modified: str = None,
        origin_domain: str = None,
    ):
        # The time when the channel group was created. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.create_time = create_time
        # The channel group description.
        self.description = description
        # The channel group name.
        self.group_name = group_name
        # The time when the channel group was last modified. It is in the yyyy-MM-ddTHH:mm:ssZ format and displayed in UTC.
        self.last_modified = last_modified
        # The origin domain.
        self.origin_domain = origin_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.origin_domain is not None:
            result['OriginDomain'] = self.origin_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('OriginDomain') is not None:
            self.origin_domain = m.get('OriginDomain')
        return self


class UpdateLivePackageChannelGroupResponseBody(TeaModel):
    def __init__(
        self,
        live_package_channel_group: UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup = None,
        request_id: str = None,
    ):
        # The information about the channel group.
        self.live_package_channel_group = live_package_channel_group
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_channel_group:
            self.live_package_channel_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_channel_group is not None:
            result['LivePackageChannelGroup'] = self.live_package_channel_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageChannelGroup') is not None:
            temp_model = UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup()
            self.live_package_channel_group = temp_model.from_map(m['LivePackageChannelGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePackageChannelGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePackageChannelGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePackageChannelGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePackageOriginEndpointRequest(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        description: str = None,
        endpoint_name: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        live_packaging_config: LivePackagingConfig = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code. It can be up to 200 characters in length. You must configure AuthorizationCode, IpWhitelist, or both. Format: [A-Za-z0-9-_.]+\
        self.authorization_code = authorization_code
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The endpoint description.
        self.description = description
        # The origin endpoint name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The IP address blacklist. It supports subnet masks. Separate multiple IP addresses with commas (,).
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,). You must configure AuthorizationCode, IpWhitelist, or both.
        self.ip_whitelist = ip_whitelist
        self.live_packaging_config = live_packaging_config
        # The playlist name. Default value: manifest.
        self.manifest_name = manifest_name
        # The protocol. Only HLS is supported.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        if self.live_packaging_config:
            self.live_packaging_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.live_packaging_config is not None:
            result['LivePackagingConfig'] = self.live_packaging_config.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LivePackagingConfig') is not None:
            temp_model = LivePackagingConfig()
            self.live_packaging_config = temp_model.from_map(m['LivePackagingConfig'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class UpdateLivePackageOriginEndpointShrinkRequest(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        description: str = None,
        endpoint_name: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        live_packaging_config_shrink: str = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code. It can be up to 200 characters in length. You must configure AuthorizationCode, IpWhitelist, or both. Format: [A-Za-z0-9-_.]+\
        self.authorization_code = authorization_code
        # The channel name.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # The endpoint description.
        self.description = description
        # The origin endpoint name. It can contain letters, digits, hyphens (-), and underscores (_). The name must be 1 to 200 characters in length. Format: [A-Za-z0-9_-]+\
        # 
        # This parameter is required.
        self.endpoint_name = endpoint_name
        # The channel group name.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The IP address blacklist. It supports subnet masks. Separate multiple IP addresses with commas (,).
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist. It supports subnet masks. 0.0.0.0/0 is not allowed. It can be up to 1,000 characters in length. Separate multiple IP addresses with commas (,). You must configure AuthorizationCode, IpWhitelist, or both.
        self.ip_whitelist = ip_whitelist
        self.live_packaging_config_shrink = live_packaging_config_shrink
        # The playlist name. Default value: manifest.
        self.manifest_name = manifest_name
        # The protocol. Only HLS is supported.
        # 
        # This parameter is required.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.live_packaging_config_shrink is not None:
            result['LivePackagingConfig'] = self.live_packaging_config_shrink
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LivePackagingConfig') is not None:
            self.live_packaging_config_shrink = m.get('LivePackagingConfig')
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(TeaModel):
    def __init__(
        self,
        authorization_code: str = None,
        channel_name: str = None,
        create_time: str = None,
        description: str = None,
        endpoint_name: str = None,
        endpoint_url: str = None,
        group_name: str = None,
        ip_blacklist: str = None,
        ip_whitelist: str = None,
        last_modified: str = None,
        live_packaging_config: LivePackagingConfig = None,
        manifest_name: str = None,
        protocol: str = None,
        timeshift_vision: int = None,
    ):
        # The authorization code.
        self.authorization_code = authorization_code
        # The channel name.
        self.channel_name = channel_name
        # The time when the endpoint was created.
        self.create_time = create_time
        # The endpoint description.
        self.description = description
        # The endpoint name.
        self.endpoint_name = endpoint_name
        # The endpoint URL.
        self.endpoint_url = endpoint_url
        # The channel group name.
        self.group_name = group_name
        # The IP address blacklist. It supports subnet masks. Multiple IP addresses are separated by commas (,).
        self.ip_blacklist = ip_blacklist
        # The IP address whitelist. It supports subnet masks. Multiple IP addresses are separated by commas (,).
        self.ip_whitelist = ip_whitelist
        # The time when the endpoint was last modified.
        self.last_modified = last_modified
        self.live_packaging_config = live_packaging_config
        # The playlist name. Default value: manifest.
        self.manifest_name = manifest_name
        # The protocol. Only HLS is supported.
        self.protocol = protocol
        # The number of days that time-shifted content is available. Maximum value: 30.
        self.timeshift_vision = timeshift_vision

    def validate(self):
        if self.live_packaging_config:
            self.live_packaging_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_code is not None:
            result['AuthorizationCode'] = self.authorization_code
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_url is not None:
            result['EndpointUrl'] = self.endpoint_url
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.ip_blacklist is not None:
            result['IpBlacklist'] = self.ip_blacklist
        if self.ip_whitelist is not None:
            result['IpWhitelist'] = self.ip_whitelist
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.live_packaging_config is not None:
            result['LivePackagingConfig'] = self.live_packaging_config.to_map()
        if self.manifest_name is not None:
            result['ManifestName'] = self.manifest_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeshift_vision is not None:
            result['TimeshiftVision'] = self.timeshift_vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationCode') is not None:
            self.authorization_code = m.get('AuthorizationCode')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointUrl') is not None:
            self.endpoint_url = m.get('EndpointUrl')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IpBlacklist') is not None:
            self.ip_blacklist = m.get('IpBlacklist')
        if m.get('IpWhitelist') is not None:
            self.ip_whitelist = m.get('IpWhitelist')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('LivePackagingConfig') is not None:
            temp_model = LivePackagingConfig()
            self.live_packaging_config = temp_model.from_map(m['LivePackagingConfig'])
        if m.get('ManifestName') is not None:
            self.manifest_name = m.get('ManifestName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TimeshiftVision') is not None:
            self.timeshift_vision = m.get('TimeshiftVision')
        return self


class UpdateLivePackageOriginEndpointResponseBody(TeaModel):
    def __init__(
        self,
        live_package_origin_endpoint: UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint = None,
        request_id: str = None,
    ):
        # The information about the origin endpoint.
        self.live_package_origin_endpoint = live_package_origin_endpoint
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_package_origin_endpoint:
            self.live_package_origin_endpoint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_origin_endpoint is not None:
            result['LivePackageOriginEndpoint'] = self.live_package_origin_endpoint.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageOriginEndpoint') is not None:
            temp_model = UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint()
            self.live_package_origin_endpoint = temp_model.from_map(m['LivePackageOriginEndpoint'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePackageOriginEndpointResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePackageOriginEndpointResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePackageOriginEndpointResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveRecordTemplateRequestRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of the recording cycle. Unit: seconds If you do not specify this parameter, the default value 6 hours is used.
        # 
        # > 
        # 
        # *   If a live stream is interrupted during a recording cycle but is resumed within 3 minutes, the stream is recorded in the same recording before and after the interruption.
        # 
        # *   If a live stream is interrupted for more than 3 minutes, a new recording is generated. To change the default stream interruption time, submit a ticket.
        self.cycle_duration = cycle_duration
        # The format of recording files.
        # 
        # >  If you set this parameter to m3u8, you must also specify the SliceOssObjectPrefix and SliceDuration parameters.
        # 
        # This parameter is required.
        self.format = format
        # The name of the recording that is stored in Object Storage Service (OSS).
        # 
        # *   The name must be less than 256 bytes in length and can contain the {JobId}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
        # *   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment. Unit: seconds
        # 
        # >  This parameter takes effect only if you set Format to m3u8.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration
        # The name of the TS segment.
        # 
        # >  This parameter is required only if you set Format to m3u8. By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {JobId}, {UnixTimestamp}, and {Sequence} variables.
        # 
        # The segment name must contain the {UnixTimestamp} and {Sequence} variables.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class UpdateLiveRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        record_format: List[UpdateLiveRecordTemplateRequestRecordFormat] = None,
        template_id: str = None,
    ):
        # The template name.
        # 
        # This parameter is required.
        self.name = name
        # The list of recording formats.
        # 
        # This parameter is required.
        self.record_format = record_format
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = UpdateLiveRecordTemplateRequestRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveRecordTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        record_format_shrink: str = None,
        template_id: str = None,
    ):
        # The template name.
        # 
        # This parameter is required.
        self.name = name
        # The list of recording formats.
        # 
        # This parameter is required.
        self.record_format_shrink = record_format_shrink
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.record_format_shrink is not None:
            result['RecordFormat'] = self.record_format_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecordFormat') is not None:
            self.record_format_shrink = m.get('RecordFormat')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveSnapshotTemplateRequest(TeaModel):
    def __init__(
        self,
        overwrite_format: str = None,
        sequence_format: str = None,
        template_id: str = None,
        template_name: str = None,
        time_interval: int = None,
    ):
        # The naming format of the snapshot captured in overwrite mode.
        # 
        # *   The value cannot start with a forward slash (/). Only the suffix .jpg is supported.
        # *   The value cannot exceed 255 characters in length.
        # *   The {JobId} placeholder is supported. It specifies the ID of the snapshot job.
        # *   Placeholders such as {UnixTimestamp}, {Sequence}, and {Date} are not allowed.
        # *   You must specify at least one of the OverwriteFormat and SequenceFormat parameters.
        self.overwrite_format = overwrite_format
        # The naming format of the snapshot captured in time series mode.
        # 
        # *   The value cannot start with a forward slash (/). Only the suffix .jpg is supported.
        # *   The value cannot exceed 255 characters in length.
        # *   The {JobId}, {Date}, {UnixTimestamp}, and {Sequence} placeholders are supported. {JobId} specifies the ID of the snapshot job. {Date} specifies the date on which the snapshot is captured. {UnixTimestamp} specifies the timestamp of the snapshot. {Sequence} specifies the sequence number of the snapshot. You must specify at least one of the {UnixTimestamp} and {Sequence} placeholders.
        # *   You must specify at least one of the OverwriteFormat and SequenceFormat parameters.
        self.sequence_format = sequence_format
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The name of the template.
        # 
        # *   It cannot exceed 128 characters in length.
        # 
        # This parameter is required.
        self.template_name = template_name
        # The interval between two adjacent snapshots. Unit: seconds.
        # 
        # *   Valid values: [5,3600].
        # 
        # This parameter is required.
        self.time_interval = time_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_format is not None:
            result['OverwriteFormat'] = self.overwrite_format
        if self.sequence_format is not None:
            result['SequenceFormat'] = self.sequence_format
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverwriteFormat') is not None:
            self.overwrite_format = m.get('OverwriteFormat')
        if m.get('SequenceFormat') is not None:
            self.sequence_format = m.get('SequenceFormat')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class UpdateLiveSnapshotTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveSnapshotTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveSnapshotTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveSnapshotTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveTranscodeJobRequestStreamInput(TeaModel):
    def __init__(
        self,
        input_url: str = None,
        type: str = None,
    ):
        # The URL of the input stream.
        # 
        # This parameter is required.
        self.input_url = input_url
        # The type of the input stream. The value can only be rtmp.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateLiveTranscodeJobRequestTimedConfig(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
    ):
        # The stop time of the transcoding job. Note: The time span between the stop time and the current time cannot exceed seven days.
        self.end_time = end_time
        # The start time of the transcoding job. Note: The time span between the start time and the current time cannot exceed seven days.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class UpdateLiveTranscodeJobRequestTranscodeOutput(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        type: str = None,
    ):
        # The streaming domain name of ApsaraVideo Live.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The type of the output stream. A value of LiveCenter indicates that the URL of the output stream is generated based on the domain name of ApsaraVideo Live. The value can only be LiveCenter.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateLiveTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        name: str = None,
        stream_input: UpdateLiveTranscodeJobRequestStreamInput = None,
        timed_config: UpdateLiveTranscodeJobRequestTimedConfig = None,
        transcode_output: UpdateLiveTranscodeJobRequestTranscodeOutput = None,
    ):
        # The job ID.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The name of the job.
        self.name = name
        # The information about the input stream.
        self.stream_input = stream_input
        # The configuration of a timed transcoding job.
        self.timed_config = timed_config
        # The information about the transcoding output.
        self.transcode_output = transcode_output

    def validate(self):
        if self.stream_input:
            self.stream_input.validate()
        if self.timed_config:
            self.timed_config.validate()
        if self.transcode_output:
            self.transcode_output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.timed_config is not None:
            result['TimedConfig'] = self.timed_config.to_map()
        if self.transcode_output is not None:
            result['TranscodeOutput'] = self.transcode_output.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StreamInput') is not None:
            temp_model = UpdateLiveTranscodeJobRequestStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TimedConfig') is not None:
            temp_model = UpdateLiveTranscodeJobRequestTimedConfig()
            self.timed_config = temp_model.from_map(m['TimedConfig'])
        if m.get('TranscodeOutput') is not None:
            temp_model = UpdateLiveTranscodeJobRequestTranscodeOutput()
            self.transcode_output = temp_model.from_map(m['TranscodeOutput'])
        return self


class UpdateLiveTranscodeJobShrinkRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        name: str = None,
        stream_input_shrink: str = None,
        timed_config_shrink: str = None,
        transcode_output_shrink: str = None,
    ):
        # The job ID.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The name of the job.
        self.name = name
        # The information about the input stream.
        self.stream_input_shrink = stream_input_shrink
        # The configuration of a timed transcoding job.
        self.timed_config_shrink = timed_config_shrink
        # The information about the transcoding output.
        self.transcode_output_shrink = transcode_output_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.stream_input_shrink is not None:
            result['StreamInput'] = self.stream_input_shrink
        if self.timed_config_shrink is not None:
            result['TimedConfig'] = self.timed_config_shrink
        if self.transcode_output_shrink is not None:
            result['TranscodeOutput'] = self.transcode_output_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StreamInput') is not None:
            self.stream_input_shrink = m.get('StreamInput')
        if m.get('TimedConfig') is not None:
            self.timed_config_shrink = m.get('TimedConfig')
        if m.get('TranscodeOutput') is not None:
            self.transcode_output_shrink = m.get('TranscodeOutput')
        return self


class UpdateLiveTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        samplerate: str = None,
    ):
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: 1 to 1000.
        self.bitrate = bitrate
        # The number of sound channels. Valid values: 1: mono 2: binaural
        self.channels = channels
        # The audio codec. Valid values: AAC MP3
        self.codec = codec
        # The audio codec profile. Valid values when the Codec parameter is set to AAC:
        # 
        # *   aac_low
        # *   aac_he
        # *   aac_he_v2
        # *   aac_ld
        self.profile = profile
        # The audio sampling rate. Valid values: 22050 to 96000.
        # 
        # Note If you set AudioProfile to aac_ld, the audio sampling rate cannot exceed 44100.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        profile: str = None,
        width: str = None,
    ):
        # The bitrate of the output video. Unit: Kbit/s. Valid values: 1 to 6000.
        self.bitrate = bitrate
        # The encoding type. Valid values:
        # 
        # *   H.264
        # *   H.265
        self.codec = codec
        # The frame rate of the output video. Unit: frames per second (FPS). Valid values: 1 to 60.
        self.fps = fps
        # The group of pictures (GOP) of the output video. Unit: frame. Valid values: 1 to 3000.
        self.gop = gop
        # The height of the output video. Valid values:
        # 
        # *   Height  128
        # *   max (Height,Width)  2560
        # *   minHeight,Width 1440
        # 
        # >  The resolution of a video transcoded by using the H.265 Narrowband HD template cannot exceed 1,280  720 pixels.
        self.height = height
        # The video encoding profile. The profile determines how a video is encoded. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values:
        # 
        # *   1: baseline. This value is suitable for mobile devices.
        # *   2: main. This value is suitable for standard-definition devices.
        # *   3: high. This value is suitable for high-definition devices.
        self.profile = profile
        # The width of the output video. Valid values:
        # 
        # *   Width  128
        # *   max (Height,Width)  2560
        # *   minHeight,Width 1440
        # 
        # >  The resolution of a video transcoded by using the H.265 Narrowband HD template cannot exceed 1,280  720 pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfig(TeaModel):
    def __init__(
        self,
        audio_params: UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams = None,
        video_params: UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams = None,
    ):
        # The audio parameters.
        self.audio_params = audio_params
        # The video parameters.
        self.video_params = video_params

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class UpdateLiveTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_config: UpdateLiveTranscodeTemplateRequestTemplateConfig = None,
        template_id: str = None,
    ):
        # The template name.
        self.name = name
        # The configuration of the template.
        self.template_config = template_config
        # The template ID. To obtain the template ID, log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com/summary), choose Real-time Media Processing > Template Management, and then click the Transcoding tab. Alternatively, find the ID from the response parameters of the [CreateLiveTranscodeTemplate](https://help.aliyun.com/document_detail/449217.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveTranscodeTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_config_shrink: str = None,
        template_id: str = None,
    ):
        # The template name.
        self.name = name
        # The configuration of the template.
        self.template_config_shrink = template_config_shrink
        # The template ID. To obtain the template ID, log on to the [Intelligent Media Services (IMS) console](https://ims.console.aliyun.com/summary), choose Real-time Media Processing > Template Management, and then click the Transcoding tab. Alternatively, find the ID from the response parameters of the [CreateLiveTranscodeTemplate](https://help.aliyun.com/document_detail/449217.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaConnectFlowInputRequest(TeaModel):
    def __init__(
        self,
        cidrs: str = None,
        flow_id: str = None,
        input_from_url: str = None,
        input_name: str = None,
        max_bitrate: int = None,
        srt_latency: int = None,
        srt_passphrase: str = None,
        srt_pbkey_len: int = None,
    ):
        # The IP address whitelist.
        self.cidrs = cidrs
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The source URL. You can modify this parameter only when the source type is RTMP-PULL or SRT-Listener.
        self.input_from_url = input_from_url
        self.input_name = input_name
        # The maximum bitrate. Unit: bit/s.
        self.max_bitrate = max_bitrate
        # The latency for the SRT stream. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.input_from_url is not None:
            result['InputFromUrl'] = self.input_from_url
        if self.input_name is not None:
            result['InputName'] = self.input_name
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('InputFromUrl') is not None:
            self.input_from_url = m.get('InputFromUrl')
        if m.get('InputName') is not None:
            self.input_name = m.get('InputName')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class UpdateMediaConnectFlowInputResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class UpdateMediaConnectFlowInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaConnectFlowInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaConnectFlowInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaConnectFlowOutputRequest(TeaModel):
    def __init__(
        self,
        cidrs: str = None,
        flow_id: str = None,
        output_name: str = None,
        output_to_url: str = None,
        player_limit: str = None,
        srt_latency: str = None,
        srt_passphrase: str = None,
        srt_pbkey_len: str = None,
    ):
        # The IP address whitelist.
        self.cidrs = cidrs
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The output name.
        # 
        # This parameter is required.
        self.output_name = output_name
        # The output URL. You can modify this parameter only when the output type is RTMP-PUSH or SRT-Caller.
        self.output_to_url = output_to_url
        # The maximum number of viewers.
        self.player_limit = player_limit
        # The latency for the SRT stream. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_latency = srt_latency
        # The SRT key. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_passphrase = srt_passphrase
        # The encryption key length. You can modify this parameter only when the source type is SRT-Listener or SRT-Caller.
        self.srt_pbkey_len = srt_pbkey_len

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrs is not None:
            result['Cidrs'] = self.cidrs
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.output_name is not None:
            result['OutputName'] = self.output_name
        if self.output_to_url is not None:
            result['OutputToUrl'] = self.output_to_url
        if self.player_limit is not None:
            result['PlayerLimit'] = self.player_limit
        if self.srt_latency is not None:
            result['SrtLatency'] = self.srt_latency
        if self.srt_passphrase is not None:
            result['SrtPassphrase'] = self.srt_passphrase
        if self.srt_pbkey_len is not None:
            result['SrtPbkeyLen'] = self.srt_pbkey_len
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrs') is not None:
            self.cidrs = m.get('Cidrs')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('OutputName') is not None:
            self.output_name = m.get('OutputName')
        if m.get('OutputToUrl') is not None:
            self.output_to_url = m.get('OutputToUrl')
        if m.get('PlayerLimit') is not None:
            self.player_limit = m.get('PlayerLimit')
        if m.get('SrtLatency') is not None:
            self.srt_latency = m.get('SrtLatency')
        if m.get('SrtPassphrase') is not None:
            self.srt_passphrase = m.get('SrtPassphrase')
        if m.get('SrtPbkeyLen') is not None:
            self.srt_pbkey_len = m.get('SrtPbkeyLen')
        return self


class UpdateMediaConnectFlowOutputResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class UpdateMediaConnectFlowOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaConnectFlowOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaConnectFlowOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaConnectFlowStatusRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        status: str = None,
    ):
        # The flow ID.
        # 
        # This parameter is required.
        self.flow_id = flow_id
        # The flow state. Valid values:
        # 
        # *   online: starts the flow.
        # *   offline: stops the flow.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdateMediaConnectFlowStatusResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The response body.
        self.content = content
        # The call description.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned error code. A value of 0 indicates that the call is successful.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class UpdateMediaConnectFlowStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaConnectFlowStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaConnectFlowStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaInfoRequest(TeaModel):
    def __init__(
        self,
        append_tags: bool = None,
        business_type: str = None,
        cate_id: int = None,
        category: str = None,
        cover_url: str = None,
        description: str = None,
        input_url: str = None,
        media_id: str = None,
        media_tags: str = None,
        reference_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        # Specifies whether to append tags. Default value: false. Valid values:
        # 
        # *   true: updates the MediaTags parameter by appending new tags.
        # *   false: updates the MediaTags parameter by overwriting existing tags with new tags.
        self.append_tags = append_tags
        # The business type. Valid values:
        # 
        # *   subtitles
        # *   watermark
        # *   opening
        # *   ending
        # *   general
        self.business_type = business_type
        # The category ID.
        self.cate_id = cate_id
        # The category.
        # 
        # *   The value can be up to 64 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.category = category
        # The URL of the thumbnail.
        # 
        # *   The value can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.cover_url = cover_url
        # The content description.
        # 
        # *   The value can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.description = description
        # The input URL of the media asset in another service. The URL must be bound to the ID of the media asset in IMS. The URL cannot be modified once registered.
        # 
        # For a media asset from Object Storage Service (OSS), the URL may have one of the following formats:
        # 
        # 1\\. http(s)://example-bucket.oss-cn-shanghai.aliyuncs.com/example.mp4
        # 
        # 2\\. oss://example-bucket/example.mp4. This format indicates that the region in which the OSS bucket of the media asset resides is the same as the region in which OSS is activated.
        self.input_url = input_url
        # The ID of the media asset. If this parameter is left empty, you must specify the input URL of the media asset, which has been registered in the IMS content library.
        self.media_id = media_id
        # The tags.
        # 
        # *   Up to 16 tags are supported.
        # *   Separate multiple tags with commas (,).
        # *   Each tag can be up to 32 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.media_tags = media_tags
        # The custom ID. The ID can be 6 to 64 characters in length and can contain only letters, digits, hyphens (-), and underscores (_). Make sure that the ID is unique among users.
        self.reference_id = reference_id
        # The title.
        # 
        # *   The value can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.title = title
        # The user data. It can be up to 1,024 bytes in size.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append_tags is not None:
            result['AppendTags'] = self.append_tags
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppendTags') is not None:
            self.append_tags = m.get('AppendTags')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UpdateMediaInfoResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset in IMS.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        profile: str = None,
        sample_rate: int = None,
    ):
        # The audio bitrate. Unit: bit/s. Valid values: 8000 to 1000000. The value must be divisible by 1000.
        self.bitrate = bitrate
        # The audio codec profile. When AudioCodec is set to aac, AAC-LOW and AAC-MAIN are supported. When AudioCodec is set to libfdk_aac, AAC-LOW, AAC-HE, and AAC-HEV2 are supported.
        self.profile = profile
        # The audio sample rate. Unit: Hz. Valid values: 22050, 32000, 44100, 48000, and 96000.
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        return self


class UpdateMediaLiveChannelRequestAudioSettings(TeaModel):
    def __init__(
        self,
        audio_codec: str = None,
        audio_codec_setting: UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting = None,
        audio_selector_name: str = None,
        language_code: str = None,
        language_name: str = None,
        name: str = None,
    ):
        # The audio codec. If it is not specified, the source specification is used. Valid values: aac and libfdk_aac.
        self.audio_codec = audio_codec
        # The audio encoding settings.
        self.audio_codec_setting = audio_codec_setting
        # The name of the audio selector.
        self.audio_selector_name = audio_selector_name
        # Enter a three-letter ISO 639-2 language code. If the audio track selected by the audio selector has a language code, the language code specified in the audio selector is used. If the selected audio track does not have a language code, or if the audio selector cannot find a track that matches its criteria, this language code is used.
        self.language_code = language_code
        # The tag that identifies the language of the RTMP input. It can be referenced by the output. The maximum length is 32 characters. Supported characters:
        # 
        # *   Unicode letters
        # *   Digits (0-9)
        # *   Underscore (_)
        # *   Hyphen (-)
        # *   Space (a space cannot be at the beginning or end)
        self.language_name = language_name
        # The name of the audio settings. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_codec_setting:
            self.audio_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_codec_setting is not None:
            result['AudioCodecSetting'] = self.audio_codec_setting.to_map()
        if self.audio_selector_name is not None:
            result['AudioSelectorName'] = self.audio_selector_name
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioCodecSetting') is not None:
            temp_model = UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting()
            self.audio_codec_setting = temp_model.from_map(m['AudioCodecSetting'])
        if m.get('AudioSelectorName') is not None:
            self.audio_selector_name = m.get('AudioSelectorName')
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection(TeaModel):
    def __init__(
        self,
        language_code: str = None,
    ):
        # Enter a three-letter ISO 639-2 language code from within an audio source.
        # 
        # This parameter is required.
        self.language_code = language_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language_code is not None:
            result['LanguageCode'] = self.language_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanguageCode') is not None:
            self.language_code = m.get('LanguageCode')
        return self


class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection(TeaModel):
    def __init__(
        self,
        pid: int = None,
    ):
        # Enter a specific PID from within a source.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection(TeaModel):
    def __init__(
        self,
        track_id: int = None,
    ):
        # Specify one or more audio tracks from within a source using Track ID.
        # 
        # This parameter is required.
        self.track_id = track_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.track_id is not None:
            result['TrackId'] = self.track_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TrackId') is not None:
            self.track_id = m.get('TrackId')
        return self


class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors(TeaModel):
    def __init__(
        self,
        audio_language_selection: UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection = None,
        audio_pid_selection: UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection = None,
        audio_track_selection: List[UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection] = None,
        name: str = None,
    ):
        # The audio language selection.
        self.audio_language_selection = audio_language_selection
        # The audio PID selection.
        self.audio_pid_selection = audio_pid_selection
        # The audio track selection.
        self.audio_track_selection = audio_track_selection
        # The name of the audio selector. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.audio_language_selection:
            self.audio_language_selection.validate()
        if self.audio_pid_selection:
            self.audio_pid_selection.validate()
        if self.audio_track_selection:
            for k in self.audio_track_selection:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_language_selection is not None:
            result['AudioLanguageSelection'] = self.audio_language_selection.to_map()
        if self.audio_pid_selection is not None:
            result['AudioPidSelection'] = self.audio_pid_selection.to_map()
        result['AudioTrackSelection'] = []
        if self.audio_track_selection is not None:
            for k in self.audio_track_selection:
                result['AudioTrackSelection'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLanguageSelection') is not None:
            temp_model = UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection()
            self.audio_language_selection = temp_model.from_map(m['AudioLanguageSelection'])
        if m.get('AudioPidSelection') is not None:
            temp_model = UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection()
            self.audio_pid_selection = temp_model.from_map(m['AudioPidSelection'])
        self.audio_track_selection = []
        if m.get('AudioTrackSelection') is not None:
            for k in m.get('AudioTrackSelection'):
                temp_model = UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection()
                self.audio_track_selection.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateMediaLiveChannelRequestInputAttachments(TeaModel):
    def __init__(
        self,
        audio_selectors: List[UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors] = None,
        input_id: str = None,
        language_name: str = None,
    ):
        # The audio selectors.
        self.audio_selectors = audio_selectors
        # The ID of the associated input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The tag that identifies the language of the RTMP input. It can be referenced by the output. The maximum length is 32 characters. Supported characters:
        # 
        # *   Unicode letters
        # *   Digits (0-9)
        # *   Underscore (_)
        # *   Hyphen (-)
        # *   Space (a space cannot be at the beginning or end)
        self.language_name = language_name

    def validate(self):
        if self.audio_selectors:
            for k in self.audio_selectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSelectors'] = []
        if self.audio_selectors is not None:
            for k in self.audio_selectors:
                result['AudioSelectors'].append(k.to_map() if k else None)
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.language_name is not None:
            result['LanguageName'] = self.language_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_selectors = []
        if m.get('AudioSelectors') is not None:
            for k in m.get('AudioSelectors'):
                temp_model = UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors()
                self.audio_selectors.append(temp_model.from_map(k))
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('LanguageName') is not None:
            self.language_name = m.get('LanguageName')
        return self


class UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        group_name: str = None,
    ):
        # ChannelName in MediaPackage.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # GroupName in MediaPackage.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting(TeaModel):
    def __init__(
        self,
        audio_group_id: str = None,
        name_modifier: str = None,
    ):
        # The manifest audio group ID. To associate several audio tracks into one group, assign the same audio group ID. Viewers can select a track as needed. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 40 characters in length.
        self.audio_group_id = audio_group_id
        # The manifest name modifier. The child manifests include this modifier in their M3U8 file names. Letters, digits, hyphens (-), and underscores (_) are supported. The maximum length is 40 characters.
        self.name_modifier = name_modifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_group_id is not None:
            result['AudioGroupId'] = self.audio_group_id
        if self.name_modifier is not None:
            result['NameModifier'] = self.name_modifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioGroupId') is not None:
            self.audio_group_id = m.get('AudioGroupId')
        if m.get('NameModifier') is not None:
            self.name_modifier = m.get('NameModifier')
        return self


class UpdateMediaLiveChannelRequestOutputGroupsOutputs(TeaModel):
    def __init__(
        self,
        audio_setting_names: List[str] = None,
        media_package_output_setting: UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting = None,
        media_type: int = None,
        name: str = None,
        video_setting_name: str = None,
    ):
        # The referenced AudioSettings.
        self.audio_setting_names = audio_setting_names
        # The settings of the output delivered to MediaPackage.
        self.media_package_output_setting = media_package_output_setting
        # The media type of the output. Valid values:
        # 
        # *   0: Audio and Video
        # *   1: Audio If you set the value to 1, you cannot reference VideoSettings.
        # *   2: Video. If you set the value to 2, you cannot reference AudioSettings.
        self.media_type = media_type
        # The name of the output. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The name of the referenced VideoSettings.
        self.video_setting_name = video_setting_name

    def validate(self):
        if self.media_package_output_setting:
            self.media_package_output_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_setting_names is not None:
            result['AudioSettingNames'] = self.audio_setting_names
        if self.media_package_output_setting is not None:
            result['MediaPackageOutputSetting'] = self.media_package_output_setting.to_map()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.video_setting_name is not None:
            result['VideoSettingName'] = self.video_setting_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettingNames') is not None:
            self.audio_setting_names = m.get('AudioSettingNames')
        if m.get('MediaPackageOutputSetting') is not None:
            temp_model = UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting()
            self.media_package_output_setting = temp_model.from_map(m['MediaPackageOutputSetting'])
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoSettingName') is not None:
            self.video_setting_name = m.get('VideoSettingName')
        return self


class UpdateMediaLiveChannelRequestOutputGroups(TeaModel):
    def __init__(
        self,
        media_package_group_setting: UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting = None,
        name: str = None,
        outputs: List[UpdateMediaLiveChannelRequestOutputGroupsOutputs] = None,
        type: str = None,
    ):
        # The MediaPackage destination.
        self.media_package_group_setting = media_package_group_setting
        # The name of the output group. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The outputs in the output group.
        # 
        # This parameter is required.
        self.outputs = outputs
        # The output group type. Only MediaPackage is supported.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.media_package_group_setting:
            self.media_package_group_setting.validate()
        if self.outputs:
            for k in self.outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_package_group_setting is not None:
            result['MediaPackageGroupSetting'] = self.media_package_group_setting.to_map()
        if self.name is not None:
            result['Name'] = self.name
        result['Outputs'] = []
        if self.outputs is not None:
            for k in self.outputs:
                result['Outputs'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaPackageGroupSetting') is not None:
            temp_model = UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting()
            self.media_package_group_setting = temp_model.from_map(m['MediaPackageGroupSetting'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.outputs = []
        if m.get('Outputs') is not None:
            for k in m.get('Outputs'):
                temp_model = UpdateMediaLiveChannelRequestOutputGroupsOutputs()
                self.outputs.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail(TeaModel):
    def __init__(
        self,
        level: str = None,
        profile: str = None,
    ):
        # The video encoding level. It is not supported yet.
        self.level = level
        # The H.264 profile. Valid values: BASELINE, HIGH, and MAIN. Default value: MAIN. The parameter takes effect only when the codec is H.264.
        self.profile = profile

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.profile is not None:
            result['Profile'] = self.profile
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        return self


class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate(TeaModel):
    def __init__(
        self,
        framerate_control: str = None,
        framerate_denominator: int = None,
        framerate_numerator: int = None,
    ):
        # The frame rate mode. Valid values: SPECIFIED (fixed frame rate) and FROM_SOURCE (use source specification).
        self.framerate_control = framerate_control
        # The denominator of the fixed frame rate. The parameter is required when FramerateControl is set to SPECIFIED. Valid values: 1 to 60. The numerator must be divisible by the denominator.
        self.framerate_denominator = framerate_denominator
        # The numerator of the fixed frame rate. The parameter is required when FramerateControl is set to SPECIFIED. Valid values: 1 to 60. The numerator must be divisible by the denominator.
        self.framerate_numerator = framerate_numerator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.framerate_control is not None:
            result['FramerateControl'] = self.framerate_control
        if self.framerate_denominator is not None:
            result['FramerateDenominator'] = self.framerate_denominator
        if self.framerate_numerator is not None:
            result['FramerateNumerator'] = self.framerate_numerator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FramerateControl') is not None:
            self.framerate_control = m.get('FramerateControl')
        if m.get('FramerateDenominator') is not None:
            self.framerate_denominator = m.get('FramerateDenominator')
        if m.get('FramerateNumerator') is not None:
            self.framerate_numerator = m.get('FramerateNumerator')
        return self


class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop(TeaModel):
    def __init__(
        self,
        bframes_num: int = None,
        gop_size: int = None,
        gop_size_units: str = None,
    ):
        # The number of B frames. Valid values: 1 to 3.
        self.bframes_num = bframes_num
        # The GOP size. When GopSizeUnits is set to SECONDS, the value range is from 1 to 20. When GopSizeUnits is set to FRAMES, the value range is from 1 to 3000.
        self.gop_size = gop_size
        # The GOP size unit. Valid values: FRAMES and SECONDS.
        self.gop_size_units = gop_size_units

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bframes_num is not None:
            result['BframesNum'] = self.bframes_num
        if self.gop_size is not None:
            result['GopSize'] = self.gop_size
        if self.gop_size_units is not None:
            result['GopSizeUnits'] = self.gop_size_units
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BframesNum') is not None:
            self.bframes_num = m.get('BframesNum')
        if m.get('GopSize') is not None:
            self.gop_size = m.get('GopSize')
        if m.get('GopSizeUnits') is not None:
            self.gop_size_units = m.get('GopSizeUnits')
        return self


class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        buffer_size: int = None,
        max_bitrate: int = None,
        rate_control_mode: str = None,
    ):
        # The video bitrate. Unit: bit/s. If you set it to 0 or leave it empty, the source specification is used. Valid values: 50000 to 6000000. The value must be divisible by 1000.
        self.bitrate = bitrate
        # The video buffer size. Unit: bit/s. Valid values: 100000 to 6000000. The value must be divisible by 1000.
        self.buffer_size = buffer_size
        # The maximum bitrate. Unit: bit/s. Valid values: 100000 to 6000000. The value must be divisible by 1000.
        self.max_bitrate = max_bitrate
        # The bitrate control mode. Valid values: CBR, ABR, and VBR.
        self.rate_control_mode = rate_control_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.buffer_size is not None:
            result['BufferSize'] = self.buffer_size
        if self.max_bitrate is not None:
            result['MaxBitrate'] = self.max_bitrate
        if self.rate_control_mode is not None:
            result['RateControlMode'] = self.rate_control_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BufferSize') is not None:
            self.buffer_size = m.get('BufferSize')
        if m.get('MaxBitrate') is not None:
            self.max_bitrate = m.get('MaxBitrate')
        if m.get('RateControlMode') is not None:
            self.rate_control_mode = m.get('RateControlMode')
        return self


class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting(TeaModel):
    def __init__(
        self,
        codec_detail: UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail = None,
        framerate: UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate = None,
        gop: UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop = None,
        rate: UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate = None,
    ):
        # The video encoding settings.
        self.codec_detail = codec_detail
        # The frame rate. If it is not specified, the source specification is used.
        self.framerate = framerate
        # The GOP setting. If it is not specified, the source specification is used.
        self.gop = gop
        # The video encoding rate. If it is not specified, the source specification is used.
        self.rate = rate

    def validate(self):
        if self.codec_detail:
            self.codec_detail.validate()
        if self.framerate:
            self.framerate.validate()
        if self.gop:
            self.gop.validate()
        if self.rate:
            self.rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_detail is not None:
            result['CodecDetail'] = self.codec_detail.to_map()
        if self.framerate is not None:
            result['Framerate'] = self.framerate.to_map()
        if self.gop is not None:
            result['Gop'] = self.gop.to_map()
        if self.rate is not None:
            result['Rate'] = self.rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecDetail') is not None:
            temp_model = UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail()
            self.codec_detail = temp_model.from_map(m['CodecDetail'])
        if m.get('Framerate') is not None:
            temp_model = UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate()
            self.framerate = temp_model.from_map(m['Framerate'])
        if m.get('Gop') is not None:
            temp_model = UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop()
            self.gop = temp_model.from_map(m['Gop'])
        if m.get('Rate') is not None:
            temp_model = UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate()
            self.rate = temp_model.from_map(m['Rate'])
        return self


class UpdateMediaLiveChannelRequestVideoSettings(TeaModel):
    def __init__(
        self,
        height: int = None,
        name: str = None,
        video_codec: str = None,
        video_codec_setting: UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting = None,
        video_codec_type: str = None,
        width: int = None,
    ):
        # The height of the output. Valid values: 0 to 2000. If you set it to 0 or leave it empty, the height automatically adapts to the specified width to maintain the original aspect ratio.
        self.height = height
        # The name of the video settings. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The video codec. Valid values: H264 and H265.
        self.video_codec = video_codec
        # The video encoding settings.
        self.video_codec_setting = video_codec_setting
        self.video_codec_type = video_codec_type
        # The width of the output. Valid values: 0 to 2000. If you set it to 0 or leave it empty, the width automatically adapts to the specified height to maintain the original aspect ratio.
        self.width = width

    def validate(self):
        if self.video_codec_setting:
            self.video_codec_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_codec_setting is not None:
            result['VideoCodecSetting'] = self.video_codec_setting.to_map()
        if self.video_codec_type is not None:
            result['VideoCodecType'] = self.video_codec_type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoCodecSetting') is not None:
            temp_model = UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting()
            self.video_codec_setting = temp_model.from_map(m['VideoCodecSetting'])
        if m.get('VideoCodecType') is not None:
            self.video_codec_type = m.get('VideoCodecType')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateMediaLiveChannelRequest(TeaModel):
    def __init__(
        self,
        audio_settings: List[UpdateMediaLiveChannelRequestAudioSettings] = None,
        channel_id: str = None,
        input_attachments: List[UpdateMediaLiveChannelRequestInputAttachments] = None,
        name: str = None,
        output_groups: List[UpdateMediaLiveChannelRequestOutputGroups] = None,
        video_settings: List[UpdateMediaLiveChannelRequestVideoSettings] = None,
    ):
        # The audio settings.
        self.audio_settings = audio_settings
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The inputs associated with the channel.
        # 
        # This parameter is required.
        self.input_attachments = input_attachments
        # The name of the channel. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The output groups.
        # 
        # This parameter is required.
        self.output_groups = output_groups
        # The video settings.
        self.video_settings = video_settings

    def validate(self):
        if self.audio_settings:
            for k in self.audio_settings:
                if k:
                    k.validate()
        if self.input_attachments:
            for k in self.input_attachments:
                if k:
                    k.validate()
        if self.output_groups:
            for k in self.output_groups:
                if k:
                    k.validate()
        if self.video_settings:
            for k in self.video_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioSettings'] = []
        if self.audio_settings is not None:
            for k in self.audio_settings:
                result['AudioSettings'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['InputAttachments'] = []
        if self.input_attachments is not None:
            for k in self.input_attachments:
                result['InputAttachments'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroups'] = []
        if self.output_groups is not None:
            for k in self.output_groups:
                result['OutputGroups'].append(k.to_map() if k else None)
        result['VideoSettings'] = []
        if self.video_settings is not None:
            for k in self.video_settings:
                result['VideoSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_settings = []
        if m.get('AudioSettings') is not None:
            for k in m.get('AudioSettings'):
                temp_model = UpdateMediaLiveChannelRequestAudioSettings()
                self.audio_settings.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.input_attachments = []
        if m.get('InputAttachments') is not None:
            for k in m.get('InputAttachments'):
                temp_model = UpdateMediaLiveChannelRequestInputAttachments()
                self.input_attachments.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_groups = []
        if m.get('OutputGroups') is not None:
            for k in m.get('OutputGroups'):
                temp_model = UpdateMediaLiveChannelRequestOutputGroups()
                self.output_groups.append(temp_model.from_map(k))
        self.video_settings = []
        if m.get('VideoSettings') is not None:
            for k in m.get('VideoSettings'):
                temp_model = UpdateMediaLiveChannelRequestVideoSettings()
                self.video_settings.append(temp_model.from_map(k))
        return self


class UpdateMediaLiveChannelShrinkRequest(TeaModel):
    def __init__(
        self,
        audio_settings_shrink: str = None,
        channel_id: str = None,
        input_attachments_shrink: str = None,
        name: str = None,
        output_groups_shrink: str = None,
        video_settings_shrink: str = None,
    ):
        # The audio settings.
        self.audio_settings_shrink = audio_settings_shrink
        # The ID of the channel.
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The inputs associated with the channel.
        # 
        # This parameter is required.
        self.input_attachments_shrink = input_attachments_shrink
        # The name of the channel. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The output groups.
        # 
        # This parameter is required.
        self.output_groups_shrink = output_groups_shrink
        # The video settings.
        self.video_settings_shrink = video_settings_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_settings_shrink is not None:
            result['AudioSettings'] = self.audio_settings_shrink
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.input_attachments_shrink is not None:
            result['InputAttachments'] = self.input_attachments_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_groups_shrink is not None:
            result['OutputGroups'] = self.output_groups_shrink
        if self.video_settings_shrink is not None:
            result['VideoSettings'] = self.video_settings_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSettings') is not None:
            self.audio_settings_shrink = m.get('AudioSettings')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('InputAttachments') is not None:
            self.input_attachments_shrink = m.get('InputAttachments')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputGroups') is not None:
            self.output_groups_shrink = m.get('OutputGroups')
        if m.get('VideoSettings') is not None:
            self.video_settings_shrink = m.get('VideoSettings')
        return self


class UpdateMediaLiveChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaLiveChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaLiveChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaLiveChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaLiveInputRequestInputSettings(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        flow_output_name: str = None,
        source_url: str = None,
        stream_name: str = None,
    ):
        self.flow_id = flow_id
        self.flow_output_name = flow_output_name
        # The source URL where the stream is pulled from. This parameter is required for PULL inputs.
        self.source_url = source_url
        # The name of the pushed stream. This parameter is required for PUSH inputs. It can be up to 255 characters in length.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_output_name is not None:
            result['FlowOutputName'] = self.flow_output_name
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowOutputName') is not None:
            self.flow_output_name = m.get('FlowOutputName')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class UpdateMediaLiveInputRequest(TeaModel):
    def __init__(
        self,
        input_id: str = None,
        input_settings: List[UpdateMediaLiveInputRequestInputSettings] = None,
        name: str = None,
        security_group_ids: List[str] = None,
    ):
        # The ID of the input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The input settings. An input can have up to two sources: primary and backup sources.
        # 
        # This parameter is required.
        self.input_settings = input_settings
        # The name of the input. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The IDs of the security groups to be associated with the input. This parameter is required for PUSH inputs.
        self.security_group_ids = security_group_ids

    def validate(self):
        if self.input_settings:
            for k in self.input_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_id is not None:
            result['InputId'] = self.input_id
        result['InputSettings'] = []
        if self.input_settings is not None:
            for k in self.input_settings:
                result['InputSettings'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        self.input_settings = []
        if m.get('InputSettings') is not None:
            for k in m.get('InputSettings'):
                temp_model = UpdateMediaLiveInputRequestInputSettings()
                self.input_settings.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        return self


class UpdateMediaLiveInputShrinkRequest(TeaModel):
    def __init__(
        self,
        input_id: str = None,
        input_settings_shrink: str = None,
        name: str = None,
        security_group_ids_shrink: str = None,
    ):
        # The ID of the input.
        # 
        # This parameter is required.
        self.input_id = input_id
        # The input settings. An input can have up to two sources: primary and backup sources.
        # 
        # This parameter is required.
        self.input_settings_shrink = input_settings_shrink
        # The name of the input. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The IDs of the security groups to be associated with the input. This parameter is required for PUSH inputs.
        self.security_group_ids_shrink = security_group_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_id is not None:
            result['InputId'] = self.input_id
        if self.input_settings_shrink is not None:
            result['InputSettings'] = self.input_settings_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids_shrink is not None:
            result['SecurityGroupIds'] = self.security_group_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputId') is not None:
            self.input_id = m.get('InputId')
        if m.get('InputSettings') is not None:
            self.input_settings_shrink = m.get('InputSettings')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids_shrink = m.get('SecurityGroupIds')
        return self


class UpdateMediaLiveInputResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaLiveInputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaLiveInputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaLiveInputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaLiveInputSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        security_group_id: str = None,
        whitelist_rules: List[str] = None,
    ):
        # The name of the security group. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The security group rules.
        # 
        # This parameter is required.
        self.whitelist_rules = whitelist_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.whitelist_rules is not None:
            result['WhitelistRules'] = self.whitelist_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules = m.get('WhitelistRules')
        return self


class UpdateMediaLiveInputSecurityGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        security_group_id: str = None,
        whitelist_rules_shrink: str = None,
    ):
        # The name of the security group. Letters, digits, hyphens (-), and underscores (_) are supported. It can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The security group rules.
        # 
        # This parameter is required.
        self.whitelist_rules_shrink = whitelist_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.whitelist_rules_shrink is not None:
            result['WhitelistRules'] = self.whitelist_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('WhitelistRules') is not None:
            self.whitelist_rules_shrink = m.get('WhitelistRules')
        return self


class UpdateMediaLiveInputSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaLiveInputSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaLiveInputSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaLiveInputSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaMarksRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_marks: str = None,
    ):
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The marks of the media asset.
        # 
        # This parameter is required.
        self.media_marks = media_marks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_marks is not None:
            result['MediaMarks'] = self.media_marks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarks') is not None:
            self.media_marks = m.get('MediaMarks')
        return self


class UpdateMediaMarksResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        media_mark_ids: str = None,
        request_id: str = None,
    ):
        # The ID of the media asset.
        self.media_id = media_id
        # The IDs of the successfully modified marks.
        self.media_mark_ids = media_mark_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_mark_ids is not None:
            result['MediaMarkIds'] = self.media_mark_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaMarkIds') is not None:
            self.media_mark_ids = m.get('MediaMarkIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaMarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaMarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaMarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaToSearchLibRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        msg_body: str = None,
        search_lib_name: str = None,
    ):
        # The ID of the media asset.
        # 
        # This parameter is required.
        self.media_id = media_id
        # The message body.
        # 
        # This parameter is required.
        self.msg_body = msg_body
        # The name of the search library. Default value: ims-default-search-lib.
        self.search_lib_name = search_lib_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.msg_body is not None:
            result['MsgBody'] = self.msg_body
        if self.search_lib_name is not None:
            result['SearchLibName'] = self.search_lib_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MsgBody') is not None:
            self.msg_body = m.get('MsgBody')
        if m.get('SearchLibName') is not None:
            self.search_lib_name = m.get('SearchLibName')
        return self


class UpdateMediaToSearchLibResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        media_id: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The status code returned.
        self.code = code
        # The ID of the media asset.
        self.media_id = media_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMediaToSearchLibResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaToSearchLibResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaToSearchLibResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        pipeline_id: str = None,
        priority: int = None,
        status: str = None,
    ):
        # The name of the MPS queue.
        self.name = name
        # The ID of the MPS queue.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id
        # The priority of the MPS queue. Valid values: 1 to 10.
        self.priority = priority
        # The state of the MPS queue.
        # 
        # Valid values:
        # 
        # *   Active
        # *   Paused
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProgramRequest(TeaModel):
    def __init__(
        self,
        ad_breaks: str = None,
        channel_name: str = None,
        clip_range: str = None,
        program_name: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
        transition: str = None,
    ):
        # The information about ad breaks.
        self.ad_breaks = ad_breaks
        # The name of the channel.
        # 
        # This parameter is required.
        self.channel_name = channel_name
        # Extracts a clip from the source.
        self.clip_range = clip_range
        # The name of the program.
        # 
        # This parameter is required.
        self.program_name = program_name
        # The name of the source location.
        self.source_location_name = source_location_name
        # The name of the source.
        self.source_name = source_name
        # The source type of the program. Valid values: vodSource and liveSource.
        self.source_type = source_type
        # The program transition method.
        self.transition = transition

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_breaks is not None:
            result['AdBreaks'] = self.ad_breaks
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.clip_range is not None:
            result['ClipRange'] = self.clip_range
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.transition is not None:
            result['Transition'] = self.transition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdBreaks') is not None:
            self.ad_breaks = m.get('AdBreaks')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ClipRange') is not None:
            self.clip_range = m.get('ClipRange')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Transition') is not None:
            self.transition = m.get('Transition')
        return self


class UpdateProgramResponseBody(TeaModel):
    def __init__(
        self,
        program: ChannelAssemblyProgram = None,
        request_id: str = None,
    ):
        # The information about the program.
        self.program = program
        # **Request ID**\
        self.request_id = request_id

    def validate(self):
        if self.program:
            self.program.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program is not None:
            result['Program'] = self.program.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Program') is not None:
            temp_model = ChannelAssemblyProgram()
            self.program = temp_model.from_map(m['Program'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRtcRobotInstanceRequestConfig(TeaModel):
    def __init__(
        self,
        enable_voice_interrupt: bool = None,
        greeting: str = None,
        voice_id: str = None,
    ):
        self.enable_voice_interrupt = enable_voice_interrupt
        self.greeting = greeting
        self.voice_id = voice_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_voice_interrupt is not None:
            result['EnableVoiceInterrupt'] = self.enable_voice_interrupt
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.voice_id is not None:
            result['VoiceId'] = self.voice_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableVoiceInterrupt') is not None:
            self.enable_voice_interrupt = m.get('EnableVoiceInterrupt')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('VoiceId') is not None:
            self.voice_id = m.get('VoiceId')
        return self


class UpdateRtcRobotInstanceRequest(TeaModel):
    def __init__(
        self,
        config: UpdateRtcRobotInstanceRequestConfig = None,
        instance_id: str = None,
    ):
        self.config = config
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = UpdateRtcRobotInstanceRequestConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UpdateRtcRobotInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        config_shrink: str = None,
        instance_id: str = None,
    ):
        self.config_shrink = config_shrink
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_shrink is not None:
            result['Config'] = self.config_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config_shrink = m.get('Config')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UpdateRtcRobotInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRtcRobotInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRtcRobotInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRtcRobotInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSourceRequest(TeaModel):
    def __init__(
        self,
        http_package_configurations: str = None,
        source_location_name: str = None,
        source_name: str = None,
        source_type: str = None,
    ):
        # The source configurations.
        # 
        # This parameter is required.
        self.http_package_configurations = http_package_configurations
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name
        # The name of the source.
        # 
        # This parameter is required.
        self.source_name = source_name
        # The source type. Valid values: vodSource and liveSource.
        # 
        # This parameter is required.
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_package_configurations is not None:
            result['HttpPackageConfigurations'] = self.http_package_configurations
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpPackageConfigurations') is not None:
            self.http_package_configurations = m.get('HttpPackageConfigurations')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class UpdateSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source: ChannelAssemblySource = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source information.
        self.source = source

    def validate(self):
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            temp_model = ChannelAssemblySource()
            self.source = temp_model.from_map(m['Source'])
        return self


class UpdateSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSourceLocationRequest(TeaModel):
    def __init__(
        self,
        base_url: str = None,
        enable_segment_delivery: bool = None,
        segment_delivery_url: str = None,
        source_location_name: str = None,
    ):
        # The protocol and hostname of the source location.
        self.base_url = base_url
        # Specifies whether to use an independent domain name to access the segments.
        self.enable_segment_delivery = enable_segment_delivery
        # The domain name used to access the segments.
        self.segment_delivery_url = segment_delivery_url
        # The name of the source location.
        # 
        # This parameter is required.
        self.source_location_name = source_location_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_url is not None:
            result['BaseUrl'] = self.base_url
        if self.enable_segment_delivery is not None:
            result['EnableSegmentDelivery'] = self.enable_segment_delivery
        if self.segment_delivery_url is not None:
            result['SegmentDeliveryUrl'] = self.segment_delivery_url
        if self.source_location_name is not None:
            result['SourceLocationName'] = self.source_location_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseUrl') is not None:
            self.base_url = m.get('BaseUrl')
        if m.get('EnableSegmentDelivery') is not None:
            self.enable_segment_delivery = m.get('EnableSegmentDelivery')
        if m.get('SegmentDeliveryUrl') is not None:
            self.segment_delivery_url = m.get('SegmentDeliveryUrl')
        if m.get('SourceLocationName') is not None:
            self.source_location_name = m.get('SourceLocationName')
        return self


class UpdateSourceLocationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source_location: ChannelAssemblySourceLocation = None,
    ):
        # **Request ID**\
        self.request_id = request_id
        # The source location information.
        self.source_location = source_location

    def validate(self):
        if self.source_location:
            self.source_location.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source_location is not None:
            result['SourceLocation'] = self.source_location.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SourceLocation') is not None:
            temp_model = ChannelAssemblySourceLocation()
            self.source_location = temp_model.from_map(m['SourceLocation'])
        return self


class UpdateSourceLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSourceLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSourceLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        cover_url: str = None,
        name: str = None,
        preview_media: str = None,
        related_mediaids: str = None,
        source: str = None,
        status: str = None,
        template_id: str = None,
    ):
        self.config = config
        # The URL of the template thumbnail.
        self.cover_url = cover_url
        # The name of the online editing template.
        self.name = name
        # The ID of the preview video.
        self.preview_media = preview_media
        # The IDs of the materials associated with the template for use by the regular template editor.
        self.related_mediaids = related_mediaids
        # The source from which the template is modified. Default value: OpenAPI. Valid values:
        # 
        # *   AliyunConsole
        # *   OpenAPI
        # *   WebSDK
        self.source = source
        # The template state. Valid values:
        # 
        # *   Available: The template is available.
        # *   Created: The template is created but not ready for use.
        # *   Uploading: The video is being uploaded.
        # *   Processing: The advanced template is being processed.
        # *   UploadFailed: Failed to upload the video.
        # *   ProcessFailed: Failed to process the advanced template.
        # 
        # >  After an advanced template is created, it enters the Processing state. In this case, the template is unavailable. The template can be used only when it is in the Available state. The time required for template processing varies based on the size of the template file. Generally, it ranges from 10 seconds to 5 minutes.
        self.status = status
        # The ID of the online editing template. You can obtain the template ID in the [Intelligent Media Services (IMS) console](https://ice.console.aliyun.com/production/template/list/common) or the response parameters of the [AddTemplate](https://help.aliyun.com/document_detail/441161.html) operation.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.related_mediaids is not None:
            result['RelatedMediaids'] = self.related_mediaids
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('RelatedMediaids') is not None:
            self.related_mediaids = m.get('RelatedMediaids')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadMediaByURLRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        entity_id: str = None,
        media_meta_data: str = None,
        post_process_config: str = None,
        upload_target_config: str = None,
        upload_urls: str = None,
        user_data: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The entity ID. You can call the CreateEntity operation to create an entity and specify a dynamic metadata structure.
        self.entity_id = entity_id
        # The metadata of the media file that you want to upload. The value must be a JSON string.
        # 
        # *   This parameter takes effect only if its value matches a URL that is specified in UploadURLs.
        # *   You must convert the JSON-formatted data, such as [UploadMetadata, UploadMetadata,], into a JSON string.
        # *   For more information, see the "UploadMetadata" section of this topic.
        self.media_meta_data = media_meta_data
        # The postprocessing configurations. You can specify this parameter if Type is set to video or audio.
        # 
        # Set ProcessType to Workflow.
        self.post_process_config = post_process_config
        # The destination storage address.
        # 
        # Set StorageType to oss.
        # 
        # Set StorageLocation to an address in ApsaraVideo VOD. You cannot set this field to an OSS URL.
        self.upload_target_config = upload_target_config
        # The URL of the source file.
        # 
        # *   The URL must contain a file name extension, such as mp4 in `https://****.mp4`.
        # 
        #     *   If the URL does not contain a file name extension, you can specify one by setting `FileExtension` in `UploadMetadata`.
        #     *   If the URL contains a file name extension and `FileExtension` is also specified, the value of `FileExtension` prevails.
        # 
        # *   URL encoding is required. Separate multiple URLs with commas (,). You can specify a maximum of 20 URLs.
        # 
        # *   Special characters may cause upload failures. Therefore, you must encode URLs before you separate them with commas (,).
        self.upload_urls = upload_urls
        # The user data. The value must be a JSON string. You can configure settings such as message callbacks.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.media_meta_data is not None:
            result['MediaMetaData'] = self.media_meta_data
        if self.post_process_config is not None:
            result['PostProcessConfig'] = self.post_process_config
        if self.upload_target_config is not None:
            result['UploadTargetConfig'] = self.upload_target_config
        if self.upload_urls is not None:
            result['UploadURLs'] = self.upload_urls
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('MediaMetaData') is not None:
            self.media_meta_data = m.get('MediaMetaData')
        if m.get('PostProcessConfig') is not None:
            self.post_process_config = m.get('PostProcessConfig')
        if m.get('UploadTargetConfig') is not None:
            self.upload_target_config = m.get('UploadTargetConfig')
        if m.get('UploadURLs') is not None:
            self.upload_urls = m.get('UploadURLs')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UploadMediaByURLResponseBodyUploadJobs(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
        source_url: str = None,
    ):
        # The ID of the upload job.
        self.job_id = job_id
        # The ID of the media asset.
        self.media_id = media_id
        # The URL of the source file that is uploaded in the upload job.
        self.source_url = source_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.source_url is not None:
            result['SourceURL'] = self.source_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('SourceURL') is not None:
            self.source_url = m.get('SourceURL')
        return self


class UploadMediaByURLResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        upload_jobs: List[UploadMediaByURLResponseBodyUploadJobs] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about upload jobs.
        self.upload_jobs = upload_jobs

    def validate(self):
        if self.upload_jobs:
            for k in self.upload_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UploadJobs'] = []
        if self.upload_jobs is not None:
            for k in self.upload_jobs:
                result['UploadJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.upload_jobs = []
        if m.get('UploadJobs') is not None:
            for k in m.get('UploadJobs'):
                temp_model = UploadMediaByURLResponseBodyUploadJobs()
                self.upload_jobs.append(temp_model.from_map(k))
        return self


class UploadMediaByURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadMediaByURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadMediaByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadStreamByURLRequest(TeaModel):
    def __init__(
        self,
        definition: str = None,
        file_extension: str = None,
        hdrtype: str = None,
        media_id: str = None,
        stream_url: str = None,
        user_data: str = None,
    ):
        # The quality of the media stream. Valid values:
        # 
        # *   FD: low definition.
        # *   LD: standard definition.
        # *   SD: high definition.
        # *   HD: ultra-high definition.
        # *   OD: original quality.
        # *   2K: 2K resolution.
        # *   4K: 4K resolution.
        # *   SQ: standard sound quality.
        # *   HQ: high sound quality.
        self.definition = definition
        # The file name extension of the media stream.
        self.file_extension = file_extension
        # The high dynamic range (HDR) format of the transcoded stream. Valid values:
        # 
        # *   HDR
        # *   HDR10
        # *   HLG
        # *   DolbyVision
        # *   HDRVivid
        # *   SDR+\
        # 
        # > 
        # 
        # *   The value is not case-sensitive,
        # 
        # *   You can leave this parameter empty for non-HDR streams.
        self.hdrtype = hdrtype
        # The ID of the media asset.
        self.media_id = media_id
        # The URL of the transcoded stream file.
        # 
        # If the URL of the transcoded stream requires authentication, you must specify the authentication parameters in the stream URL and make sure that the URL can be accessed over the Internet.
        self.stream_url = stream_url
        # The user data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.file_extension is not None:
            result['FileExtension'] = self.file_extension
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('FileExtension') is not None:
            self.file_extension = m.get('FileExtension')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UploadStreamByURLResponseBody(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        job_id: str = None,
        media_id: str = None,
        request_id: str = None,
        source_url: str = None,
    ):
        # The OSS URL of the file.
        self.file_url = file_url
        # The ID of the upload job.
        self.job_id = job_id
        # The ID of the media asset.
        self.media_id = media_id
        # The request ID.
        self.request_id = request_id
        # The URL of the source file that is uploaded in the upload job.
        self.source_url = source_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source_url is not None:
            result['SourceURL'] = self.source_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SourceURL') is not None:
            self.source_url = m.get('SourceURL')
        return self


class UploadStreamByURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadStreamByURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadStreamByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


