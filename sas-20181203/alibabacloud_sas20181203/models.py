# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class QueryIncidentTracingSubNodesCountRequest(TeaModel):
    def __init__(
        self,
        vertex_id_and_type_list: List[List[str]] = None,
    ):
        self.vertex_id_and_type_list = vertex_id_and_type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vertex_id_and_type_list is not None:
            result['VertexIdAndTypeList'] = self.vertex_id_and_type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VertexIdAndTypeList') is not None:
            self.vertex_id_and_type_list = m.get('VertexIdAndTypeList')
        return self


class AddAssetSelectionCriteriaRequestTargetOperationList(TeaModel):
    def __init__(
        self,
        operation: str = None,
        target: str = None,
    ):
        self.operation = operation
        self.target = target

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.target is not None:
            result['Target'] = self.target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        return self


class AddAssetSelectionCriteriaRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        criteria_operation: str = None,
        selection_key: str = None,
        target_operation_list: List[AddAssetSelectionCriteriaRequestTargetOperationList] = None,
    ):
        self.criteria = criteria
        self.criteria_operation = criteria_operation
        self.selection_key = selection_key
        self.target_operation_list = target_operation_list

    def validate(self):
        if self.target_operation_list:
            for k in self.target_operation_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_operation is not None:
            result['CriteriaOperation'] = self.criteria_operation
        if self.selection_key is not None:
            result['SelectionKey'] = self.selection_key
        result['TargetOperationList'] = []
        if self.target_operation_list is not None:
            for k in self.target_operation_list:
                result['TargetOperationList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaOperation') is not None:
            self.criteria_operation = m.get('CriteriaOperation')
        if m.get('SelectionKey') is not None:
            self.selection_key = m.get('SelectionKey')
        self.target_operation_list = []
        if m.get('TargetOperationList') is not None:
            for k in m.get('TargetOperationList'):
                temp_model = AddAssetSelectionCriteriaRequestTargetOperationList()
                self.target_operation_list.append(temp_model.from_map(k))
        return self


class AddAssetSelectionCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddAssetSelectionCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAssetSelectionCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAssetSelectionCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCheckInstanceResultWhiteListRequest(TeaModel):
    def __init__(
        self,
        check_group_id: str = None,
        check_id: int = None,
        instance_ids: List[str] = None,
    ):
        # The ID of the group to which the check item belongs.
        self.check_group_id = check_group_id
        # The ID of the check item.
        self.check_id = check_id
        # The instance IDs of assets.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_group_id is not None:
            result['CheckGroupId'] = self.check_group_id
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckGroupId') is not None:
            self.check_group_id = m.get('CheckGroupId')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class AddCheckInstanceResultWhiteListResponseBody(TeaModel):
    def __init__(
        self,
        data: Dict[str, Any] = None,
        request_id: str = None,
    ):
        # The adding result.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCheckInstanceResultWhiteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCheckInstanceResultWhiteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCheckInstanceResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCheckResultWhiteListRequest(TeaModel):
    def __init__(
        self,
        check_ids: List[int] = None,
    ):
        # The IDs of the check items.
        self.check_ids = check_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        return self


class AddCheckResultWhiteListResponseBody(TeaModel):
    def __init__(
        self,
        data: Dict[str, Any] = None,
        request_id: str = None,
    ):
        # The data returned.
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCheckResultWhiteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCheckResultWhiteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCheckResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddClientUserDefineRuleRequest(TeaModel):
    def __init__(
        self,
        action_type: int = None,
        cmdline: str = None,
        file_path: str = None,
        ip: str = None,
        md_5list: str = None,
        name: str = None,
        new_file_path: str = None,
        parent_cmdline: str = None,
        parent_proc_path: str = None,
        platform: str = None,
        port: int = None,
        port_str: str = None,
        proc_path: str = None,
        registry_content: str = None,
        registry_key: str = None,
        type: int = None,
    ):
        self.action_type = action_type
        self.cmdline = cmdline
        self.file_path = file_path
        self.ip = ip
        self.md_5list = md_5list
        self.name = name
        self.new_file_path = new_file_path
        self.parent_cmdline = parent_cmdline
        self.parent_proc_path = parent_proc_path
        self.platform = platform
        self.port = port
        self.port_str = port_str
        self.proc_path = proc_path
        self.registry_content = registry_content
        self.registry_key = registry_key
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.ip is not None:
            result['IP'] = self.ip
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult(TeaModel):
    def __init__(
        self,
        id: int = None,
        platform: str = None,
        switch_id: str = None,
    ):
        self.id = id
        self.platform = platform
        self.switch_id = switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        return self


class AddClientUserDefineRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_define_rule_add_result: AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult = None,
    ):
        self.request_id = request_id
        self.user_define_rule_add_result = user_define_rule_add_result

    def validate(self):
        if self.user_define_rule_add_result:
            self.user_define_rule_add_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_add_result is not None:
            result['UserDefineRuleAddResult'] = self.user_define_rule_add_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleAddResult') is not None:
            temp_model = AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult()
            self.user_define_rule_add_result = temp_model.from_map(m['UserDefineRuleAddResult'])
        return self


class AddClientUserDefineRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddClientUserDefineRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddInstallCodeRequest(TeaModel):
    def __init__(
        self,
        expired_date: int = None,
        group_id: int = None,
        only_image: bool = None,
        os: str = None,
        vendor_name: str = None,
    ):
        # 6134
        self.expired_date = expired_date
        # Specifies whether to create an image. Default value: **false**. Valid values:
        # 
        # *   **false**: does not create an image.
        # *   **true**: creates an image.
        self.group_id = group_id
        # The operating system of the instance. Default value: **linux**. Valid values:
        # 
        # *   **linux**\
        # *   **windows**\
        # *   **windows-2003**\
        self.only_image = only_image
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.os = os
        # The ID of the asset group to which the you want to add the asset.
        # 
        # >  You can call the [DescribeAllGroups](~~describeallgroups~~) operation to query the IDs of asset groups.
        self.vendor_name = vendor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expired_date is not None:
            result['ExpiredDate'] = self.expired_date
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.only_image is not None:
            result['OnlyImage'] = self.only_image
        if self.os is not None:
            result['Os'] = self.os
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpiredDate') is not None:
            self.expired_date = m.get('ExpiredDate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OnlyImage') is not None:
            self.only_image = m.get('OnlyImage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class AddInstallCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The validity period of the installation command. The value is a 13-digit timestamp.
        # 
        # >  The installation command is valid only within the validity period. An expired installation command cannot be used to install the Security Center agent.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddInstallCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddInstallCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPrivateRegistryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        extra_param: str = None,
        net_type: int = None,
        password: str = None,
        protocol_type: int = None,
        registry_host_ip: str = None,
        registry_region_id: str = None,
        registry_type: str = None,
        registry_version: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
    ):
        # The domain name of the image repository.
        self.domain_name = domain_name
        # The additional parameter of the image repository. This parameter is required when you set the RegistryType parameter to **quay**. Valid values:
        # 
        # *   **namespace**\
        # *   **authToken**\
        self.extra_param = extra_param
        # The network type. Valid values:
        # 
        # *   **1**: Internet
        # *   **2**: virtual private cloud (VPC)
        self.net_type = net_type
        # The password that is used to log on to the image repository.
        self.password = password
        # The type of the protocol. Valid values:
        # 
        # *   **1**: HTTP
        # *   **2**: HTTPS
        self.protocol_type = protocol_type
        # The IP address of the image repository.
        self.registry_host_ip = registry_host_ip
        # The ID of the region.
        # 
        # > You can call the [ListImageRegistryRegions](~~ListImageRegistryRegions~~) operation to query the IDs of supported regions.
        self.registry_region_id = registry_region_id
        # The type of the private image repository. Valid values:
        # 
        # *   **harbor**\
        # *   **quay**\
        self.registry_type = registry_type
        # The version of the image repository. Valid values:
        # 
        # *   **V1**\
        # *   **V2**\
        self.registry_version = registry_version
        # The number of images that are scanned per hour.
        self.trans_per_hour = trans_per_hour
        # The username that is used to log on to the image repository.
        self.user_name = user_name
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.extra_param is not None:
            result['ExtraParam'] = self.extra_param
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_region_id is not None:
            result['RegistryRegionId'] = self.registry_region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExtraParam') is not None:
            self.extra_param = m.get('ExtraParam')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryRegionId') is not None:
            self.registry_region_id = m.get('RegistryRegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AddPrivateRegistryResponseBodyData(TeaModel):
    def __init__(
        self,
        ali_uid: int = None,
        domain_name: str = None,
        id: int = None,
        net_type: int = None,
        password: str = None,
        protocol_type: int = None,
        region_id: str = None,
        registry_host_ip: str = None,
        registry_type: str = None,
        registry_version: str = None,
        token: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
    ):
        # The ID of the user.
        self.ali_uid = ali_uid
        # The domain name of the image repository.
        self.domain_name = domain_name
        # The ID of the image repository.
        self.id = id
        # The network type. Valid values:
        # 
        # *   **1**: Internet
        # *   **2**: VPC
        self.net_type = net_type
        # The password.
        self.password = password
        # The type of the protocol. Valid values:
        # 
        # *   **1**: HTTP
        # *   **2**: HTTPS
        self.protocol_type = protocol_type
        # The region ID of the image repository.
        self.region_id = region_id
        # The IP address of the image repository.
        self.registry_host_ip = registry_host_ip
        # The type of the image repository. Valid values:
        # 
        # *   **harbor**\
        # *   **quay**\
        self.registry_type = registry_type
        # The version of the image repository. Default value: -. Valid values:
        # 
        # *   **-**: the default version
        # *   **V1**\
        # *   **V2**\
        self.registry_version = registry_version
        # The value of the token.
        self.token = token
        # The number of scan tasks that are performed per hour.
        self.trans_per_hour = trans_per_hour
        # The username.
        self.user_name = user_name
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AddPrivateRegistryResponseBody(TeaModel):
    def __init__(
        self,
        data: AddPrivateRegistryResponseBodyData = None,
        request_id: str = None,
    ):
        # The handling result.
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = AddPrivateRegistryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPrivateRegistryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPrivateRegistryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPrivateRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTagWithUuidRequest(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
        uuid_list: str = None,
    ):
        # The name of the tag.
        self.tag_name = tag_name
        # The UUIDs of the servers. Separate multiple UUIDs with commas (,).
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class AddTagWithUuidResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddTagWithUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTagWithUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddUninstallClientsByUuidsRequest(TeaModel):
    def __init__(
        self,
        call_method: str = None,
        feedback: str = None,
        region: str = None,
        source_ip: str = None,
        uuids: str = None,
    ):
        self.call_method = call_method
        self.feedback = feedback
        self.region = region
        self.source_ip = source_ip
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_method is not None:
            result['CallMethod'] = self.call_method
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.region is not None:
            result['Region'] = self.region
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallMethod') is not None:
            self.call_method = m.get('CallMethod')
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class AddUninstallClientsByUuidsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddUninstallClientsByUuidsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddUninstallClientsByUuidsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddUninstallClientsByUuidsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddVpcHoneyPotRequest(TeaModel):
    def __init__(
        self,
        vpc_id: str = None,
    ):
        # The ID of the virtual private cloud (VPC) in which you want to create a honeypot.
        # 
        # > You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to obtain the VPC ID. The VPC ID is the value of the InstanceId parameter.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AddVpcHoneyPotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddVpcHoneyPotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddVpcHoneyPotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AdvanceSecurityEventOperationsRequest(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        event_type: str = None,
        resource_owner_id: int = None,
        rule_id: int = None,
    ):
        self.event_name = event_name
        self.event_type = event_type
        self.resource_owner_id = resource_owner_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(TeaModel):
    def __init__(
        self,
        filed_alias_name: str = None,
        filed_name: str = None,
        mark_mis_type: str = None,
        mark_mis_value: str = None,
        supported_mis_type: List[str] = None,
    ):
        self.filed_alias_name = filed_alias_name
        self.filed_name = filed_name
        self.mark_mis_type = mark_mis_type
        self.mark_mis_value = mark_mis_value
        self.supported_mis_type = supported_mis_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_type is not None:
            result['MarkMisType'] = self.mark_mis_type
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisType') is not None:
            self.mark_mis_type = m.get('MarkMisType')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(TeaModel):
    def __init__(
        self,
        filed_alias_name: str = None,
        filed_name: str = None,
        mark_mis_value: str = None,
        supported_mis_type: List[str] = None,
    ):
        self.filed_alias_name = filed_alias_name
        self.filed_name = filed_name
        self.mark_mis_value = mark_mis_value
        self.supported_mis_type = supported_mis_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse(TeaModel):
    def __init__(
        self,
        mark_field: List[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField] = None,
        mark_fields_source: List[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource] = None,
        operation_code: str = None,
        operation_params: str = None,
        user_can_operate: bool = None,
    ):
        self.mark_field = mark_field
        self.mark_fields_source = mark_fields_source
        self.operation_code = operation_code
        self.operation_params = operation_params
        self.user_can_operate = user_can_operate

    def validate(self):
        if self.mark_field:
            for k in self.mark_field:
                if k:
                    k.validate()
        if self.mark_fields_source:
            for k in self.mark_fields_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MarkField'] = []
        if self.mark_field is not None:
            for k in self.mark_field:
                result['MarkField'].append(k.to_map() if k else None)
        result['MarkFieldsSource'] = []
        if self.mark_fields_source is not None:
            for k in self.mark_fields_source:
                result['MarkFieldsSource'].append(k.to_map() if k else None)
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.user_can_operate is not None:
            result['UserCanOperate'] = self.user_can_operate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mark_field = []
        if m.get('MarkField') is not None:
            for k in m.get('MarkField'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField()
                self.mark_field.append(temp_model.from_map(k))
        self.mark_fields_source = []
        if m.get('MarkFieldsSource') is not None:
            for k in m.get('MarkFieldsSource'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource()
                self.mark_fields_source.append(temp_model.from_map(k))
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('UserCanOperate') is not None:
            self.user_can_operate = m.get('UserCanOperate')
        return self


class AdvanceSecurityEventOperationsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_event_operations_response: List[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse] = None,
    ):
        self.request_id = request_id
        self.security_event_operations_response = security_event_operations_response

    def validate(self):
        if self.security_event_operations_response:
            for k in self.security_event_operations_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperationsResponse'] = []
        if self.security_event_operations_response is not None:
            for k in self.security_event_operations_response:
                result['SecurityEventOperationsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operations_response = []
        if m.get('SecurityEventOperationsResponse') is not None:
            for k in m.get('SecurityEventOperationsResponse'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse()
                self.security_event_operations_response.append(temp_model.from_map(k))
        return self


class AdvanceSecurityEventOperationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AdvanceSecurityEventOperationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AdvanceSecurityEventOperationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchOperateCommonOverallConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        type_list: List[str] = None,
    ):
        self.config = config
        self.type_list = type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class BatchOperateCommonOverallConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchOperateCommonOverallConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchOperateCommonOverallConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchOperateCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindAuthToMachineRequest(TeaModel):
    def __init__(
        self,
        auth_version: int = None,
        auto_bind: int = None,
        bind: List[str] = None,
        bind_all: bool = None,
        criteria: str = None,
        logical_exp: str = None,
        un_bind: List[str] = None,
    ):
        # The edition of Security Center. Valid values:
        # 
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version
        # The shortage in the quota for cores of servers that can be protected.
        self.auto_bind = auto_bind
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.bind = bind
        # The UUID of the server that you want to bind to Security Center.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.bind_all = bind_all
        # The status code that indicates the result. Valid values:
        # 
        # *   **0**: The servers are bound to or unbound from Security Center.
        # *   **1**: The values that you specified for the parameters are invalid.
        # *   **2**: The quota for servers that can be protected is insufficient.
        # *   **3**: The quota for cores of servers that can be protected is insufficient.
        self.criteria = criteria
        # The search conditions that are used to filter servers. The value of this parameter is in the JSON format and is case-sensitive.
        # 
        # >  A search condition can be an instance ID, instance name, virtual private cloud (VPC) ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.
        self.logical_exp = logical_exp
        # Binds servers to Security Center or unbinds servers from Security Center.
        self.un_bind = un_bind

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.auto_bind is not None:
            result['AutoBind'] = self.auto_bind
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.bind_all is not None:
            result['BindAll'] = self.bind_all
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.un_bind is not None:
            result['UnBind'] = self.un_bind
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('AutoBind') is not None:
            self.auto_bind = m.get('AutoBind')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('BindAll') is not None:
            self.bind_all = m.get('BindAll')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('UnBind') is not None:
            self.un_bind = m.get('UnBind')
        return self


class BindAuthToMachineResponseBody(TeaModel):
    def __init__(
        self,
        bind_count: int = None,
        insufficient_core_count: int = None,
        insufficient_ecs_count: int = None,
        request_id: str = None,
        result_code: int = None,
        un_bind_count: int = None,
    ):
        self.bind_count = bind_count
        self.insufficient_core_count = insufficient_core_count
        self.insufficient_ecs_count = insufficient_ecs_count
        self.request_id = request_id
        self.result_code = result_code
        self.un_bind_count = un_bind_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.insufficient_core_count is not None:
            result['InsufficientCoreCount'] = self.insufficient_core_count
        if self.insufficient_ecs_count is not None:
            result['InsufficientEcsCount'] = self.insufficient_ecs_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.un_bind_count is not None:
            result['UnBindCount'] = self.un_bind_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('InsufficientCoreCount') is not None:
            self.insufficient_core_count = m.get('InsufficientCoreCount')
        if m.get('InsufficientEcsCount') is not None:
            self.insufficient_ecs_count = m.get('InsufficientEcsCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('UnBindCount') is not None:
            self.un_bind_count = m.get('UnBindCount')
        return self


class BindAuthToMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindAuthToMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindAuthToMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelOnceTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CancelOnceTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelOnceTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelOnceTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeCheckConfigRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        region_id: str = None,
        standard_ids: List[int] = None,
        start_time: int = None,
    ):
        # The end time of the check. The value specifies a point in time in a day. The time period that is specified by the start time and end time must be one of the following time periods:
        # 
        # *   **00:00 to 06:00:** If you set the StartTime parameter to 0, you must set the EndTime parameter to 6.
        # *   **06:00 to 12:00**: If you set the StartTime parameter to 6, you must set the EndTime parameter to 12.
        # *   **12:00 to 18:00**: If you set the StartTime parameter to 12, you must set the EndTime parameter to 18.
        # *  **18:00 to 24:00:** If you set the StartTime parameter to 18, you must set the EndTime parameter to 24.
        self.end_time = end_time
        # The region ID of the bastion host to query.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id
        # An array that consists of the information about the check item.
        self.standard_ids = standard_ids
        # The start time of the check. The value specifies a point in time in a day.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.standard_ids is not None:
            result['StandardIds'] = self.standard_ids
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StandardIds') is not None:
            self.standard_ids = m.get('StandardIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ChangeCheckConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeCheckConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeCheckConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeCheckConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeCheckCustomConfigRequestCustomConfigs(TeaModel):
    def __init__(
        self,
        name: str = None,
        operation: str = None,
        value: str = None,
    ):
        self.name = name
        self.operation = operation
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ChangeCheckCustomConfigRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        custom_configs: List[ChangeCheckCustomConfigRequestCustomConfigs] = None,
        region_id: str = None,
    ):
        self.check_id = check_id
        self.custom_configs = custom_configs
        self.region_id = region_id

    def validate(self):
        if self.custom_configs:
            for k in self.custom_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        result['CustomConfigs'] = []
        if self.custom_configs is not None:
            for k in self.custom_configs:
                result['CustomConfigs'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        self.custom_configs = []
        if m.get('CustomConfigs') is not None:
            for k in m.get('CustomConfigs'):
                temp_model = ChangeCheckCustomConfigRequestCustomConfigs()
                self.custom_configs.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ChangeCheckCustomConfigResponseBody(TeaModel):
    def __init__(
        self,
        illegal_custom_configs: List[ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs] = None,
        request_id: str = None,
    ):
        self.illegal_custom_configs = illegal_custom_configs
        self.request_id = request_id

    def validate(self):
        if self.illegal_custom_configs:
            for k in self.illegal_custom_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IllegalCustomConfigs'] = []
        if self.illegal_custom_configs is not None:
            for k in self.illegal_custom_configs:
                result['IllegalCustomConfigs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.illegal_custom_configs = []
        if m.get('IllegalCustomConfigs') is not None:
            for k in m.get('IllegalCustomConfigs'):
                temp_model = ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs()
                self.illegal_custom_configs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeCheckCustomConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeCheckCustomConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeCheckCustomConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckQuaraFileIdRequest(TeaModel):
    def __init__(
        self,
        quara_file_ids: List[str] = None,
        uuid: str = None,
    ):
        self.quara_file_ids = quara_file_ids
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quara_file_ids is not None:
            result['QuaraFileIds'] = self.quara_file_ids
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('QuaraFileIds') is not None:
            self.quara_file_ids = m.get('QuaraFileIds')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CheckQuaraFileIdResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckQuaraFileIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckQuaraFileIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckQuaraFileIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckSecurityEventIdRequest(TeaModel):
    def __init__(
        self,
        security_event_ids: List[str] = None,
        uuid: str = None,
    ):
        # The IDs of alert events. You can specify up to 100 IDs. If you do not specify this parameter, the value of the response parameter **Data** is **false**. The value false indicates that no alert events are generated on the server.
        # 
        # > You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the IDs of alert events.
        self.security_event_ids = security_event_ids
        # The UUID of the server.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CheckSecurityEventIdResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert events are generated on the server. Valid values:
        # 
        # *   **true**\
        # *   **false**: no
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckSecurityEventIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckSecurityEventIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckSecurityEventIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckUserHasEcsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # CheckUserHasEcs
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class CheckUserHasEcsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CheckUserHasEcsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckUserHasEcsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckUserHasEcsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmVirusEventsRequest(TeaModel):
    def __init__(
        self,
        operation_all: int = None,
        operation_code: str = None,
        operation_range: str = None,
    ):
        # Confirms the alert events that you want to handle.
        self.operation_all = operation_all
        # The ID of the request.
        self.operation_code = operation_code
        # The server on which you want to perform the alert events.
        self.operation_range = operation_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_all is not None:
            result['OperationAll'] = self.operation_all
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_range is not None:
            result['OperationRange'] = self.operation_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationAll') is not None:
            self.operation_all = m.get('OperationAll')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationRange') is not None:
            self.operation_range = m.get('OperationRange')
        return self


class ConfirmVirusEventsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class ConfirmVirusEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfirmVirusEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmVirusEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAntiBruteForceRuleRequest(TeaModel):
    def __init__(
        self,
        default_rule: bool = None,
        fail_count: int = None,
        forbidden_time: int = None,
        name: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        span: int = None,
        uuid_list: List[str] = None,
    ):
        self.default_rule = default_rule
        self.fail_count = fail_count
        self.forbidden_time = forbidden_time
        self.name = name
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip
        self.span = span
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.name is not None:
            result['Name'] = self.name
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule(TeaModel):
    def __init__(
        self,
        rule_id: int = None,
    ):
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class CreateAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(
        self,
        create_anti_brute_force_rule: CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule = None,
        request_id: str = None,
    ):
        self.create_anti_brute_force_rule = create_anti_brute_force_rule
        self.request_id = request_id

    def validate(self):
        if self.create_anti_brute_force_rule:
            self.create_anti_brute_force_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_anti_brute_force_rule is not None:
            result['CreateAntiBruteForceRule'] = self.create_anti_brute_force_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateAntiBruteForceRule') is not None:
            temp_model = CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule()
            self.create_anti_brute_force_rule = temp_model.from_map(m['CreateAntiBruteForceRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAntiBruteForceRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAntiBruteForceRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAssetSelectionConfigRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        target_type: str = None,
    ):
        self.business_type = business_type
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class CreateAssetSelectionConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        selection_key: int = None,
        target_type: str = None,
    ):
        self.business_type = business_type
        self.selection_key = selection_key
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.selection_key is not None:
            result['SelectionKey'] = self.selection_key
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('SelectionKey') is not None:
            self.selection_key = m.get('SelectionKey')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class CreateAssetSelectionConfigResponseBody(TeaModel):
    def __init__(
        self,
        data: CreateAssetSelectionConfigResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateAssetSelectionConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAssetSelectionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAssetSelectionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAssetSelectionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        policy: Dict[str, Any] = None,
        policy_region_id: str = None,
        policy_version: str = None,
        uuid_list: List[str] = None,
    ):
        self.name = name
        self.policy = policy
        self.policy_region_id = policy_region_id
        self.policy_version = policy_version
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateBackupPolicyShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        policy_shrink: str = None,
        policy_region_id: str = None,
        policy_version: str = None,
        uuid_list: List[str] = None,
    ):
        self.name = name
        self.policy_shrink = policy_shrink
        self.policy_region_id = policy_region_id
        self.policy_version = policy_version
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.policy_shrink is not None:
            result['Policy'] = self.policy_shrink
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy_shrink = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateBackupPolicyResponseBodyBackupPolicy(TeaModel):
    def __init__(
        self,
        id: str = None,
        status: str = None,
    ):
        self.id = id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreateBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        backup_policy: CreateBackupPolicyResponseBodyBackupPolicy = None,
        request_id: str = None,
    ):
        self.backup_policy = backup_policy
        self.request_id = request_id

    def validate(self):
        if self.backup_policy:
            self.backup_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_policy is not None:
            result['BackupPolicy'] = self.backup_policy.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupPolicy') is not None:
            temp_model = CreateBackupPolicyResponseBodyBackupPolicy()
            self.backup_policy = temp_model.from_map(m['BackupPolicy'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateContainerScanTaskRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        container_ids: str = None,
        lang: str = None,
    ):
        # The ID of the cluster to which the container belongs.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~182997~~) operation to query the IDs of clusters.
        self.cluster_id = cluster_id
        # The ID of the container.
        self.container_ids = container_ids
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_ids is not None:
            result['ContainerIds'] = self.container_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerIds') is not None:
            self.container_ids = m.get('ContainerIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class CreateContainerScanTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        can_create: bool = None,
        collect_time: int = None,
        exec_time: int = None,
        finish_count: int = None,
        progress: int = None,
        result: str = None,
        status: str = None,
        task_id: str = None,
        total_count: int = None,
    ):
        # Indicates whether you can create more scan tasks.
        self.can_create = can_create
        # The collection time.
        self.collect_time = collect_time
        # The execution time of the task.
        self.exec_time = exec_time
        # The number of scan tasks that are complete.
        self.finish_count = finish_count
        # The progress of the task.
        self.progress = progress
        # The execution result of the task.
        self.result = result
        # The status of the task.
        self.status = status
        # The ID of the task.
        self.task_id = task_id
        # The total number of scan tasks.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateContainerScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        data: CreateContainerScanTaskResponseBodyData = None,
        http_status_code: int = None,
        request_id: str = None,
    ):
        # The data returned.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateContainerScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateContainerScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateContainerScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateContainerScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomBlockRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        expire_time: int = None,
        resource_owner_id: int = None,
        uuids: str = None,
    ):
        self.block_ip = block_ip
        self.bound = bound
        self.expire_time = expire_time
        self.resource_owner_id = resource_owner_id
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class CreateCustomBlockRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomBlockRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomBlockRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCycleTaskRequest(TeaModel):
    def __init__(
        self,
        enable: int = None,
        first_date_str: int = None,
        interval_period: int = None,
        param: str = None,
        period_unit: str = None,
        source: str = None,
        target_end_time: int = None,
        target_start_time: int = None,
        task_name: str = None,
        task_type: str = None,
    ):
        self.enable = enable
        self.first_date_str = first_date_str
        self.interval_period = interval_period
        self.param = param
        self.period_unit = period_unit
        self.source = source
        self.target_end_time = target_end_time
        self.target_start_time = target_start_time
        self.task_name = task_name
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.source is not None:
            result['Source'] = self.source
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateCycleTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCycleTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCycleTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileDetectRequest(TeaModel):
    def __init__(
        self,
        hash_key: str = None,
        oss_key: str = None,
        source_ip: str = None,
        type: int = None,
    ):
        self.hash_key = hash_key
        self.oss_key = oss_key
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateFileDetectResponseBody(TeaModel):
    def __init__(
        self,
        hash_key: str = None,
        request_id: str = None,
    ):
        self.hash_key = hash_key
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateFileDetectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFileDetectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileDetectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileDetectUploadUrlRequestHashKeyContextList(TeaModel):
    def __init__(
        self,
        file_size: int = None,
        hash_key: str = None,
    ):
        # The size of the file. Unit: bytes.
        self.file_size = file_size
        # The hash value of the file.
        self.hash_key = hash_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        return self


class CreateFileDetectUploadUrlRequest(TeaModel):
    def __init__(
        self,
        hash_key_context_list: List[CreateFileDetectUploadUrlRequestHashKeyContextList] = None,
        hash_key_list: List[str] = None,
        type: int = None,
    ):
        # The hash values of files.
        # 
        # > You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.
        self.hash_key_context_list = hash_key_context_list
        # The identifiers of files. Only MD5 hash values are supported.
        # 
        # > You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.
        self.hash_key_list = hash_key_list
        # The type of the file. Valid values:
        # 
        # *   **0**: unknown file
        # *   **1**: binary file
        # *   **2**: webshell file
        # *   **4**: script file
        # 
        # > If you do not know the type of the file, set this parameter to **0**.
        self.type = type

    def validate(self):
        if self.hash_key_context_list:
            for k in self.hash_key_context_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HashKeyContextList'] = []
        if self.hash_key_context_list is not None:
            for k in self.hash_key_context_list:
                result['HashKeyContextList'].append(k.to_map() if k else None)
        if self.hash_key_list is not None:
            result['HashKeyList'] = self.hash_key_list
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hash_key_context_list = []
        if m.get('HashKeyContextList') is not None:
            for k in m.get('HashKeyContextList'):
                temp_model = CreateFileDetectUploadUrlRequestHashKeyContextList()
                self.hash_key_context_list.append(temp_model.from_map(k))
        if m.get('HashKeyList') is not None:
            self.hash_key_list = m.get('HashKeyList')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateFileDetectUploadUrlResponseBodyUploadUrlListContext(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        oss_key: str = None,
        policy: str = None,
        signature: str = None,
    ):
        # The AccessKey ID that is used to access the OSS bucket.
        self.access_id = access_id
        # The key of the file that is used after the file is uploaded to the OSS bucket.
        self.oss_key = oss_key
        # The policy that poses limits on file upload. For example, the policy can limit the size of the file.
        self.policy = policy
        # The signature that is used to upload the file.
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class CreateFileDetectUploadUrlResponseBodyUploadUrlList(TeaModel):
    def __init__(
        self,
        code: str = None,
        context: CreateFileDetectUploadUrlResponseBodyUploadUrlListContext = None,
        expire: str = None,
        file_exist: bool = None,
        hash_key: str = None,
        internal_url: str = None,
        message: str = None,
        public_url: str = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The signature information.
        self.context = context
        # The timestamp when the values of the parameters expire. Unit: milliseconds.
        self.expire = expire
        # Indicates whether the file exists in the cloud. Valid values:
        # 
        # *   **true**: The file exists in the cloud. You do not need to upload the file.
        # *   **false**: The file does not exist in the cloud. You must upload the file.
        self.file_exist = file_exist
        # The identifier of the file.
        self.hash_key = hash_key
        # The internal endpoint of the URL to which the file is uploaded.
        self.internal_url = internal_url
        # The error message returned.
        self.message = message
        # The public endpoint of the URL to which the file is uploaded.
        self.public_url = public_url

    def validate(self):
        if self.context:
            self.context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.context is not None:
            result['Context'] = self.context.to_map()
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.file_exist is not None:
            result['FileExist'] = self.file_exist
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.internal_url is not None:
            result['InternalUrl'] = self.internal_url
        if self.message is not None:
            result['Message'] = self.message
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Context') is not None:
            temp_model = CreateFileDetectUploadUrlResponseBodyUploadUrlListContext()
            self.context = temp_model.from_map(m['Context'])
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('FileExist') is not None:
            self.file_exist = m.get('FileExist')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('InternalUrl') is not None:
            self.internal_url = m.get('InternalUrl')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        return self


class CreateFileDetectUploadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        upload_url_list: List[CreateFileDetectUploadUrlResponseBodyUploadUrlList] = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array consisting of the parameters that are required to upload a file.
        self.upload_url_list = upload_url_list

    def validate(self):
        if self.upload_url_list:
            for k in self.upload_url_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UploadUrlList'] = []
        if self.upload_url_list is not None:
            for k in self.upload_url_list:
                result['UploadUrlList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.upload_url_list = []
        if m.get('UploadUrlList') is not None:
            for k in m.get('UploadUrlList'):
                temp_model = CreateFileDetectUploadUrlResponseBodyUploadUrlList()
                self.upload_url_list.append(temp_model.from_map(k))
        return self


class CreateFileDetectUploadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFileDetectUploadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileDetectUploadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotRequest(TeaModel):
    def __init__(
        self,
        honeypot_image_id: str = None,
        honeypot_image_name: str = None,
        honeypot_name: str = None,
        meta: str = None,
        node_id: str = None,
    ):
        # The ID of the honeypot image.
        # 
        # > You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to query the IDs of images from the **HoneypotImageId** response parameter.
        self.honeypot_image_id = honeypot_image_id
        # The name of the honeypot image.
        # 
        # > You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to query the names of images from the **HoneypotImageName** response parameter.
        self.honeypot_image_name = honeypot_image_name
        # The custom name of the honeypot.
        self.honeypot_name = honeypot_name
        # The custom configuration of the honeypot in the JSON format. The value contains the following fields:
        # 
        # *   **trojan_git**: Git-specific Defense. Valid values:
        # 
        #     *   **zip**: Git Source Code Package
        #     *   **web**: Git Directory Leak
        #     *   **close**: Disabled
        # 
        # *   **trojan_git_addr**: Git Trojan Address.
        # 
        # *   **trojan_git.zip**: Git Trojan.
        # 
        # *   **burp**: Burp-specific Defense. Valid values:
        # 
        #     *   **open**: Enable
        #     *   **close**: Disable
        # 
        # *   **portrait_option**: Source Tracing Configuration. Valid values:
        # 
        #     *   **false**: Disable
        #     *   **true**: Enable
        self.meta = meta
        # The ID of the management node.
        # 
        # > You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class CreateHoneypotResponseBodyData(TeaModel):
    def __init__(
        self,
        control_node_name: str = None,
        honeypot_id: str = None,
        honeypot_image_display_name: str = None,
        honeypot_image_name: str = None,
        honeypot_name: str = None,
        node_id: str = None,
        preset_id: str = None,
        state: List[str] = None,
    ):
        # The name of the management node.
        self.control_node_name = control_node_name
        # The ID of the honeypot.
        self.honeypot_id = honeypot_id
        # The display name of the honeypot image.
        self.honeypot_image_display_name = honeypot_image_display_name
        # The name of the honeypot image.
        self.honeypot_image_name = honeypot_image_name
        # The custom name of the honeypot.
        self.honeypot_name = honeypot_name
        # The ID of the management node.
        self.node_id = node_id
        # The ID of the custom configuration for the honeypot.
        self.preset_id = preset_id
        # An array that consists of the status information about the honeypot.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class CreateHoneypotResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateHoneypotResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The information about the honeypot.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The error message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateHoneypotResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHoneypotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotNodeRequest(TeaModel):
    def __init__(
        self,
        allow_honeypot_access_internet: bool = None,
        available_probe_num: int = None,
        node_name: str = None,
        security_group_probe_ip_list: List[str] = None,
    ):
        # Specifies whether to allow honeypots to access the Internet. Valid values:
        # 
        # *   **true**: allows honeypots to access the Internet.
        # *   **false**: does not allow honeypots to access the Internet.
        self.allow_honeypot_access_internet = allow_honeypot_access_internet
        # The number of available probes.
        self.available_probe_num = available_probe_num
        # The name of the management node.
        self.node_name = node_name
        # The CIDR blocks that are allowed to access the management node.
        self.security_group_probe_ip_list = security_group_probe_ip_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.available_probe_num is not None:
            result['AvailableProbeNum'] = self.available_probe_num
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('AvailableProbeNum') is not None:
            self.available_probe_num = m.get('AvailableProbeNum')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        return self


class CreateHoneypotNodeResponseBodyHoneypotNode(TeaModel):
    def __init__(
        self,
        node_id: str = None,
    ):
        # The ID of the management node.
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class CreateHoneypotNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        honeypot_node: CreateHoneypotNodeResponseBodyHoneypotNode = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The data returned.
        self.honeypot_node = honeypot_node
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The error message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.honeypot_node:
            self.honeypot_node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_node is not None:
            result['HoneypotNode'] = self.honeypot_node.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotNode') is not None:
            temp_model = CreateHoneypotNodeResponseBodyHoneypotNode()
            self.honeypot_node = temp_model.from_map(m['HoneypotNode'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHoneypotNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotPresetRequest(TeaModel):
    def __init__(
        self,
        honeypot_image_name: str = None,
        lang: str = None,
        meta: str = None,
        node_id: str = None,
        preset_name: str = None,
    ):
        self.honeypot_image_name = honeypot_image_name
        self.lang = lang
        self.meta = meta
        self.node_id = node_id
        self.preset_name = preset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class CreateHoneypotPresetResponseBodyHoneypotPreset(TeaModel):
    def __init__(
        self,
        honeypot_preset_id: str = None,
    ):
        self.honeypot_preset_id = honeypot_preset_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        return self


class CreateHoneypotPresetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        honeypot_preset: CreateHoneypotPresetResponseBodyHoneypotPreset = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.honeypot_preset = honeypot_preset
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.honeypot_preset:
            self.honeypot_preset.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_preset is not None:
            result['HoneypotPreset'] = self.honeypot_preset.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotPreset') is not None:
            temp_model = CreateHoneypotPresetResponseBodyHoneypotPreset()
            self.honeypot_preset = temp_model.from_map(m['HoneypotPreset'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotPresetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHoneypotPresetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotProbeRequestHoneypotBindListBindPortList(TeaModel):
    def __init__(
        self,
        bind_port: bool = None,
        end_port: int = None,
        fixed: bool = None,
        start_port: int = None,
        target_port: int = None,
    ):
        self.bind_port = bind_port
        self.end_port = end_port
        self.fixed = fixed
        self.start_port = start_port
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_port is not None:
            result['BindPort'] = self.bind_port
        if self.end_port is not None:
            result['EndPort'] = self.end_port
        if self.fixed is not None:
            result['Fixed'] = self.fixed
        if self.start_port is not None:
            result['StartPort'] = self.start_port
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindPort') is not None:
            self.bind_port = m.get('BindPort')
        if m.get('EndPort') is not None:
            self.end_port = m.get('EndPort')
        if m.get('Fixed') is not None:
            self.fixed = m.get('Fixed')
        if m.get('StartPort') is not None:
            self.start_port = m.get('StartPort')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class CreateHoneypotProbeRequestHoneypotBindList(TeaModel):
    def __init__(
        self,
        bind_port_list: List[CreateHoneypotProbeRequestHoneypotBindListBindPortList] = None,
        honeypot_id: str = None,
    ):
        self.bind_port_list = bind_port_list
        self.honeypot_id = honeypot_id

    def validate(self):
        if self.bind_port_list:
            for k in self.bind_port_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BindPortList'] = []
        if self.bind_port_list is not None:
            for k in self.bind_port_list:
                result['BindPortList'].append(k.to_map() if k else None)
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bind_port_list = []
        if m.get('BindPortList') is not None:
            for k in m.get('BindPortList'):
                temp_model = CreateHoneypotProbeRequestHoneypotBindListBindPortList()
                self.bind_port_list.append(temp_model.from_map(k))
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        return self


class CreateHoneypotProbeRequest(TeaModel):
    def __init__(
        self,
        arp: bool = None,
        business_group_id: str = None,
        control_node_id: str = None,
        display_name: str = None,
        honeypot_bind_list: List[CreateHoneypotProbeRequestHoneypotBindList] = None,
        ping: bool = None,
        probe_type: str = None,
        probe_version: str = None,
        proxy_ip: str = None,
        uuid: str = None,
        vpc_id: str = None,
    ):
        self.arp = arp
        self.business_group_id = business_group_id
        self.control_node_id = control_node_id
        self.display_name = display_name
        self.honeypot_bind_list = honeypot_bind_list
        self.ping = ping
        self.probe_type = probe_type
        self.probe_version = probe_version
        self.proxy_ip = proxy_ip
        self.uuid = uuid
        self.vpc_id = vpc_id

    def validate(self):
        if self.honeypot_bind_list:
            for k in self.honeypot_bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.business_group_id is not None:
            result['BusinessGroupId'] = self.business_group_id
        if self.control_node_id is not None:
            result['ControlNodeId'] = self.control_node_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        result['HoneypotBindList'] = []
        if self.honeypot_bind_list is not None:
            for k in self.honeypot_bind_list:
                result['HoneypotBindList'].append(k.to_map() if k else None)
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.proxy_ip is not None:
            result['ProxyIp'] = self.proxy_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('BusinessGroupId') is not None:
            self.business_group_id = m.get('BusinessGroupId')
        if m.get('ControlNodeId') is not None:
            self.control_node_id = m.get('ControlNodeId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        self.honeypot_bind_list = []
        if m.get('HoneypotBindList') is not None:
            for k in m.get('HoneypotBindList'):
                temp_model = CreateHoneypotProbeRequestHoneypotBindList()
                self.honeypot_bind_list.append(temp_model.from_map(k))
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('ProxyIp') is not None:
            self.proxy_ip = m.get('ProxyIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateHoneypotProbeResponseBodyHoneypotProbe(TeaModel):
    def __init__(
        self,
        probe_id: str = None,
    ):
        self.probe_id = probe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class CreateHoneypotProbeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        honeypot_probe: CreateHoneypotProbeResponseBodyHoneypotProbe = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.honeypot_probe = honeypot_probe
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.honeypot_probe:
            self.honeypot_probe.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_probe is not None:
            result['HoneypotProbe'] = self.honeypot_probe.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotProbe') is not None:
            temp_model = CreateHoneypotProbeResponseBodyHoneypotProbe()
            self.honeypot_probe = temp_model.from_map(m['HoneypotProbe'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotProbeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHoneypotProbeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInterceptionRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        dst_target_list: Dict[str, Any] = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        rule_type: str = None,
        src_target: Dict[str, Any] = None,
    ):
        # The ID of the container cluster.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The information about the destination network object. The value of this parameter contains the following fields:
        # 
        # *   targetId: the ID of the destination network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
        # *   ports: the destination port ranges.
        self.dst_target_list = dst_target_list
        # The action on traffic. Valid values:
        # 
        # *   **1**: blocks traffic.
        # *   **2**: allows traffic and generates alerts.
        # *   **3**: allows traffic and does not generate alerts.
        self.intercept_type = intercept_type
        # The priority of the defense rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.
        self.order_index = order_index
        # The name of the defense rule.
        self.rule_name = rule_name
        # Specifies the status of the defense rule. Valid values:
        # 
        # *   **0**: disables the rule.
        # *   **1**: enables the rule.
        self.rule_switch = rule_switch
        # The type of the defense rule. Valid values:
        # 
        # *   customize: custom rule
        self.rule_type = rule_type
        # The source network object. The value of this parameter contains the following field:
        # 
        # *   targetId: the ID of the source network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
        self.src_target = src_target

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.dst_target_list is not None:
            result['DstTargetList'] = self.dst_target_list
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.src_target is not None:
            result['SrcTarget'] = self.src_target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('DstTargetList') is not None:
            self.dst_target_list = m.get('DstTargetList')
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('SrcTarget') is not None:
            self.src_target = m.get('SrcTarget')
        return self


class CreateInterceptionRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        dst_target_list_shrink: str = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        rule_type: str = None,
        src_target_shrink: str = None,
    ):
        # The ID of the container cluster.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The information about the destination network object. The value of this parameter contains the following fields:
        # 
        # *   targetId: the ID of the destination network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
        # *   ports: the destination port ranges.
        self.dst_target_list_shrink = dst_target_list_shrink
        # The action on traffic. Valid values:
        # 
        # *   **1**: blocks traffic.
        # *   **2**: allows traffic and generates alerts.
        # *   **3**: allows traffic and does not generate alerts.
        self.intercept_type = intercept_type
        # The priority of the defense rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.
        self.order_index = order_index
        # The name of the defense rule.
        self.rule_name = rule_name
        # Specifies the status of the defense rule. Valid values:
        # 
        # *   **0**: disables the rule.
        # *   **1**: enables the rule.
        self.rule_switch = rule_switch
        # The type of the defense rule. Valid values:
        # 
        # *   customize: custom rule
        self.rule_type = rule_type
        # The source network object. The value of this parameter contains the following field:
        # 
        # *   targetId: the ID of the source network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
        self.src_target_shrink = src_target_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.dst_target_list_shrink is not None:
            result['DstTargetList'] = self.dst_target_list_shrink
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.src_target_shrink is not None:
            result['SrcTarget'] = self.src_target_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('DstTargetList') is not None:
            self.dst_target_list_shrink = m.get('DstTargetList')
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('SrcTarget') is not None:
            self.src_target_shrink = m.get('SrcTarget')
        return self


class CreateInterceptionRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateInterceptionRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateInterceptionRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInterceptionRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInterceptionTargetRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        tag_list: List[str] = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.image_list = image_list
        self.namespace = namespace
        self.tag_list = tag_list
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class CreateInterceptionTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class CreateInterceptionTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateInterceptionTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInterceptionTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateJenkinsImageRegistryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        extra_param: str = None,
        net_type: int = None,
        password: str = None,
        persistence_day: int = None,
        protocol_type: int = None,
        region_id: str = None,
        registry_host_ip: str = None,
        registry_name: str = None,
        registry_type: str = None,
        registry_version: str = None,
        source_ip: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
        white_list: str = None,
    ):
        # The domain name of the image repository.
        self.domain_name = domain_name
        # The additional parameters of the image repository. The value of this parameter contains the following fields:
        # 
        # *   **namespace**: the namespace
        # *   **authToken**: the authorization token
        self.extra_param = extra_param
        # The network type. Valid values:
        # 
        # *   **1**: Internet
        # *   **2**: Virtual Private Cloud (VPC)
        self.net_type = net_type
        # The password.
        self.password = password
        # The number of days during which assets can be retained.
        self.persistence_day = persistence_day
        # The type of the protocol. Valid values:
        # 
        # *   **1**: HTTP
        # *   **2**: HTTPS
        self.protocol_type = protocol_type
        # The region ID of the image repository.
        self.region_id = region_id
        # The IP address of the image repository.
        self.registry_host_ip = registry_host_ip
        # The alias of the image repository.
        self.registry_name = registry_name
        # The type of the image repository. Valid values:
        # 
        # *   **CI/CD**: Jenkins
        self.registry_type = registry_type
        # The version of the image repository. Default value: -. Valid values:
        # 
        # *   **-**: the default version
        # *   **V1**: V1.0
        # *   **V2**: V2.0
        self.registry_version = registry_version
        # The source IP address of the request.
        self.source_ip = source_ip
        # The number of images that can be scanned per hour.
        self.trans_per_hour = trans_per_hour
        # The username.
        self.user_name = user_name
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The whitelist of IP addresses.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.extra_param is not None:
            result['ExtraParam'] = self.extra_param
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExtraParam') is not None:
            self.extra_param = m.get('ExtraParam')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateJenkinsImageRegistryResponseBodyData(TeaModel):
    def __init__(
        self,
        black_list: str = None,
        domain_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        net_type: int = None,
        password: str = None,
        persistence_day: int = None,
        protocol_type: int = None,
        region_id: str = None,
        registry_host_ip: str = None,
        registry_name: str = None,
        registry_type: str = None,
        token: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
        white_list: str = None,
    ):
        # The blacklist.
        self.black_list = black_list
        # The domain name of the image repository.
        self.domain_name = domain_name
        # The creation time. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.gmt_create = gmt_create
        # The update time. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.gmt_modified = gmt_modified
        # The ID of the image repository.
        self.id = id
        # The network type. Valid values:
        # 
        # *   **1**: Internet
        # *   **2**: VPC
        self.net_type = net_type
        # The password.
        self.password = password
        # The number of days during which assets can be retained.
        self.persistence_day = persistence_day
        # The type of the protocol. Valid values:
        # 
        # *   **1**: HTTP
        # *   **2**: HTTPS
        self.protocol_type = protocol_type
        # The region ID of the image repository.
        self.region_id = region_id
        # The IP address of the image repository.
        self.registry_host_ip = registry_host_ip
        # The alias of the image repository.
        self.registry_name = registry_name
        # The type of the image repository. Valid values:
        # 
        # *   **CI/CD**: Jenkins
        self.registry_type = registry_type
        # The authentication token of the user.
        self.token = token
        # The number of images that can be scanned per hour.
        self.trans_per_hour = trans_per_hour
        # The username.
        self.user_name = user_name
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The whitelist.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_list is not None:
            result['BlackList'] = self.black_list
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlackList') is not None:
            self.black_list = m.get('BlackList')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateJenkinsImageRegistryResponseBody(TeaModel):
    def __init__(
        self,
        data: CreateJenkinsImageRegistryResponseBodyData = None,
        http_status_code: int = None,
        request_id: str = None,
        time_cost: int = None,
    ):
        # The result of creating the image repository.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The ID of the request.
        self.request_id = request_id
        # The time consumed. Unit: seconds.
        self.time_cost = time_cost

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateJenkinsImageRegistryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class CreateJenkinsImageRegistryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateJenkinsImageRegistryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateJenkinsImageRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateAssetGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_name: str = None,
        uuids: str = None,
    ):
        self.group_id = group_id
        # CreateOrUpdateAssetGroup
        self.group_name = group_name
        # Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class CreateOrUpdateAssetGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        request_id: str = None,
    ):
        self.group_id = group_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateAssetGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateAssetGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateAssetGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRestoreJobRequest(TeaModel):
    def __init__(
        self,
        includes: str = None,
        snapshot_hash: str = None,
        snapshot_id: str = None,
        snapshot_version: str = None,
        source_type: str = None,
        target: str = None,
        uuid: str = None,
        vault_id: str = None,
    ):
        # The directory in which the files included in the restoration task are located. This parameter is specified when you create the anti-ransomware policy. The value is a directory that requires protection.
        self.includes = includes
        # The hash value of the snapshot.
        # 
        # > You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.
        self.snapshot_hash = snapshot_hash
        # The ID of the snapshot that you want to use for restoration.
        # 
        # > You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.
        self.snapshot_id = snapshot_id
        # The version of the backup data.
        # 
        # > You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.
        self.snapshot_version = snapshot_version
        # The type of the data source. Valid values:
        # 
        # *   **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
        # *   **File**: backup snapshots for on-premises servers
        self.source_type = source_type
        # The path to which you want to restore data.
        self.target = target
        # The UUID of the server whose data you want to restore.
        self.uuid = uuid
        # The ID of the backup vault that is used in the restoration task.
        # 
        # > You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.
        self.vault_id = vault_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.includes is not None:
            result['Includes'] = self.includes
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_version is not None:
            result['SnapshotVersion'] = self.snapshot_version
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target is not None:
            result['Target'] = self.target
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Includes') is not None:
            self.includes = m.get('Includes')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotVersion') is not None:
            self.snapshot_version = m.get('SnapshotVersion')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class CreateRestoreJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRestoreJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRestoreJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRestoreJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateServiceLinkedRoleRequest(TeaModel):
    def __init__(
        self,
        service_linked_role: str = None,
    ):
        self.service_linked_role = service_linked_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_linked_role is not None:
            result['ServiceLinkedRole'] = self.service_linked_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServiceLinkedRole') is not None:
            self.service_linked_role = m.get('ServiceLinkedRole')
        return self


class CreateServiceLinkedRoleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateServiceLinkedRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateServiceLinkedRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateServiceLinkedRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimilarSecurityEventsQueryTaskRequest(TeaModel):
    def __init__(
        self,
        resource_owner_id: int = None,
        security_event_id: int = None,
        similar_event_scenario_code: str = None,
        source_ip: str = None,
    ):
        self.resource_owner_id = resource_owner_id
        self.security_event_id = security_event_id
        self.similar_event_scenario_code = similar_event_scenario_code
        # CreateSimilarSecurityEventsQueryTask
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.similar_event_scenario_code is not None:
            result['SimilarEventScenarioCode'] = self.similar_event_scenario_code
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SimilarEventScenarioCode') is not None:
            self.similar_event_scenario_code = m.get('SimilarEventScenarioCode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse(TeaModel):
    def __init__(
        self,
        status: str = None,
        task_id: int = None,
    ):
        self.status = status
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateSimilarSecurityEventsQueryTaskResponseBody(TeaModel):
    def __init__(
        self,
        create_similar_security_events_query_task_response: CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse = None,
        request_id: str = None,
    ):
        self.create_similar_security_events_query_task_response = create_similar_security_events_query_task_response
        self.request_id = request_id

    def validate(self):
        if self.create_similar_security_events_query_task_response:
            self.create_similar_security_events_query_task_response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_similar_security_events_query_task_response is not None:
            result['CreateSimilarSecurityEventsQueryTaskResponse'] = self.create_similar_security_events_query_task_response.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateSimilarSecurityEventsQueryTaskResponse') is not None:
            temp_model = CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse()
            self.create_similar_security_events_query_task_response = temp_model.from_map(m['CreateSimilarSecurityEventsQueryTaskResponse'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSimilarSecurityEventsQueryTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSimilarSecurityEventsQueryTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSimilarSecurityEventsQueryTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSuspEventNoteRequest(TeaModel):
    def __init__(
        self,
        event_id: int = None,
        note: str = None,
    ):
        self.event_id = event_id
        self.note = note

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.note is not None:
            result['Note'] = self.note
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('Note') is not None:
            self.note = m.get('Note')
        return self


class CreateSuspEventNoteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSuspEventNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSuspEventNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSuspEventNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUniBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        account_name: str = None,
        account_password: str = None,
        database_add_by_user: str = None,
        database_type: str = None,
        full_plan: Dict[str, Any] = None,
        inc_plan: Dict[str, Any] = None,
        instance_id: str = None,
        policy_name: str = None,
        retention: int = None,
        speed_limiter: int = None,
        uni_region_id: str = None,
        uuid: str = None,
    ):
        self.account_name = account_name
        self.account_password = account_password
        self.database_add_by_user = database_add_by_user
        self.database_type = database_type
        self.full_plan = full_plan
        self.inc_plan = inc_plan
        self.instance_id = instance_id
        self.policy_name = policy_name
        self.retention = retention
        self.speed_limiter = speed_limiter
        self.uni_region_id = uni_region_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.database_add_by_user is not None:
            result['DatabaseAddByUser'] = self.database_add_by_user
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('DatabaseAddByUser') is not None:
            self.database_add_by_user = m.get('DatabaseAddByUser')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            self.full_plan = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan = m.get('IncPlan')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateUniBackupPolicyShrinkRequest(TeaModel):
    def __init__(
        self,
        account_name: str = None,
        account_password: str = None,
        database_add_by_user: str = None,
        database_type: str = None,
        full_plan_shrink: str = None,
        inc_plan_shrink: str = None,
        instance_id: str = None,
        policy_name: str = None,
        retention: int = None,
        speed_limiter: int = None,
        uni_region_id: str = None,
        uuid: str = None,
    ):
        self.account_name = account_name
        self.account_password = account_password
        self.database_add_by_user = database_add_by_user
        self.database_type = database_type
        self.full_plan_shrink = full_plan_shrink
        self.inc_plan_shrink = inc_plan_shrink
        self.instance_id = instance_id
        self.policy_name = policy_name
        self.retention = retention
        self.speed_limiter = speed_limiter
        self.uni_region_id = uni_region_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.database_add_by_user is not None:
            result['DatabaseAddByUser'] = self.database_add_by_user
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan_shrink is not None:
            result['FullPlan'] = self.full_plan_shrink
        if self.inc_plan_shrink is not None:
            result['IncPlan'] = self.inc_plan_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('DatabaseAddByUser') is not None:
            self.database_add_by_user = m.get('DatabaseAddByUser')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            self.full_plan_shrink = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan_shrink = m.get('IncPlan')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateUniBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUniBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUniBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUniRestorePlanRequest(TeaModel):
    def __init__(
        self,
        database: str = None,
        instance_uuid: str = None,
        policy_id: int = None,
        reset_scn: str = None,
        reset_time: str = None,
        restore_info: str = None,
        time_point: int = None,
    ):
        self.database = database
        self.instance_uuid = instance_uuid
        self.policy_id = policy_id
        self.reset_scn = reset_scn
        self.reset_time = reset_time
        self.restore_info = restore_info
        self.time_point = time_point

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.reset_scn is not None:
            result['ResetScn'] = self.reset_scn
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.restore_info is not None:
            result['RestoreInfo'] = self.restore_info
        if self.time_point is not None:
            result['TimePoint'] = self.time_point
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('ResetScn') is not None:
            self.reset_scn = m.get('ResetScn')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('RestoreInfo') is not None:
            self.restore_info = m.get('RestoreInfo')
        if m.get('TimePoint') is not None:
            self.time_point = m.get('TimePoint')
        return self


class CreateUniRestorePlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUniRestorePlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUniRestorePlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUniRestorePlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVulAutoRepairConfigRequestVulAutoRepairConfigList(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        name: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The name of the vulnerability.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateVulAutoRepairConfigRequest(TeaModel):
    def __init__(
        self,
        reason: str = None,
        type: str = None,
        vul_auto_repair_config_list: List[CreateVulAutoRepairConfigRequestVulAutoRepairConfigList] = None,
    ):
        # The reason why the vulnerability can be automatically fixed.
        self.reason = reason
        # The type of the vulnerability. Valid values: 
        # - **cve**: Linux software vulnerability 
        # - **sys**: Windows system vulnerability
        self.type = type
        # The vulnerabilities that can be automatically fixed.
        self.vul_auto_repair_config_list = vul_auto_repair_config_list

    def validate(self):
        if self.vul_auto_repair_config_list:
            for k in self.vul_auto_repair_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        result['VulAutoRepairConfigList'] = []
        if self.vul_auto_repair_config_list is not None:
            for k in self.vul_auto_repair_config_list:
                result['VulAutoRepairConfigList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.vul_auto_repair_config_list = []
        if m.get('VulAutoRepairConfigList') is not None:
            for k in m.get('VulAutoRepairConfigList'):
                temp_model = CreateVulAutoRepairConfigRequestVulAutoRepairConfigList()
                self.vul_auto_repair_config_list.append(temp_model.from_map(k))
        return self


class CreateVulAutoRepairConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The error message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateVulAutoRepairConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVulAutoRepairConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVulAutoRepairConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAntiBruteForceRuleRequest(TeaModel):
    def __init__(
        self,
        ids: List[int] = None,
    ):
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class DeleteAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAntiBruteForceRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAntiBruteForceRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        policy_version: str = None,
    ):
        self.id = id
        self.policy_version = policy_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        return self


class DeleteBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBackupPolicyMachineRequest(TeaModel):
    def __init__(
        self,
        policy_id: int = None,
        policy_version: str = None,
        uuid: str = None,
        uuid_list: List[str] = None,
    ):
        self.policy_id = policy_id
        self.policy_version = policy_version
        self.uuid = uuid
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DeleteBackupPolicyMachineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBackupPolicyMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBackupPolicyMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBackupPolicyMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClientUserDefineRuleRequest(TeaModel):
    def __init__(
        self,
        id_list: List[int] = None,
    ):
        self.id_list = id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id_list is not None:
            result['IdList'] = self.id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IdList') is not None:
            self.id_list = m.get('IdList')
        return self


class DeleteClientUserDefineRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteClientUserDefineRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteClientUserDefineRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomBlockRecordRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        resource_owner_id: int = None,
    ):
        self.id = id
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCustomBlockRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomBlockRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomBlockRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCycleTaskRequest(TeaModel):
    def __init__(
        self,
        config_id: str = None,
    ):
        self.config_id = config_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        return self


class DeleteCycleTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCycleTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCycleTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        source_ip: str = None,
    ):
        # WB01014029
        self.group_id = group_id
        # DeleteGroup
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DeleteGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotRequest(TeaModel):
    def __init__(
        self,
        honeypot_id: str = None,
        lang: str = None,
    ):
        self.honeypot_id = honeypot_id
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteHoneypotResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHoneypotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotNodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        node_id: str = None,
    ):
        self.lang = lang
        # Deletes a specified management node.
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class DeleteHoneypotNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHoneypotNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotPresetRequest(TeaModel):
    def __init__(
        self,
        honeypot_preset_id: str = None,
        lang: str = None,
    ):
        self.honeypot_preset_id = honeypot_preset_id
        # **zh**
        # - **zh**
        # - **en**
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteHoneypotPresetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotPresetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHoneypotPresetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotProbeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        probe_id: str = None,
    ):
        # **zh**
        # 
        # - **zh**
        # - **en**
        self.lang = lang
        self.probe_id = probe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class DeleteHoneypotProbeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotProbeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHoneypotProbeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstallCodeRequest(TeaModel):
    def __init__(
        self,
        captcha_code: str = None,
    ):
        self.captcha_code = captcha_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        return self


class DeleteInstallCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstallCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstallCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInterceptionRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        rule_ids: List[int] = None,
    ):
        self.cluster_id = cluster_id
        self.rule_ids = rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        return self


class DeleteInterceptionRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInterceptionRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInterceptionRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInterceptionRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInterceptionTargetRequest(TeaModel):
    def __init__(
        self,
        target_ids: str = None,
    ):
        self.target_ids = target_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_ids is not None:
            result['TargetIds'] = self.target_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetIds') is not None:
            self.target_ids = m.get('TargetIds')
        return self


class DeleteInterceptionTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DeleteInterceptionTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInterceptionTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInterceptionTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLoginBaseConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        target: str = None,
        type: str = None,
    ):
        # The content of the logon security settings to delete. The content varies based on the type of the logon security settings. Valid values:
        # 
        # *   **login\_common_ip**: approved logon IP addresses
        # 
        # Example: {"ip":"10.23.23.23"}.
        # 
        # *   **login\_common_time**: approved logon time ranges
        # 
        # Example: {"startTime":"06:00:00","endTime":"16:00:00"}.
        # 
        # *   **login\_common_account**: approved logon accounts
        # 
        # Example: {"account":"test_account\_001"}.
        # 
        # *   **login\_common_location**: approved logon locations
        # 
        # Example: {"location":"Shanghai"}.
        self.config = config
        # The UUID of the server whose logon security settings you want to delete.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.target = target
        # The type of the logon security settings to delete. Valid values:
        # 
        # *   **login\_common_ip**: approved logon IP addresses
        # *   **login\_common_time**: approved logon time ranges
        # *   **login\_common_account**: approved logon accounts
        # *   **login\_common_location**: approved logon locations
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteLoginBaseConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLoginBaseConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLoginBaseConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLoginBaseConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrivateRegistryRequest(TeaModel):
    def __init__(
        self,
        registry_id: int = None,
    ):
        self.registry_id = registry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_id is not None:
            result['RegistryId'] = self.registry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegistryId') is not None:
            self.registry_id = m.get('RegistryId')
        return self


class DeletePrivateRegistryResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePrivateRegistryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrivateRegistryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrivateRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecurityEventMarkMissListRequest(TeaModel):
    def __init__(
        self,
        ids: List[int] = None,
        resource_owner_id: int = None,
    ):
        # The IDs of custom defense rule.
        self.ids = ids
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteSecurityEventMarkMissListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSecurityEventMarkMissListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSecurityEventMarkMissListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecurityEventMarkMissListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStrategyRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        self.id = id
        self.lang = lang
        # Deletes a baseline check policy.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DeleteStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSuspEventNodeRequest(TeaModel):
    def __init__(
        self,
        note_id: int = None,
    ):
        self.note_id = note_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        return self


class DeleteSuspEventNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSuspEventNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSuspEventNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSuspEventNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTagWithUuidRequest(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
        uuid_list: str = None,
    ):
        self.tag_name = tag_name
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DeleteTagWithUuidResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTagWithUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTagWithUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUniBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        policy_id: int = None,
        policy_ids: str = None,
    ):
        self.policy_id = policy_id
        self.policy_ids = policy_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_ids is not None:
            result['PolicyIds'] = self.policy_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyIds') is not None:
            self.policy_ids = m.get('PolicyIds')
        return self


class DeleteUniBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteUniBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUniBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVpcHoneyPotRequest(TeaModel):
    def __init__(
        self,
        vpc_id: str = None,
    ):
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DeleteVpcHoneyPotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVpcHoneyPotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVpcHoneyPotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVulWhitelistRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        whitelist: str = None,
    ):
        self.id = id
        self.whitelist = whitelist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class DeleteVulWhitelistResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVulWhitelistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVulWhitelistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccessKeyLeakDetailRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeAccessKeyLeakDetailResponseBody(TeaModel):
    def __init__(
        self,
        accesskey_id: str = None,
        asset: str = None,
        code: str = None,
        deal_time: str = None,
        deal_type: str = None,
        github_file_name: str = None,
        github_file_type: str = None,
        github_file_update_time: str = None,
        github_file_url: str = None,
        github_repo_name: str = None,
        github_repo_url: str = None,
        github_user: str = None,
        github_user_pic_url: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        remark: str = None,
        request_id: str = None,
        source: str = None,
        type: str = None,
        whitelist_status: str = None,
    ):
        self.accesskey_id = accesskey_id
        self.asset = asset
        self.code = code
        self.deal_time = deal_time
        self.deal_type = deal_type
        self.github_file_name = github_file_name
        self.github_file_type = github_file_type
        self.github_file_update_time = github_file_update_time
        self.github_file_url = github_file_url
        self.github_repo_name = github_repo_name
        self.github_repo_url = github_repo_url
        self.github_user = github_user
        self.github_user_pic_url = github_user_pic_url
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.remark = remark
        self.request_id = request_id
        self.source = source
        self.type = type
        self.whitelist_status = whitelist_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accesskey_id is not None:
            result['AccesskeyId'] = self.accesskey_id
        if self.asset is not None:
            result['Asset'] = self.asset
        if self.code is not None:
            result['Code'] = self.code
        if self.deal_time is not None:
            result['DealTime'] = self.deal_time
        if self.deal_type is not None:
            result['DealType'] = self.deal_type
        if self.github_file_name is not None:
            result['GithubFileName'] = self.github_file_name
        if self.github_file_type is not None:
            result['GithubFileType'] = self.github_file_type
        if self.github_file_update_time is not None:
            result['GithubFileUpdateTime'] = self.github_file_update_time
        if self.github_file_url is not None:
            result['GithubFileUrl'] = self.github_file_url
        if self.github_repo_name is not None:
            result['GithubRepoName'] = self.github_repo_name
        if self.github_repo_url is not None:
            result['GithubRepoUrl'] = self.github_repo_url
        if self.github_user is not None:
            result['GithubUser'] = self.github_user
        if self.github_user_pic_url is not None:
            result['GithubUserPicUrl'] = self.github_user_pic_url
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist_status is not None:
            result['WhitelistStatus'] = self.whitelist_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccesskeyId') is not None:
            self.accesskey_id = m.get('AccesskeyId')
        if m.get('Asset') is not None:
            self.asset = m.get('Asset')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DealTime') is not None:
            self.deal_time = m.get('DealTime')
        if m.get('DealType') is not None:
            self.deal_type = m.get('DealType')
        if m.get('GithubFileName') is not None:
            self.github_file_name = m.get('GithubFileName')
        if m.get('GithubFileType') is not None:
            self.github_file_type = m.get('GithubFileType')
        if m.get('GithubFileUpdateTime') is not None:
            self.github_file_update_time = m.get('GithubFileUpdateTime')
        if m.get('GithubFileUrl') is not None:
            self.github_file_url = m.get('GithubFileUrl')
        if m.get('GithubRepoName') is not None:
            self.github_repo_name = m.get('GithubRepoName')
        if m.get('GithubRepoUrl') is not None:
            self.github_repo_url = m.get('GithubRepoUrl')
        if m.get('GithubUser') is not None:
            self.github_user = m.get('GithubUser')
        if m.get('GithubUserPicUrl') is not None:
            self.github_user_pic_url = m.get('GithubUserPicUrl')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WhitelistStatus') is not None:
            self.whitelist_status = m.get('WhitelistStatus')
        return self


class DescribeAccessKeyLeakDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAccessKeyLeakDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccessKeyLeakDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccesskeyLeakListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        query: str = None,
        start_ts: int = None,
        status: str = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The number of entries to return on each page.\
        # Maximum value: 100. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The AccessKey ID that you want to query. Only exact match is supported.
        self.query = query
        # The beginning of the time range to query. You can query all AccessKey pair leaks that are detected later than this time point. The value of this parameter is a UNIX timestamp. Unit: milliseconds.
        self.start_ts = start_ts
        # Specifies whether an AccessKey pair leak is handled. Valid values:
        # 
        # *   **pending**: unhandled
        # *   **dealed**: handled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList(TeaModel):
    def __init__(
        self,
        accesskey_id: str = None,
        ali_user_name: str = None,
        asset: str = None,
        deal_time: str = None,
        deal_type: str = None,
        gmt_modified: int = None,
        id: int = None,
        status: str = None,
        type: str = None,
        url: str = None,
        user_type: str = None,
    ):
        # The ID of the AccessKey pair that is leaked.
        self.accesskey_id = accesskey_id
        # The name of the Alibaba Cloud account that is affected.
        self.ali_user_name = ali_user_name
        # The platform to which the asset belongs. The value is fixed as **Cloud platform**.
        self.asset = asset
        # The time when the AccessKey pair leak is handled.
        self.deal_time = deal_time
        # The method to handle the AccessKey pair leak. Valid values:
        # 
        # *   **pending**: The AccessKey pair leak is unhandled.
        # *   **manual**: The AccessKey pair leak is manually handled.
        # *   **disable**: The AccessKey pair leak is disabled.
        # *   **add-whitelist**: The AccessKey pair leak is added to the whitelist.
        self.deal_type = deal_type
        # The time when the AccessKey pair leak is first detected. The value of this parameter is a UNIX timestamp. Unit: milliseconds.
        self.gmt_modified = gmt_modified
        # The primary key ID of the database.
        self.id = id
        # Indicates whether the AccessKey pair leak is handled. Valid values:
        # 
        # *   **pending**: unhandled
        # *   **dealed**: handled
        self.status = status
        # The type of the leak. The value is fixed as **AccessKey**.
        self.type = type
        # The URL of the platform on which the AccessKey pair leak is detected.
        self.url = url
        # The type of the account to which the leaked AccessKey pair belongs. Valid values:
        # 
        # *   **master**: Alibaba Cloud account
        # *   **ram**: RAM user
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accesskey_id is not None:
            result['AccesskeyId'] = self.accesskey_id
        if self.ali_user_name is not None:
            result['AliUserName'] = self.ali_user_name
        if self.asset is not None:
            result['Asset'] = self.asset
        if self.deal_time is not None:
            result['DealTime'] = self.deal_time
        if self.deal_type is not None:
            result['DealType'] = self.deal_type
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccesskeyId') is not None:
            self.accesskey_id = m.get('AccesskeyId')
        if m.get('AliUserName') is not None:
            self.ali_user_name = m.get('AliUserName')
        if m.get('Asset') is not None:
            self.asset = m.get('Asset')
        if m.get('DealTime') is not None:
            self.deal_time = m.get('DealTime')
        if m.get('DealType') is not None:
            self.deal_type = m.get('DealType')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeAccesskeyLeakListResponseBody(TeaModel):
    def __init__(
        self,
        access_key_leak_list: List[DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList] = None,
        ak_leak_count: int = None,
        current_page: int = None,
        gmt_last: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # An array that consists of the details about AccessKey pair leaks.
        self.access_key_leak_list = access_key_leak_list
        # The number of AccessKey pair leaks that are unhandled.
        self.ak_leak_count = ak_leak_count
        # The page number of the returned page.
        self.current_page = current_page
        # This parameter is deprecated.
        self.gmt_last = gmt_last
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of AccessKey pair leaks.
        self.total_count = total_count

    def validate(self):
        if self.access_key_leak_list:
            for k in self.access_key_leak_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccessKeyLeakList'] = []
        if self.access_key_leak_list is not None:
            for k in self.access_key_leak_list:
                result['AccessKeyLeakList'].append(k.to_map() if k else None)
        if self.ak_leak_count is not None:
            result['AkLeakCount'] = self.ak_leak_count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.access_key_leak_list = []
        if m.get('AccessKeyLeakList') is not None:
            for k in m.get('AccessKeyLeakList'):
                temp_model = DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList()
                self.access_key_leak_list.append(temp_model.from_map(k))
        if m.get('AkLeakCount') is not None:
            self.ak_leak_count = m.get('AkLeakCount')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAccesskeyLeakListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAccesskeyLeakListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccesskeyLeakListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAffectedAssetsRequest(TeaModel):
    def __init__(
        self,
        current: str = None,
        levels: str = None,
        page_size: str = None,
    ):
        # The number of the page to return.
        self.current = current
        # The severity. Separate multiple severities with commas (,). Valid values:
        # 
        # *   serious
        # *   suspicious
        # *   remind
        self.levels = levels
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAffectedAssetsResponseBodyAssetList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        risk_num: int = None,
        uuid: str = None,
    ):
        # The ID of the server.
        self.instance_id = instance_id
        # The name of the server.
        self.instance_name = instance_name
        # The public IP address of the server.
        self.internet_ip = internet_ip
        # The private IP address of the server.
        self.intranet_ip = intranet_ip
        # The number of viruses detected on the server.
        self.risk_num = risk_num
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.risk_num is not None:
            result['RiskNum'] = self.risk_num
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('RiskNum') is not None:
            self.risk_num = m.get('RiskNum')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAffectedAssetsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAffectedAssetsResponseBody(TeaModel):
    def __init__(
        self,
        asset_list: List[DescribeAffectedAssetsResponseBodyAssetList] = None,
        page_info: DescribeAffectedAssetsResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the affected servers.
        self.asset_list = asset_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.asset_list:
            for k in self.asset_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AssetList'] = []
        if self.asset_list is not None:
            for k in self.asset_list:
                result['AssetList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.asset_list = []
        if m.get('AssetList') is not None:
            for k in m.get('AssetList'):
                temp_model = DescribeAffectedAssetsResponseBodyAssetList()
                self.asset_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeAffectedAssetsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAffectedAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAffectedAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAffectedAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAffectedMaliciousFileImagesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        current_page: int = None,
        image: str = None,
        image_digest: str = None,
        image_layer: str = None,
        image_tag: str = None,
        lang: str = None,
        levels: str = None,
        malicious_md_5: str = None,
        namespace: str = None,
        page_size: str = None,
        pod: str = None,
        repo_id: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_region_id: str = None,
        scan_range: List[str] = None,
    ):
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The total number of images that have malicious image samples.
        self.container_id = container_id
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page
        # An array consisting of the images that have malicious image samples.
        self.image = image
        # The severity of the malicious image sample. Separate multiple severities with commas (,). Valid values: serious suspicious remind
        self.image_digest = image_digest
        # The text that is highlighted.
        self.image_layer = image_layer
        # The timestamp of the last scan.
        self.image_tag = image_tag
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.lang = lang
        # The region ID of the image repository. Valid values:
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-zhangjiakou**: China (Zhangjiakou)
        # *   **cn-hangzhou**: China (Hangzhou)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **cn-hongkong**: China (Hong Kong)
        # *   **ap-southeast-1**: Singapore
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        # *   **us-east-1**: US (Virginia)
        # *   **us-west-1**: US (Silicon Valley)
        # *   **eu-central-1**: Germany (Frankfurt)
        # *   **eu-west-1**: UK (London)
        # *   **ap-south-1**: India (Mumbai)
        self.levels = levels
        # The timestamp of the first scan.
        self.malicious_md_5 = malicious_md_5
        # The namespace to which the image repository belongs.
        self.namespace = namespace
        # The name of the image.
        self.page_size = page_size
        # The image layer.
        self.pod = pod
        # The type of the asset that you want to scan. Valid values:
        # 
        # *   **container**\
        # *   **image**\
        self.repo_id = repo_id
        # The ID of the container.
        self.repo_instance_id = repo_instance_id
        # The number of images that have malicious image samples returned on the current page.
        self.repo_name = repo_name
        # The image digest.
        self.repo_namespace = repo_namespace
        # The number of entries to return on each page. Default value: **20**.
        self.repo_region_id = repo_region_id
        # The handling status of the malicious image sample. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: verifying
        # *   **3**: added to the whitelist
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        digest: str = None,
        download_url: str = None,
        file_path: str = None,
        first_scan_timestamp: int = None,
        high_light: str = None,
        image: str = None,
        image_uuid: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        latest_scan_timestamp: int = None,
        latest_verify_timestamp: int = None,
        layer: str = None,
        level: str = None,
        malicious_md_5: str = None,
        namespace: str = None,
        pod: str = None,
        repo_id: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_region_id: str = None,
        status: int = None,
        tag: str = None,
        target_id: str = None,
        target_name: str = None,
        target_type: str = None,
        uuid: str = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.container_id = container_id
        # The name of the cluster.
        self.digest = digest
        self.download_url = download_url
        # The number of entries returned per page. Default value: **20**.
        self.file_path = file_path
        # The ID of the container.
        self.first_scan_timestamp = first_scan_timestamp
        self.high_light = high_light
        self.image = image
        # The namespace to which the image repository belongs.
        # 
        # >  Fuzzy match is supported.
        self.image_uuid = image_uuid
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        # Queries the details of malicious image samples.
        self.latest_scan_timestamp = latest_scan_timestamp
        # The ID of the image repository.
        # 
        # >  You can call the [ListRepository](~~145293~~) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.
        self.latest_verify_timestamp = latest_verify_timestamp
        # The pod.
        self.layer = layer
        self.level = level
        # The pod.
        self.malicious_md_5 = malicious_md_5
        # The namespace.
        self.namespace = namespace
        self.pod = pod
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.repo_id = repo_id
        # The timestamp of the last verification.
        self.repo_instance_id = repo_instance_id
        # DescribeAffectedMaliciousFileImages
        self.repo_name = repo_name
        # The pagination information.
        self.repo_region_id = repo_region_id
        # The name of the image repository.
        # 
        # >  Fuzzy match is supported.
        self.status = status
        # The UUID of the image.
        self.tag = tag
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.first_scan_timestamp is not None:
            result['FirstScanTimestamp'] = self.first_scan_timestamp
        if self.high_light is not None:
            result['HighLight'] = self.high_light
        if self.image is not None:
            result['Image'] = self.image
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.latest_scan_timestamp is not None:
            result['LatestScanTimestamp'] = self.latest_scan_timestamp
        if self.latest_verify_timestamp is not None:
            result['LatestVerifyTimestamp'] = self.latest_verify_timestamp
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FirstScanTimestamp') is not None:
            self.first_scan_timestamp = m.get('FirstScanTimestamp')
        if m.get('HighLight') is not None:
            self.high_light = m.get('HighLight')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LatestScanTimestamp') is not None:
            self.latest_scan_timestamp = m.get('LatestScanTimestamp')
        if m.get('LatestVerifyTimestamp') is not None:
            self.latest_verify_timestamp = m.get('LatestVerifyTimestamp')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAffectedMaliciousFileImagesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The URL to download the malicious image sample.
        self.count = count
        # The image digest.
        self.current_page = current_page
        # The tag that is added to the image.
        self.page_size = page_size
        # The types of the assets that you want to scan.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAffectedMaliciousFileImagesResponseBody(TeaModel):
    def __init__(
        self,
        affected_malicious_file_images_response: List[DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse] = None,
        page_info: DescribeAffectedMaliciousFileImagesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The region ID of the image repository.
        self.affected_malicious_file_images_response = affected_malicious_file_images_response
        # The ID of the container image.
        self.page_info = page_info
        # The ID of the container image.
        # 
        # >  You can call the [ListRepository](~~145293~~) operation to query the IDs of container images from the value of the **InstanceId** response parameter.
        self.request_id = request_id

    def validate(self):
        if self.affected_malicious_file_images_response:
            for k in self.affected_malicious_file_images_response:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AffectedMaliciousFileImagesResponse'] = []
        if self.affected_malicious_file_images_response is not None:
            for k in self.affected_malicious_file_images_response:
                result['AffectedMaliciousFileImagesResponse'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.affected_malicious_file_images_response = []
        if m.get('AffectedMaliciousFileImagesResponse') is not None:
            for k in m.get('AffectedMaliciousFileImagesResponse'):
                temp_model = DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse()
                self.affected_malicious_file_images_response.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeAffectedMaliciousFileImagesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAffectedMaliciousFileImagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAffectedMaliciousFileImagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAffectedMaliciousFileImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAgentInstallStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        uuids: str = None,
    ):
        # The language of the content within the request and response. Valid value:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # The UUIDs of the servers. Separate multiple UUIDs with commas (,).
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList(TeaModel):
    def __init__(
        self,
        message: str = None,
        resule_code: str = None,
        result: int = None,
        uuid: str = None,
    ):
        # The message returned.
        self.message = message
        # The result code returned. Valid values:
        # 
        # *   **-1**: The agent is not installed.
        # *   **0**: The agent is installed.
        # *   **1**: The directory of the agent failed to be created.
        # *   **2**: The installation package failed to be downloaded.
        # *   **3**: The installation file does not exist.
        # *   **4**: The verification information about the installation file does not exist.
        # *   **5**: The installation file failed to pass the verification.
        # *   **6**: The installation file failed to be executed.
        # *   **7**: The agent failed to be installed because the required permissions are not granted.
        # *   **8**: No process of the agent was detected.
        # *   **100**: The agent failed to be installed because an unknown error occurred.
        # *   **1001**: The agent failed to be installed because the automatic installation of the agent is not supported in the region.
        # *   **1002**: The agent failed to be installed because the agent cannot be installed on servers outside the cloud. You can install the agent only on supported servers.
        # *   **1003**: The agent failed to be installed because the operating system type of the server is not supported.
        # *   **1004**: An internal error occurred. Try again later.
        # *   **1005**: The Elastic Compute Service (ECS) instance is not running. Start the ECS instance and try again.
        # *   **1006**: The automatic installation of the agent is not supported on an ECS instance that resides in the classic network.
        # *   **1007**: The process of the installation command is manually stopped.
        # *   **1008**: The agent failed to be installed because Cloud Assistant is not installed.
        # *   **1009**: The execution of the installation command timed out. Try again later.
        # *   **1010**: The agent on the server is already online. You do not need to install the agent.
        self.resule_code = resule_code
        # The installation result. Valid value:
        # 
        # *   **-1**: not installed
        # *   **0**: being installed
        # *   **1**: installed
        # *   **2**: installation failed
        self.result = result
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.resule_code is not None:
            result['ResuleCode'] = self.resule_code
        if self.result is not None:
            result['Result'] = self.result
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ResuleCode') is not None:
            self.resule_code = m.get('ResuleCode')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAgentInstallStatusResponseBody(TeaModel):
    def __init__(
        self,
        aegis_client_invoke_status_response_list: List[DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList] = None,
        request_id: str = None,
    ):
        # An array that consists of the installation results for the servers.
        self.aegis_client_invoke_status_response_list = aegis_client_invoke_status_response_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.aegis_client_invoke_status_response_list:
            for k in self.aegis_client_invoke_status_response_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisClientInvokeStatusResponseList'] = []
        if self.aegis_client_invoke_status_response_list is not None:
            for k in self.aegis_client_invoke_status_response_list:
                result['AegisClientInvokeStatusResponseList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aegis_client_invoke_status_response_list = []
        if m.get('AegisClientInvokeStatusResponseList') is not None:
            for k in m.get('AegisClientInvokeStatusResponseList'):
                temp_model = DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList()
                self.aegis_client_invoke_status_response_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAgentInstallStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAgentInstallStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAgentInstallStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventDetailRequest(TeaModel):
    def __init__(
        self,
        alarm_unique_info: str = None,
        from_: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        # The unique ID of the alert event.
        # 
        # >  To query the details of an alert event, you must specify the unique ID of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the unique IDs of alert events.
        self.alarm_unique_info = alarm_unique_info
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the field that displays tracing information.
        self.name = name
        # The type of the field that displays tracing information. Valid values:
        # 
        # *   **text**\
        # *   **html**\
        self.type = type
        # The value of the field that displays tracing information.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlarmEventDetailResponseBodyDataCauseDetails(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: List[DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue] = None,
    ):
        # The key that is used to trace the alert event.
        self.key = key
        # An array consisting of the value that is used to trace the alert event.
        self.value = value

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        result['Value'] = []
        if self.value is not None:
            for k in self.value:
                result['Value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        self.value = []
        if m.get('Value') is not None:
            for k in m.get('Value'):
                temp_model = DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue()
                self.value.append(temp_model.from_map(k))
        return self


class DescribeAlarmEventDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        alarm_event_alias_name: str = None,
        alarm_event_desc: str = None,
        alarm_unique_info: str = None,
        app_name: str = None,
        can_be_deal_on_line: bool = None,
        can_cancel_fault: bool = None,
        cause_details: List[DescribeAlarmEventDetailResponseBodyDataCauseDetails] = None,
        contain_hw_mode: bool = None,
        container_id: str = None,
        container_image_id: str = None,
        container_image_name: str = None,
        data_source: str = None,
        end_time: int = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        k_8s_cluster_id: str = None,
        k_8s_cluster_name: str = None,
        k_8s_namespace: str = None,
        k_8s_node_id: str = None,
        k_8s_node_name: str = None,
        k_8s_pod_name: str = None,
        level: str = None,
        solution: str = None,
        start_time: int = None,
        type: str = None,
        uuid: str = None,
    ):
        # The name of the alert event.
        self.alarm_event_alias_name = alarm_event_alias_name
        # The description of the alert event.
        self.alarm_event_desc = alarm_event_desc
        # The unique ID of the alert event.
        # 
        # >  To query the details about an alert event, you must specify the unique ID of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the unique IDs of alert events.
        self.alarm_unique_info = alarm_unique_info
        # The name of the container application.
        self.app_name = app_name
        # Indicates whether the online handling of the alert event is supported. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_be_deal_on_line = can_be_deal_on_line
        # Indicates whether you can cancel marking the alert event as a false positive. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_cancel_fault = can_cancel_fault
        # An array consisting of the cause of the alert event, which can be used to trace the alert event.
        self.cause_details = cause_details
        # Indicates whether the Safeguard Mode For Major Activities mode is enabled.
        self.contain_hw_mode = contain_hw_mode
        # The ID of the container application.
        self.container_id = container_id
        # The ID of the image to which the container belongs.
        self.container_image_id = container_image_id
        # The name of the image to which the container belongs.
        self.container_image_name = container_image_name
        # The data source of the alert event.
        self.data_source = data_source
        # The timestamp when the alert event ends. Unit: milliseconds.
        self.end_time = end_time
        # The name of the instance.
        self.instance_name = instance_name
        # The public IP address of the associated instance.
        self.internet_ip = internet_ip
        # The private IP address of the associated instance.
        self.intranet_ip = intranet_ip
        # The ID of the Kubernetes cluster.
        self.k_8s_cluster_id = k_8s_cluster_id
        # The name of the Kubernetes cluster.
        self.k_8s_cluster_name = k_8s_cluster_name
        # The namespace of the Kubernetes cluster.
        self.k_8s_namespace = k_8s_namespace
        # The ID of the Kubernetes cluster node.
        self.k_8s_node_id = k_8s_node_id
        # The name of the Kubernetes cluster node.
        self.k_8s_node_name = k_8s_node_name
        # The name of the Kubernetes pod.
        self.k_8s_pod_name = k_8s_pod_name
        # The severity of the alert event. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level
        # The solution to the alert event.
        self.solution = solution
        # The timestamp when the alert event starts. Unit: milliseconds.
        self.start_time = start_time
        # The alert type of the alert event. Valid values:
        # 
        # *   Suspicious process
        # *   Webshell
        # *   Unusual logon
        # *   Exception
        # *   Sensitive file tampering
        # *   Malicious process (cloud threat detection)
        # *   Suspicious network connection
        # *   Other
        # *   Abnormal account
        # *   Application intrusion event
        # *   Cloud threat detection
        # *   Precise defense
        # *   Application whitelist
        # *   Persistent webshell
        # *   Web application threat detection
        # *   Malicious script
        # *   Threat intelligence
        # *   Malicious network activity
        # *   Cluster exception
        # *   Webshell (on-premises threat detection)
        # *   Vulnerability exploitation
        # *   Malicious process (on-premises threat detection)
        # *   Trusted exception
        self.type = type
        # The instance UUID of the asset.
        self.uuid = uuid

    def validate(self):
        if self.cause_details:
            for k in self.cause_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_alias_name is not None:
            result['AlarmEventAliasName'] = self.alarm_event_alias_name
        if self.alarm_event_desc is not None:
            result['AlarmEventDesc'] = self.alarm_event_desc
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        result['CauseDetails'] = []
        if self.cause_details is not None:
            for k in self.cause_details:
                result['CauseDetails'].append(k.to_map() if k else None)
        if self.contain_hw_mode is not None:
            result['ContainHwMode'] = self.contain_hw_mode
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_image_id is not None:
            result['ContainerImageId'] = self.container_image_id
        if self.container_image_name is not None:
            result['ContainerImageName'] = self.container_image_name
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.k_8s_cluster_id is not None:
            result['K8sClusterId'] = self.k_8s_cluster_id
        if self.k_8s_cluster_name is not None:
            result['K8sClusterName'] = self.k_8s_cluster_name
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.k_8s_node_id is not None:
            result['K8sNodeId'] = self.k_8s_node_id
        if self.k_8s_node_name is not None:
            result['K8sNodeName'] = self.k_8s_node_name
        if self.k_8s_pod_name is not None:
            result['K8sPodName'] = self.k_8s_pod_name
        if self.level is not None:
            result['Level'] = self.level
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmEventAliasName') is not None:
            self.alarm_event_alias_name = m.get('AlarmEventAliasName')
        if m.get('AlarmEventDesc') is not None:
            self.alarm_event_desc = m.get('AlarmEventDesc')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        self.cause_details = []
        if m.get('CauseDetails') is not None:
            for k in m.get('CauseDetails'):
                temp_model = DescribeAlarmEventDetailResponseBodyDataCauseDetails()
                self.cause_details.append(temp_model.from_map(k))
        if m.get('ContainHwMode') is not None:
            self.contain_hw_mode = m.get('ContainHwMode')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerImageId') is not None:
            self.container_image_id = m.get('ContainerImageId')
        if m.get('ContainerImageName') is not None:
            self.container_image_name = m.get('ContainerImageName')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('K8sClusterId') is not None:
            self.k_8s_cluster_id = m.get('K8sClusterId')
        if m.get('K8sClusterName') is not None:
            self.k_8s_cluster_name = m.get('K8sClusterName')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('K8sNodeId') is not None:
            self.k_8s_node_id = m.get('K8sNodeId')
        if m.get('K8sNodeName') is not None:
            self.k_8s_node_name = m.get('K8sNodeName')
        if m.get('K8sPodName') is not None:
            self.k_8s_pod_name = m.get('K8sPodName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAlarmEventDetailResponseBody(TeaModel):
    def __init__(
        self,
        data: DescribeAlarmEventDetailResponseBodyData = None,
        request_id: str = None,
    ):
        # The details about the alert event.
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeAlarmEventDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAlarmEventDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAlarmEventDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventStackInfoRequest(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        lang: str = None,
        source_ip: str = None,
        unique_info: str = None,
        uuid: str = None,
    ):
        # The name of the event.
        # 
        # >  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of events.
        self.event_name = event_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # The ID of the alert event.
        self.unique_info = unique_info
        # The UUID of the server to query.
        # 
        # >  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAlarmEventStackInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stack_info: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The stack information of the alert details.
        self.stack_info = stack_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stack_info is not None:
            result['StackInfo'] = self.stack_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StackInfo') is not None:
            self.stack_info = m.get('StackInfo')
        return self


class DescribeAlarmEventStackInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAlarmEventStackInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventStackInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllEntityResponseBodyEntityList(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        os: str = None,
        uuid: str = None,
    ):
        self.group_id = group_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.ip = ip
        self.os = os
        # DescribeAllEntity
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.os is not None:
            result['Os'] = self.os
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAllEntityResponseBody(TeaModel):
    def __init__(
        self,
        entity_list: List[DescribeAllEntityResponseBodyEntityList] = None,
        request_id: str = None,
    ):
        # Queries the information about all assets. The information includes asset group IDs and asset names.
        self.entity_list = entity_list
        # The IP address of the server.
        self.request_id = request_id

    def validate(self):
        if self.entity_list:
            for k in self.entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EntityList'] = []
        if self.entity_list is not None:
            for k in self.entity_list:
                result['EntityList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.entity_list = []
        if m.get('EntityList') is not None:
            for k in m.get('EntityList'):
                temp_model = DescribeAllEntityResponseBodyEntityList()
                self.entity_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllEntityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllEntityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllGroupsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeAllGroupsResponseBodyGroups(TeaModel):
    def __init__(
        self,
        group_flag: int = None,
        group_id: int = None,
        group_name: str = None,
    ):
        self.group_flag = group_flag
        self.group_id = group_id
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_flag is not None:
            result['GroupFlag'] = self.group_flag
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupFlag') is not None:
            self.group_flag = m.get('GroupFlag')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DescribeAllGroupsResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        groups: List[DescribeAllGroupsResponseBodyGroups] = None,
        request_id: str = None,
    ):
        self.count = count
        self.groups = groups
        self.request_id = request_id

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = DescribeAllGroupsResponseBodyGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllImageBaselineRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList(TeaModel):
    def __init__(
        self,
        alias: str = None,
        class_key: str = None,
        item_key: str = None,
        name_key: str = None,
    ):
        self.alias = alias
        self.class_key = class_key
        self.item_key = item_key
        self.name_key = name_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.item_key is not None:
            result['ItemKey'] = self.item_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('ItemKey') is not None:
            self.item_key = m.get('ItemKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList(TeaModel):
    def __init__(
        self,
        alias: str = None,
        baseline_item_list: List[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList] = None,
        class_key: str = None,
        name_key: str = None,
    ):
        self.alias = alias
        self.baseline_item_list = baseline_item_list
        self.class_key = class_key
        self.name_key = name_key

    def validate(self):
        if self.baseline_item_list:
            for k in self.baseline_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['BaselineItemList'] = []
        if self.baseline_item_list is not None:
            for k in self.baseline_item_list:
                result['BaselineItemList'].append(k.to_map() if k else None)
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.baseline_item_list = []
        if m.get('BaselineItemList') is not None:
            for k in m.get('BaselineItemList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList()
                self.baseline_item_list.append(temp_model.from_map(k))
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList(TeaModel):
    def __init__(
        self,
        alias: str = None,
        baseline_name_list: List[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList] = None,
        class_key: str = None,
    ):
        self.alias = alias
        self.baseline_name_list = baseline_name_list
        self.class_key = class_key

    def validate(self):
        if self.baseline_name_list:
            for k in self.baseline_name_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['BaselineNameList'] = []
        if self.baseline_name_list is not None:
            for k in self.baseline_name_list:
                result['BaselineNameList'].append(k.to_map() if k else None)
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.baseline_name_list = []
        if m.get('BaselineNameList') is not None:
            for k in m.get('BaselineNameList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList()
                self.baseline_name_list.append(temp_model.from_map(k))
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselines(TeaModel):
    def __init__(
        self,
        baseline_class_list: List[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList] = None,
    ):
        self.baseline_class_list = baseline_class_list

    def validate(self):
        if self.baseline_class_list:
            for k in self.baseline_class_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineClassList'] = []
        if self.baseline_class_list is not None:
            for k in self.baseline_class_list:
                result['BaselineClassList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.baseline_class_list = []
        if m.get('BaselineClassList') is not None:
            for k in m.get('BaselineClassList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList()
                self.baseline_class_list.append(temp_model.from_map(k))
        return self


class DescribeAllImageBaselineResponseBody(TeaModel):
    def __init__(
        self,
        image_baselines: DescribeAllImageBaselineResponseBodyImageBaselines = None,
        request_id: str = None,
    ):
        self.image_baselines = image_baselines
        self.request_id = request_id

    def validate(self):
        if self.image_baselines:
            self.image_baselines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_baselines is not None:
            result['ImageBaselines'] = self.image_baselines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageBaselines') is not None:
            temp_model = DescribeAllImageBaselineResponseBodyImageBaselines()
            self.image_baselines = temp_model.from_map(m['ImageBaselines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllImageBaselineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllImageBaselineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllImageBaselineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAntiBruteForceRulesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        id: int = None,
        name: str = None,
        page_size: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.current_page = current_page
        self.id = id
        self.name = name
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeAntiBruteForceRulesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAntiBruteForceRulesResponseBodyRules(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        default_rule: bool = None,
        enable_smart_rule: bool = None,
        fail_count: int = None,
        forbidden_time: int = None,
        id: int = None,
        machine_count: int = None,
        name: str = None,
        span: int = None,
        uuid_list: List[str] = None,
    ):
        self.create_time = create_time
        self.default_rule = default_rule
        self.enable_smart_rule = enable_smart_rule
        self.fail_count = fail_count
        self.forbidden_time = forbidden_time
        self.id = id
        self.machine_count = machine_count
        self.name = name
        self.span = span
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.enable_smart_rule is not None:
            result['EnableSmartRule'] = self.enable_smart_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.id is not None:
            result['Id'] = self.id
        if self.machine_count is not None:
            result['MachineCount'] = self.machine_count
        if self.name is not None:
            result['Name'] = self.name
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('EnableSmartRule') is not None:
            self.enable_smart_rule = m.get('EnableSmartRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MachineCount') is not None:
            self.machine_count = m.get('MachineCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeAntiBruteForceRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeAntiBruteForceRulesResponseBodyPageInfo = None,
        request_id: str = None,
        rules: List[DescribeAntiBruteForceRulesResponseBodyRules] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.rules = rules

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeAntiBruteForceRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeAntiBruteForceRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeAntiBruteForceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAntiBruteForceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAntiBruteForceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppVulScanCycleResponseBody(TeaModel):
    def __init__(
        self,
        cycle: str = None,
        request_id: str = None,
    ):
        self.cycle = cycle
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle is not None:
            result['Cycle'] = self.cycle
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cycle') is not None:
            self.cycle = m.get('Cycle')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAppVulScanCycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppVulScanCycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppVulScanCycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetDetailByUuidRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        # The operating system version of the server.
        self.lang = lang
        # The details of the CPU.
        self.source_ip = source_ip
        # The public IP address of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAssetDetailByUuidResponseBodyAssetDetail(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        auth_modify_time: int = None,
        auth_version: int = None,
        bind: bool = None,
        client_status: str = None,
        client_version: str = None,
        cpu: int = None,
        cpu_info: str = None,
        create_time: int = None,
        disk_info_list: List[str] = None,
        flag: int = None,
        group_trace: str = None,
        host_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        ip_list: List[str] = None,
        kernel: str = None,
        mac_list: List[str] = None,
        mem: int = None,
        memory: int = None,
        os: str = None,
        os_detail: str = None,
        os_name: str = None,
        region: str = None,
        region_id: str = None,
        region_name: str = None,
        sys_info: str = None,
        tag: str = None,
        uuid: str = None,
        vpc_instance_id: str = None,
    ):
        # The name of the region in which the server resides.
        self.asset_type = asset_type
        # The operating system information about the server.
        self.auth_modify_time = auth_modify_time
        # The name of the host.
        self.auth_version = auth_version
        # The memory size of the server. Unit: MB.
        self.bind = bind
        # The name of the server.
        self.client_status = client_status
        # An array that consists of the information about the disk.
        self.client_version = client_version
        # The IP addresses of the server.
        self.cpu = cpu
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.cpu_info = cpu_info
        # The status of the Security Center agent. Valid values:
        # 
        # *   **pause**: The Security Center agent suspends protection for your server.
        # *   **online**: The Security Center agent is protecting your server.
        # *   **offline**: The Security Center agent does not protect your server.
        self.create_time = create_time
        self.disk_info_list = disk_info_list
        # The MAC addresses of the server.
        self.flag = flag
        # The ID of the server.
        self.group_trace = group_trace
        # The type of the asset. Valid values:
        # 
        # *   **0**: ECS instance
        # *   **1**: Server Load Balancer (SLB) instance
        # *   **2**: NAT gateway
        # *   **3**: ApsaraDB RDS database
        # *   **4**: ApsaraDB for MongoDB database
        # *   **5**: ApsaraDB for Redis database
        # *   **6**: image
        # *   **7**: container
        self.host_name = host_name
        # The UUID of the server.
        self.instance_id = instance_id
        # The operating system type of the server.
        self.instance_name = instance_name
        # The name of the operating system.
        self.internet_ip = internet_ip
        # The number of CPU cores.
        self.intranet_ip = intranet_ip
        # The private IP address of the server.
        self.ip = ip
        # The information about the disk. This parameter contains the following fields:
        # 
        # *   **diskName**: the name of the disk.
        # *   **totalSize**: the total amount of the disk space. Unit: GB.
        # *   **useSize**: the amount of the used disk space. Unit: GB.
        # *   **useSizeByte**: the amount of the used disk space. Unit: bytes.
        # *   **totalSizeByte**: the total amount of the disk space. Unit: bytes.
        self.ip_list = ip_list
        # The memory size of the server. Unit: GB.
        self.kernel = kernel
        self.mac_list = mac_list
        # The region in which the server resides.
        self.mem = mem
        # The group to which the server belongs. By default, the servers that are not grouped belong to the **Default** group.
        self.memory = memory
        # The ID of the region in which the asset resides.
        self.os = os
        # The tag that is added to the server.
        self.os_detail = os_detail
        # The ID of the virtual private cloud (VPC) in which the server resides.
        self.os_name = os_name
        # The timestamp when Security Center is authorized to protect the asset. Unit: milliseconds.
        self.region = region
        # Indicates whether the asset is provided by Alibaba Cloud. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.region_id = region_id
        # The media access control (MAC) addresses of the server.
        self.region_name = region_name
        # The version of the Security Center agent.
        self.sys_info = sys_info
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition (Unauthorized)
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.tag = tag
        # The IP addresses of the server.
        self.uuid = uuid
        # The IP address that is assigned to the Elastic Compute Service (ECS) instance.
        self.vpc_instance_id = vpc_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.auth_modify_time is not None:
            result['AuthModifyTime'] = self.auth_modify_time
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_info is not None:
            result['CpuInfo'] = self.cpu_info
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.disk_info_list is not None:
            result['DiskInfoList'] = self.disk_info_list
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.group_trace is not None:
            result['GroupTrace'] = self.group_trace
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_list is not None:
            result['IpList'] = self.ip_list
        if self.kernel is not None:
            result['Kernel'] = self.kernel
        if self.mac_list is not None:
            result['MacList'] = self.mac_list
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.os is not None:
            result['Os'] = self.os
        if self.os_detail is not None:
            result['OsDetail'] = self.os_detail
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.sys_info is not None:
            result['SysInfo'] = self.sys_info
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AuthModifyTime') is not None:
            self.auth_modify_time = m.get('AuthModifyTime')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuInfo') is not None:
            self.cpu_info = m.get('CpuInfo')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DiskInfoList') is not None:
            self.disk_info_list = m.get('DiskInfoList')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('GroupTrace') is not None:
            self.group_trace = m.get('GroupTrace')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpList') is not None:
            self.ip_list = m.get('IpList')
        if m.get('Kernel') is not None:
            self.kernel = m.get('Kernel')
        if m.get('MacList') is not None:
            self.mac_list = m.get('MacList')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsDetail') is not None:
            self.os_detail = m.get('OsDetail')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('SysInfo') is not None:
            self.sys_info = m.get('SysInfo')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        return self


class DescribeAssetDetailByUuidResponseBody(TeaModel):
    def __init__(
        self,
        asset_detail: DescribeAssetDetailByUuidResponseBodyAssetDetail = None,
        request_id: str = None,
    ):
        # The kernel version of the operating system.
        self.asset_detail = asset_detail
        # The timestamp when Security Center records the details of the server. Unit: milliseconds.
        self.request_id = request_id

    def validate(self):
        if self.asset_detail:
            self.asset_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_detail is not None:
            result['AssetDetail'] = self.asset_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetDetail') is not None:
            temp_model = DescribeAssetDetailByUuidResponseBodyAssetDetail()
            self.asset_detail = temp_model.from_map(m['AssetDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetDetailByUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAssetDetailByUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetDetailByUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetDetailByUuidsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        uuids: str = None,
    ):
        self.lang = lang
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeAssetDetailByUuidsResponseBodyAssetList(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        client_status: str = None,
        flag: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        os: str = None,
        os_name: str = None,
        region: str = None,
        region_id: str = None,
        region_name: str = None,
        uuid: str = None,
        vpc_instance_id: str = None,
    ):
        self.asset_type = asset_type
        self.client_status = client_status
        self.flag = flag
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.ip = ip
        self.os = os
        self.os_name = os_name
        self.region = region
        self.region_id = region_id
        self.region_name = region_name
        self.uuid = uuid
        self.vpc_instance_id = vpc_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.os is not None:
            result['Os'] = self.os
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        return self


class DescribeAssetDetailByUuidsResponseBody(TeaModel):
    def __init__(
        self,
        asset_list: List[DescribeAssetDetailByUuidsResponseBodyAssetList] = None,
        request_id: str = None,
    ):
        self.asset_list = asset_list
        self.request_id = request_id

    def validate(self):
        if self.asset_list:
            for k in self.asset_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AssetList'] = []
        if self.asset_list is not None:
            for k in self.asset_list:
                result['AssetList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.asset_list = []
        if m.get('AssetList') is not None:
            for k in m.get('AssetList'):
                temp_model = DescribeAssetDetailByUuidsResponseBodyAssetList()
                self.asset_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetDetailByUuidsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAssetDetailByUuidsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetDetailByUuidsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetSummaryResponseBodyAssetsSummary(TeaModel):
    def __init__(
        self,
        total_asset_all_region: int = None,
        total_core_all_region: int = None,
        total_core_num: int = None,
    ):
        self.total_asset_all_region = total_asset_all_region
        self.total_core_all_region = total_core_all_region
        self.total_core_num = total_core_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_asset_all_region is not None:
            result['TotalAssetAllRegion'] = self.total_asset_all_region
        if self.total_core_all_region is not None:
            result['TotalCoreAllRegion'] = self.total_core_all_region
        if self.total_core_num is not None:
            result['TotalCoreNum'] = self.total_core_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TotalAssetAllRegion') is not None:
            self.total_asset_all_region = m.get('TotalAssetAllRegion')
        if m.get('TotalCoreAllRegion') is not None:
            self.total_core_all_region = m.get('TotalCoreAllRegion')
        if m.get('TotalCoreNum') is not None:
            self.total_core_num = m.get('TotalCoreNum')
        return self


class DescribeAssetSummaryResponseBody(TeaModel):
    def __init__(
        self,
        assets_summary: DescribeAssetSummaryResponseBodyAssetsSummary = None,
        request_id: str = None,
    ):
        self.assets_summary = assets_summary
        self.request_id = request_id

    def validate(self):
        if self.assets_summary:
            self.assets_summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_summary is not None:
            result['AssetsSummary'] = self.assets_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetsSummary') is not None:
            temp_model = DescribeAssetSummaryResponseBodyAssetsSummary()
            self.assets_summary = temp_model.from_map(m['AssetsSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAssetSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetsSecurityEventSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.cluster_id = cluster_id
        self.container_field_name = container_field_name
        self.container_field_value = container_field_value
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeAssetsSecurityEventSummaryResponseBodyAssets(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        risk_count: int = None,
        total_count: int = None,
    ):
        self.asset_type = asset_type
        self.risk_count = risk_count
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAssetsSecurityEventSummaryResponseBody(TeaModel):
    def __init__(
        self,
        assets: List[DescribeAssetsSecurityEventSummaryResponseBodyAssets] = None,
        request_id: str = None,
    ):
        self.assets = assets
        self.request_id = request_id

    def validate(self):
        if self.assets:
            for k in self.assets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Assets'] = []
        if self.assets is not None:
            for k in self.assets:
                result['Assets'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.assets = []
        if m.get('Assets') is not None:
            for k in m.get('Assets'):
                temp_model = DescribeAssetsSecurityEventSummaryResponseBodyAssets()
                self.assets.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetsSecurityEventSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAssetsSecurityEventSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetsSecurityEventSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAttackAnalysisDataRequest(TeaModel):
    def __init__(
        self,
        base_64: str = None,
        current_page: int = None,
        data: str = None,
        end_time: int = None,
        lang: str = None,
        page_size: int = None,
        start_time: int = None,
        type: str = None,
    ):
        self.base_64 = base_64
        self.current_page = current_page
        self.data = data
        self.end_time = end_time
        self.lang = lang
        self.page_size = page_size
        self.start_time = start_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_64 is not None:
            result['Base64'] = self.base_64
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Base64') is not None:
            self.base_64 = m.get('Base64')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAttackAnalysisDataResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.data = data
        self.page = page
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeAttackAnalysisDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAttackAnalysisDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAttackAnalysisDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoDelConfigResponseBody(TeaModel):
    def __init__(
        self,
        days: int = None,
        request_id: str = None,
    ):
        self.days = days
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAutoDelConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAutoDelConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoDelConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackUpExportInfoRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        export_type: str = None,
        lang: str = None,
        page_size: int = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The type of archived information. Valid values:
        # 
        # *   **suspiciousExport**: alert event
        self.export_type = export_type
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeBackUpExportInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        current_count: int = None,
        file_name: str = None,
        gmt_create: int = None,
        id: int = None,
        link: str = None,
        message: str = None,
        progress: int = None,
        status: str = None,
        total_count: int = None,
    ):
        # The number of exported entries.
        self.current_count = current_count
        # The name of the file.
        self.file_name = file_name
        # The time when the export task was created.
        self.gmt_create = gmt_create
        # The ID of the export task.
        self.id = id
        # The URL at which you can download the archived information.
        self.link = link
        # The error message that is returned when the export task fails.
        self.message = message
        # The progress percentage of the export task.
        self.progress = progress
        # The status of the export task. Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **exporting**: The task is in progress.
        # *   **success**: The task is complete.
        self.status = status
        # The total number of entries in the file.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackUpExportInfoResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackUpExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeBackUpExportInfoResponseBodyData] = None,
        page_info: DescribeBackUpExportInfoResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The data returned.
        self.data = data
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeBackUpExportInfoResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackUpExportInfoResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackUpExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackUpExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackUpExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupClientsRequest(TeaModel):
    def __init__(
        self,
        support_region_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.support_region_id = support_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.support_region_id is not None:
            result['SupportRegionId'] = self.support_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SupportRegionId') is not None:
            self.support_region_id = m.get('SupportRegionId')
        return self


class DescribeBackupClientsResponseBodyClients(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        client_status: str = None,
        client_version: str = None,
        instance_id: str = None,
        uuid: str = None,
    ):
        self.client_id = client_id
        self.client_status = client_status
        self.client_version = client_version
        self.instance_id = instance_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupClientsResponseBody(TeaModel):
    def __init__(
        self,
        clients: List[DescribeBackupClientsResponseBodyClients] = None,
        request_id: str = None,
    ):
        # DescribeBackupClients
        self.clients = clients
        # Queries the servers on which the anti-ransomware agent is installed in a specified region.
        self.request_id = request_id

    def validate(self):
        if self.clients:
            for k in self.clients:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clients'] = []
        if self.clients is not None:
            for k in self.clients:
                result['Clients'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clients = []
        if m.get('Clients') is not None:
            for k in m.get('Clients'):
                temp_model = DescribeBackupClientsResponseBodyClients()
                self.clients.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupClientsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupClientsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupClientsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupFilesRequest(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_size: str = None,
        path: str = None,
        snapshot_hash: str = None,
        uuid: str = None,
    ):
        # The UUID of the server to which an anti-ransomware policy is applied.
        self.current_page = current_page
        # An array that consists of the backup files returned.
        self.page_size = page_size
        # The pagination information.
        self.path = path
        # The size of the backup file. Unit: bytes.
        self.snapshot_hash = snapshot_hash
        # The number of entries to return on each page. Default value: **10**.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.path is not None:
            result['Path'] = self.path
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupFilesResponseBodyBackupFiles(TeaModel):
    def __init__(
        self,
        name: str = None,
        size: int = None,
        subtree: str = None,
        type: str = None,
    ):
        self.name = name
        self.size = size
        self.subtree = subtree
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.size is not None:
            result['Size'] = self.size
        if self.subtree is not None:
            result['Subtree'] = self.subtree
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Subtree') is not None:
            self.subtree = m.get('Subtree')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeBackupFilesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.current_page = current_page
        # Queries backup files.
        self.page_size = page_size
        # WB01014029
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackupFilesResponseBody(TeaModel):
    def __init__(
        self,
        backup_files: List[DescribeBackupFilesResponseBodyBackupFiles] = None,
        page_info: DescribeBackupFilesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.backup_files = backup_files
        # The number of entries returned per page. Default value: **10**.
        self.page_info = page_info
        # The number of the page to return. Default value: **1**.
        self.request_id = request_id

    def validate(self):
        if self.backup_files:
            for k in self.backup_files:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackupFiles'] = []
        if self.backup_files is not None:
            for k in self.backup_files:
                result['BackupFiles'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backup_files = []
        if m.get('BackupFiles') is not None:
            for k in m.get('BackupFiles'):
                temp_model = DescribeBackupFilesResponseBodyBackupFiles()
                self.backup_files.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackupFilesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupMachineStatusRequest(TeaModel):
    def __init__(
        self,
        policy_id: int = None,
        policy_version: str = None,
        uuid: str = None,
    ):
        # The ID of the anti-ransomware policy.
        # 
        # >  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.policy_id = policy_id
        # The version of the anti-ransomware policy. Valid values:
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        self.policy_version = policy_version
        # The UUID of the server.
        # 
        # >  You can call the [DescribeBackupPolicy](~~DescribeBackupPolicy~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_status: str = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_status = error_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_status is not None:
            result['ErrorStatus'] = self.error_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorStatus') is not None:
            self.error_status = m.get('ErrorStatus')
        return self


class DescribeBackupMachineStatusResponseBodyBackupMachineStatus(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        client_status: str = None,
        client_version: str = None,
        error_code: str = None,
        error_list: List[DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList] = None,
        instance_id: str = None,
        region_id: str = None,
        saved_backup_count: int = None,
        status: str = None,
        uuid: str = None,
        vault_id: str = None,
    ):
        # The ID of the anti-ransomware agent.
        self.client_id = client_id
        # The status of the anti-ransomware agent. Valid values:
        # 
        # *   **ONLINE**: normal
        # *   **CLIENT_CONNECTION_ERROR**: abnormal
        # *   **UNINSTALLING**: being uninstalled
        # *   **UNINSTALL_FAILED**: failed to be uninstalled
        # *   **UPGRADING**: being upgraded
        # *   **UPGRADE_FAILED**: failed to be upgraded
        self.client_status = client_status
        # The version of the anti-ransomware agent.
        self.client_version = client_version
        # The error code returned.
        self.error_code = error_code
        # An array that consists of the error information reported by the backup server.
        self.error_list = error_list
        # The ID of the server.
        self.instance_id = instance_id
        # The ID of the region in which the server resides.
        self.region_id = region_id
        # The number of backup versions.
        self.saved_backup_count = saved_backup_count
        # The status of the anti-ransomware agent. Valid values:
        # 
        # *   **NOT_INSTALLED**: not installed
        # *   **CLIENT_CONNECTION_ERROR**: abnormal
        # *   **ACTIVATED**: normal
        self.status = status
        # The UUID of the server.
        self.uuid = uuid
        # The ID of the backup vault in which the backup data is stored.
        self.vault_id = vault_id

    def validate(self):
        if self.error_list:
            for k in self.error_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorList'] = []
        if self.error_list is not None:
            for k in self.error_list:
                result['ErrorList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.saved_backup_count is not None:
            result['SavedBackupCount'] = self.saved_backup_count
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_list = []
        if m.get('ErrorList') is not None:
            for k in m.get('ErrorList'):
                temp_model = DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList()
                self.error_list.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SavedBackupCount') is not None:
            self.saved_backup_count = m.get('SavedBackupCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeBackupMachineStatusResponseBody(TeaModel):
    def __init__(
        self,
        backup_machine_status: DescribeBackupMachineStatusResponseBodyBackupMachineStatus = None,
        request_id: str = None,
    ):
        # The backup status of the server.
        self.backup_machine_status = backup_machine_status
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.backup_machine_status:
            self.backup_machine_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_machine_status is not None:
            result['BackupMachineStatus'] = self.backup_machine_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupMachineStatus') is not None:
            temp_model = DescribeBackupMachineStatusResponseBodyBackupMachineStatus()
            self.backup_machine_status = temp_model.from_map(m['BackupMachineStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupMachineStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupMachineStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupMachineStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupPoliciesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        machine_remark: str = None,
        name: str = None,
        page_size: int = None,
        status: str = None,
    ):
        # The number of entries returned per page. Default value: 10.
        self.current_page = current_page
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.machine_remark = machine_remark
        # The number of the page to return. Default value: 1.
        self.name = name
        # The page number of the returned page.
        self.page_size = page_size
        # The pagination information.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeBackupPoliciesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The version of the anti-ransomware policy. Valid values:
        # 
        # *   1.0.0
        # *   2.0.0
        self.count = count
        # An array that consists of the anti-ransomware policies returned.
        self.current_page = current_page
        # The number of the servers on which the anti-ransomware agent is in an abnormal state.
        self.page_size = page_size
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: The anti-ransomware policy is manually enabled.
        # *   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
        # *   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackupPoliciesResponseBodyPolicies(TeaModel):
    def __init__(
        self,
        client_error_count: int = None,
        client_error_uuid_list: List[str] = None,
        client_status: str = None,
        health_client_count: int = None,
        health_client_uuid_list: List[str] = None,
        id: int = None,
        name: str = None,
        policy: str = None,
        policy_region_id: str = None,
        policy_version: str = None,
        remarked_uuid_list: List[str] = None,
        server_type: str = None,
        service_error_count: int = None,
        service_error_uuid_list: List[str] = None,
        status: str = None,
        upgrade_status: str = None,
        uuid_list: List[str] = None,
    ):
        # The upgrade status of the anti-ransomware policy. Valid values:
        # 
        # *   **NotUpgraded**\
        # *   **Upgrading**\
        # *   **UpgradeFailed**\
        # *   **UpgradeSuccess**\
        self.client_error_count = client_error_count
        # The UUIDs of the servers to which the anti-ransomware policy is applied.
        self.client_error_uuid_list = client_error_uuid_list
        # The UUIDs of the servers on which the anti-ransomware agent is in an **abnormal** state.
        self.client_status = client_status
        # The UUIDs that are returned based on the value of the MachineRemark request parameter.
        self.health_client_count = health_client_count
        # The total number of anti-ransomware policies returned.
        self.health_client_uuid_list = health_client_uuid_list
        # The UUIDs that are returned based on the value of the MachineRemark request parameter.
        self.id = id
        # The UUIDs of the servers on which the anti-ransomware agent is in an **abnormal** state.
        self.name = name
        # The status of the anti-ransomware agent. Valid values:
        # 
        # *   **running**: normal
        # *   **exception**: abnormal
        self.policy = policy
        # The ID of the anti-ransomware policy.
        self.policy_region_id = policy_region_id
        # The ID of the region that you specified for data backup when you installed the anti-ransomware agent for the server not deployed on Alibaba Cloud.
        self.policy_version = policy_version
        # The UUIDs of the servers on which data backup is exceptional.
        self.remarked_uuid_list = remarked_uuid_list
        # The UUIDs of the servers on which the anti-ransomware agent is in a **normal** state.
        self.server_type = server_type
        # The number of the servers on which the anti-ransomware agent is in a normal state.
        self.service_error_count = service_error_count
        # The type of the server. Valid values:
        # 
        # *   **OUT_CLOUD**: server not deployed on Alibaba Cloud
        # *   **ALIYUN**: Elastic Compute Service (ECS) instance
        # *   **TRIPARTITE**: simple application server
        self.service_error_uuid_list = service_error_uuid_list
        # The number of servers on which data backup is exceptional.
        self.status = status
        # The name of the anti-ransomware policy.
        self.upgrade_status = upgrade_status
        # The UUIDs of the servers on which the anti-ransomware agent is in a **normal** state.
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_error_count is not None:
            result['ClientErrorCount'] = self.client_error_count
        if self.client_error_uuid_list is not None:
            result['ClientErrorUuidList'] = self.client_error_uuid_list
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.health_client_count is not None:
            result['HealthClientCount'] = self.health_client_count
        if self.health_client_uuid_list is not None:
            result['HealthClientUuidList'] = self.health_client_uuid_list
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.remarked_uuid_list is not None:
            result['RemarkedUuidList'] = self.remarked_uuid_list
        if self.server_type is not None:
            result['ServerType'] = self.server_type
        if self.service_error_count is not None:
            result['ServiceErrorCount'] = self.service_error_count
        if self.service_error_uuid_list is not None:
            result['ServiceErrorUuidList'] = self.service_error_uuid_list
        if self.status is not None:
            result['Status'] = self.status
        if self.upgrade_status is not None:
            result['UpgradeStatus'] = self.upgrade_status
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientErrorCount') is not None:
            self.client_error_count = m.get('ClientErrorCount')
        if m.get('ClientErrorUuidList') is not None:
            self.client_error_uuid_list = m.get('ClientErrorUuidList')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('HealthClientCount') is not None:
            self.health_client_count = m.get('HealthClientCount')
        if m.get('HealthClientUuidList') is not None:
            self.health_client_uuid_list = m.get('HealthClientUuidList')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('RemarkedUuidList') is not None:
            self.remarked_uuid_list = m.get('RemarkedUuidList')
        if m.get('ServerType') is not None:
            self.server_type = m.get('ServerType')
        if m.get('ServiceErrorCount') is not None:
            self.service_error_count = m.get('ServiceErrorCount')
        if m.get('ServiceErrorUuidList') is not None:
            self.service_error_uuid_list = m.get('ServiceErrorUuidList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpgradeStatus') is not None:
            self.upgrade_status = m.get('UpgradeStatus')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeBackupPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeBackupPoliciesResponseBodyPageInfo = None,
        policies: List[DescribeBackupPoliciesResponseBodyPolicies] = None,
        request_id: str = None,
    ):
        # The number of entries returned on the current page.
        self.page_info = page_info
        # The configurations of the anti-ransomware policy. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **IsDefault**: the type of the anti-ransomware policy. Valid values:
        # 
        #     *   **1**: recommended policy
        #     *   **0**: custom policy
        # 
        # *   **Include**: the format of the files that are protected. If the value of this field is \[], all formats of files are protected.
        # 
        # *   **Source**: the directory that is protected. If the value of this field is \[], all directories are protected.
        # 
        # *   **ExcludeSystemPath**: indicates whether a specified directory is excluded from the anti-ransomware policy. If the value of this field is **true**, the directory is excluded. If this field is left empty, no directories are excluded.
        # 
        # *   **Exclude**: the directory that is excluded from the anti-ransomware policy. If no directory is specified, the value of this field is \[].
        # 
        # *   **Schedule**: the start time and interval of a data backup task. A start time that begins during off-peak hours but does not start on the hour is recommended. Examples:
        # 
        #     *   If the value of this field is I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
        #     *   If the value of this field is I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.
        # 
        # *   **Retention**: the period during which backup data is retained. Unit: days. If the value of this field is 7, backup data is retained for a week. If the value of this field is 365, backup data is retained for a year. If the value of this field is -1, backup data is permanently retained.
        # 
        # *   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If the value of this field is 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.
        # 
        # *   **UseVss**: indicates whether the VSS feature is enabled. The feature is available only for Windows servers. Valid values:
        # 
        #     *   **true**: yes
        #     *   **false**: no
        # 
        # >  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.
        self.policies = policies
        # The total number of anti-ransomware policies returned.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackupPoliciesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = DescribeBackupPoliciesResponseBodyPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: The anti-ransomware policy is manually enabled.
        # *   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
        # *   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeBackupPolicyResponseBodyBackupPolicyDetail(TeaModel):
    def __init__(
        self,
        client_status: str = None,
        id: int = None,
        name: str = None,
        policy: str = None,
        policy_version: str = None,
        region_id: str = None,
        status: str = None,
        uuid_list: List[str] = None,
    ):
        self.client_status = client_status
        self.id = id
        self.name = name
        # DescribeBackupPolicy
        self.policy = policy
        # Queries the details of an anti-ransomware policy for servers.
        self.policy_version = policy_version
        self.region_id = region_id
        # The ID of the anti-ransomware policy.
        self.status = status
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        backup_policy_detail: DescribeBackupPolicyResponseBodyBackupPolicyDetail = None,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.backup_policy_detail = backup_policy_detail
        # The ID of the region in which backup data is stored.
        self.request_id = request_id

    def validate(self):
        if self.backup_policy_detail:
            self.backup_policy_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_policy_detail is not None:
            result['BackupPolicyDetail'] = self.backup_policy_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupPolicyDetail') is not None:
            temp_model = DescribeBackupPolicyResponseBodyBackupPolicyDetail()
            self.backup_policy_detail = temp_model.from_map(m['BackupPolicyDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupRestoreCountResponseBodyBackupRestoreCount(TeaModel):
    def __init__(
        self,
        recovering: int = None,
        total: int = None,
    ):
        self.recovering = recovering
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recovering is not None:
            result['Recovering'] = self.recovering
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Recovering') is not None:
            self.recovering = m.get('Recovering')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeBackupRestoreCountResponseBody(TeaModel):
    def __init__(
        self,
        backup_restore_count: DescribeBackupRestoreCountResponseBodyBackupRestoreCount = None,
        request_id: str = None,
    ):
        self.backup_restore_count = backup_restore_count
        self.request_id = request_id

    def validate(self):
        if self.backup_restore_count:
            self.backup_restore_count.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_restore_count is not None:
            result['BackupRestoreCount'] = self.backup_restore_count.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupRestoreCount') is not None:
            temp_model = DescribeBackupRestoreCountResponseBodyBackupRestoreCount()
            self.backup_restore_count = temp_model.from_map(m['BackupRestoreCount'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupRestoreCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBackupRestoreCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupRestoreCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBruteForceRecordsRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        current_page: int = None,
        page_size: int = None,
        resource_owner_id: int = None,
        status: int = None,
    ):
        self.block_ip = block_ip
        self.current_page = current_page
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeBruteForceRecordsResponseBodyMachineList(TeaModel):
    def __init__(
        self,
        ali_net_online: bool = None,
        block_expire_date: int = None,
        block_ip: str = None,
        block_type: str = None,
        error_code: str = None,
        id: int = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        port: str = None,
        rule_name: str = None,
        source: str = None,
        status: int = None,
        uuid: str = None,
    ):
        self.ali_net_online = ali_net_online
        self.block_expire_date = block_expire_date
        self.block_ip = block_ip
        self.block_type = block_type
        self.error_code = error_code
        self.id = id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.port = port
        self.rule_name = rule_name
        self.source = source
        self.status = status
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_net_online is not None:
            result['AliNetOnline'] = self.ali_net_online
        if self.block_expire_date is not None:
            result['BlockExpireDate'] = self.block_expire_date
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.port is not None:
            result['Port'] = self.port
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliNetOnline') is not None:
            self.ali_net_online = m.get('AliNetOnline')
        if m.get('BlockExpireDate') is not None:
            self.block_expire_date = m.get('BlockExpireDate')
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBruteForceRecordsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBruteForceRecordsResponseBody(TeaModel):
    def __init__(
        self,
        machine_list: List[DescribeBruteForceRecordsResponseBodyMachineList] = None,
        page_info: DescribeBruteForceRecordsResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.machine_list = machine_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = DescribeBruteForceRecordsResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBruteForceRecordsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBruteForceRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBruteForceRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBruteForceRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBruteForceSummaryRequest(TeaModel):
    def __init__(
        self,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.resource_owner_id = resource_owner_id
        # DescribeBruteForceSummary
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeBruteForceSummaryResponseBodyBruteForceSummary(TeaModel):
    def __init__(
        self,
        all_strategy_count: int = None,
        anti_brute_force_rule_count: str = None,
        custom_effective_count: str = None,
        custom_record_count: str = None,
        effective_count: int = None,
        system_effective_count: str = None,
        system_record_count: str = None,
    ):
        self.all_strategy_count = all_strategy_count
        self.anti_brute_force_rule_count = anti_brute_force_rule_count
        self.custom_effective_count = custom_effective_count
        self.custom_record_count = custom_record_count
        self.effective_count = effective_count
        self.system_effective_count = system_effective_count
        self.system_record_count = system_record_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_strategy_count is not None:
            result['AllStrategyCount'] = self.all_strategy_count
        if self.anti_brute_force_rule_count is not None:
            result['AntiBruteForceRuleCount'] = self.anti_brute_force_rule_count
        if self.custom_effective_count is not None:
            result['CustomEffectiveCount'] = self.custom_effective_count
        if self.custom_record_count is not None:
            result['CustomRecordCount'] = self.custom_record_count
        if self.effective_count is not None:
            result['EffectiveCount'] = self.effective_count
        if self.system_effective_count is not None:
            result['SystemEffectiveCount'] = self.system_effective_count
        if self.system_record_count is not None:
            result['SystemRecordCount'] = self.system_record_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllStrategyCount') is not None:
            self.all_strategy_count = m.get('AllStrategyCount')
        if m.get('AntiBruteForceRuleCount') is not None:
            self.anti_brute_force_rule_count = m.get('AntiBruteForceRuleCount')
        if m.get('CustomEffectiveCount') is not None:
            self.custom_effective_count = m.get('CustomEffectiveCount')
        if m.get('CustomRecordCount') is not None:
            self.custom_record_count = m.get('CustomRecordCount')
        if m.get('EffectiveCount') is not None:
            self.effective_count = m.get('EffectiveCount')
        if m.get('SystemEffectiveCount') is not None:
            self.system_effective_count = m.get('SystemEffectiveCount')
        if m.get('SystemRecordCount') is not None:
            self.system_record_count = m.get('SystemRecordCount')
        return self


class DescribeBruteForceSummaryResponseBody(TeaModel):
    def __init__(
        self,
        brute_force_summary: DescribeBruteForceSummaryResponseBodyBruteForceSummary = None,
        request_id: str = None,
    ):
        self.brute_force_summary = brute_force_summary
        self.request_id = request_id

    def validate(self):
        if self.brute_force_summary:
            self.brute_force_summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.brute_force_summary is not None:
            result['BruteForceSummary'] = self.brute_force_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BruteForceSummary') is not None:
            temp_model = DescribeBruteForceSummaryResponseBodyBruteForceSummary()
            self.brute_force_summary = temp_model.from_map(m['BruteForceSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBruteForceSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBruteForceSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBruteForceSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckEcsWarningsRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
    ):
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeCheckEcsWarningsResponseBody(TeaModel):
    def __init__(
        self,
        can_try: str = None,
        request_id: str = None,
        sas_version: str = None,
        weak_password_count: str = None,
    ):
        self.can_try = can_try
        self.request_id = request_id
        self.sas_version = sas_version
        self.weak_password_count = weak_password_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_try is not None:
            result['CanTry'] = self.can_try
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sas_version is not None:
            result['SasVersion'] = self.sas_version
        if self.weak_password_count is not None:
            result['WeakPasswordCount'] = self.weak_password_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanTry') is not None:
            self.can_try = m.get('CanTry')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SasVersion') is not None:
            self.sas_version = m.get('SasVersion')
        if m.get('WeakPasswordCount') is not None:
            self.weak_password_count = m.get('WeakPasswordCount')
        return self


class DescribeCheckEcsWarningsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckEcsWarningsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckEcsWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckFixDetailsRequest(TeaModel):
    def __init__(
        self,
        check_ids: str = None,
        lang: str = None,
        risk_id: int = None,
    ):
        # Indicates whether the rule is optional. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.check_ids = check_ids
        # The description of the rule.
        self.lang = lang
        # The default value of the rule.
        self.risk_id = risk_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList(TeaModel):
    def __init__(
        self,
        enum_value: str = None,
        max_value: int = None,
        min_value: int = None,
        param_default_value: str = None,
        param_desc: str = None,
        param_name: str = None,
        param_type: int = None,
        rule_id: str = None,
        value: str = None,
    ):
        self.enum_value = enum_value
        self.max_value = max_value
        self.min_value = min_value
        # The number of risk items that can be fixed.
        self.param_default_value = param_default_value
        # The ID of the risk item.
        self.param_desc = param_desc
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.param_name = param_name
        # Queries the parameters that you can configure to fix specified risk items.
        self.param_type = param_type
        self.rule_id = rule_id
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        default_value: int = None,
        optional: int = None,
        param_list: List[DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList] = None,
        rule_desc: str = None,
        rule_id: str = None,
        value: int = None,
        var_name: str = None,
    ):
        # The information about the rule parameter.
        self.check_id = check_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.default_value = default_value
        # The rule that is supported by the risk item.
        self.optional = optional
        # An array that consists of the rule parameters.
        self.param_list = param_list
        # The ID of the risk item.
        # 
        # >  You can call the [DescribeCheckWarningSummary](~~116179~~) operation to query the IDs of risk items.
        self.rule_desc = rule_desc
        # The data returned.
        self.rule_id = rule_id
        # The ID of the rule.
        self.value = value
        # The specified value of the rule parameter.
        self.var_name = var_name

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.value is not None:
            result['Value'] = self.value
        if self.var_name is not None:
            result['VarName'] = self.var_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('VarName') is not None:
            self.var_name = m.get('VarName')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetails(TeaModel):
    def __init__(
        self,
        check_desc: str = None,
        check_id: int = None,
        check_item: str = None,
        rules: List[DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules] = None,
    ):
        # The description of the risk item.
        self.check_desc = check_desc
        # The minimum value of the rule parameter.
        self.check_id = check_id
        # The information about the parameter.
        self.check_item = check_item
        # The options that can be selected for the rule parameter if the value of the ParamType parameter is 2.
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeCheckFixDetailsResponseBody(TeaModel):
    def __init__(
        self,
        check_fix_details: List[DescribeCheckFixDetailsResponseBodyCheckFixDetails] = None,
        count: int = None,
        request_id: str = None,
    ):
        # The specified value of the rule parameter.
        self.check_fix_details = check_fix_details
        self.count = count
        self.request_id = request_id

    def validate(self):
        if self.check_fix_details:
            for k in self.check_fix_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckFixDetails'] = []
        if self.check_fix_details is not None:
            for k in self.check_fix_details:
                result['CheckFixDetails'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_fix_details = []
        if m.get('CheckFixDetails') is not None:
            for k in m.get('CheckFixDetails'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetails()
                self.check_fix_details.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCheckFixDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckFixDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckFixDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningDetailRequest(TeaModel):
    def __init__(
        self,
        check_warning_id: int = None,
        lang: str = None,
        source_ip: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.check_warning_id = check_warning_id
        # The ID of the check item.
        self.lang = lang
        # The additional information about the risk item.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_warning_id is not None:
            result['CheckWarningId'] = self.check_warning_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckWarningId') is not None:
            self.check_warning_id = m.get('CheckWarningId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeCheckWarningDetailResponseBody(TeaModel):
    def __init__(
        self,
        advice: str = None,
        check_id: int = None,
        description: str = None,
        item: str = None,
        level: str = None,
        prompt: str = None,
        request_id: str = None,
        type: str = None,
    ):
        # Queries the details about a specified check item.
        self.advice = advice
        self.check_id = check_id
        self.description = description
        self.item = item
        self.level = level
        self.prompt = prompt
        self.request_id = request_id
        # DescribeCheckWarningDetail
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.description is not None:
            result['Description'] = self.description
        if self.item is not None:
            result['Item'] = self.item
        if self.level is not None:
            result['Level'] = self.level
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCheckWarningDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckWarningDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningMachinesRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        lang: str = None,
        risk_id: int = None,
        status: int = None,
    ):
        # The ID of the check item.
        # 
        # > You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of check items.
        self.check_id = check_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the baseline.
        # 
        # > You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of baselines.
        self.risk_id = risk_id
        # Specifies whether the check item passed the baseline check. Valid values:
        # *   **1**: no
        # *   **3**: yes
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCheckWarningMachinesResponseBodyMachines(TeaModel):
    def __init__(
        self,
        bind: bool = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        region_id: str = None,
        uuid: str = None,
    ):
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind
        # The ID of the server.
        self.instance_id = instance_id
        # The name of the server.
        self.instance_name = instance_name
        # The public IP address of the server.
        self.internet_ip = internet_ip
        # The private IP address of the server.
        self.intranet_ip = intranet_ip
        # The ID of the region in which the server resides.
        self.region_id = region_id
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningMachinesResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        machines: List[DescribeCheckWarningMachinesResponseBodyMachines] = None,
        request_id: str = None,
    ):
        # The number of the servers on which the same risk item is detected.
        self.count = count
        # An array consisting of the servers on which the same risk item is detected.
        self.machines = machines
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.machines:
            for k in self.machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Machines'] = []
        if self.machines is not None:
            for k in self.machines:
                result['Machines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.machines = []
        if m.get('Machines') is not None:
            for k in m.get('Machines'):
                temp_model = DescribeCheckWarningMachinesResponseBodyMachines()
                self.machines.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCheckWarningMachinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckWarningMachinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: int = None,
        group_id: int = None,
        lang: str = None,
        page_size: int = None,
        risk_name: str = None,
        risk_status: int = None,
        source_ip: str = None,
        status: str = None,
        strategy_id: int = None,
        target_type: str = None,
        type_name: str = None,
        uuids: str = None,
    ):
        # The value of the container field.
        self.cluster_id = cluster_id
        # The level-1 type of check items.
        # 
        # >  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the level-1 types of check items.
        self.container_field_name = container_field_name
        # The ID of the baseline check policy.
        self.container_field_value = container_field_value
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.current_page = current_page
        self.group_id = group_id
        # The statistics of check items.
        self.lang = lang
        # The UUID of the asset.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets.
        self.page_size = page_size
        # The level-2 type of the risk item.
        self.risk_name = risk_name
        # The type of the query condition. Valid values:
        # 
        # *   **uuid**: the ID of an asset
        self.risk_status = risk_status
        # The source IP address of the request.
        self.source_ip = source_ip
        # The number of high-risk items.
        self.status = status
        # The number of assets on which risk items are detected.
        self.strategy_id = strategy_id
        # The number of check items.
        self.target_type = target_type
        # The page number of the current page.
        self.type_name = type_name
        # The name of the container field. Valid values:
        # 
        # *   **clusterId**: the ID of the cluster
        # *   **image**: the name of the image
        # *   **imageId**: the ID of the image
        # *   **namespace**: the namespace
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeCheckWarningSummaryResponseBodyWarningSummarys(TeaModel):
    def __init__(
        self,
        check_count: int = None,
        check_exploit: bool = None,
        container_risk: bool = None,
        database_risk: bool = None,
        high_warning_count: int = None,
        last_found_time: str = None,
        level: str = None,
        low_warning_count: int = None,
        medium_warning_count: int = None,
        risk_id: int = None,
        risk_name: str = None,
        sub_type_alias: str = None,
        type_alias: str = None,
        warning_machine_count: int = None,
    ):
        # The statistics of check items.
        self.check_count = check_count
        self.check_exploit = check_exploit
        self.container_risk = container_risk
        self.database_risk = database_risk
        self.high_warning_count = high_warning_count
        # The number of low-risk items.
        self.last_found_time = last_found_time
        self.level = level
        # The number of entries to return on each page.
        self.low_warning_count = low_warning_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.medium_warning_count = medium_warning_count
        # The number of check items returned on the current page.
        self.risk_id = risk_id
        self.risk_name = risk_name
        # Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
        self.sub_type_alias = sub_type_alias
        self.type_alias = type_alias
        # DescribeCheckWarningSummary
        self.warning_machine_count = warning_machine_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_count is not None:
            result['CheckCount'] = self.check_count
        if self.check_exploit is not None:
            result['CheckExploit'] = self.check_exploit
        if self.container_risk is not None:
            result['ContainerRisk'] = self.container_risk
        if self.database_risk is not None:
            result['DatabaseRisk'] = self.database_risk
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.last_found_time is not None:
            result['LastFoundTime'] = self.last_found_time
        if self.level is not None:
            result['Level'] = self.level
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        if self.warning_machine_count is not None:
            result['WarningMachineCount'] = self.warning_machine_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckCount') is not None:
            self.check_count = m.get('CheckCount')
        if m.get('CheckExploit') is not None:
            self.check_exploit = m.get('CheckExploit')
        if m.get('ContainerRisk') is not None:
            self.container_risk = m.get('ContainerRisk')
        if m.get('DatabaseRisk') is not None:
            self.database_risk = m.get('DatabaseRisk')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LastFoundTime') is not None:
            self.last_found_time = m.get('LastFoundTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        if m.get('WarningMachineCount') is not None:
            self.warning_machine_count = m.get('WarningMachineCount')
        return self


class DescribeCheckWarningSummaryResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        warning_summarys: List[DescribeCheckWarningSummaryResponseBodyWarningSummarys] = None,
    ):
        # The level-1 type of the check item. Examples: database, system, weak password, and middleware.
        self.count = count
        # Indicates whether the risk item can be exploited. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.current_page = current_page
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~182997~~) operation to query the IDs of container clusters.
        self.page_size = page_size
        # The number of entries to return on each page.
        self.request_id = request_id
        # The ID of the risk item.
        self.total_count = total_count
        # The number of medium-risk items.
        self.warning_summarys = warning_summarys

    def validate(self):
        if self.warning_summarys:
            for k in self.warning_summarys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WarningSummarys'] = []
        if self.warning_summarys is not None:
            for k in self.warning_summarys:
                result['WarningSummarys'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.warning_summarys = []
        if m.get('WarningSummarys') is not None:
            for k in m.get('WarningSummarys'):
                temp_model = DescribeCheckWarningSummaryResponseBodyWarningSummarys()
                self.warning_summarys.append(temp_model.from_map(k))
        return self


class DescribeCheckWarningSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckWarningSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningsRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        check_type: str = None,
        container_name: str = None,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        risk_id: int = None,
        risk_status: int = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        # The ID of the check item.
        self.check_id = check_id
        # The type of the check item. Valid values:
        # 
        # *   **hc.check.type.identity_auth**: identity authentication
        # *   **hc.check.type.access_control**: access control
        # *   **hc.check.type.network_service**: network and service
        # *   **hc.check.type.service_conf**: service configuration
        # *   **hc.check.type.file_rights**: file permission
        # *   **hc.check.type.security_audit**: security audit
        # *   **hc.check.type.attack_defense**: intrusion prevention
        # *   **hc.check.type.others**: others
        self.check_type = check_type
        # The name of container.
        self.container_name = container_name
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # The ID of the baseline risk item.
        # 
        # > To query specified baseline risk items and the check items of a specified server, you must provide the IDs of the baseline risk items. You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs.
        self.risk_id = risk_id
        # The status of the check item. Valid values:
        # 
        # *   **1**: failed
        # *   **2**: verifying
        # *   **3**: passed
        # *   **5**: expired
        # *   **6**: ignored
        self.risk_status = risk_status
        # The source IP address of the request.
        self.source_ip = source_ip
        # The UUID of the server on which the baseline check is performed.
        # 
        # > To query specified risk items and the check items of a specified server, you must provide the ID of the server on which the baseline check is performed. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the IDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningsResponseBodyCheckWarnings(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        check_warning_id: int = None,
        exec_error_message: str = None,
        fix_status: int = None,
        item: str = None,
        level: str = None,
        reason: str = None,
        status: int = None,
        type: str = None,
        uuid: str = None,
    ):
        # The ID of the check item.
        self.check_id = check_id
        # The ID of the alert that is triggered by the check item.
        self.check_warning_id = check_warning_id
        # The error message in check result.
        self.exec_error_message = exec_error_message
        # The fixing status of the check item. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.fix_status = fix_status
        # The name of the check item.
        self.item = item
        # The risk level of the risk item. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.level = level
        # The description of the check item.
        self.reason = reason
        # The status of the check item. Valid values:
        # 
        # *   **1**: failed
        # *   **2**: verifying
        # *   **3**: passed
        # *   **5**: expired
        # *   **6**: ignored
        self.status = status
        # The type of the check item.
        self.type = type
        # The UUID of the server on which the baseline check is performed.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_warning_id is not None:
            result['CheckWarningId'] = self.check_warning_id
        if self.exec_error_message is not None:
            result['ExecErrorMessage'] = self.exec_error_message
        if self.fix_status is not None:
            result['FixStatus'] = self.fix_status
        if self.item is not None:
            result['Item'] = self.item
        if self.level is not None:
            result['Level'] = self.level
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckWarningId') is not None:
            self.check_warning_id = m.get('CheckWarningId')
        if m.get('ExecErrorMessage') is not None:
            self.exec_error_message = m.get('ExecErrorMessage')
        if m.get('FixStatus') is not None:
            self.fix_status = m.get('FixStatus')
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningsResponseBody(TeaModel):
    def __init__(
        self,
        check_warnings: List[DescribeCheckWarningsResponseBodyCheckWarnings] = None,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # An array that consists of the details about the check item.
        self.check_warnings = check_warnings
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.check_warnings:
            for k in self.check_warnings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckWarnings'] = []
        if self.check_warnings is not None:
            for k in self.check_warnings:
                result['CheckWarnings'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_warnings = []
        if m.get('CheckWarnings') is not None:
            for k in m.get('CheckWarnings'):
                temp_model = DescribeCheckWarningsResponseBodyCheckWarnings()
                self.check_warnings.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCheckWarningsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCheckWarningsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClientConfSetupRequest(TeaModel):
    def __init__(
        self,
        strategy_tag: str = None,
        strategy_tag_value: str = None,
    ):
        # The tag that is added to the server.
        self.strategy_tag = strategy_tag
        # The value of the tag. Valid values:
        # 
        # *   major
        # *   advanced
        # *   basic
        self.strategy_tag_value = strategy_tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class DescribeClientConfSetupResponseBodyClientConf(TeaModel):
    def __init__(
        self,
        config: str = None,
        strategy_tag: str = None,
        strategy_tag_value: str = None,
    ):
        # The configurations of the usage for the Security Center agent.
        self.config = config
        # The tag that is added to the configuration.
        self.strategy_tag = strategy_tag
        # The value of the tag. Valid values:
        # 
        # *   major
        # *   advanced
        # *   basic
        self.strategy_tag_value = strategy_tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class DescribeClientConfSetupResponseBody(TeaModel):
    def __init__(
        self,
        client_conf: DescribeClientConfSetupResponseBodyClientConf = None,
        request_id: str = None,
    ):
        # The configurations of the Security Center agent.
        self.client_conf = client_conf
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.client_conf:
            self.client_conf.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_conf is not None:
            result['ClientConf'] = self.client_conf.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientConf') is not None:
            temp_model = DescribeClientConfSetupResponseBodyClientConf()
            self.client_conf = temp_model.from_map(m['ClientConf'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClientConfSetupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClientConfSetupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClientConfSetupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClientConfStrategyRequest(TeaModel):
    def __init__(
        self,
        tag: str = None,
        tag_value: str = None,
    ):
        # The tag that is added to the server.
        self.tag = tag
        # The value of the tag. Valid values:
        # 
        # *   major
        # *   advanced
        # *   basic
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeClientConfStrategyResponseBodyTargetList(TeaModel):
    def __init__(
        self,
        uuid: str = None,
    ):
        # The UUID of the Security Center agent.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeClientConfStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        target_list: List[DescribeClientConfStrategyResponseBodyTargetList] = None,
        total_count: int = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array that consists of the configurations.
        self.target_list = target_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeClientConfStrategyResponseBodyTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeClientConfStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClientConfStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClientConfStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudCenterInstancesRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        current_page: int = None,
        importance: int = None,
        lang: str = None,
        logical_exp: str = None,
        machine_types: str = None,
        no_group_trace: bool = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The search conditions that are used to filter assets. The value of this parameter is in the JSON format and is case-sensitive.
        # 
        # > A search condition can be an instance ID, instance name, VPC ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The importance level of the asset. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.importance = importance
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The logical operator that you want to use to evaluate multiple search conditions. Default value: **OR**. Valid values:
        # 
        # *   **OR**: The search conditions are evaluated by using a logical **OR**.
        # *   **AND**: The search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp
        # The type of the assets that you want to query. Valid values:
        # 
        # *   **ecs**: servers
        # *   **cloud_product**: Alibaba Cloud services
        self.machine_types = machine_types
        # Specifies whether to internationalize the name of the **default** group. Default value: **false**. Valid values:
        # 
        # *   **true**: The system returns the Chinese name of the default group for the **GroupTrace** response parameter.********\
        # *   **false**: The system returns default for the **GroupTrace** response parameter.
        self.no_group_trace = no_group_trace
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # The ID of the region in which the asset resides.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.no_group_trace is not None:
            result['NoGroupTrace'] = self.no_group_trace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('NoGroupTrace') is not None:
            self.no_group_trace = m.get('NoGroupTrace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCloudCenterInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        alarm_status: str = None,
        asset_type: str = None,
        auth_modify_time: int = None,
        auth_version: int = None,
        auth_version_name: str = None,
        bind: bool = None,
        client_status: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cores: int = None,
        cpu_info: str = None,
        created_time: int = None,
        exposed_status: int = None,
        flag: int = None,
        group_id: int = None,
        group_trace: str = None,
        hc_status: str = None,
        health_check_count: int = None,
        importance: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        ip_list_string: str = None,
        kernel: str = None,
        last_login_timestamp: int = None,
        mac_list_string: str = None,
        mem: int = None,
        os: str = None,
        os_name: str = None,
        pod_count: int = None,
        region: str = None,
        region_id: str = None,
        region_name: str = None,
        risk_count: str = None,
        risk_status: str = None,
        safe_event_count: int = None,
        status: str = None,
        tag: str = None,
        tag_id: str = None,
        uuid: str = None,
        vendor: int = None,
        vendor_name: str = None,
        vpc_instance_id: str = None,
        vul_count: int = None,
        vul_status: str = None,
    ):
        # Indicates whether alerts are generated on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status
        # The type of the asset. Valid values:
        # 
        # *   **0**: an ECS instance
        # *   **1**: a Server Load Balancer (SLB) instance
        # *   **2**: a NAT gateway
        # *   **3**: an ApsaraDB RDS instance
        # *   **4**: an ApsaraDB for MongoDB instance
        # *   **5**: an ApsaraDB for Redis instance
        # *   **6**: a container image
        # *   **7**: a container
        self.asset_type = asset_type
        # The timestamp when Security Center is authorized to scan the asset. Unit: milliseconds.
        self.auth_modify_time = auth_modify_time
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        self.auth_version = auth_version
        # The name of the Security Center edition that is authorized to scan the asset. Valid values:
        # 
        # *   Basic edition
        # *   Anti-virus edition
        # *   Advanced edition
        # *   Enterprise edition
        # *   Ultimate edition
        # *   Value-added Plan edition
        self.auth_version_name = auth_version_name
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind
        # The status of the Security Center agent installed on the asset. Valid values:
        # 
        # *   **online**: The Security Center agent is **enabled**.
        # *   **offline**: The Security Center agent is **disabled**.
        # *   **pause**: The Security Center agent is **suspended**.
        self.client_status = client_status
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The number of the CPU cores for the asset.
        self.cores = cores
        # The CPU information about the asset.
        self.cpu_info = cpu_info
        # The timestamp when the cluster was created. Unit: milliseconds.
        self.created_time = created_time
        # Indicates whether the asset is exposed. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.exposed_status = exposed_status
        # Indicates whether the asset is an Alibaba Cloud asset. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.flag = flag
        # The ID of the asset group to which the asset belongs.
        self.group_id = group_id
        # The name of the group to which the asset belongs.
        self.group_trace = group_trace
        # Indicates whether baseline risk items are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.hc_status = hc_status
        # The number of baseline risks that are detected on the asset.
        self.health_check_count = health_check_count
        # The importance level of the asset. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.importance = importance
        # The ID of the asset.
        self.instance_id = instance_id
        # The name of the asset.
        self.instance_name = instance_name
        # The public IP address of the asset.
        self.internet_ip = internet_ip
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip
        # The public IP address of the asset.
        self.ip = ip
        # The IP addresses of the system.
        self.ip_list_string = ip_list_string
        # The version of the kernel.
        self.kernel = kernel
        # The timestamp when the Security Center agent was last online. Unit: milliseconds.
        self.last_login_timestamp = last_login_timestamp
        # The MAC address of the system.
        self.mac_list_string = mac_list_string
        # The memory size. Unit: MB.
        self.mem = mem
        # The operating system of the asset.
        self.os = os
        # The version of the operating system that the asset runs.
        self.os_name = os_name
        # The number of pods.
        self.pod_count = pod_count
        # The region ID of the asset.
        self.region = region
        # The ID of the region in which the asset resides.
        self.region_id = region_id
        # The name of the region in which the asset resides.
        self.region_name = region_name
        # The statistics about baseline risks that are detected on the asset. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **account**: the number of accounts that are used to log on from unapproved logon locations and whose passwords are cracked
        # *   **appNum**: the number of scanners
        # *   **asapVulCount**: the total number of high-risk vulnerabilities
        # *   **baselineHigh**: the number of high-risk baseline risks
        # *   **baselineLow**: the number of low-risk baseline risks
        # *   **baselineMedium**: the number of medium-risk baseline risks
        # *   **baselineNum**: the total number of baseline risks
        # *   **cmsNum**: the number of Web-CMS vulnerabilities
        # *   **containerAsap**: the number of high-risk vulnerabilities that are detected on containers
        # *   **containerLater**: the number of medium-risk vulnerabilities that are detected on containers
        # *   **containerNntf**: the number of low-risk vulnerabilities that are detected on containers
        # *   **containerRemind**: the number of alerts whose Emergency level is Reminder on containers
        # *   **containerSerious**: the number of alerts whose Emergency level is Urgent on containers
        # *   **containerSuspicious**: the number of alerts whose Emergency level is Suspicious on containers
        # *   **cveNum**: the number of Linux software vulnerabilities
        # *   **emgNum**: the number of urgent vulnerabilities
        # *   **health**: the number of baseline risks that are unhandled
        # *   **imageBaselineHigh**: the number of high-risk baseline risks that are detected on images
        # *   **imageBaselineLow**: the number of low-risk baseline risks that are detected on images
        # *   **imageBaselineMedium**: the number of medium-risk baseline risks that are detected on images
        # *   **imageBaselineNum**: the total number of baseline risks that are detected on images
        # *   **imageMaliciousFileRemind**: the number of malicious files that are detected on images and have the Emergency level of Reminder
        # *   **imageMaliciousFileSerious**: the number of malicious files that are detected on images and have the Emergency level of Urgent
        # *   **imageMaliciousFileSuspicious**: the number of malicious files that are detected on images and have the Emergency level of Suspicious
        # *   **imageVulAsap**: the number of high-risk vulnerabilities that are detected on images
        # *   **imageVulLater**: the number of medium-risk vulnerabilities that are detected on an image
        # *   **imageVulNntf**: the number of low-risk vulnerabilities that are detected on an image
        # *   **laterVulCount**: the number of medium-risk vulnerabilities
        # *   **newSuspicious**: the number of alerts
        # *   **nntfVulCount**: the number of low-risk vulnerabilities
        # *   **remindNum**: the number of alerts whose Emergency level is Reminder
        # *   **scaNum**: the number of vulnerabilities that are detected based on software component analysis
        # *   **seriousNum**: the number of alerts whose Emergency level is Urgent
        # *   **suspNum**: the number of alerts whose Emergency level is Suspicious
        # *   **suspicious**: the total number of alerts
        # *   **sysNum**: the number of Windows system vulnerabilities
        # *   **trojan**: the number of trojans
        # *   **uuid**: the UUID of the asset
        # *   **vul**: the number of vulnerabilities
        # *   **weakPWNum**: the number of weak passwords
        self.risk_count = risk_count
        # Indicates whether risks are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.risk_status = risk_status
        # The number of alerts that are generated on the asset.
        self.safe_event_count = safe_event_count
        # The status of the asset. Valid values:
        # 
        # *   **Running**: running
        # *   **notRunning**: stopped
        self.status = status
        # The name of the asset tag.
        self.tag = tag
        # The ID of the asset tag.
        self.tag_id = tag_id
        # The UUID of the asset.
        self.uuid = uuid
        # The category of the service provider (SP) for the asset. Valid values:
        # 
        # *   **0**: The asset is provided by Alibaba Cloud.
        # *   **1**: The asset is not provided by Alibaba Cloud.
        # *   **2**: The asset resides in a data center.
        # *   **3**, **4**, **5**, and **7**: other cloud asset.
        # *   **8**: a light-weight asset.
        self.vendor = vendor
        # The name of the SP for the asset.
        # 
        # Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        # *   **OUT**: a third-party service provider
        # *   **IDC**: a data center
        # *   **TENCENT**: Tencent Cloud
        # *   **HUAWEICLOUD**: HUAWEI CLOUD
        # *   **Microsoft**: Microsoft Azure
        # *   **AWS**: Amazon Web Services (AWS)
        # *   **TRIPARTITE**: a lightweight server
        self.vendor_name = vendor_name
        # The ID of the VPC to which the asset belongs.
        self.vpc_instance_id = vpc_instance_id
        # The number of vulnerabilities that are detected on the asset.
        self.vul_count = vul_count
        # Indicates whether vulnerabilities are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.auth_modify_time is not None:
            result['AuthModifyTime'] = self.auth_modify_time
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.auth_version_name is not None:
            result['AuthVersionName'] = self.auth_version_name
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.cpu_info is not None:
            result['CpuInfo'] = self.cpu_info
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.exposed_status is not None:
            result['ExposedStatus'] = self.exposed_status
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_trace is not None:
            result['GroupTrace'] = self.group_trace
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.health_check_count is not None:
            result['HealthCheckCount'] = self.health_check_count
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_list_string is not None:
            result['IpListString'] = self.ip_list_string
        if self.kernel is not None:
            result['Kernel'] = self.kernel
        if self.last_login_timestamp is not None:
            result['LastLoginTimestamp'] = self.last_login_timestamp
        if self.mac_list_string is not None:
            result['MacListString'] = self.mac_list_string
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.os is not None:
            result['Os'] = self.os
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.pod_count is not None:
            result['PodCount'] = self.pod_count
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.safe_event_count is not None:
            result['SafeEventCount'] = self.safe_event_count
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AuthModifyTime') is not None:
            self.auth_modify_time = m.get('AuthModifyTime')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('AuthVersionName') is not None:
            self.auth_version_name = m.get('AuthVersionName')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('CpuInfo') is not None:
            self.cpu_info = m.get('CpuInfo')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('ExposedStatus') is not None:
            self.exposed_status = m.get('ExposedStatus')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupTrace') is not None:
            self.group_trace = m.get('GroupTrace')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('HealthCheckCount') is not None:
            self.health_check_count = m.get('HealthCheckCount')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpListString') is not None:
            self.ip_list_string = m.get('IpListString')
        if m.get('Kernel') is not None:
            self.kernel = m.get('Kernel')
        if m.get('LastLoginTimestamp') is not None:
            self.last_login_timestamp = m.get('LastLoginTimestamp')
        if m.get('MacListString') is not None:
            self.mac_list_string = m.get('MacListString')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('PodCount') is not None:
            self.pod_count = m.get('PodCount')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SafeEventCount') is not None:
            self.safe_event_count = m.get('SafeEventCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeCloudCenterInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCloudCenterInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instances: List[DescribeCloudCenterInstancesResponseBodyInstances] = None,
        page_info: DescribeCloudCenterInstancesResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # An array that consists of the details about the assets.
        self.instances = instances
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeCloudCenterInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeCloudCenterInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCloudCenterInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudCenterInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudCenterInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudProductFieldStatisticsResponseBodyGroupedFields(TeaModel):
    def __init__(
        self,
        category_count: str = None,
        instance_count: int = None,
        risk_instance_count: int = None,
    ):
        self.category_count = category_count
        self.instance_count = instance_count
        self.risk_instance_count = risk_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_count is not None:
            result['CategoryCount'] = self.category_count
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryCount') is not None:
            self.category_count = m.get('CategoryCount')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        return self


class DescribeCloudProductFieldStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        grouped_fields: DescribeCloudProductFieldStatisticsResponseBodyGroupedFields = None,
        request_id: str = None,
    ):
        self.grouped_fields = grouped_fields
        self.request_id = request_id

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = DescribeCloudProductFieldStatisticsResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudProductFieldStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudProductFieldStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudProductFieldStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterBasicInfoRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        target_type: str = None,
        type: str = None,
    ):
        self.cluster_id = cluster_id
        self.target_type = target_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterBasicInfoResponseBodyClusterInfo(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        create_time: int = None,
        current_version: str = None,
        instance_count: int = None,
        region_id: str = None,
        state: str = None,
        target_result: bool = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.cluster_type = cluster_type
        self.create_time = create_time
        self.current_version = current_version
        self.instance_count = instance_count
        self.region_id = region_id
        self.state = state
        self.target_result = target_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state is not None:
            result['State'] = self.state
        if self.target_result is not None:
            result['TargetResult'] = self.target_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TargetResult') is not None:
            self.target_result = m.get('TargetResult')
        return self


class DescribeClusterBasicInfoResponseBody(TeaModel):
    def __init__(
        self,
        cluster_info: DescribeClusterBasicInfoResponseBodyClusterInfo = None,
        request_id: str = None,
    ):
        self.cluster_info = cluster_info
        self.request_id = request_id

    def validate(self):
        if self.cluster_info:
            self.cluster_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_info is not None:
            result['ClusterInfo'] = self.cluster_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterInfo') is not None:
            temp_model = DescribeClusterBasicInfoResponseBodyClusterInfo()
            self.cluster_info = temp_model.from_map(m['ClusterInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterBasicInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterBasicInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterBasicInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterInfoListRequest(TeaModel):
    def __init__(
        self,
        target: str = None,
        target_type: str = None,
        type: str = None,
    ):
        self.target = target
        self.target_type = target_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterInfoListResponseBodyClusterList(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        region_id: str = None,
        state: str = None,
        target_result: bool = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.cluster_type = cluster_type
        self.region_id = region_id
        self.state = state
        self.target_result = target_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state is not None:
            result['State'] = self.state
        if self.target_result is not None:
            result['TargetResult'] = self.target_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TargetResult') is not None:
            self.target_result = m.get('TargetResult')
        return self


class DescribeClusterInfoListResponseBody(TeaModel):
    def __init__(
        self,
        cluster_list: List[DescribeClusterInfoListResponseBodyClusterList] = None,
        request_id: str = None,
    ):
        self.cluster_list = cluster_list
        self.request_id = request_id

    def validate(self):
        if self.cluster_list:
            for k in self.cluster_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterList'] = []
        if self.cluster_list is not None:
            for k in self.cluster_list:
                result['ClusterList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster_list = []
        if m.get('ClusterList') is not None:
            for k in m.get('ClusterList'):
                temp_model = DescribeClusterInfoListResponseBodyClusterList()
                self.cluster_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterInfoListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterInfoListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterInfoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterNetworkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        # The end timestamp of the query. Unit: milliseconds.
        # 
        # > The days between the start timestamp and the end timestamp cannot exceed **seven** days.
        self.end_time = end_time
        # The start timestamp of the query. Unit: milliseconds.
        # 
        # > The days between the start timestamp and the end timestamp cannot exceed **seven** days.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeClusterNetworkResponseBodyClusterNetworkEdge(TeaModel):
    def __init__(
        self,
        dst_node_id: str = None,
        dst_node_type: str = None,
        id: str = None,
        port: str = None,
        src_node_id: str = None,
        src_node_type: str = None,
    ):
        # The ID of the destination node.
        self.dst_node_id = dst_node_id
        # The type of the destination node. Valid values:
        # 
        # *   **cluster**: a cluster
        self.dst_node_type = dst_node_type
        # The ID of the topology edge.
        self.id = id
        # The port number of the topology edge.
        self.port = port
        # The ID of the source node.
        self.src_node_id = src_node_id
        # The type of the source node. Valid values:
        # 
        # *   **cluster**: a cluster
        # *   **internet**: a network node in another cluster
        self.src_node_type = src_node_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_node_id is not None:
            result['DstNodeId'] = self.dst_node_id
        if self.dst_node_type is not None:
            result['DstNodeType'] = self.dst_node_type
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.src_node_id is not None:
            result['SrcNodeId'] = self.src_node_id
        if self.src_node_type is not None:
            result['SrcNodeType'] = self.src_node_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstNodeId') is not None:
            self.dst_node_id = m.get('DstNodeId')
        if m.get('DstNodeType') is not None:
            self.dst_node_type = m.get('DstNodeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SrcNodeId') is not None:
            self.src_node_id = m.get('SrcNodeId')
        if m.get('SrcNodeType') is not None:
            self.src_node_type = m.get('SrcNodeType')
        return self


class DescribeClusterNetworkResponseBodyClusterNetworkNode(TeaModel):
    def __init__(
        self,
        cnnf_switch: int = None,
        id: str = None,
        interception_type: int = None,
        name: str = None,
        net_topo_switch: str = None,
        risk_level: str = None,
        type: str = None,
    ):
        # The micro-segmentation switch. Valid values:
        # 
        # *   **0**: The switch is turned off.
        # *   **1**: The switch is turned on.
        self.cnnf_switch = cnnf_switch
        # The ID of the node.
        self.id = id
        # The network type. Valid values:
        # 
        # *   **0**: classic network
        # *   **1**: virtual private cloud (VPC)
        self.interception_type = interception_type
        # The name of the node.
        self.name = name
        # The network topology switch. Valid values:
        # 
        # *   **ON**\
        # *   **OFF**\
        self.net_topo_switch = net_topo_switch
        # The risk level. Valid values:
        # 
        # *   **3**: high
        # *   **2**: medium
        # *   **1**: low
        # *   **0**: warning
        # *   **-1**: unknown
        self.risk_level = risk_level
        # The type of the node. Valid values:
        # 
        # *   **cluster**: a cluster
        # *   **internet**: a node in another cluster
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cnnf_switch is not None:
            result['CnnfSwitch'] = self.cnnf_switch
        if self.id is not None:
            result['Id'] = self.id
        if self.interception_type is not None:
            result['InterceptionType'] = self.interception_type
        if self.name is not None:
            result['Name'] = self.name
        if self.net_topo_switch is not None:
            result['NetTopoSwitch'] = self.net_topo_switch
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CnnfSwitch') is not None:
            self.cnnf_switch = m.get('CnnfSwitch')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterceptionType') is not None:
            self.interception_type = m.get('InterceptionType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetTopoSwitch') is not None:
            self.net_topo_switch = m.get('NetTopoSwitch')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterNetworkResponseBodyClusterNetwork(TeaModel):
    def __init__(
        self,
        edge: List[DescribeClusterNetworkResponseBodyClusterNetworkEdge] = None,
        node: List[DescribeClusterNetworkResponseBodyClusterNetworkNode] = None,
    ):
        # An array that consists of information about the topology edge.
        self.edge = edge
        # An array that consists of information about the node.
        self.node = node

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = DescribeClusterNetworkResponseBodyClusterNetworkEdge()
                self.edge.append(temp_model.from_map(k))
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = DescribeClusterNetworkResponseBodyClusterNetworkNode()
                self.node.append(temp_model.from_map(k))
        return self


class DescribeClusterNetworkResponseBody(TeaModel):
    def __init__(
        self,
        cluster_network: DescribeClusterNetworkResponseBodyClusterNetwork = None,
        request_id: str = None,
    ):
        # Information about the network topology edge in the cluster.
        self.cluster_network = cluster_network
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.cluster_network:
            self.cluster_network.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_network is not None:
            result['ClusterNetwork'] = self.cluster_network.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterNetwork') is not None:
            temp_model = DescribeClusterNetworkResponseBodyClusterNetwork()
            self.cluster_network = temp_model.from_map(m['ClusterNetwork'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterVulStatisticsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        types: str = None,
    ):
        self.cluster_id = cluster_id
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class DescribeClusterVulStatisticsResponseBodyVulStat(TeaModel):
    def __init__(
        self,
        asap_count: str = None,
        later_count: str = None,
        nntf_count: str = None,
    ):
        self.asap_count = asap_count
        self.later_count = later_count
        self.nntf_count = nntf_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        return self


class DescribeClusterVulStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vul_stat: DescribeClusterVulStatisticsResponseBodyVulStat = None,
    ):
        self.request_id = request_id
        self.vul_stat = vul_stat

    def validate(self):
        if self.vul_stat:
            self.vul_stat.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_stat is not None:
            result['VulStat'] = self.vul_stat.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulStat') is not None:
            temp_model = DescribeClusterVulStatisticsResponseBodyVulStat()
            self.vul_stat = temp_model.from_map(m['VulStat'])
        return self


class DescribeClusterVulStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterVulStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterVulStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonOverallConfigRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        type: str = None,
    ):
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigResponseBodyOverallConfig(TeaModel):
    def __init__(
        self,
        config: str = None,
        type: str = None,
    ):
        self.config = config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigResponseBody(TeaModel):
    def __init__(
        self,
        overall_config: DescribeCommonOverallConfigResponseBodyOverallConfig = None,
        request_id: str = None,
    ):
        self.overall_config = overall_config
        self.request_id = request_id

    def validate(self):
        if self.overall_config:
            self.overall_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverallConfig') is not None:
            temp_model = DescribeCommonOverallConfigResponseBodyOverallConfig()
            self.overall_config = temp_model.from_map(m['OverallConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCommonOverallConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCommonOverallConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonOverallConfigListRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        type_list: List[str] = None,
    ):
        self.source_ip = source_ip
        self.type_list = type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class DescribeCommonOverallConfigListResponseBodyOverallList(TeaModel):
    def __init__(
        self,
        config: str = None,
        total_count: int = None,
        type: str = None,
    ):
        self.config = config
        self.total_count = total_count
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigListResponseBody(TeaModel):
    def __init__(
        self,
        overall_list: List[DescribeCommonOverallConfigListResponseBodyOverallList] = None,
        request_id: str = None,
    ):
        self.overall_list = overall_list
        self.request_id = request_id

    def validate(self):
        if self.overall_list:
            for k in self.overall_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OverallList'] = []
        if self.overall_list is not None:
            for k in self.overall_list:
                result['OverallList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.overall_list = []
        if m.get('OverallList') is not None:
            for k in m.get('OverallList'):
                temp_model = DescribeCommonOverallConfigListResponseBodyOverallList()
                self.overall_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCommonOverallConfigListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCommonOverallConfigListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonOverallConfigListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonTargetConfigRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetConfigResponseBodyTargetList(TeaModel):
    def __init__(
        self,
        flag: str = None,
        target: str = None,
        target_type: str = None,
    ):
        self.flag = flag
        self.target = target
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeCommonTargetConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        target_list: List[DescribeCommonTargetConfigResponseBodyTargetList] = None,
    ):
        self.request_id = request_id
        self.target_list = target_list

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeCommonTargetConfigResponseBodyTargetList()
                self.target_list.append(temp_model.from_map(k))
        return self


class DescribeCommonTargetConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCommonTargetConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonTargetResultListRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        type: str = None,
    ):
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetResultListResponseBodyTargetConfig(TeaModel):
    def __init__(
        self,
        flag: str = None,
        target_default: str = None,
        target_list: List[str] = None,
        target_type: str = None,
        total_count: str = None,
        type: str = None,
    ):
        self.flag = flag
        self.target_default = target_default
        self.target_list = target_list
        self.target_type = target_type
        self.total_count = total_count
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target_default is not None:
            result['TargetDefault'] = self.target_default
        if self.target_list is not None:
            result['TargetList'] = self.target_list
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('TargetDefault') is not None:
            self.target_default = m.get('TargetDefault')
        if m.get('TargetList') is not None:
            self.target_list = m.get('TargetList')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetResultListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        target_config: DescribeCommonTargetResultListResponseBodyTargetConfig = None,
    ):
        self.request_id = request_id
        self.target_config = target_config

    def validate(self):
        if self.target_config:
            self.target_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.target_config is not None:
            result['TargetConfig'] = self.target_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TargetConfig') is not None:
            temp_model = DescribeCommonTargetResultListResponseBodyTargetConfig()
            self.target_config = temp_model.from_map(m['TargetConfig'])
        return self


class DescribeCommonTargetResultListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCommonTargetResultListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonTargetResultListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConcernNecessityRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeConcernNecessityResponseBody(TeaModel):
    def __init__(
        self,
        concern_necessity: List[str] = None,
        request_id: str = None,
    ):
        self.concern_necessity = concern_necessity
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.concern_necessity is not None:
            result['ConcernNecessity'] = self.concern_necessity
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConcernNecessity') is not None:
            self.concern_necessity = m.get('ConcernNecessity')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeConcernNecessityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeConcernNecessityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConcernNecessityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerCriteriaRequest(TeaModel):
    def __init__(
        self,
        group_field: str = None,
        value: str = None,
    ):
        self.group_field = group_field
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeContainerCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeContainerCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeContainerCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeContainerCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContainerCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerInstancesRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        current_page: int = None,
        logical_exp: str = None,
        page_size: int = None,
    ):
        # The search conditions that are used to filter containers. The value of this parameter is in the JSON format and is case-sensitive. The value contains the following fields:
        # 
        # *   **name**: the search condition.
        # 
        # *   **name**: the value of the search condition.
        # 
        # *   **logicalExp**: the logical relationship among multiple search conditions. Valid values:
        # 
        #     *   **OR**: Search conditions are evaluated by using a logical **OR**.
        #     *   **AND**: Search conditions are evaluated by using a logical **AND**.
        # 
        # > You can use search conditions such as the container ID, cluster ID, cluster name, cluster type, risk level, and region. You can call the [DescribeContainerCriteria](~~DescribeContainerCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The logical operator that you want to use to evaluate multiple search conditions. Valid values:
        # 
        # *   **OR**: Search conditions are evaluated by using a logical **OR**.
        # *   **AND**: Search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeContainerInstancesResponseBodyContainerInstanceList(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        alarm_status: str = None,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        create_timestamp: int = None,
        hc_count: int = None,
        hc_status: str = None,
        host_ip: str = None,
        image: str = None,
        image_digest: str = None,
        image_id: str = None,
        image_repo_name: str = None,
        image_repo_namespace: str = None,
        image_repo_tag: str = None,
        image_uuid: str = None,
        instance_id: str = None,
        namespace: str = None,
        node_info: str = None,
        node_name: str = None,
        pod: str = None,
        pod_ip: str = None,
        region_id: str = None,
        risk_count: str = None,
        risk_status: str = None,
        update_mark: str = None,
        vul_count: int = None,
        vul_status: str = None,
    ):
        # The number of alerts.
        self.alarm_count = alarm_count
        # Indicates whether alerts are generated for the container. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status
        # The name of the application.
        self.app_name = app_name
        # The ID of cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The ID of the container.
        self.container_id = container_id
        # The timestamp when the cluster was created. Unit: milliseconds.
        self.create_timestamp = create_timestamp
        # The number of baseline risks.
        self.hc_count = hc_count
        # Indicates whether baseline risks are detected. Valid values:
        # 
        # *   **NO**\
        # *   **YES**\
        self.hc_status = hc_status
        # The IP address of the server.
        self.host_ip = host_ip
        # The image of the container.
        self.image = image
        # The digest value of the image.
        self.image_digest = image_digest
        # The ID of the image.
        self.image_id = image_id
        # The name of the image repository.
        self.image_repo_name = image_repo_name
        # The namespace to which the image repository belongs.
        self.image_repo_namespace = image_repo_namespace
        # The tag that is added to the image.
        self.image_repo_tag = image_repo_tag
        # The UUID of the image.
        self.image_uuid = image_uuid
        # The instance ID of the asset.
        self.instance_id = instance_id
        # The namespace.
        self.namespace = namespace
        # The node information.
        self.node_info = node_info
        # The name of the node.
        self.node_name = node_name
        # The pod.
        self.pod = pod
        # The IP address of the pod.
        self.pod_ip = pod_ip
        # The region ID of the container.
        self.region_id = region_id
        # The number of risks.
        self.risk_count = risk_count
        # Indicates whether risks exist. Valid values:
        # 
        # *   **NO**\
        # *   **YES**\
        self.risk_status = risk_status
        # The update identifier of the container.
        self.update_mark = update_mark
        # The number of vulnerabilities that are detected in the container cluster.
        self.vul_count = vul_count
        # Indicates whether vulnerabilities are detected in the container. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_repo_name is not None:
            result['ImageRepoName'] = self.image_repo_name
        if self.image_repo_namespace is not None:
            result['ImageRepoNamespace'] = self.image_repo_namespace
        if self.image_repo_tag is not None:
            result['ImageRepoTag'] = self.image_repo_tag
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_info is not None:
            result['NodeInfo'] = self.node_info
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.update_mark is not None:
            result['UpdateMark'] = self.update_mark
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageRepoName') is not None:
            self.image_repo_name = m.get('ImageRepoName')
        if m.get('ImageRepoNamespace') is not None:
            self.image_repo_namespace = m.get('ImageRepoNamespace')
        if m.get('ImageRepoTag') is not None:
            self.image_repo_tag = m.get('ImageRepoTag')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeInfo') is not None:
            self.node_info = m.get('NodeInfo')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('UpdateMark') is not None:
            self.update_mark = m.get('UpdateMark')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeContainerInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeContainerInstancesResponseBody(TeaModel):
    def __init__(
        self,
        container_instance_list: List[DescribeContainerInstancesResponseBodyContainerInstanceList] = None,
        page_info: DescribeContainerInstancesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the information about containers.
        self.container_instance_list = container_instance_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.container_instance_list:
            for k in self.container_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContainerInstanceList'] = []
        if self.container_instance_list is not None:
            for k in self.container_instance_list:
                result['ContainerInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.container_instance_list = []
        if m.get('ContainerInstanceList') is not None:
            for k in m.get('ContainerInstanceList'):
                temp_model = DescribeContainerInstancesResponseBodyContainerInstanceList()
                self.container_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeContainerInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContainerInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerStatisticsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # DescribeContainerStatistics
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribeContainerStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        remind_alarm_count: int = None,
        serious_alarm_count: int = None,
        suspicious_alarm_count: int = None,
        total_alarm_count: int = None,
        total_node: int = None,
        has_risk_node: int = None,
    ):
        self.remind_alarm_count = remind_alarm_count
        self.serious_alarm_count = serious_alarm_count
        self.suspicious_alarm_count = suspicious_alarm_count
        self.total_alarm_count = total_alarm_count
        self.total_node = total_node
        self.has_risk_node = has_risk_node

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind_alarm_count is not None:
            result['RemindAlarmCount'] = self.remind_alarm_count
        if self.serious_alarm_count is not None:
            result['SeriousAlarmCount'] = self.serious_alarm_count
        if self.suspicious_alarm_count is not None:
            result['SuspiciousAlarmCount'] = self.suspicious_alarm_count
        if self.total_alarm_count is not None:
            result['TotalAlarmCount'] = self.total_alarm_count
        if self.total_node is not None:
            result['TotalNode'] = self.total_node
        if self.has_risk_node is not None:
            result['hasRiskNode'] = self.has_risk_node
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RemindAlarmCount') is not None:
            self.remind_alarm_count = m.get('RemindAlarmCount')
        if m.get('SeriousAlarmCount') is not None:
            self.serious_alarm_count = m.get('SeriousAlarmCount')
        if m.get('SuspiciousAlarmCount') is not None:
            self.suspicious_alarm_count = m.get('SuspiciousAlarmCount')
        if m.get('TotalAlarmCount') is not None:
            self.total_alarm_count = m.get('TotalAlarmCount')
        if m.get('TotalNode') is not None:
            self.total_node = m.get('TotalNode')
        if m.get('hasRiskNode') is not None:
            self.has_risk_node = m.get('hasRiskNode')
        return self


class DescribeContainerStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        data: DescribeContainerStatisticsResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeContainerStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContainerStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerTagsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        current_page: int = None,
        field_name: str = None,
        field_value: str = None,
        namespace: str = None,
        page_size: int = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.current_page = current_page
        self.field_name = field_name
        self.field_value = field_value
        self.namespace = namespace
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeContainerTagsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        tag_values: List[str] = None,
    ):
        self.request_id = request_id
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tag_values is not None:
            result['TagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TagValues') is not None:
            self.tag_values = m.get('TagValues')
        return self


class DescribeContainerTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContainerTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCountNotScannedImageResponseBody(TeaModel):
    def __init__(
        self,
        not_scanned_cnt: int = None,
        request_id: str = None,
    ):
        self.not_scanned_cnt = not_scanned_cnt
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.not_scanned_cnt is not None:
            result['NotScannedCnt'] = self.not_scanned_cnt
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotScannedCnt') is not None:
            self.not_scanned_cnt = m.get('NotScannedCnt')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCountNotScannedImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCountNotScannedImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCountNotScannedImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCountScannedImageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scanned_count: int = None,
    ):
        self.request_id = request_id
        self.scanned_count = scanned_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scanned_count is not None:
            result['ScannedCount'] = self.scanned_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScannedCount') is not None:
            self.scanned_count = m.get('ScannedCount')
        return self


class DescribeCountScannedImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCountScannedImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCountScannedImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCriteriaRequest(TeaModel):
    def __init__(
        self,
        machine_types: str = None,
        support_auto_tag: bool = None,
        value: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.machine_types = machine_types
        # Queries the filter conditions that are used to search for assets in fuzzy match mode.
        self.support_auto_tag = support_auto_tag
        # The attribute values of the assets that match the keyword.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.support_auto_tag is not None:
            result['SupportAutoTag'] = self.support_auto_tag
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('SupportAutoTag') is not None:
            self.support_auto_tag = m.get('SupportAutoTag')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        multi_values: str = None,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.multi_values = multi_values
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.multi_values is not None:
            result['MultiValues'] = self.multi_values
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MultiValues') is not None:
            self.multi_values = m.get('MultiValues')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        # DescribeCriteria
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomBlockRecordsRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        current_page: int = None,
        page_size: int = None,
        resource_owner_id: int = None,
        status: int = None,
    ):
        # The IP address that you want to block by using the defense rule.
        self.block_ip = block_ip
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        # The status of the defense rule. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: enabled
        # *   **2**: failed
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCustomBlockRecordsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCustomBlockRecordsResponseBodyRecordListTargetList(TeaModel):
    def __init__(
        self,
        target: str = None,
        target_type: str = None,
    ):
        # The ID of the server.
        self.target = target
        # The type of the query condition. Valid values:
        # 
        # *   **uuid**: the ID of an asset
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeCustomBlockRecordsResponseBodyRecordList(TeaModel):
    def __init__(
        self,
        block_expire_date: int = None,
        block_ip: str = None,
        bound: str = None,
        enable_count: int = None,
        id: int = None,
        server_count: int = None,
        source: str = None,
        status: int = None,
        target_list: List[DescribeCustomBlockRecordsResponseBodyRecordListTargetList] = None,
    ):
        # The timestamp when the defense rule expires.
        self.block_expire_date = block_expire_date
        # The blocked IP address.
        self.block_ip = block_ip
        # The direction of the traffic that is sent by the blocked IP address. Valid values:
        # 
        # *   **in**: inbound
        # *   **out**: outbound
        self.bound = bound
        # The number of servers to which the defense rule is applied.
        self.enable_count = enable_count
        # The ID of the defense rule.
        self.id = id
        # The total number of servers on which the IP address is blocked.
        self.server_count = server_count
        # The source of the defense rule. Valid values:
        self.source = source
        # The status of the defense rule. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: enabled
        # *   **2**: failed
        self.status = status
        # An array consisting of the servers to which the defense rule is applied.
        self.target_list = target_list

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_expire_date is not None:
            result['BlockExpireDate'] = self.block_expire_date
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.enable_count is not None:
            result['EnableCount'] = self.enable_count
        if self.id is not None:
            result['Id'] = self.id
        if self.server_count is not None:
            result['ServerCount'] = self.server_count
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockExpireDate') is not None:
            self.block_expire_date = m.get('BlockExpireDate')
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('EnableCount') is not None:
            self.enable_count = m.get('EnableCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ServerCount') is not None:
            self.server_count = m.get('ServerCount')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeCustomBlockRecordsResponseBodyRecordListTargetList()
                self.target_list.append(temp_model.from_map(k))
        return self


class DescribeCustomBlockRecordsResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeCustomBlockRecordsResponseBodyPageInfo = None,
        record_list: List[DescribeCustomBlockRecordsResponseBodyRecordList] = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # An array that consists of the defense rules.
        self.record_list = record_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.record_list:
            for k in self.record_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['RecordList'] = []
        if self.record_list is not None:
            for k in self.record_list:
                result['RecordList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeCustomBlockRecordsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.record_list = []
        if m.get('RecordList') is not None:
            for k in m.get('RecordList'):
                temp_model = DescribeCustomBlockRecordsResponseBodyRecordList()
                self.record_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCustomBlockRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustomBlockRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomBlockRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCycleTaskListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        task_name: str = None,
        task_type: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The number of entries to return on each page.
        self.page_size = page_size
        # The name of the task. Valid values:
        # 
        # *   **VIRUS\_VUL\_SCHEDULE_SCAN**: virus scan task
        # *   **IMAGE_SCAN**: image scan task
        # *   **EMG\_VUL\_SCHEDULE_SCAN**: urgent vulnerability scan task
        self.task_name = task_name
        # The type of the task. Valid values:
        # 
        # *   **VIRUS\_VUL\_SCHEDULE_SCAN**: virus scan task
        # *   **IMAGE_SCAN**: image scan task
        # *   **EMG\_VUL\_SCHEDULE_SCAN**: urgent vulnerability scan task
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeCycleTaskListResponseBodyCycleScheduleResponseList(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        enable: int = None,
        first_date_str: int = None,
        interval_period: int = None,
        last_task_id: str = None,
        next_start_time_str: int = None,
        param: str = None,
        period_unit: str = None,
        target_end_time: int = None,
        target_start_time: int = None,
        task_name: str = None,
        task_type: str = None,
    ):
        # The ID of the task configuration.
        self.config_id = config_id
        # Indicates whether the task is enabled. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.enable = enable
        # The first time when the task starts.
        self.first_date_str = first_date_str
        # The interval of the task.
        self.interval_period = interval_period
        # The ID of the task when the task last runs.
        self.last_task_id = last_task_id
        # The next time when the task starts. The value is a UNIX timestamp. Unit: milliseconds.
        self.next_start_time_str = next_start_time_str
        # The additional information.
        self.param = param
        # The unit of the scan interval. Valid values:
        # 
        # *   **day**: days
        # *   **hour**: hours
        self.period_unit = period_unit
        # The period of time before the task ends. Unit: hours.
        self.target_end_time = target_end_time
        # The period of time before the task starts for the next time. Unit: hours.
        self.target_start_time = target_start_time
        # The name of the task.
        self.task_name = task_name
        # The type of the task.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.last_task_id is not None:
            result['LastTaskId'] = self.last_task_id
        if self.next_start_time_str is not None:
            result['NextStartTimeStr'] = self.next_start_time_str
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('LastTaskId') is not None:
            self.last_task_id = m.get('LastTaskId')
        if m.get('NextStartTimeStr') is not None:
            self.next_start_time_str = m.get('NextStartTimeStr')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeCycleTaskListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCycleTaskListResponseBody(TeaModel):
    def __init__(
        self,
        cycle_schedule_response_list: List[DescribeCycleTaskListResponseBodyCycleScheduleResponseList] = None,
        page_info: DescribeCycleTaskListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of periodic scan tasks.
        self.cycle_schedule_response_list = cycle_schedule_response_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.cycle_schedule_response_list:
            for k in self.cycle_schedule_response_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleScheduleResponseList'] = []
        if self.cycle_schedule_response_list is not None:
            for k in self.cycle_schedule_response_list:
                result['CycleScheduleResponseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_schedule_response_list = []
        if m.get('CycleScheduleResponseList') is not None:
            for k in m.get('CycleScheduleResponseList'):
                temp_model = DescribeCycleTaskListResponseBodyCycleScheduleResponseList()
                self.cycle_schedule_response_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeCycleTaskListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCycleTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCycleTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCycleTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDingTalkRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        rule_action_name: str = None,
    ):
        # The UID of the user.
        self.current_page = current_page
        # The pagination information.
        self.page_size = page_size
        # The group IDs.
        self.rule_action_name = rule_action_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_action_name is not None:
            result['RuleActionName'] = self.rule_action_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleActionName') is not None:
            self.rule_action_name = m.get('RuleActionName')
        return self


class DescribeDingTalkResponseBodyActionList(TeaModel):
    def __init__(
        self,
        action_name: str = None,
        ali_uid: int = None,
        config_list: str = None,
        ding_talk_lang: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        group_id_list: str = None,
        id: int = None,
        interval_time: int = None,
        status: int = None,
        url: str = None,
    ):
        # DescribeDingTalk
        self.action_name = action_name
        self.ali_uid = ali_uid
        # The modification time.
        self.config_list = config_list
        self.ding_talk_lang = ding_talk_lang
        # Obtains DingTalk notifications.
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.group_id_list = group_id_list
        self.id = id
        self.interval_time = interval_time
        # The list of notification settings.
        self.status = status
        # ```
        # http(s)://[Endpoint]/?Action=DescribeDingTalk
        # &<>
        # ```
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_name is not None:
            result['ActionName'] = self.action_name
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.config_list is not None:
            result['ConfigList'] = self.config_list
        if self.ding_talk_lang is not None:
            result['DingTalkLang'] = self.ding_talk_lang
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_time is not None:
            result['IntervalTime'] = self.interval_time
        if self.status is not None:
            result['Status'] = self.status
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionName') is not None:
            self.action_name = m.get('ActionName')
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('ConfigList') is not None:
            self.config_list = m.get('ConfigList')
        if m.get('DingTalkLang') is not None:
            self.ding_talk_lang = m.get('DingTalkLang')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalTime') is not None:
            self.interval_time = m.get('IntervalTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeDingTalkResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The ID of the notification.
        self.current_page = current_page
        # The name of the notification.
        self.page_size = page_size
        # Alert notification
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDingTalkResponseBody(TeaModel):
    def __init__(
        self,
        action_list: List[DescribeDingTalkResponseBodyActionList] = None,
        page_info: DescribeDingTalkResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of details of notifications.
        self.action_list = action_list
        # The status of the notification. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.page_info = page_info
        # [{\"type\":\"vul\",\"configItemList\":[{\"key\":\"key\", \"valueList\":\"123\"}]}]
        self.request_id = request_id

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionList'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['ActionList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_list = []
        if m.get('ActionList') is not None:
            for k in m.get('ActionList'):
                temp_model = DescribeDingTalkResponseBodyActionList()
                self.action_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeDingTalkResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDingTalkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDingTalkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDingTalkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainCountRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
    ):
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        root_domains_count: int = None,
        sub_domains_count: int = None,
        total_domains_count: int = None,
    ):
        self.request_id = request_id
        self.root_domains_count = root_domains_count
        self.sub_domains_count = sub_domains_count
        self.total_domains_count = total_domains_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root_domains_count is not None:
            result['RootDomainsCount'] = self.root_domains_count
        if self.sub_domains_count is not None:
            result['SubDomainsCount'] = self.sub_domains_count
        if self.total_domains_count is not None:
            result['TotalDomainsCount'] = self.total_domains_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RootDomainsCount') is not None:
            self.root_domains_count = m.get('RootDomainsCount')
        if m.get('SubDomainsCount') is not None:
            self.sub_domains_count = m.get('SubDomainsCount')
        if m.get('TotalDomainsCount') is not None:
            self.total_domains_count = m.get('TotalDomainsCount')
        return self


class DescribeDomainCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainDetailRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        source_ip: str = None,
    ):
        # The domain name or the name of website that you want to query.
        # 
        # >  Fuzzy match is not supported. You must enter a complete domain name or a website.
        self.domain_name = domain_name
        # The type of the domain asset. Valid values:
        # 
        # *   **0**: an Elastic Compute Service (ECS) instance
        # *   **1**: a Server Load Balancer (SLB) instance
        # *   **2**: a Network Address Translation (NAT) gateway
        # *   **3**: an ApsaraDB RDS instance
        # *   **4**: an ApsaraDB for MongoDB instance
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainDetailResponseBodyDomainDetailItems(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        uuid: str = None,
    ):
        self.asset_type = asset_type
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeDomainDetailResponseBody(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        domain: str = None,
        domain_detail_items: List[DescribeDomainDetailResponseBodyDomainDetailItems] = None,
        request_id: str = None,
        root_domain: str = None,
        vul_count: int = None,
    ):
        # 1.2.XX.XX
        self.alarm_count = alarm_count
        # The total number of alerts in your website assets.
        self.domain = domain
        # DescribeDomainDetail
        self.domain_detail_items = domain_detail_items
        # The instance UUID of the domain asset.
        self.request_id = request_id
        # Queries the details of domain assets within your Alibaba Cloud account.
        self.root_domain = root_domain
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.vul_count = vul_count

    def validate(self):
        if self.domain_detail_items:
            for k in self.domain_detail_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.domain is not None:
            result['Domain'] = self.domain
        result['DomainDetailItems'] = []
        if self.domain_detail_items is not None:
            for k in self.domain_detail_items:
                result['DomainDetailItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root_domain is not None:
            result['RootDomain'] = self.root_domain
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        self.domain_detail_items = []
        if m.get('DomainDetailItems') is not None:
            for k in m.get('DomainDetailItems'):
                temp_model = DescribeDomainDetailResponseBodyDomainDetailItems()
                self.domain_detail_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RootDomain') is not None:
            self.root_domain = m.get('RootDomain')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        return self


class DescribeDomainDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        domain_type: str = None,
        fuzzy_domain: str = None,
        page_size: int = None,
        source_ip: str = None,
    ):
        # Queries the information about the domain assets within your Alibaba Cloud account.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **10**.
        self.domain_type = domain_type
        # The name of the domain or website.
        self.fuzzy_domain = fuzzy_domain
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.page_size = page_size
        # The number of entries to return on each page. Default value: **10**.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.fuzzy_domain is not None:
            result['FuzzyDomain'] = self.fuzzy_domain
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('FuzzyDomain') is not None:
            self.fuzzy_domain = m.get('FuzzyDomain')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainListResponseBodyDomainListResponseList(TeaModel):
    def __init__(
        self,
        domain: str = None,
        ip_list: str = None,
    ):
        self.domain = domain
        self.ip_list = ip_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_list is not None:
            result['IpList'] = self.ip_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpList') is not None:
            self.ip_list = m.get('IpList')
        return self


class DescribeDomainListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainListResponseBody(TeaModel):
    def __init__(
        self,
        domain_list_response_list: List[DescribeDomainListResponseBodyDomainListResponseList] = None,
        page_info: DescribeDomainListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.domain_list_response_list = domain_list_response_list
        self.page_info = page_info
        # DescribeDomainList
        self.request_id = request_id

    def validate(self):
        if self.domain_list_response_list:
            for k in self.domain_list_response_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainListResponseList'] = []
        if self.domain_list_response_list is not None:
            for k in self.domain_list_response_list:
                result['DomainListResponseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_list_response_list = []
        if m.get('DomainListResponseList') is not None:
            for k in m.get('DomainListResponseList'):
                temp_model = DescribeDomainListResponseBodyDomainListResponseList()
                self.domain_list_response_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeDomainListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDomainListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEmgUserAgreementResponseBody(TeaModel):
    def __init__(
        self,
        auth: bool = None,
        request_id: str = None,
    ):
        self.auth = auth
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth is not None:
            result['Auth'] = self.auth
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Auth') is not None:
            self.auth = m.get('Auth')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEmgUserAgreementResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEmgUserAgreementResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEmgUserAgreementResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEmgVulItemRequest(TeaModel):
    def __init__(
        self,
        check_type: int = None,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        risk_status: str = None,
        scan_type: str = None,
        vul_name: str = None,
    ):
        # The check method. Valid values:
        # 
        # *   **0**: proof of concept (POC) verification
        # *   **1**: version comparison
        self.check_type = check_type
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # Specifies whether the vulnerability poses risks.\
        # If you do not specify this parameter, all vulnerabilities are queried regardless of whether the vulnerabilities pose risks. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.risk_status = risk_status
        # The method that is used to detect the vulnerability.\
        # If you do not specify this parameter, all vulnerabilities are queried regardless of which method is used. Valid values:
        # 
        # *   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
        # *   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.
        self.scan_type = scan_type
        # The name of the urgent vulnerability.
        self.vul_name = vul_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.scan_type is not None:
            result['ScanType'] = self.scan_type
        if self.vul_name is not None:
            result['VulName'] = self.vul_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('ScanType') is not None:
            self.scan_type = m.get('ScanType')
        if m.get('VulName') is not None:
            self.vul_name = m.get('VulName')
        return self


class DescribeEmgVulItemResponseBodyGroupedVulItems(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        check_type: int = None,
        gmt_last_check: int = None,
        gmt_publish: int = None,
        name: str = None,
        pending_count: int = None,
        progress: int = None,
        status: int = None,
        type: str = None,
    ):
        # The name of the urgent vulnerability.
        self.alias_name = alias_name
        # The check method.
        self.check_type = check_type
        # The timestamp when the urgent vulnerability was last detected. Unit: milliseconds.
        self.gmt_last_check = gmt_last_check
        # The timestamp when the vulnerability was disclosed. Unit: milliseconds.
        self.gmt_publish = gmt_publish
        # The name of the detection rule.
        self.name = name
        # The number of unhandled urgent vulnerabilities.
        self.pending_count = pending_count
        # The progress of the urgent vulnerability detection task. Valid values: 0 to 100.
        # 
        # > This parameter is returned only when an urgent vulnerability is being detected.
        self.progress = progress
        # The detection status of the urgent vulnerability. Valid values:
        # 
        # *   **10**: The urgent vulnerability is not detected.
        # *   **20**: The urgent vulnerability is being detected.
        # *   **30**: The urgent vulnerability detection is complete.
        self.status = status
        # The method that is used to detect the urgent vulnerability. Valid values:
        # 
        # *   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
        # *   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.gmt_last_check is not None:
            result['GmtLastCheck'] = self.gmt_last_check
        if self.gmt_publish is not None:
            result['GmtPublish'] = self.gmt_publish
        if self.name is not None:
            result['Name'] = self.name
        if self.pending_count is not None:
            result['PendingCount'] = self.pending_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('GmtLastCheck') is not None:
            self.gmt_last_check = m.get('GmtLastCheck')
        if m.get('GmtPublish') is not None:
            self.gmt_publish = m.get('GmtPublish')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PendingCount') is not None:
            self.pending_count = m.get('PendingCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeEmgVulItemResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        grouped_vul_items: List[DescribeEmgVulItemResponseBodyGroupedVulItems] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page
        # An array that consists of the urgent vulnerabilities returned.
        self.grouped_vul_items = grouped_vul_items
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of the urgent vulnerabilities returned.
        self.total_count = total_count

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeEmgVulItemResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEmgVulItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEmgVulItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEmgVulItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventLevelCountRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        container_ids: str = None,
        from_: str = None,
        target_type: str = None,
    ):
        # The ID of the container cluster.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id
        # The key of the condition that is used to query alert events on containers. Valid values:
        # 
        # *   **instanceId**: the ID of the asset
        # *   **appName**: the name of the application
        # *   **clusterId**: the ID of the cluster
        # *   **regionId**: the ID of the region
        # *   **nodeName**: the name of the node
        # *   **namespace**: the namespace
        # *   **clusterName**: the name of the cluster
        # *   **image**: the name of the image
        # *   **imageRepoName**: the name of the image repository
        # *   **imageRepoNamespace**: the namespace to which the image repository belongs
        # *   **imageRepoTag**: the tag that is added to the image
        # *   **imageDigest**: the digest of the image
        self.container_field_name = container_field_name
        # The value of the condition that is used to query alert events on containers. If you specify multiple values, separate them with commas (,).
        self.container_field_value = container_field_value
        # The ID of the container.
        self.container_ids = container_ids
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_
        # The type of the query condition. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the UUID of the asset
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.container_ids is not None:
            result['ContainerIds'] = self.container_ids
        if self.from_ is not None:
            result['From'] = self.from_
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('ContainerIds') is not None:
            self.container_ids = m.get('ContainerIds')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeEventLevelCountResponseBodyEventLevels(TeaModel):
    def __init__(
        self,
        remind: int = None,
        serious: int = None,
        suspicious: int = None,
    ):
        # The number of alerts whose Emergency level is Reminder.
        self.remind = remind
        # The number of alerts whose Emergency level is Urgent.
        self.serious = serious
        # The number of alerts whose Emergency level is Suspicious.
        self.suspicious = suspicious

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind is not None:
            result['Remind'] = self.remind
        if self.serious is not None:
            result['Serious'] = self.serious
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Remind') is not None:
            self.remind = m.get('Remind')
        if m.get('Serious') is not None:
            self.serious = m.get('Serious')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        return self


class DescribeEventLevelCountResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        event_levels: DescribeEventLevelCountResponseBodyEventLevels = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The statistics of alerts by risk level.
        self.event_levels = event_levels
        # The error message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.event_levels:
            self.event_levels.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.event_levels is not None:
            result['EventLevels'] = self.event_levels.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EventLevels') is not None:
            temp_model = DescribeEventLevelCountResponseBodyEventLevels()
            self.event_levels = temp_model.from_map(m['EventLevels'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeEventLevelCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventLevelCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventLevelCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventOnStageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeEventOnStageResponseBodySecurityEventStageResponse(TeaModel):
    def __init__(
        self,
        security_event_on_stag: Dict[str, Any] = None,
    ):
        self.security_event_on_stag = security_event_on_stag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_on_stag is not None:
            result['SecurityEventOnStag'] = self.security_event_on_stag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityEventOnStag') is not None:
            self.security_event_on_stag = m.get('SecurityEventOnStag')
        return self


class DescribeEventOnStageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_event_stage_response: DescribeEventOnStageResponseBodySecurityEventStageResponse = None,
    ):
        self.request_id = request_id
        self.security_event_stage_response = security_event_stage_response

    def validate(self):
        if self.security_event_stage_response:
            self.security_event_stage_response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event_stage_response is not None:
            result['SecurityEventStageResponse'] = self.security_event_stage_response.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEventStageResponse') is not None:
            temp_model = DescribeEventOnStageResponseBodySecurityEventStageResponse()
            self.security_event_stage_response = temp_model.from_map(m['SecurityEventStageResponse'])
        return self


class DescribeEventOnStageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventOnStageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventOnStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExcludeSystemPathRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeExcludeSystemPathResponseBodyExcludePaths(TeaModel):
    def __init__(
        self,
        os: str = None,
        path: str = None,
    ):
        self.os = os
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.os is not None:
            result['Os'] = self.os
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class DescribeExcludeSystemPathResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExcludeSystemPathResponseBody(TeaModel):
    def __init__(
        self,
        exclude_paths: List[DescribeExcludeSystemPathResponseBodyExcludePaths] = None,
        page_info: DescribeExcludeSystemPathResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.exclude_paths = exclude_paths
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.exclude_paths:
            for k in self.exclude_paths:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExcludePaths'] = []
        if self.exclude_paths is not None:
            for k in self.exclude_paths:
                result['ExcludePaths'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.exclude_paths = []
        if m.get('ExcludePaths') is not None:
            for k in m.get('ExcludePaths'):
                temp_model = DescribeExcludeSystemPathResponseBodyExcludePaths()
                self.exclude_paths.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeExcludeSystemPathResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExcludeSystemPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExcludeSystemPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExcludeSystemPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExportInfoRequest(TeaModel):
    def __init__(
        self,
        export_id: int = None,
    ):
        # The ID of the export task.
        # 
        # > You can call the [ExportRecord](~~ExportRecord~~) operation to query the IDs of export tasks.
        self.export_id = export_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        current_count: int = None,
        export_status: str = None,
        file_name: str = None,
        id: int = None,
        link: str = None,
        message: str = None,
        progress: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The number of exported entries.
        self.current_count = current_count
        # The status of the export task.
        # 
        # Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **exporting**: The task is in progress.
        # *   **success**: The task is complete.
        self.export_status = export_status
        # The name of the exported Excel file.
        self.file_name = file_name
        # The ID of the export task.
        self.id = id
        # The URL at which you can download the exported Excel file.
        self.link = link
        # The message that shows the task result. The value is fixed as **success**, which indicates that the task is complete.
        self.message = message
        # The progress percentage of the export task.
        self.progress = progress
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries in the exported Excel file.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedCheckWarningRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        type_name: str = None,
        uuids: str = None,
    ):
        self.lang = lang
        self.type_name = type_name
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeExposedCheckWarningResponseBodyWarningList(TeaModel):
    def __init__(
        self,
        risk_id: int = None,
        risk_name: str = None,
        sub_type_alias: str = None,
        type_alias: str = None,
        uuid: str = None,
    ):
        self.risk_id = risk_id
        self.risk_name = risk_name
        self.sub_type_alias = sub_type_alias
        self.type_alias = type_alias
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedCheckWarningResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        request_id: str = None,
        warning_list: List[DescribeExposedCheckWarningResponseBodyWarningList] = None,
    ):
        self.count = count
        self.request_id = request_id
        self.warning_list = warning_list

    def validate(self):
        if self.warning_list:
            for k in self.warning_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['WarningList'] = []
        if self.warning_list is not None:
            for k in self.warning_list:
                result['WarningList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.warning_list = []
        if m.get('WarningList') is not None:
            for k in m.get('WarningList'):
                temp_model = DescribeExposedCheckWarningResponseBodyWarningList()
                self.warning_list.append(temp_model.from_map(k))
        return self


class DescribeExposedCheckWarningResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedCheckWarningResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedCheckWarningResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceCriteriaRequest(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        # DescribeExposedInstanceCriteria
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeExposedInstanceCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeExposedInstanceCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeExposedInstanceCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeExposedInstanceCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedInstanceCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceDetailRequest(TeaModel):
    def __init__(
        self,
        uuid: str = None,
    ):
        # The server group to which the server belongs.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        name: str = None,
        necessity: str = None,
        type: str = None,
        uuid: str = None,
    ):
        self.alias_name = alias_name
        self.name = name
        self.necessity = necessity
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        name: str = None,
        necessity: str = None,
        type: str = None,
        uuid: str = None,
    ):
        # Queries the details about a specified server that is exposed on the Internet.
        self.alias_name = alias_name
        # DescribeExposedInstanceDetail
        self.name = name
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.necessity = necessity
        # The resource from which the server is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the public IP address of an Elastic Compute Service (ECS) instance
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **EIP**: an elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.type = type
        # The ID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChains(TeaModel):
    def __init__(
        self,
        all_vul_list: List[DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList] = None,
        exposure_component: str = None,
        exposure_ip: str = None,
        exposure_port: str = None,
        exposure_type: str = None,
        exposure_type_id: str = None,
        group_no: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        real_vul_list: List[DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList] = None,
        region_id: str = None,
        uuid: str = None,
    ):
        self.all_vul_list = all_vul_list
        # The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.
        # 
        # *   If the value of the ExposureType parameter is **INTERNET_IP**, the value of this parameter is an empty string.
        # *   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the Internet-facing SLB instance.
        # *   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
        # *   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
        self.exposure_component = exposure_component
        # The name of the server.
        self.exposure_ip = exposure_ip
        # The information about the vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.exposure_port = exposure_port
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        # 
        # >  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.
        self.exposure_type = exposure_type
        # The public IP address of the server.
        self.exposure_type_id = exposure_type_id
        # The port that is exposed on the Internet.
        self.group_no = group_no
        # The public IP address.
        self.instance_id = instance_id
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerabilities
        # *   **sys**: Windows system vulnerabilities
        # *   **cms**: Web-CMS vulnerabilities
        # *   **app**: application vulnerabilities
        # *   **emg**: urgent vulnerabilities
        # *   **sca**: middleware vulnerabilities
        self.instance_name = instance_name
        # The alias of the vulnerability.
        self.internet_ip = internet_ip
        # The name of the vulnerability.
        self.intranet_ip = intranet_ip
        # The information about all vulnerabilities on the server.
        self.real_vul_list = real_vul_list
        # The alias of the vulnerability.
        self.region_id = region_id
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        if self.all_vul_list:
            for k in self.all_vul_list:
                if k:
                    k.validate()
        if self.real_vul_list:
            for k in self.real_vul_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllVulList'] = []
        if self.all_vul_list is not None:
            for k in self.all_vul_list:
                result['AllVulList'].append(k.to_map() if k else None)
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.group_no is not None:
            result['GroupNo'] = self.group_no
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        result['RealVulList'] = []
        if self.real_vul_list is not None:
            for k in self.real_vul_list:
                result['RealVulList'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.all_vul_list = []
        if m.get('AllVulList') is not None:
            for k in m.get('AllVulList'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList()
                self.all_vul_list.append(temp_model.from_map(k))
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('GroupNo') is not None:
            self.group_no = m.get('GroupNo')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        self.real_vul_list = []
        if m.get('RealVulList') is not None:
            for k in m.get('RealVulList'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList()
                self.real_vul_list.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBody(TeaModel):
    def __init__(
        self,
        exposed_chains: List[DescribeExposedInstanceDetailResponseBodyExposedChains] = None,
        request_id: str = None,
    ):
        # The UUID of the server that is exposed on the Internet.
        # 
        # >  You can call the [DescribeExposedInstanceList](~~DescribeExposedInstanceList~~) operation to query the UUIDs of servers.
        self.exposed_chains = exposed_chains
        # The exposure details about the server.
        self.request_id = request_id

    def validate(self):
        if self.exposed_chains:
            for k in self.exposed_chains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExposedChains'] = []
        if self.exposed_chains is not None:
            for k in self.exposed_chains:
                result['ExposedChains'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.exposed_chains = []
        if m.get('ExposedChains') is not None:
            for k in m.get('ExposedChains'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChains()
                self.exposed_chains.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedInstanceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        exposure_component: str = None,
        exposure_ip: str = None,
        exposure_port: str = None,
        group_id: int = None,
        health_status: bool = None,
        instance_id: str = None,
        instance_name: str = None,
        page_size: int = None,
        vul_status: bool = None,
    ):
        # The server component that is exposed on the Internet.
        self.current_page = current_page
        # The total number of servers that are exposed on the Internet.
        self.exposure_component = exposure_component
        # The ID of the region where the server resides.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.exposure_ip = exposure_ip
        # The public IP address that is exposed on the Internet.
        self.exposure_port = exposure_port
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.group_id = group_id
        # The name of the server.
        self.health_status = health_status
        # The UUID of the server.
        self.instance_id = instance_id
        # The ID of the server group.
        self.instance_name = instance_name
        # The health status of the Elastic Compute Service (ECS) instance in the scaling group. ECS instances that are not in the Running state are considered unhealthy. Valid values:
        # 
        # *   Healthy
        # *   Unhealthy
        # 
        # Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.
        # 
        # Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycle. If the lifecycle of the ECS instances is not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release them. If the lifecycle of the ECS instances is managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases them.
        # 
        # >  Make sure that you have sufficient balance within your account. If you have overdue payments in your account, pay-as-you-go and preemptible instances are stopped or released. For information about how the status of ECS instances changes when you have overdue payments in your account, see [Overdue payments](~~170589~~).
        self.page_size = page_size
        # The public IP address of the server.
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeExposedInstanceListResponseBodyExposedInstances(TeaModel):
    def __init__(
        self,
        asap_vul_count: int = None,
        exploit_health_count: int = None,
        exposure_component: str = None,
        exposure_ip: str = None,
        exposure_port: str = None,
        exposure_type: str = None,
        exposure_type_id: str = None,
        group_id: int = None,
        group_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        later_vul_count: int = None,
        nntf_vul_count: int = None,
        region_id: str = None,
        total_vul_count: int = None,
        uuid: str = None,
    ):
        # An array that consists of the details about the exposed asset.
        self.asap_vul_count = asap_vul_count
        self.exploit_health_count = exploit_health_count
        self.exposure_component = exposure_component
        # The number of entries returned on the current page.
        self.exposure_ip = exposure_ip
        # Queries the information about the servers that are exposed on the Internet.
        self.exposure_port = exposure_port
        # Specifies whether the server has vulnerabilities. Valid values:
        # 
        # *   **true**: The server has vulnerabilities.
        # *   **false**: The server does not have vulnerabilities.
        self.exposure_type = exposure_type
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.exposure_type_id = exposure_type_id
        self.group_id = group_id
        self.group_name = group_name
        # The ID of the server.
        self.instance_id = instance_id
        self.instance_name = instance_name
        # The pagination information.
        self.internet_ip = internet_ip
        # The number of entries returned per page.
        self.intranet_ip = intranet_ip
        self.later_vul_count = later_vul_count
        # The private IP address of the server.
        self.nntf_vul_count = nntf_vul_count
        # The ID of the server.
        self.region_id = region_id
        # The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the ExposureType parameter.
        # 
        # *   If the value of the ExposureType parameter is **INTERNET_IP**, this parameter is empty.
        # *   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the SLB instance.
        # *   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
        # *   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
        self.total_vul_count = total_vul_count
        # DescribeExposedInstanceList
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_vul_count is not None:
            result['AsapVulCount'] = self.asap_vul_count
        if self.exploit_health_count is not None:
            result['ExploitHealthCount'] = self.exploit_health_count
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.later_vul_count is not None:
            result['LaterVulCount'] = self.later_vul_count
        if self.nntf_vul_count is not None:
            result['NntfVulCount'] = self.nntf_vul_count
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.total_vul_count is not None:
            result['TotalVulCount'] = self.total_vul_count
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsapVulCount') is not None:
            self.asap_vul_count = m.get('AsapVulCount')
        if m.get('ExploitHealthCount') is not None:
            self.exploit_health_count = m.get('ExploitHealthCount')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LaterVulCount') is not None:
            self.later_vul_count = m.get('LaterVulCount')
        if m.get('NntfVulCount') is not None:
            self.nntf_vul_count = m.get('NntfVulCount')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TotalVulCount') is not None:
            self.total_vul_count = m.get('TotalVulCount')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The ID of the server group.
        # 
        # > You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.
        self.count = count
        # The number of the page to return.
        self.current_page = current_page
        # The number of low-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.page_size = page_size
        # The number of medium-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExposedInstanceListResponseBody(TeaModel):
    def __init__(
        self,
        exposed_instances: List[DescribeExposedInstanceListResponseBodyExposedInstances] = None,
        page_info: DescribeExposedInstanceListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The port that is exposed on the Internet.
        self.exposed_instances = exposed_instances
        # The public IP address of the server.
        self.page_info = page_info
        # The resource from which the asset is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the public IP address of an ECS instance
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **EIP**: an elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.request_id = request_id

    def validate(self):
        if self.exposed_instances:
            for k in self.exposed_instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExposedInstances'] = []
        if self.exposed_instances is not None:
            for k in self.exposed_instances:
                result['ExposedInstances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.exposed_instances = []
        if m.get('ExposedInstances') is not None:
            for k in m.get('ExposedInstances'):
                temp_model = DescribeExposedInstanceListResponseBodyExposedInstances()
                self.exposed_instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeExposedInstanceListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedInstanceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        exposed_asap_vul_count: int = None,
        exposed_component_count: int = None,
        exposed_instance_count: int = None,
        exposed_ip_count: int = None,
        exposed_later_vul_count: int = None,
        exposed_nntf_vul_count: int = None,
        exposed_port_count: int = None,
        exposed_week_password_machine_count: int = None,
        gateway_asset_count: int = None,
        request_id: str = None,
    ):
        self.exposed_asap_vul_count = exposed_asap_vul_count
        # The total number of low-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.exposed_component_count = exposed_component_count
        # DescribeExposedStatistics
        self.exposed_instance_count = exposed_instance_count
        self.exposed_ip_count = exposed_ip_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.exposed_later_vul_count = exposed_later_vul_count
        self.exposed_nntf_vul_count = exposed_nntf_vul_count
        # Queries the exposure statistics of the assets on the Internet.
        self.exposed_port_count = exposed_port_count
        self.exposed_week_password_machine_count = exposed_week_password_machine_count
        self.gateway_asset_count = gateway_asset_count
        # The total number of servers that are exposed on the Internet.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exposed_asap_vul_count is not None:
            result['ExposedAsapVulCount'] = self.exposed_asap_vul_count
        if self.exposed_component_count is not None:
            result['ExposedComponentCount'] = self.exposed_component_count
        if self.exposed_instance_count is not None:
            result['ExposedInstanceCount'] = self.exposed_instance_count
        if self.exposed_ip_count is not None:
            result['ExposedIpCount'] = self.exposed_ip_count
        if self.exposed_later_vul_count is not None:
            result['ExposedLaterVulCount'] = self.exposed_later_vul_count
        if self.exposed_nntf_vul_count is not None:
            result['ExposedNntfVulCount'] = self.exposed_nntf_vul_count
        if self.exposed_port_count is not None:
            result['ExposedPortCount'] = self.exposed_port_count
        if self.exposed_week_password_machine_count is not None:
            result['ExposedWeekPasswordMachineCount'] = self.exposed_week_password_machine_count
        if self.gateway_asset_count is not None:
            result['GatewayAssetCount'] = self.gateway_asset_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExposedAsapVulCount') is not None:
            self.exposed_asap_vul_count = m.get('ExposedAsapVulCount')
        if m.get('ExposedComponentCount') is not None:
            self.exposed_component_count = m.get('ExposedComponentCount')
        if m.get('ExposedInstanceCount') is not None:
            self.exposed_instance_count = m.get('ExposedInstanceCount')
        if m.get('ExposedIpCount') is not None:
            self.exposed_ip_count = m.get('ExposedIpCount')
        if m.get('ExposedLaterVulCount') is not None:
            self.exposed_later_vul_count = m.get('ExposedLaterVulCount')
        if m.get('ExposedNntfVulCount') is not None:
            self.exposed_nntf_vul_count = m.get('ExposedNntfVulCount')
        if m.get('ExposedPortCount') is not None:
            self.exposed_port_count = m.get('ExposedPortCount')
        if m.get('ExposedWeekPasswordMachineCount') is not None:
            self.exposed_week_password_machine_count = m.get('ExposedWeekPasswordMachineCount')
        if m.get('GatewayAssetCount') is not None:
            self.gateway_asset_count = m.get('GatewayAssetCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedStatisticsDetailRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        statistics_type: str = None,
        statistics_type_gateway_type: str = None,
        statistics_type_instance_value: str = None,
    ):
        # The number of entries returned on the current page.
        self.current_page = current_page
        # The ID of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**.
        self.page_size = page_size
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.statistics_type = statistics_type
        # The system component that is exposed on the Internet.
        self.statistics_type_gateway_type = statistics_type_gateway_type
        # The pagination information.
        self.statistics_type_instance_value = statistics_type_instance_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.statistics_type is not None:
            result['StatisticsType'] = self.statistics_type
        if self.statistics_type_gateway_type is not None:
            result['StatisticsTypeGatewayType'] = self.statistics_type_gateway_type
        if self.statistics_type_instance_value is not None:
            result['StatisticsTypeInstanceValue'] = self.statistics_type_instance_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StatisticsType') is not None:
            self.statistics_type = m.get('StatisticsType')
        if m.get('StatisticsTypeGatewayType') is not None:
            self.statistics_type_gateway_type = m.get('StatisticsTypeGatewayType')
        if m.get('StatisticsTypeInstanceValue') is not None:
            self.statistics_type_instance_value = m.get('StatisticsTypeInstanceValue')
        return self


class DescribeExposedStatisticsDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array consisting of the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet and are returned.
        self.count = count
        # exposureType
        self.current_page = current_page
        # The port that is exposed on the Internet.
        self.page_size = page_size
        # lb-2ze4rso39h4nczcqs****\
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExposedStatisticsDetailResponseBodyStatisticsDetails(TeaModel):
    def __init__(
        self,
        exposed_count: int = None,
        exposure_component: str = None,
        exposure_ip: str = None,
        exposure_port: str = None,
        exposure_type: str = None,
        exposure_type_id: str = None,
        exposure_type_instance_name: str = None,
        region_id: str = None,
    ):
        # The total number of system vulnerabilities that are detected on your server and are exposed on the Internet.
        self.exposed_count = exposed_count
        # Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
        self.exposure_component = exposure_component
        # The type of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**. Valid values:
        # 
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.exposure_ip = exposure_ip
        # The number of entries returned per page.
        self.exposure_port = exposure_port
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.exposure_type = exposure_type
        # DescribeExposedStatisticsDetail
        self.exposure_type_id = exposure_type_id
        # The name of the gateway asset that is exposed on the Internet.
        self.exposure_type_instance_name = exposure_type_instance_name
        # 20
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exposed_count is not None:
            result['ExposedCount'] = self.exposed_count
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.exposure_type_instance_name is not None:
            result['ExposureTypeInstanceName'] = self.exposure_type_instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExposedCount') is not None:
            self.exposed_count = m.get('ExposedCount')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('ExposureTypeInstanceName') is not None:
            self.exposure_type_instance_name = m.get('ExposureTypeInstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeExposedStatisticsDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeExposedStatisticsDetailResponseBodyPageInfo = None,
        request_id: str = None,
        statistics_details: List[DescribeExposedStatisticsDetailResponseBodyStatisticsDetails] = None,
    ):
        # The number of the page to return.
        self.page_info = page_info
        # The resource from which the asset is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the IP address of the Elastic Compute Service (ECS) instance
        # *   **SLB**: the public IP address of the SLB instance
        # *   **EIP**: the elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.request_id = request_id
        # The region ID of the asset.
        self.statistics_details = statistics_details

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.statistics_details:
            for k in self.statistics_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StatisticsDetails'] = []
        if self.statistics_details is not None:
            for k in self.statistics_details:
                result['StatisticsDetails'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeExposedStatisticsDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics_details = []
        if m.get('StatisticsDetails') is not None:
            for k in m.get('StatisticsDetails'):
                temp_model = DescribeExposedStatisticsDetailResponseBodyStatisticsDetails()
                self.statistics_details.append(temp_model.from_map(k))
        return self


class DescribeExposedStatisticsDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExposedStatisticsDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedStatisticsDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFieldStatisticsRequest(TeaModel):
    def __init__(
        self,
        machine_types: str = None,
        region_id: str = None,
    ):
        # The total number of cloud services that are protected by Security Center.
        self.machine_types = machine_types
        # The number of regions to which the servers belong.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeFieldStatisticsResponseBodyGroupedFields(TeaModel):
    def __init__(
        self,
        ali_yun_instance_count: int = None,
        aws_instance_count: int = None,
        azure_instance_count: int = None,
        exposed_instance_count: int = None,
        general_asset_count: int = None,
        group_count: int = None,
        huawei_instance_count: int = None,
        idc_instance_count: int = None,
        important_asset_count: int = None,
        instance_count: int = None,
        instance_sync_task_count: int = None,
        new_instance_count: int = None,
        no_risk_instance_count: int = None,
        not_running_status_count: int = None,
        offline_instance_count: int = None,
        out_machine_instance_count: int = None,
        pause_instance_count: int = None,
        region_count: int = None,
        risk_instance_count: int = None,
        tencent_instance_count: int = None,
        test_asset_count: int = None,
        tripartite_instance_count: int = None,
        un_know_status_instance_count: int = None,
        unprotected_instance_count: int = None,
        vpc_count: int = None,
    ):
        self.ali_yun_instance_count = ali_yun_instance_count
        self.aws_instance_count = aws_instance_count
        self.azure_instance_count = azure_instance_count
        # The data returned.
        self.exposed_instance_count = exposed_instance_count
        # The number of server groups.
        self.general_asset_count = general_asset_count
        # The type of the asset to query. If no asset types are specified, all types of assets are returned. Valid values:
        # 
        # *   **ecs**: server
        # *   **cloud_product**: Alibaba Cloud service
        self.group_count = group_count
        self.huawei_instance_count = huawei_instance_count
        # DescribeFieldStatistics
        self.idc_instance_count = idc_instance_count
        # The number of assets that are at risk.
        self.important_asset_count = important_asset_count
        # The number of assets that are deployed on Alibaba Cloud.
        self.instance_count = instance_count
        # The number of assets whose importance is common.
        self.instance_sync_task_count = instance_sync_task_count
        # The number of assets whose statuses are unknown.
        self.new_instance_count = new_instance_count
        # The number of servers that are shut down.
        self.no_risk_instance_count = no_risk_instance_count
        # WB01224678
        self.not_running_status_count = not_running_status_count
        # The number of unprotected assets.
        self.offline_instance_count = offline_instance_count
        self.out_machine_instance_count = out_machine_instance_count
        # Queries the statistics of assets that belong to your account.
        self.pause_instance_count = pause_instance_count
        # The number of virtual private clouds (VPCs).
        self.region_count = region_count
        self.risk_instance_count = risk_instance_count
        # The number of servers.
        self.tencent_instance_count = tencent_instance_count
        # The number of servers outside the cloud.
        self.test_asset_count = test_asset_count
        self.tripartite_instance_count = tripartite_instance_count
        # The number of newly added servers.
        self.un_know_status_instance_count = un_know_status_instance_count
        # The number of servers whose Security Center agent status is Offline.
        self.unprotected_instance_count = unprotected_instance_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.vpc_count = vpc_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_yun_instance_count is not None:
            result['AliYunInstanceCount'] = self.ali_yun_instance_count
        if self.aws_instance_count is not None:
            result['AwsInstanceCount'] = self.aws_instance_count
        if self.azure_instance_count is not None:
            result['AzureInstanceCount'] = self.azure_instance_count
        if self.exposed_instance_count is not None:
            result['ExposedInstanceCount'] = self.exposed_instance_count
        if self.general_asset_count is not None:
            result['GeneralAssetCount'] = self.general_asset_count
        if self.group_count is not None:
            result['GroupCount'] = self.group_count
        if self.huawei_instance_count is not None:
            result['HuaweiInstanceCount'] = self.huawei_instance_count
        if self.idc_instance_count is not None:
            result['IdcInstanceCount'] = self.idc_instance_count
        if self.important_asset_count is not None:
            result['ImportantAssetCount'] = self.important_asset_count
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_sync_task_count is not None:
            result['InstanceSyncTaskCount'] = self.instance_sync_task_count
        if self.new_instance_count is not None:
            result['NewInstanceCount'] = self.new_instance_count
        if self.no_risk_instance_count is not None:
            result['NoRiskInstanceCount'] = self.no_risk_instance_count
        if self.not_running_status_count is not None:
            result['NotRunningStatusCount'] = self.not_running_status_count
        if self.offline_instance_count is not None:
            result['OfflineInstanceCount'] = self.offline_instance_count
        if self.out_machine_instance_count is not None:
            result['OutMachineInstanceCount'] = self.out_machine_instance_count
        if self.pause_instance_count is not None:
            result['PauseInstanceCount'] = self.pause_instance_count
        if self.region_count is not None:
            result['RegionCount'] = self.region_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.tencent_instance_count is not None:
            result['TencentInstanceCount'] = self.tencent_instance_count
        if self.test_asset_count is not None:
            result['TestAssetCount'] = self.test_asset_count
        if self.tripartite_instance_count is not None:
            result['TripartiteInstanceCount'] = self.tripartite_instance_count
        if self.un_know_status_instance_count is not None:
            result['UnKnowStatusInstanceCount'] = self.un_know_status_instance_count
        if self.unprotected_instance_count is not None:
            result['UnprotectedInstanceCount'] = self.unprotected_instance_count
        if self.vpc_count is not None:
            result['VpcCount'] = self.vpc_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliYunInstanceCount') is not None:
            self.ali_yun_instance_count = m.get('AliYunInstanceCount')
        if m.get('AwsInstanceCount') is not None:
            self.aws_instance_count = m.get('AwsInstanceCount')
        if m.get('AzureInstanceCount') is not None:
            self.azure_instance_count = m.get('AzureInstanceCount')
        if m.get('ExposedInstanceCount') is not None:
            self.exposed_instance_count = m.get('ExposedInstanceCount')
        if m.get('GeneralAssetCount') is not None:
            self.general_asset_count = m.get('GeneralAssetCount')
        if m.get('GroupCount') is not None:
            self.group_count = m.get('GroupCount')
        if m.get('HuaweiInstanceCount') is not None:
            self.huawei_instance_count = m.get('HuaweiInstanceCount')
        if m.get('IdcInstanceCount') is not None:
            self.idc_instance_count = m.get('IdcInstanceCount')
        if m.get('ImportantAssetCount') is not None:
            self.important_asset_count = m.get('ImportantAssetCount')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceSyncTaskCount') is not None:
            self.instance_sync_task_count = m.get('InstanceSyncTaskCount')
        if m.get('NewInstanceCount') is not None:
            self.new_instance_count = m.get('NewInstanceCount')
        if m.get('NoRiskInstanceCount') is not None:
            self.no_risk_instance_count = m.get('NoRiskInstanceCount')
        if m.get('NotRunningStatusCount') is not None:
            self.not_running_status_count = m.get('NotRunningStatusCount')
        if m.get('OfflineInstanceCount') is not None:
            self.offline_instance_count = m.get('OfflineInstanceCount')
        if m.get('OutMachineInstanceCount') is not None:
            self.out_machine_instance_count = m.get('OutMachineInstanceCount')
        if m.get('PauseInstanceCount') is not None:
            self.pause_instance_count = m.get('PauseInstanceCount')
        if m.get('RegionCount') is not None:
            self.region_count = m.get('RegionCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('TencentInstanceCount') is not None:
            self.tencent_instance_count = m.get('TencentInstanceCount')
        if m.get('TestAssetCount') is not None:
            self.test_asset_count = m.get('TestAssetCount')
        if m.get('TripartiteInstanceCount') is not None:
            self.tripartite_instance_count = m.get('TripartiteInstanceCount')
        if m.get('UnKnowStatusInstanceCount') is not None:
            self.un_know_status_instance_count = m.get('UnKnowStatusInstanceCount')
        if m.get('UnprotectedInstanceCount') is not None:
            self.unprotected_instance_count = m.get('UnprotectedInstanceCount')
        if m.get('VpcCount') is not None:
            self.vpc_count = m.get('VpcCount')
        return self


class DescribeFieldStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        grouped_fields: DescribeFieldStatisticsResponseBodyGroupedFields = None,
        request_id: str = None,
    ):
        # The number of assets whose importance is test.
        self.grouped_fields = grouped_fields
        # The information about servers that are returned.
        self.request_id = request_id

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = DescribeFieldStatisticsResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFieldStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFieldStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFieldStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFrontVulPatchListRequest(TeaModel):
    def __init__(
        self,
        info: str = None,
        lang: str = None,
        operate_type: str = None,
        type: str = None,
    ):
        self.info = info
        self.lang = lang
        self.operate_type = operate_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        name: str = None,
    ):
        self.alias_name = alias_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchList(TeaModel):
    def __init__(
        self,
        patch_list: List[DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList] = None,
        uuid: str = None,
    ):
        self.patch_list = patch_list
        self.uuid = uuid

    def validate(self):
        if self.patch_list:
            for k in self.patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PatchList'] = []
        if self.patch_list is not None:
            for k in self.patch_list:
                result['PatchList'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.patch_list = []
        if m.get('PatchList') is not None:
            for k in m.get('PatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList()
                self.patch_list.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeFrontVulPatchListResponseBody(TeaModel):
    def __init__(
        self,
        front_patch_list: List[DescribeFrontVulPatchListResponseBodyFrontPatchList] = None,
        request_id: str = None,
    ):
        self.front_patch_list = front_patch_list
        self.request_id = request_id

    def validate(self):
        if self.front_patch_list:
            for k in self.front_patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrontPatchList'] = []
        if self.front_patch_list is not None:
            for k in self.front_patch_list:
                result['FrontPatchList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.front_patch_list = []
        if m.get('FrontPatchList') is not None:
            for k in m.get('FrontPatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchList()
                self.front_patch_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFrontVulPatchListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFrontVulPatchListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFrontVulPatchListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupStructRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGroupStructResponseBody(TeaModel):
    def __init__(
        self,
        group_father: int = None,
        group_flag: int = None,
        group_id: int = None,
        group_index: int = None,
        group_level: int = None,
        group_name: str = None,
        groups: List[str] = None,
        machine_num: int = None,
        request_id: str = None,
    ):
        self.group_father = group_father
        self.group_flag = group_flag
        self.group_id = group_id
        self.group_index = group_index
        self.group_level = group_level
        self.group_name = group_name
        self.groups = groups
        self.machine_num = machine_num
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_father is not None:
            result['GroupFather'] = self.group_father
        if self.group_flag is not None:
            result['GroupFlag'] = self.group_flag
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_index is not None:
            result['GroupIndex'] = self.group_index
        if self.group_level is not None:
            result['GroupLevel'] = self.group_level
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.machine_num is not None:
            result['MachineNum'] = self.machine_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupFather') is not None:
            self.group_father = m.get('GroupFather')
        if m.get('GroupFlag') is not None:
            self.group_flag = m.get('GroupFlag')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupIndex') is not None:
            self.group_index = m.get('GroupIndex')
        if m.get('GroupLevel') is not None:
            self.group_level = m.get('GroupLevel')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('MachineNum') is not None:
            self.machine_num = m.get('MachineNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupStructResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupStructResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupStructResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedContainerInstancesRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        current_page: int = None,
        field_value: str = None,
        group_field: str = None,
        logical_exp: str = None,
        page_size: int = None,
    ):
        self.criteria = criteria
        self.current_page = current_page
        self.field_value = field_value
        self.group_field = group_field
        self.logical_exp = logical_exp
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        create_time: int = None,
        custer_state: str = None,
        hc_count: int = None,
        host_ip: str = None,
        image: str = None,
        image_digest: str = None,
        image_repo_name: str = None,
        image_repo_namespace: str = None,
        image_repo_tag: str = None,
        image_uuid: str = None,
        instance_count: int = None,
        instance_id: str = None,
        namespace: str = None,
        pod: str = None,
        pod_ip: str = None,
        region_id: str = None,
        risk_instance_count: int = None,
        risk_level: str = None,
        risk_status: str = None,
        vul_count: int = None,
    ):
        self.alarm_count = alarm_count
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.cluster_type = cluster_type
        self.create_time = create_time
        self.custer_state = custer_state
        self.hc_count = hc_count
        self.host_ip = host_ip
        self.image = image
        self.image_digest = image_digest
        self.image_repo_name = image_repo_name
        self.image_repo_namespace = image_repo_namespace
        self.image_repo_tag = image_repo_tag
        self.image_uuid = image_uuid
        self.instance_count = instance_count
        self.instance_id = instance_id
        self.namespace = namespace
        self.pod = pod
        self.pod_ip = pod_ip
        self.region_id = region_id
        self.risk_instance_count = risk_instance_count
        self.risk_level = risk_level
        self.risk_status = risk_status
        self.vul_count = vul_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.custer_state is not None:
            result['CusterState'] = self.custer_state
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_repo_name is not None:
            result['ImageRepoName'] = self.image_repo_name
        if self.image_repo_namespace is not None:
            result['ImageRepoNamespace'] = self.image_repo_namespace
        if self.image_repo_tag is not None:
            result['ImageRepoTag'] = self.image_repo_tag
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CusterState') is not None:
            self.custer_state = m.get('CusterState')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageRepoName') is not None:
            self.image_repo_name = m.get('ImageRepoName')
        if m.get('ImageRepoNamespace') is not None:
            self.image_repo_namespace = m.get('ImageRepoNamespace')
        if m.get('ImageRepoTag') is not None:
            self.image_repo_tag = m.get('ImageRepoTag')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        return self


class DescribeGroupedContainerInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedContainerInstancesResponseBody(TeaModel):
    def __init__(
        self,
        grouped_container_instance_list: List[DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList] = None,
        page_info: DescribeGroupedContainerInstancesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.grouped_container_instance_list = grouped_container_instance_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.grouped_container_instance_list:
            for k in self.grouped_container_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupedContainerInstanceList'] = []
        if self.grouped_container_instance_list is not None:
            for k in self.grouped_container_instance_list:
                result['GroupedContainerInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.grouped_container_instance_list = []
        if m.get('GroupedContainerInstanceList') is not None:
            for k in m.get('GroupedContainerInstanceList'):
                temp_model = DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList()
                self.grouped_container_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedContainerInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedContainerInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupedContainerInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedContainerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedInstancesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        field_value: str = None,
        group_field: str = None,
        lang: str = None,
        machine_types: str = None,
        no_page: bool = None,
        page_size: int = None,
        sale_version_check_code: str = None,
        vendor: int = None,
        vendors: str = None,
    ):
        # The number of entries to return on each page. Default value: **20**.
        self.current_page = current_page
        # The pagination information.
        self.field_value = field_value
        # An array that consists of the information about the assets.
        self.group_field = group_field
        # The number of entries returned on the current page.
        self.lang = lang
        # Specifies whether to enable paged query. Default value: **true**. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.machine_types = machine_types
        # The number of assets on which high-risk vulnerabilities are detected.
        self.no_page = no_page
        # The type of the server group. Valid values:
        # 
        # *   **0**: the default group
        # *   **1**: other group
        self.page_size = page_size
        self.sale_version_check_code = sale_version_check_code
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.vendor = vendor
        # The name of the group to which the assets belong. Fuzzy search is supported.
        self.vendors = vendors

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.no_page is not None:
            result['NoPage'] = self.no_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sale_version_check_code is not None:
            result['SaleVersionCheckCode'] = self.sale_version_check_code
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('NoPage') is not None:
            self.no_page = m.get('NoPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SaleVersionCheckCode') is not None:
            self.sale_version_check_code = m.get('SaleVersionCheckCode')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class DescribeGroupedInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        asap_vul_instance_count: int = None,
        auth_version_check_count: int = None,
        field_alias_name: str = None,
        group_flag: int = None,
        instance_count: str = None,
        risk_instance_count: str = None,
        un_protected_instance_count: str = None,
    ):
        self.asap_vul_instance_count = asap_vul_instance_count
        self.auth_version_check_count = auth_version_check_count
        self.field_alias_name = field_alias_name
        self.group_flag = group_flag
        self.instance_count = instance_count
        self.risk_instance_count = risk_instance_count
        self.un_protected_instance_count = un_protected_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_vul_instance_count is not None:
            result['AsapVulInstanceCount'] = self.asap_vul_instance_count
        if self.auth_version_check_count is not None:
            result['AuthVersionCheckCount'] = self.auth_version_check_count
        if self.field_alias_name is not None:
            result['FieldAliasName'] = self.field_alias_name
        if self.group_flag is not None:
            result['GroupFlag'] = self.group_flag
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.un_protected_instance_count is not None:
            result['UnProtectedInstanceCount'] = self.un_protected_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsapVulInstanceCount') is not None:
            self.asap_vul_instance_count = m.get('AsapVulInstanceCount')
        if m.get('AuthVersionCheckCount') is not None:
            self.auth_version_check_count = m.get('AuthVersionCheckCount')
        if m.get('FieldAliasName') is not None:
            self.field_alias_name = m.get('FieldAliasName')
        if m.get('GroupFlag') is not None:
            self.group_flag = m.get('GroupFlag')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('UnProtectedInstanceCount') is not None:
            self.un_protected_instance_count = m.get('UnProtectedInstanceCount')
        return self


class DescribeGroupedInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 58928
        self.count = count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.current_page = current_page
        # Queries the statistical information about assets based on a specified filter condition.
        self.page_size = page_size
        # DescribeGroupedInstances
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instances: List[DescribeGroupedInstancesResponseBodyInstances] = None,
        page_info: DescribeGroupedInstancesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.instances = instances
        # The number of assets that are not protected by Security Center.
        self.page_info = page_info
        # The name of the server group.
        self.request_id = request_id

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeGroupedInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupedInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedMaliciousFilesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        current_page: int = None,
        fuzzy_malicious_name: str = None,
        image_digest: str = None,
        image_layer: str = None,
        image_tag: str = None,
        lang: str = None,
        levels: str = None,
        malicious_md_5: str = None,
        page_size: str = None,
        repo_id: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_region_id: str = None,
        scan_range: List[str] = None,
    ):
        self.cluster_id = cluster_id
        self.current_page = current_page
        self.fuzzy_malicious_name = fuzzy_malicious_name
        self.image_digest = image_digest
        self.image_layer = image_layer
        self.image_tag = image_tag
        self.lang = lang
        self.levels = levels
        self.malicious_md_5 = malicious_md_5
        self.page_size = page_size
        self.repo_id = repo_id
        self.repo_instance_id = repo_instance_id
        self.repo_name = repo_name
        self.repo_namespace = repo_namespace
        self.repo_region_id = repo_region_id
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.fuzzy_malicious_name is not None:
            result['FuzzyMaliciousName'] = self.fuzzy_malicious_name
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FuzzyMaliciousName') is not None:
            self.fuzzy_malicious_name = m.get('FuzzyMaliciousName')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse(TeaModel):
    def __init__(
        self,
        first_scan_timestamp: int = None,
        image_count: int = None,
        latest_scan_timestamp: int = None,
        level: str = None,
        malicious_md_5: str = None,
        malicious_name: str = None,
        status: int = None,
    ):
        self.first_scan_timestamp = first_scan_timestamp
        self.image_count = image_count
        self.latest_scan_timestamp = latest_scan_timestamp
        self.level = level
        self.malicious_md_5 = malicious_md_5
        self.malicious_name = malicious_name
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_scan_timestamp is not None:
            result['FirstScanTimestamp'] = self.first_scan_timestamp
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.latest_scan_timestamp is not None:
            result['LatestScanTimestamp'] = self.latest_scan_timestamp
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.malicious_name is not None:
            result['MaliciousName'] = self.malicious_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstScanTimestamp') is not None:
            self.first_scan_timestamp = m.get('FirstScanTimestamp')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('LatestScanTimestamp') is not None:
            self.latest_scan_timestamp = m.get('LatestScanTimestamp')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('MaliciousName') is not None:
            self.malicious_name = m.get('MaliciousName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeGroupedMaliciousFilesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedMaliciousFilesResponseBody(TeaModel):
    def __init__(
        self,
        grouped_malicious_file_response: List[DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse] = None,
        page_info: DescribeGroupedMaliciousFilesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.grouped_malicious_file_response = grouped_malicious_file_response
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.grouped_malicious_file_response:
            for k in self.grouped_malicious_file_response:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupedMaliciousFileResponse'] = []
        if self.grouped_malicious_file_response is not None:
            for k in self.grouped_malicious_file_response:
                result['GroupedMaliciousFileResponse'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.grouped_malicious_file_response = []
        if m.get('GroupedMaliciousFileResponse') is not None:
            for k in m.get('GroupedMaliciousFileResponse'):
                temp_model = DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse()
                self.grouped_malicious_file_response.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedMaliciousFilesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedMaliciousFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupedMaliciousFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedMaliciousFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedTagsRequest(TeaModel):
    def __init__(
        self,
        machine_types: str = None,
    ):
        # ecs
        self.machine_types = machine_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        return self


class DescribeGroupedTagsResponseBodyGroupedFileds(TeaModel):
    def __init__(
        self,
        count: str = None,
        name: str = None,
        tag_id: int = None,
    ):
        self.count = count
        self.name = name
        self.tag_id = tag_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        return self


class DescribeGroupedTagsResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        grouped_fileds: List[DescribeGroupedTagsResponseBodyGroupedFileds] = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.count = count
        self.grouped_fileds = grouped_fileds
        # This parameter is deprecated.
        self.http_status_code = http_status_code
        # Queries the statistics of asset tags.
        self.request_id = request_id
        # DescribeGroupedTags
        self.success = success

    def validate(self):
        if self.grouped_fileds:
            for k in self.grouped_fileds:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['GroupedFileds'] = []
        if self.grouped_fileds is not None:
            for k in self.grouped_fileds:
                result['GroupedFileds'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.grouped_fileds = []
        if m.get('GroupedFileds') is not None:
            for k in m.get('GroupedFileds'):
                temp_model = DescribeGroupedTagsResponseBodyGroupedFileds()
                self.grouped_fileds.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeGroupedTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupedTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedVulRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        asset_type: str = None,
        attach_types: str = None,
        container_field_name: str = None,
        current_page: int = None,
        dealed: str = None,
        group_id: str = None,
        lang: str = None,
        necessity: str = None,
        page_size: int = None,
        search_tags: str = None,
        target_type: str = None,
        type: str = None,
        uuids: str = None,
    ):
        self.alias_name = alias_name
        self.asset_type = asset_type
        self.attach_types = attach_types
        self.container_field_name = container_field_name
        self.current_page = current_page
        self.dealed = dealed
        self.group_id = group_id
        # The name of the vulnerability.
        self.lang = lang
        self.necessity = necessity
        self.page_size = page_size
        self.search_tags = search_tags
        self.target_type = target_type
        # The total number of fixed vulnerabilities.
        self.type = type
        # The number of vulnerabilities that have the **high** priority.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeGroupedVulResponseBodyGroupedVulItems(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        asap_count: int = None,
        gmt_last: int = None,
        handled_count: int = None,
        later_count: int = None,
        name: str = None,
        nntf_count: int = None,
        rasp_defend: int = None,
        tags: str = None,
        total_fix_count: int = None,
        type: str = None,
    ):
        self.alias_name = alias_name
        self.asap_count = asap_count
        self.gmt_last = gmt_last
        self.handled_count = handled_count
        self.later_count = later_count
        self.name = name
        self.nntf_count = nntf_count
        # RASP
        # - **0**
        # - **1**
        # > 
        self.rasp_defend = rasp_defend
        self.tags = tags
        self.total_fix_count = total_fix_count
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.handled_count is not None:
            result['HandledCount'] = self.handled_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.rasp_defend is not None:
            result['RaspDefend'] = self.rasp_defend
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.total_fix_count is not None:
            result['TotalFixCount'] = self.total_fix_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('HandledCount') is not None:
            self.handled_count = m.get('HandledCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('RaspDefend') is not None:
            self.rasp_defend = m.get('RaspDefend')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TotalFixCount') is not None:
            self.total_fix_count = m.get('TotalFixCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeGroupedVulResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        grouped_vul_items: List[DescribeGroupedVulResponseBodyGroupedVulItems] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.grouped_vul_items = grouped_vul_items
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeGroupedVulResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedVulResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupedVulResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHcExportInfoRequest(TeaModel):
    def __init__(
        self,
        export_id: int = None,
    ):
        self.export_id = export_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeHcExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        current_count: int = None,
        file_name: str = None,
        gmt_create: int = None,
        id: int = None,
        link: str = None,
        progress: int = None,
        request_id: str = None,
        result_status: str = None,
        total_count: int = None,
    ):
        self.current_count = current_count
        self.file_name = file_name
        self.gmt_create = gmt_create
        self.id = id
        self.link = link
        self.progress = progress
        self.request_id = request_id
        self.result_status = result_status
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_status is not None:
            result['ResultStatus'] = self.result_status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultStatus') is not None:
            self.result_status = m.get('ResultStatus')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeHcExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHcExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHcExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHoneyPotAuthRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeHoneyPotAuthResponseBody(TeaModel):
    def __init__(
        self,
        honey_pot_auth_count: int = None,
        honey_pot_count: int = None,
        request_id: str = None,
    ):
        self.honey_pot_auth_count = honey_pot_auth_count
        self.honey_pot_count = honey_pot_count
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honey_pot_auth_count is not None:
            result['HoneyPotAuthCount'] = self.honey_pot_auth_count
        if self.honey_pot_count is not None:
            result['HoneyPotCount'] = self.honey_pot_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneyPotAuthCount') is not None:
            self.honey_pot_auth_count = m.get('HoneyPotAuthCount')
        if m.get('HoneyPotCount') is not None:
            self.honey_pot_count = m.get('HoneyPotCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeHoneyPotAuthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHoneyPotAuthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHoneyPotAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHoneyPotSuspStatisticsRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        statistics_days: int = None,
        statistics_key_type: str = None,
    ):
        self.from_ = from_
        self.lang = lang
        self.statistics_days = statistics_days
        self.statistics_key_type = statistics_key_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.statistics_days is not None:
            result['StatisticsDays'] = self.statistics_days
        if self.statistics_key_type is not None:
            result['StatisticsKeyType'] = self.statistics_key_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StatisticsDays') is not None:
            self.statistics_days = m.get('StatisticsDays')
        if m.get('StatisticsKeyType') is not None:
            self.statistics_key_type = m.get('StatisticsKeyType')
        return self


class DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse(TeaModel):
    def __init__(
        self,
        count: int = None,
        instance_id: str = None,
        instance_name: str = None,
        type: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        self.count = count
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.type = type
        self.vpc_id = vpc_id
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.type is not None:
            result['Type'] = self.type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class DescribeHoneyPotSuspStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        susp_honey_pot_statistics_response: List[DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse] = None,
    ):
        self.request_id = request_id
        self.susp_honey_pot_statistics_response = susp_honey_pot_statistics_response

    def validate(self):
        if self.susp_honey_pot_statistics_response:
            for k in self.susp_honey_pot_statistics_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspHoneyPotStatisticsResponse'] = []
        if self.susp_honey_pot_statistics_response is not None:
            for k in self.susp_honey_pot_statistics_response:
                result['SuspHoneyPotStatisticsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_honey_pot_statistics_response = []
        if m.get('SuspHoneyPotStatisticsResponse') is not None:
            for k in m.get('SuspHoneyPotStatisticsResponse'):
                temp_model = DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse()
                self.susp_honey_pot_statistics_response.append(temp_model.from_map(k))
        return self


class DescribeHoneyPotSuspStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHoneyPotSuspStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHoneyPotSuspStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRequest(TeaModel):
    def __init__(
        self,
        image_instance_id: str = None,
        image_region_id: str = None,
        image_repo_id: str = None,
        image_tag: str = None,
    ):
        # The instance ID of the image.
        # 
        # >  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of instances.
        self.image_instance_id = image_instance_id
        # The region ID of the image.
        # 
        # >  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of regions.
        self.image_region_id = image_region_id
        # The ID of the image repository.
        # 
        # >  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of image repositories.
        self.image_repo_id = image_repo_id
        # The tag that is added to the image.
        # 
        # >  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query tags.
        self.image_tag = image_tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_instance_id is not None:
            result['ImageInstanceId'] = self.image_instance_id
        if self.image_region_id is not None:
            result['ImageRegionId'] = self.image_region_id
        if self.image_repo_id is not None:
            result['ImageRepoId'] = self.image_repo_id
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageInstanceId') is not None:
            self.image_instance_id = m.get('ImageInstanceId')
        if m.get('ImageRegionId') is not None:
            self.image_region_id = m.get('ImageRegionId')
        if m.get('ImageRepoId') is not None:
            self.image_repo_id = m.get('ImageRepoId')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        return self


class DescribeImageResponseBodyData(TeaModel):
    def __init__(
        self,
        digest: str = None,
    ):
        # The digest value of the image.
        self.digest = digest

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        return self


class DescribeImageResponseBody(TeaModel):
    def __init__(
        self,
        data: DescribeImageResponseBodyData = None,
        request_id: str = None,
    ):
        # The information about the image digest.
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeImageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineCheckResultRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        risk_level: str = None,
        scan_range: List[str] = None,
    ):
        self.criteria = criteria
        self.criteria_type = criteria_type
        self.current_page = current_page
        self.image_uuid = image_uuid
        self.lang = lang
        self.page_size = page_size
        self.risk_level = risk_level
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageBaselineCheckResultResponseBodyBaselineResult(TeaModel):
    def __init__(
        self,
        baseline_class_alias: str = None,
        baseline_item_count: int = None,
        baseline_name_alias: str = None,
        baseline_name_key: str = None,
        baseline_name_level: str = None,
        first_scan_time: int = None,
        high_risk_item_count: int = None,
        last_scan_time: int = None,
        low_risk_item_count: int = None,
        middle_risk_item_count: int = None,
        status: int = None,
    ):
        self.baseline_class_alias = baseline_class_alias
        self.baseline_item_count = baseline_item_count
        self.baseline_name_alias = baseline_name_alias
        self.baseline_name_key = baseline_name_key
        self.baseline_name_level = baseline_name_level
        self.first_scan_time = first_scan_time
        self.high_risk_item_count = high_risk_item_count
        self.last_scan_time = last_scan_time
        self.low_risk_item_count = low_risk_item_count
        self.middle_risk_item_count = middle_risk_item_count
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_item_count is not None:
            result['BaselineItemCount'] = self.baseline_item_count
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.baseline_name_level is not None:
            result['BaselineNameLevel'] = self.baseline_name_level
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.high_risk_item_count is not None:
            result['HighRiskItemCount'] = self.high_risk_item_count
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_item_count is not None:
            result['LowRiskItemCount'] = self.low_risk_item_count
        if self.middle_risk_item_count is not None:
            result['MiddleRiskItemCount'] = self.middle_risk_item_count
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineItemCount') is not None:
            self.baseline_item_count = m.get('BaselineItemCount')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('BaselineNameLevel') is not None:
            self.baseline_name_level = m.get('BaselineNameLevel')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('HighRiskItemCount') is not None:
            self.high_risk_item_count = m.get('HighRiskItemCount')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskItemCount') is not None:
            self.low_risk_item_count = m.get('LowRiskItemCount')
        if m.get('MiddleRiskItemCount') is not None:
            self.middle_risk_item_count = m.get('MiddleRiskItemCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageBaselineCheckResultResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineCheckResultResponseBody(TeaModel):
    def __init__(
        self,
        baseline_result: List[DescribeImageBaselineCheckResultResponseBodyBaselineResult] = None,
        page_info: DescribeImageBaselineCheckResultResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.baseline_result = baseline_result
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.baseline_result:
            for k in self.baseline_result:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineResult'] = []
        if self.baseline_result is not None:
            for k in self.baseline_result:
                result['BaselineResult'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.baseline_result = []
        if m.get('BaselineResult') is not None:
            for k in m.get('BaselineResult'):
                temp_model = DescribeImageBaselineCheckResultResponseBodyBaselineResult()
                self.baseline_result.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineCheckResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineCheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageBaselineCheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineCheckSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        risk_level: str = None,
        scan_range: List[str] = None,
    ):
        # The number of images on which **low** baseline risks are detected.
        self.cluster_id = cluster_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.criteria = criteria
        # The severity of the image baseline that you want to query. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.criteria_type = criteria_type
        # The number of images on which **medium** baseline risks are detected.
        self.current_page = current_page
        # An array that consists of the check results of image baselines.
        self.lang = lang
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.page_size = page_size
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.risk_level = risk_level
        # The keyword of the baseline category.
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary(TeaModel):
    def __init__(
        self,
        baseline_class_alias: str = None,
        baseline_class_key: str = None,
        baseline_name_alias: str = None,
        baseline_name_key: str = None,
        baseline_name_level: str = None,
        first_scan_time: int = None,
        high_risk_image: int = None,
        last_scan_time: int = None,
        low_risk_image: int = None,
        middle_risk_image: int = None,
        status: int = None,
    ):
        self.baseline_class_alias = baseline_class_alias
        self.baseline_class_key = baseline_class_key
        self.baseline_name_alias = baseline_name_alias
        self.baseline_name_key = baseline_name_key
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.baseline_name_level = baseline_name_level
        self.first_scan_time = first_scan_time
        # DescribeImageBaselineCheckSummary
        self.high_risk_image = high_risk_image
        # Queries the check results of image baselines that are included in an image scan task.
        self.last_scan_time = last_scan_time
        self.low_risk_image = low_risk_image
        # The number of entries returned per page. Default value: **20**.
        self.middle_risk_image = middle_risk_image
        # The number of entries to return on each page. Default value: **20**.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.baseline_name_level is not None:
            result['BaselineNameLevel'] = self.baseline_name_level
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.high_risk_image is not None:
            result['HighRiskImage'] = self.high_risk_image
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_image is not None:
            result['LowRiskImage'] = self.low_risk_image
        if self.middle_risk_image is not None:
            result['MiddleRiskImage'] = self.middle_risk_image
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('BaselineNameLevel') is not None:
            self.baseline_name_level = m.get('BaselineNameLevel')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('HighRiskImage') is not None:
            self.high_risk_image = m.get('HighRiskImage')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskImage') is not None:
            self.low_risk_image = m.get('LowRiskImage')
        if m.get('MiddleRiskImage') is not None:
            self.middle_risk_image = m.get('MiddleRiskImage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageBaselineCheckSummaryResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The pagination information.
        self.count = count
        # The type of the search condition. Valid values:
        # 
        # *   **BaselineNameAlias**: baseline name
        # *   **BaselineClassAlias**: baseline category
        self.current_page = current_page
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~182997~~) operation to query the IDs of container clusters.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineCheckSummaryResponseBody(TeaModel):
    def __init__(
        self,
        baseline_result_summary: List[DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary] = None,
        page_info: DescribeImageBaselineCheckSummaryResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The name of the baseline.
        self.baseline_result_summary = baseline_result_summary
        # The search condition for the image baseline.
        self.page_info = page_info
        # The types of the assets that you want to scan.
        self.request_id = request_id

    def validate(self):
        if self.baseline_result_summary:
            for k in self.baseline_result_summary:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineResultSummary'] = []
        if self.baseline_result_summary is not None:
            for k in self.baseline_result_summary:
                result['BaselineResultSummary'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.baseline_result_summary = []
        if m.get('BaselineResultSummary') is not None:
            for k in m.get('BaselineResultSummary'):
                temp_model = DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary()
                self.baseline_result_summary.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineCheckSummaryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineCheckSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageBaselineCheckSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineDetailRequest(TeaModel):
    def __init__(
        self,
        baseline_item_key: str = None,
        image_uuid: str = None,
        lang: str = None,
    ):
        self.baseline_item_key = baseline_item_key
        self.image_uuid = image_uuid
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeImageBaselineDetailResponseBodyBaselineDetail(TeaModel):
    def __init__(
        self,
        advice: str = None,
        baseline_class_alias: str = None,
        baseline_item_alias: str = None,
        baseline_item_key: str = None,
        baseline_name_alias: str = None,
        description: str = None,
        level: str = None,
        prompt: str = None,
        result_id: str = None,
    ):
        self.advice = advice
        self.baseline_class_alias = baseline_class_alias
        self.baseline_item_alias = baseline_item_alias
        self.baseline_item_key = baseline_item_key
        self.baseline_name_alias = baseline_name_alias
        self.description = description
        self.level = level
        self.prompt = prompt
        self.result_id = result_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_item_alias is not None:
            result['BaselineItemAlias'] = self.baseline_item_alias
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.description is not None:
            result['Description'] = self.description
        if self.level is not None:
            result['Level'] = self.level
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.result_id is not None:
            result['ResultId'] = self.result_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineItemAlias') is not None:
            self.baseline_item_alias = m.get('BaselineItemAlias')
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ResultId') is not None:
            self.result_id = m.get('ResultId')
        return self


class DescribeImageBaselineDetailResponseBody(TeaModel):
    def __init__(
        self,
        baseline_detail: DescribeImageBaselineDetailResponseBodyBaselineDetail = None,
        request_id: str = None,
    ):
        self.baseline_detail = baseline_detail
        self.request_id = request_id

    def validate(self):
        if self.baseline_detail:
            self.baseline_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_detail is not None:
            result['BaselineDetail'] = self.baseline_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineDetail') is not None:
            temp_model = DescribeImageBaselineDetailResponseBodyBaselineDetail()
            self.baseline_detail = temp_model.from_map(m['BaselineDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageBaselineDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineItemListRequest(TeaModel):
    def __init__(
        self,
        baseline_class_key: str = None,
        baseline_name_key: str = None,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        scan_range: List[str] = None,
        status: str = None,
        uuids: List[str] = None,
    ):
        # The key of the baseline type.
        self.baseline_class_key = baseline_class_key
        # The key of the baseline name.
        self.baseline_name_key = baseline_name_key
        # The number of the page to return.
        self.current_page = current_page
        # The UUID of the image.
        self.image_uuid = image_uuid
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page.
        self.page_size = page_size
        # The types of the assets that are scanned.
        self.scan_range = scan_range
        # The status of the baseline risk item. Valid values:
        # 
        # *   **0**: unfixed
        # *   **1**: fixed
        # *   **2**: pending verification
        # *   **3**: fixing failed
        self.status = status
        # The UUIDs of images.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.status is not None:
            result['Status'] = self.status
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageBaselineItemListResponseBodyBaselineItemInfos(TeaModel):
    def __init__(
        self,
        baseline_class_alias: str = None,
        baseline_class_key: str = None,
        baseline_item_alias: str = None,
        baseline_item_key: str = None,
        baseline_name_alias: str = None,
        baseline_name_key: str = None,
        status: int = None,
        white_list: int = None,
    ):
        # The alias of the baseline type.
        self.baseline_class_alias = baseline_class_alias
        # The key of the baseline type.
        self.baseline_class_key = baseline_class_key
        # The alias of the baseline check item.
        self.baseline_item_alias = baseline_item_alias
        # The key of the baseline check item.
        self.baseline_item_key = baseline_item_key
        # The alias of the baseline.
        self.baseline_name_alias = baseline_name_alias
        # The key of the baseline name.
        self.baseline_name_key = baseline_name_key
        # The status of the baseline risk item. Valid values:
        # 
        # *   **0**: unfixed
        # *   **1**: fixed
        # *   **2**: pending verification
        # *   **3**: fixing failed
        self.status = status
        # Indicates whether the baseline check item is added to the whitelist. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_item_alias is not None:
            result['BaselineItemAlias'] = self.baseline_item_alias
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.status is not None:
            result['Status'] = self.status
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineItemAlias') is not None:
            self.baseline_item_alias = m.get('BaselineItemAlias')
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class DescribeImageBaselineItemListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineItemListResponseBody(TeaModel):
    def __init__(
        self,
        baseline_item_infos: List[DescribeImageBaselineItemListResponseBodyBaselineItemInfos] = None,
        page_info: DescribeImageBaselineItemListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of baseline check items.
        self.baseline_item_infos = baseline_item_infos
        # The pagination information.
        self.page_info = page_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.baseline_item_infos:
            for k in self.baseline_item_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineItemInfos'] = []
        if self.baseline_item_infos is not None:
            for k in self.baseline_item_infos:
                result['BaselineItemInfos'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.baseline_item_infos = []
        if m.get('BaselineItemInfos') is not None:
            for k in m.get('BaselineItemInfos'):
                temp_model = DescribeImageBaselineItemListResponseBodyBaselineItemInfos()
                self.baseline_item_infos.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineItemListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineItemListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageBaselineItemListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineItemListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: int = None,
    ):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList(TeaModel):
    def __init__(
        self,
        class_key: str = None,
        item_key: str = None,
        name_key: str = None,
    ):
        # The key of the baseline type.
        self.class_key = class_key
        # The key of the baseline check item.
        self.item_key = item_key
        # The key of the name for the baseline.
        self.name_key = name_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.item_key is not None:
            result['ItemKey'] = self.item_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('ItemKey') is not None:
            self.item_key = m.get('ItemKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeImageBaselineStrategyResponseBodyStrategy(TeaModel):
    def __init__(
        self,
        baseline_item_list: List[DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList] = None,
        selected_item_count: int = None,
        strategy_id: int = None,
        strategy_name: str = None,
        total_item_count: int = None,
        type: str = None,
    ):
        # An array that contains the baselines.
        self.baseline_item_list = baseline_item_list
        # The number of selected baseline check items.
        self.selected_item_count = selected_item_count
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id
        # The name of the baseline check policy.
        self.strategy_name = strategy_name
        # The total number of baseline check items.
        self.total_item_count = total_item_count
        # The type of the baseline check policy. Valid values:
        # 
        # *   **default**: the default policy
        # *   **full**: a policy that uses all baselines
        # *   **normal**: a policy that uses general baselines
        self.type = type

    def validate(self):
        if self.baseline_item_list:
            for k in self.baseline_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineItemList'] = []
        if self.baseline_item_list is not None:
            for k in self.baseline_item_list:
                result['BaselineItemList'].append(k.to_map() if k else None)
        if self.selected_item_count is not None:
            result['SelectedItemCount'] = self.selected_item_count
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        if self.total_item_count is not None:
            result['TotalItemCount'] = self.total_item_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.baseline_item_list = []
        if m.get('BaselineItemList') is not None:
            for k in m.get('BaselineItemList'):
                temp_model = DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList()
                self.baseline_item_list.append(temp_model.from_map(k))
        if m.get('SelectedItemCount') is not None:
            self.selected_item_count = m.get('SelectedItemCount')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        if m.get('TotalItemCount') is not None:
            self.total_item_count = m.get('TotalItemCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageBaselineStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy: DescribeImageBaselineStrategyResponseBodyStrategy = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # An array that consists of the information about the baseline check policy.
        self.strategy = strategy

    def validate(self):
        if self.strategy:
            self.strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategy') is not None:
            temp_model = DescribeImageBaselineStrategyResponseBodyStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        return self


class DescribeImageBaselineStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageBaselineStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageCriteriaRequest(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeImageCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeImageCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeImageCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageFixTaskRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        page_size: int = None,
        start_time: int = None,
        status: str = None,
    ):
        # The number of the page to return. Default value: **1**\
        self.current_page = current_page
        # The timestamp when the task ends. Unit: milliseconds.
        self.end_time = end_time
        # The number of entries to return on each page. Default value: **20**\
        self.page_size = page_size
        # The timestamp when the task starts. Unit: milliseconds.
        self.start_time = start_time
        # The status of the task. Valid values:
        # 
        # *   **1**: The task is running.
        # *   **2**: The task is successful.
        # *   **3**: The task failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageFixTaskResponseBodyBuildTasks(TeaModel):
    def __init__(
        self,
        build_task_id: str = None,
        finish_time: str = None,
        fix_time: str = None,
        new_tag: str = None,
        new_uuid: str = None,
        old_tag: str = None,
        old_uuid: str = None,
        region_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        status: int = None,
        task_type: str = None,
        vul_alias: str = None,
    ):
        # The ID of the task.
        self.build_task_id = build_task_id
        # The timestamp when the task starts. Unit: milliseconds.
        self.finish_time = finish_time
        # The timestamp when the task ends. Unit: milliseconds.
        self.fix_time = fix_time
        # The version of the image after image risks are fixed.
        self.new_tag = new_tag
        # The UUID of the image after image risks are fixed.
        self.new_uuid = new_uuid
        # The version of the image.
        self.old_tag = old_tag
        # The UUID of the image.
        self.old_uuid = old_uuid
        # The region of the image.
        self.region_id = region_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace of the image.
        self.repo_namespace = repo_namespace
        # The status of the task. Valid values:
        # 
        # *   **1**: The task is running.
        # *   **2**: The task is successful.
        # *   **3**: The task failed.
        self.status = status
        # The type of the task. The value is fixed as IMAGE_REPAIR. The value indicates a task that fixes image risks.
        self.task_type = task_type
        # The alias of the fixed vulnerability.
        self.vul_alias = vul_alias

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_task_id is not None:
            result['BuildTaskId'] = self.build_task_id
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fix_time is not None:
            result['FixTime'] = self.fix_time
        if self.new_tag is not None:
            result['NewTag'] = self.new_tag
        if self.new_uuid is not None:
            result['NewUuid'] = self.new_uuid
        if self.old_tag is not None:
            result['OldTag'] = self.old_tag
        if self.old_uuid is not None:
            result['OldUuid'] = self.old_uuid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.status is not None:
            result['Status'] = self.status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.vul_alias is not None:
            result['VulAlias'] = self.vul_alias
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildTaskId') is not None:
            self.build_task_id = m.get('BuildTaskId')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FixTime') is not None:
            self.fix_time = m.get('FixTime')
        if m.get('NewTag') is not None:
            self.new_tag = m.get('NewTag')
        if m.get('NewUuid') is not None:
            self.new_uuid = m.get('NewUuid')
        if m.get('OldTag') is not None:
            self.old_tag = m.get('OldTag')
        if m.get('OldUuid') is not None:
            self.old_uuid = m.get('OldUuid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('VulAlias') is not None:
            self.vul_alias = m.get('VulAlias')
        return self


class DescribeImageFixTaskResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of tasks returned on the current page.
        self.count = count
        # The page number of the returned page. Default value: **1**\
        self.current_page = current_page
        # The number of entries returned per page. Default value: **20**\
        self.page_size = page_size
        # The total number of tasks returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageFixTaskResponseBody(TeaModel):
    def __init__(
        self,
        build_tasks: List[DescribeImageFixTaskResponseBodyBuildTasks] = None,
        page_info: DescribeImageFixTaskResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The tasks returned.
        self.build_tasks = build_tasks
        # The pagination information.
        self.page_info = page_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.build_tasks:
            for k in self.build_tasks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BuildTasks'] = []
        if self.build_tasks is not None:
            for k in self.build_tasks:
                result['BuildTasks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.build_tasks = []
        if m.get('BuildTasks') is not None:
            for k in m.get('BuildTasks'):
                temp_model = DescribeImageFixTaskResponseBodyBuildTasks()
                self.build_tasks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageFixTaskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageFixTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageFixTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageFixTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageGroupedVulListRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        cluster_id: str = None,
        current_page: int = None,
        cve_id: str = None,
        group_id: str = None,
        image_digest: str = None,
        image_layer: str = None,
        image_tag: str = None,
        is_latest: int = None,
        lang: str = None,
        name: str = None,
        necessity: str = None,
        page_size: int = None,
        patch_id: int = None,
        repo_id: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_region_id: str = None,
        scan_range: List[str] = None,
        type: str = None,
        uuids: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The ID of the container cluster.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the ID of the container cluster.
        self.cluster_id = cluster_id
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.
        self.cve_id = cve_id
        # The ID of the asset group.
        self.group_id = group_id
        # The SHA-256 value of the image digest.
        self.image_digest = image_digest
        # The layer of the image.
        self.image_layer = image_layer
        # The tag of the image.
        self.image_tag = image_tag
        # Specifies whether to query the vulnerabilities in the latest images. If you do not specify this parameter, the vulnerabilities in all images are queried. Valid values:
        # 
        # *   **0**: does not query the vulnerabilities in the latest images.
        # *   **1**: queries the vulnerabilities in the latest images.
        self.is_latest = is_latest
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The name of the vulnerability.
        self.name = name
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # The ID of the patch that is used to fix the vulnerability.
        self.patch_id = patch_id
        # The ID of the image repository.
        self.repo_id = repo_id
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id
        # An array consisting of the types of the assets that you want to scan.
        self.scan_range = scan_range
        # The type of the vulnerability that you want to query. Valid values:
        # 
        # *   **cve**: image system vulnerability
        # *   **sca**: image application vulnerability
        self.type = type
        # The UUID of the asset. Separate multiple UUIDs with commas (,).
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.is_latest is not None:
            result['IsLatest'] = self.is_latest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.patch_id is not None:
            result['PatchId'] = self.patch_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('IsLatest') is not None:
            self.is_latest = m.get('IsLatest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PatchId') is not None:
            self.patch_id = m.get('PatchId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageGroupedVulListResponseBodyGroupedVulItems(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        asap_count: int = None,
        can_fix: str = None,
        gmt_last: int = None,
        last_scan_time: int = None,
        later_count: int = None,
        name: str = None,
        nntf_count: int = None,
        status: int = None,
        tags: str = None,
        type: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The number of vulnerabilities that have the high priority.
        self.asap_count = asap_count
        self.can_fix = can_fix
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.gmt_last = gmt_last
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_scan_time = last_scan_time
        # The number of vulnerabilities that have the medium priority.
        self.later_count = later_count
        # The name of the vulnerability.
        self.name = name
        # The number of vulnerabilities that have the low priority.
        self.nntf_count = nntf_count
        # The status of the vulnerability. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: verifying
        # *   **3**: added to the whitelist
        self.status = status
        # The tag of the vulnerability. Valid values:
        # 
        # *   Restart required
        # *   Remote exploitation
        # *   Exploit exists
        # *   Exploitable
        # *   Privilege escalation
        # *   Code execution
        self.tags = tags
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: image system vulnerability
        # *   **sca**: image application vulnerability
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.can_fix is not None:
            result['CanFix'] = self.can_fix
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('CanFix') is not None:
            self.can_fix = m.get('CanFix')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageGroupedVulListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        grouped_vul_items: List[DescribeImageGroupedVulListResponseBodyGroupedVulItems] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # An array that consists of the image vulnerabilities.
        self.grouped_vul_items = grouped_vul_items
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of image system vulnerabilities.
        self.total_count = total_count

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeImageGroupedVulListResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageGroupedVulListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageGroupedVulListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageGroupedVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageInfoListRequest(TeaModel):
    def __init__(
        self,
        uuids: str = None,
    ):
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageInfoListResponseBodyImageInfos(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        alarm_status: str = None,
        digest: str = None,
        endpoints: str = None,
        image_create: int = None,
        image_id: str = None,
        image_size: int = None,
        image_update: int = None,
        instance_id: str = None,
        region_id: str = None,
        registry_type: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_type: str = None,
        risk_status: str = None,
        status: str = None,
        tag: str = None,
        tag_immutable: int = None,
        uuid: str = None,
        vul_count: int = None,
        vul_status: str = None,
    ):
        self.alarm_count = alarm_count
        self.alarm_status = alarm_status
        self.digest = digest
        self.endpoints = endpoints
        self.image_create = image_create
        self.image_id = image_id
        self.image_size = image_size
        self.image_update = image_update
        self.instance_id = instance_id
        self.region_id = region_id
        self.registry_type = registry_type
        self.repo_id = repo_id
        self.repo_name = repo_name
        self.repo_namespace = repo_namespace
        self.repo_type = repo_type
        self.risk_status = risk_status
        self.status = status
        self.tag = tag
        self.tag_immutable = tag_immutable
        self.uuid = uuid
        self.vul_count = vul_count
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_immutable is not None:
            result['TagImmutable'] = self.tag_immutable
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagImmutable') is not None:
            self.tag_immutable = m.get('TagImmutable')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageInfoListResponseBody(TeaModel):
    def __init__(
        self,
        image_infos: List[DescribeImageInfoListResponseBodyImageInfos] = None,
        request_id: str = None,
    ):
        self.image_infos = image_infos
        self.request_id = request_id

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageInfoListResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageInfoListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageInfoListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageInfoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageInstancesRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        current_page: int = None,
        logical_exp: str = None,
        page_size: int = None,
        scanned: bool = None,
    ):
        # The search condition that is used to filter the server. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **name**: the search condition
        # 
        # *   **name**: the value of the search condition
        # 
        # *   **logicalExp**: the logical relation for multiple search conditions Valid values:
        # 
        #     *   **OR**: The search conditions use a logical **OR**.
        #     *   **AND**: The search conditions use a logical **AND**.
        # 
        # > You can call the [DescribeImageCriteria](~~DescribeImageCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page
        # The logical relationship that you want to use to evaluate multiple search conditions. Valid values:
        # 
        # *   **OR**: The search conditions are evaluated by using a logical **OR**.
        # *   **AND**: The search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > : We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # Specifies whether the image is scanned. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.scanned = scanned

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scanned is not None:
            result['Scanned'] = self.scanned
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Scanned') is not None:
            self.scanned = m.get('Scanned')
        return self


class DescribeImageInstancesResponseBodyImageInstanceList(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        alarm_status: str = None,
        deployed: int = None,
        digest: str = None,
        endpoints: str = None,
        hc_count: int = None,
        hc_status: str = None,
        image_create: str = None,
        image_id: str = None,
        image_size: str = None,
        image_update: str = None,
        instance_id: str = None,
        region_id: str = None,
        registry_type: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_type: str = None,
        risk_status: str = None,
        sca_progress: int = None,
        sca_result: str = None,
        sca_status: str = None,
        status: str = None,
        tag: str = None,
        uuid: str = None,
        vul_count: int = None,
        vul_status: str = None,
    ):
        # The number of alerts that are generated on the image.
        self.alarm_count = alarm_count
        # Indicates whether alerts are generated for the image. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status
        # Indicates whether the image was deployed. Valid values:
        # 
        # *   **0**: The image was not deployed.
        # *   **1**: The image was deployed.
        self.deployed = deployed
        # The digest value of the image.
        self.digest = digest
        # The address of the image.
        self.endpoints = endpoints
        # The number of baseline risks.
        self.hc_count = hc_count
        # Indicates whether the image baseline risks exist. Valid values:
        # 
        # *   **NO**\
        # *   **YES**\
        self.hc_status = hc_status
        # The timestamp when the image was created. Unit: milliseconds.
        self.image_create = image_create
        # The ID of the image.
        self.image_id = image_id
        # The size of the image. Unit: MB.
        self.image_size = image_size
        # The timestamp when the image was updated. Unit: milliseconds.
        self.image_update = image_update
        # The ID of the image instance.
        self.instance_id = instance_id
        # The region ID of the image.
        self.region_id = region_id
        # The type of the image. Valid values:
        # 
        # *   **acr**\
        # *   **harbor**\
        # *   **quay**\
        # *   **CI/CD**\
        self.registry_type = registry_type
        # The ID of the image repository.
        self.repo_id = repo_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The type of the repository. Valid values:
        # 
        # *   **private**\
        # *   **public**\
        self.repo_type = repo_type
        # Indicates whether risks exist. Valid values:
        # 
        # *   **NO**: No risks exist.
        # *   **YES**: Risks exist.
        self.risk_status = risk_status
        # The scan progress of the image. Valid values: 0 to 100.
        self.sca_progress = sca_progress
        # The error code of the image scan result. Valid values:
        # 
        # *   **TASK_NOT_EXISTS**: The image scan task does not exist.
        # *   **TASK_NOT_SUPPORT_REGION**: The image scan task cannot be performed in the current region.
        # *   **forbid_create_repeat_task**: The image scan task already exists.
        self.sca_result = sca_result
        # The scan status of the image. Valid values:
        # 
        # *   **INIT**: The image scan task is to be started.
        # *   **START**: The image scan task is started.
        # *   **MESSAGE_SEND**: The message about the image scan task is sent.
        # *   **START_RUN**: The image scan task is started.
        # *   **DOWNLOAD**: The image scan result is downloaded.
        # *   **PRE_ANALYZER**: The image scan task is being processed.
        # *   **WEB_SHELL_ANALYZER**: The WebShell analysis is complete.
        # *   **CVE_ANALYZER**: The CVE analysis is complete.
        # *   **BIN_ANALYZER**: The binary analysis of the image is complete.
        # *   **OTHER_ANALYZER**: The extended analysis of the image is complete.
        # *   **SUCCESS**: The image scan task is complete.
        # *   **PRE_ANALYZER_SUCCESS**: The image scan task is processed.
        # *   **FAIL**: The image scan task fails.
        # *   **TIMEOUT**: The image scan task times out.
        self.sca_status = sca_status
        # The status of the image. Valid values:
        # 
        # *   **NORMAL**: The image is normal.
        self.status = status
        # The tag of the image.
        self.tag = tag
        # The UUID of the server.
        self.uuid = uuid
        # The number of vulnerabilities in the image.
        self.vul_count = vul_count
        # Indicates whether vulnerabilities exist in the image. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.deployed is not None:
            result['Deployed'] = self.deployed
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.sca_progress is not None:
            result['ScaProgress'] = self.sca_progress
        if self.sca_result is not None:
            result['ScaResult'] = self.sca_result
        if self.sca_status is not None:
            result['ScaStatus'] = self.sca_status
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Deployed') is not None:
            self.deployed = m.get('Deployed')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('ScaProgress') is not None:
            self.sca_progress = m.get('ScaProgress')
        if m.get('ScaResult') is not None:
            self.sca_result = m.get('ScaResult')
        if m.get('ScaStatus') is not None:
            self.sca_status = m.get('ScaStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of images returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageInstancesResponseBody(TeaModel):
    def __init__(
        self,
        image_instance_list: List[DescribeImageInstancesResponseBodyImageInstanceList] = None,
        page_info: DescribeImageInstancesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the information about the image.
        self.image_instance_list = image_instance_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.image_instance_list:
            for k in self.image_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInstanceList'] = []
        if self.image_instance_list is not None:
            for k in self.image_instance_list:
                result['ImageInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_instance_list = []
        if m.get('ImageInstanceList') is not None:
            for k in m.get('ImageInstanceList'):
                temp_model = DescribeImageInstancesResponseBodyImageInstanceList()
                self.image_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageLatestScanTaskRequest(TeaModel):
    def __init__(
        self,
        digest: str = None,
    ):
        self.digest = digest

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        return self


class DescribeImageLatestScanTaskResponseBodyTask(TeaModel):
    def __init__(
        self,
        create: str = None,
        finish: int = None,
        finish_time: int = None,
        id: int = None,
        modified: str = None,
        name: str = None,
        source: str = None,
        start_time: int = None,
        status: str = None,
        target: str = None,
        target_type: str = None,
        task_id: str = None,
        task_type: str = None,
    ):
        self.create = create
        self.finish = finish
        self.finish_time = finish_time
        self.id = id
        self.modified = modified
        self.name = name
        self.source = source
        self.start_time = start_time
        self.status = status
        self.target = target
        self.target_type = target_type
        self.task_id = task_id
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create is not None:
            result['Create'] = self.create
        if self.finish is not None:
            result['Finish'] = self.finish
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modified is not None:
            result['Modified'] = self.modified
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Create') is not None:
            self.create = m.get('Create')
        if m.get('Finish') is not None:
            self.finish = m.get('Finish')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Modified') is not None:
            self.modified = m.get('Modified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeImageLatestScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task: List[DescribeImageLatestScanTaskResponseBodyTask] = None,
    ):
        self.request_id = request_id
        self.task = task

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = DescribeImageLatestScanTaskResponseBodyTask()
                self.task.append(temp_model.from_map(k))
        return self


class DescribeImageLatestScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageLatestScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageLatestScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageListBySensitiveFileRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        image_digest: str = None,
        lang: str = None,
        page_size: int = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        risk_level: str = None,
        scan_range: List[str] = None,
        sensitive_file_key: str = None,
    ):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page
        # The image digest.
        # > Fuzzy match is supported.
        self.image_digest = image_digest
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size
        # The ID of the container image.
        # 
        # > You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of container images from the value of the InstanceId response parameter.
        self.repo_instance_id = repo_instance_id
        # The name of the image repository.
        # 
        # > Fuzzy match is supported.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        # > Fuzzy match is supported.
        self.repo_namespace = repo_namespace
        # The risk level of the file. Separate multiple levels with commas (,). Valid values:
        # 
        # - **high**\
        # - **medium**\
        # - **low**\
        self.risk_level = risk_level
        # An array consisting of the types of the assets that you want to scan. Valid values:
        # - **image**\
        # - **container**\
        self.scan_range = scan_range
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google\_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github\_ssh_key**: Github SSH Key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN Token
        # *   **ssh\_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel\_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord\_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws\_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker\_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec\_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s\_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh\_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common\_database_cfg**: Common Database Config
        # *   **wordpress\_database_cfg**: Wordpress Database Config
        # *   **googlecloud\_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful\_preview_token**: Contentful Preview Token
        # *   **php\_database_cfg**: PHP Database Config
        # *   **atom\_remote_sync**: Atom Remote Sync Config
        # *   **aws\_session_token**: AWS Session Token
        # *   **atom\_sftp_cfg**: Atom SFTP Config
        # *   **asana\_client\_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa\_private_key**: RSA Private Key
        # *   **github\_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver\_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github\_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: macOS Keychain
        # *   **amazon\_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes\_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp\_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github\_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs\_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab\_personal_token**: GitLab Personal Token
        # *   **rails\_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun\_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp\_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github\_app_token**: Github App Token
        # *   **hashicorp\_vault_token**: Hashicorp Vault Token
        # *   **pgp\_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common\_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix\_web_passwd**: Phoenix Web Credential
        # *   **puttygen\_private_key**: PuTTYgen Private Key
        # *   **google\_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob\_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr\_private_key**: OTR Private Key
        # *   **contentful\_delivery_token**: Contentful Delivery Token
        # *   **digital\_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa\_private_key**: DSA Private Key
        # *   **rails\_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic\_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.sensitive_file_key = sensitive_file_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageListBySensitiveFileShrinkRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        image_digest: str = None,
        lang: str = None,
        page_size: int = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        risk_level: str = None,
        scan_range_shrink: str = None,
        sensitive_file_key: str = None,
    ):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page
        # The image digest.
        # > Fuzzy match is supported.
        self.image_digest = image_digest
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size
        # The ID of the container image.
        # 
        # > You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of container images from the value of the InstanceId response parameter.
        self.repo_instance_id = repo_instance_id
        # The name of the image repository.
        # 
        # > Fuzzy match is supported.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        # > Fuzzy match is supported.
        self.repo_namespace = repo_namespace
        # The risk level of the file. Separate multiple levels with commas (,). Valid values:
        # 
        # - **high**\
        # - **medium**\
        # - **low**\
        self.risk_level = risk_level
        # An array consisting of the types of the assets that you want to scan. Valid values:
        # - **image**\
        # - **container**\
        self.scan_range_shrink = scan_range_shrink
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google\_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github\_ssh_key**: Github SSH Key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN Token
        # *   **ssh\_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel\_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord\_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws\_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker\_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec\_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s\_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh\_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common\_database_cfg**: Common Database Config
        # *   **wordpress\_database_cfg**: Wordpress Database Config
        # *   **googlecloud\_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful\_preview_token**: Contentful Preview Token
        # *   **php\_database_cfg**: PHP Database Config
        # *   **atom\_remote_sync**: Atom Remote Sync Config
        # *   **aws\_session_token**: AWS Session Token
        # *   **atom\_sftp_cfg**: Atom SFTP Config
        # *   **asana\_client\_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa\_private_key**: RSA Private Key
        # *   **github\_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver\_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github\_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: macOS Keychain
        # *   **amazon\_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes\_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp\_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github\_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs\_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab\_personal_token**: GitLab Personal Token
        # *   **rails\_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun\_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp\_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github\_app_token**: Github App Token
        # *   **hashicorp\_vault_token**: Hashicorp Vault Token
        # *   **pgp\_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common\_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix\_web_passwd**: Phoenix Web Credential
        # *   **puttygen\_private_key**: PuTTYgen Private Key
        # *   **google\_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob\_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr\_private_key**: OTR Private Key
        # *   **contentful\_delivery_token**: Contentful Delivery Token
        # *   **digital\_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa\_private_key**: DSA Private Key
        # *   **rails\_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic\_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.sensitive_file_key = sensitive_file_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageListBySensitiveFileResponseBodyImageInfos(TeaModel):
    def __init__(
        self,
        digest: str = None,
        first_scan_time: int = None,
        instance_id: str = None,
        last_scan_time: int = None,
        region_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        risk_level: str = None,
        tag: str = None,
        uuid: str = None,
    ):
        # The image digest.
        self.digest = digest
        # The UNIX timestamp of when the first scan was performed. Unit: milliseconds.
        self.first_scan_time = first_scan_time
        # The ID of the image instance.
        self.instance_id = instance_id
        # The UNIX timestamp of when the last scan was performed. Unit: milliseconds.
        self.last_scan_time = last_scan_time
        # The region ID of the image instance.
        self.region_id = region_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The risk level. Valid values:
        # - **high**\
        # - **medium**\
        # - **low**\
        self.risk_level = risk_level
        # The tag that is added to the image.
        self.tag = tag
        # The UUID of the image.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageListBySensitiveFileResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        last_row_key: str = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The key of the last data entry.
        self.last_row_key = last_row_key
        # The number of entries returned per page. Default value: 20.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageListBySensitiveFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        image_infos: List[DescribeImageListBySensitiveFileResponseBodyImageInfos] = None,
        message: str = None,
        page_info: DescribeImageListBySensitiveFileResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The HTTP status code.
        self.http_status_code = http_status_code
        # An array that consists of the information about the images.
        self.image_infos = image_infos
        # The error message returned.
        self.message = message
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageListBySensitiveFileResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageListBySensitiveFileResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageListBySensitiveFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageListBySensitiveFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageListBySensitiveFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageListWithBaselineNameRequest(TeaModel):
    def __init__(
        self,
        baseline_name_key: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        image: str = None,
        image_digest: str = None,
        lang: str = None,
        namespace: str = None,
        page_size: int = None,
        pod: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        scan_range: List[str] = None,
    ):
        # The name of the image baseline.
        self.baseline_name_key = baseline_name_key
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The ID of the container.
        self.container_id = container_id
        # The search condition for the image baseline.
        self.criteria = criteria
        # The type of the search condition. Valid values:
        # 
        # *   **BaselineNameAlias**: baseline name
        # *   **BaselineClassAlias**: baseline category
        self.criteria_type = criteria_type
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The name of the image to which the container belongs.
        self.image = image
        # The SHA-256 value of the image digest.
        self.image_digest = image_digest
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The namespace.
        self.namespace = namespace
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The pod.
        self.pod = pod
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The types of the assets that you want to scan.
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageListWithBaselineNameResponseBodyImageInfos(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        digest: str = None,
        high_risk_image: int = None,
        image: str = None,
        image_create: int = None,
        image_id: str = None,
        image_size: int = None,
        image_update: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        last_scan_time: int = None,
        low_risk_image: int = None,
        middle_risk_image: int = None,
        namespace: str = None,
        no_risk_image: int = None,
        pod: str = None,
        region_id: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_type: str = None,
        risk_status: str = None,
        tag: str = None,
        target_id: str = None,
        target_name: str = None,
        target_type: str = None,
        total_item_count: int = None,
        uuid: str = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The ID of the container.
        self.container_id = container_id
        # The SHA-256 value of the image digest.
        self.digest = digest
        # The number of images on which **high** baseline risks are detected.
        self.high_risk_image = high_risk_image
        # The name of the image.
        self.image = image
        # The timestamp when the image was created. Unit: milliseconds.
        self.image_create = image_create
        # The ID of the image.
        self.image_id = image_id
        # The size of the image.
        self.image_size = image_size
        # The timestamp when the image was updated. Unit: milliseconds.
        self.image_update = image_update
        # The ID of the image instance.
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.last_scan_time = last_scan_time
        # The number of images on which **low** baseline risks are detected.
        self.low_risk_image = low_risk_image
        # The number of images on which **medium** baseline risks are detected.
        self.middle_risk_image = middle_risk_image
        # The namespace.
        self.namespace = namespace
        # The number of images that do not have baseline risks.
        self.no_risk_image = no_risk_image
        # The pod.
        self.pod = pod
        # The region ID of the image instance.
        self.region_id = region_id
        # The ID of the image repository.
        self.repo_id = repo_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The type of the image repository.
        self.repo_type = repo_type
        # Indicates whether the image is at risk. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.risk_status = risk_status
        # The version of the image.
        self.tag = tag
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type
        # The total number of risk items that are detected on the image by using the baseline.
        self.total_item_count = total_item_count
        # The UUID of the image.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.high_risk_image is not None:
            result['HighRiskImage'] = self.high_risk_image
        if self.image is not None:
            result['Image'] = self.image
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_image is not None:
            result['LowRiskImage'] = self.low_risk_image
        if self.middle_risk_image is not None:
            result['MiddleRiskImage'] = self.middle_risk_image
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_risk_image is not None:
            result['NoRiskImage'] = self.no_risk_image
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.total_item_count is not None:
            result['TotalItemCount'] = self.total_item_count
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('HighRiskImage') is not None:
            self.high_risk_image = m.get('HighRiskImage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskImage') is not None:
            self.low_risk_image = m.get('LowRiskImage')
        if m.get('MiddleRiskImage') is not None:
            self.middle_risk_image = m.get('MiddleRiskImage')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoRiskImage') is not None:
            self.no_risk_image = m.get('NoRiskImage')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TotalItemCount') is not None:
            self.total_item_count = m.get('TotalItemCount')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageListWithBaselineNameResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of the images returned on the current page.
        self.count = count
        # The page number of the returned page. Default value: **1**.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size
        # The total number of images on which baseline risks are detected.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageListWithBaselineNameResponseBody(TeaModel):
    def __init__(
        self,
        image_infos: List[DescribeImageListWithBaselineNameResponseBodyImageInfos] = None,
        page_info: DescribeImageListWithBaselineNameResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the images returned.
        self.image_infos = image_infos
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageListWithBaselineNameResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageListWithBaselineNameResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageListWithBaselineNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageListWithBaselineNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageListWithBaselineNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoCriteriaRequest(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageRepoCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeImageRepoCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeImageRepoCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeImageRepoCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageRepoCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoDetailListRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        current_page: int = None,
        logical_exp: str = None,
        page_size: int = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.criteria = criteria
        # The pagination information.
        self.current_page = current_page
        # The data returned.
        self.logical_exp = logical_exp
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeImageRepoDetailListResponseBodyImageRepoResponses(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        alarm_status: str = None,
        endpoints: str = None,
        hc_count: int = None,
        hc_status: str = None,
        image_count: int = None,
        instance_id: str = None,
        region_id: str = None,
        registry_type: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        risk_status: str = None,
        vul_count: int = None,
        vul_status: str = None,
    ):
        # The number of images.
        self.alarm_count = alarm_count
        # The region ID of the image.
        self.alarm_status = alarm_status
        # Indicates whether alerts are generated for the image repository. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.endpoints = endpoints
        # The number of alerts that are generated for the image repository.
        self.hc_count = hc_count
        # The namespace to which the image repository belongs.
        self.hc_status = hc_status
        self.image_count = image_count
        # The number of baseline risk items on the image repository.
        self.instance_id = instance_id
        # The number of vulnerabilities detected on the image repository.
        self.region_id = region_id
        # The ID of the image repository.
        self.registry_type = registry_type
        # Indicates whether baseline risk items are detected on the image repository. Valid values:
        # 
        # *   **NO**\
        # *   **YES**\
        self.repo_id = repo_id
        self.repo_name = repo_name
        self.repo_namespace = repo_namespace
        # The type of the image repository. Valid values:
        # 
        # *   **acr**\
        # *   **harbor**\
        # *   **quay**\
        # *   **CI/CD**\
        self.risk_status = risk_status
        # The name of the image repository.
        self.vul_count = vul_count
        # The ID of the image.
        self.vul_status = vul_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageRepoDetailListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The address of the image repository.
        self.count = count
        # The number of entries returned on the current page.
        self.current_page = current_page
        # An array that consists of the information about image repositories.
        self.page_size = page_size
        # The information about the image repository.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageRepoDetailListResponseBody(TeaModel):
    def __init__(
        self,
        image_repo_responses: List[DescribeImageRepoDetailListResponseBodyImageRepoResponses] = None,
        page_info: DescribeImageRepoDetailListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # Indicates whether the image repository is at risk. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.image_repo_responses = image_repo_responses
        # The total number of image repositories.
        self.page_info = page_info
        # The number of entries returned per page.
        self.request_id = request_id

    def validate(self):
        if self.image_repo_responses:
            for k in self.image_repo_responses:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageRepoResponses'] = []
        if self.image_repo_responses is not None:
            for k in self.image_repo_responses:
                result['ImageRepoResponses'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_repo_responses = []
        if m.get('ImageRepoResponses') is not None:
            for k in m.get('ImageRepoResponses'):
                temp_model = DescribeImageRepoDetailListResponseBodyImageRepoResponses()
                self.image_repo_responses.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageRepoDetailListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoDetailListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageRepoDetailListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoDetailListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        field_name: str = None,
        field_value: str = None,
        operate_type: str = None,
        page_size: int = None,
        repo_name: str = None,
        repo_namespace: str = None,
        target_type: str = None,
        type: str = None,
    ):
        # The type of the feature. Valid values:
        # 
        # *   **image_repo**: image repository protection
        self.current_page = current_page
        # Indicates whether the feature takes effect on the image repository. Valid values:
        # 
        # *   **add**: yes
        # *   **del**: no
        self.field_name = field_name
        # The namespace to which the image repository belongs.
        self.field_value = field_value
        # The pagination information.
        self.operate_type = operate_type
        # The type of the operation. Valid values:
        # 
        # *   **count**: counts statistics
        # *   **other**: others
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.repo_name = repo_name
        # The name of the image repository.
        self.repo_namespace = repo_namespace
        # The total number of image repositories.
        self.target_type = target_type
        # The information about the image repository.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageRepoListResponseBodyImageRepoList(TeaModel):
    def __init__(
        self,
        flag: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
    ):
        self.flag = flag
        self.repo_name = repo_name
        self.repo_namespace = repo_namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        return self


class DescribeImageRepoListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # Queries the statistics and configurations of the feature that protects images.
        self.count = count
        # The namespace to which the image repository belongs.
        self.current_page = current_page
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.page_size = page_size
        # The name of the image repository.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageRepoListResponseBody(TeaModel):
    def __init__(
        self,
        add_target_count: int = None,
        all_target_count: int = None,
        del_target_count: int = None,
        image_repo_list: List[DescribeImageRepoListResponseBodyImageRepoList] = None,
        page_info: DescribeImageRepoListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the information about image repositories.
        self.add_target_count = add_target_count
        # The number of the page to return. Default value: **1**.
        self.all_target_count = all_target_count
        # The condition by which the feature is applied. Valid values:
        # 
        # *   **image_repo**: the ID of the image repository
        self.del_target_count = del_target_count
        # DescribeImageRepoList
        self.image_repo_list = image_repo_list
        # The number of entries returned per page.
        self.page_info = page_info
        # The number of image repositories that are added to Security Center.
        self.request_id = request_id

    def validate(self):
        if self.image_repo_list:
            for k in self.image_repo_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_target_count is not None:
            result['AddTargetCount'] = self.add_target_count
        if self.all_target_count is not None:
            result['AllTargetCount'] = self.all_target_count
        if self.del_target_count is not None:
            result['DelTargetCount'] = self.del_target_count
        result['ImageRepoList'] = []
        if self.image_repo_list is not None:
            for k in self.image_repo_list:
                result['ImageRepoList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddTargetCount') is not None:
            self.add_target_count = m.get('AddTargetCount')
        if m.get('AllTargetCount') is not None:
            self.all_target_count = m.get('AllTargetCount')
        if m.get('DelTargetCount') is not None:
            self.del_target_count = m.get('DelTargetCount')
        self.image_repo_list = []
        if m.get('ImageRepoList') is not None:
            for k in m.get('ImageRepoList'):
                temp_model = DescribeImageRepoListResponseBodyImageRepoList()
                self.image_repo_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageRepoListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageRepoListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageScanAuthCountResponseBodyImageScan(TeaModel):
    def __init__(
        self,
        image_scan_capacity: int = None,
        instance_id: str = None,
        scan_count: int = None,
    ):
        self.image_scan_capacity = image_scan_capacity
        self.instance_id = instance_id
        self.scan_count = scan_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_capacity is not None:
            result['ImageScanCapacity'] = self.image_scan_capacity
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.scan_count is not None:
            result['ScanCount'] = self.scan_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageScanCapacity') is not None:
            self.image_scan_capacity = m.get('ImageScanCapacity')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ScanCount') is not None:
            self.scan_count = m.get('ScanCount')
        return self


class DescribeImageScanAuthCountResponseBody(TeaModel):
    def __init__(
        self,
        image_scan: DescribeImageScanAuthCountResponseBodyImageScan = None,
        request_id: str = None,
    ):
        self.image_scan = image_scan
        self.request_id = request_id

    def validate(self):
        if self.image_scan:
            self.image_scan.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan is not None:
            result['ImageScan'] = self.image_scan.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageScan') is not None:
            temp_model = DescribeImageScanAuthCountResponseBodyImageScan()
            self.image_scan = temp_model.from_map(m['ImageScan'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageScanAuthCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageScanAuthCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageScanAuthCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageScanAuthorizationResponseBodyAuthStatus(TeaModel):
    def __init__(
        self,
        status: bool = None,
    ):
        # Indicates whether Security Center is authorized to scan images. Valid values:
        # * **true**: yes 
        # * **false**: no
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageScanAuthorizationResponseBody(TeaModel):
    def __init__(
        self,
        auth_status: DescribeImageScanAuthorizationResponseBodyAuthStatus = None,
        request_id: str = None,
    ):
        # The authorization status of image scans.
        self.auth_status = auth_status
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.auth_status:
            self.auth_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_status is not None:
            result['AuthStatus'] = self.auth_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthStatus') is not None:
            temp_model = DescribeImageScanAuthorizationResponseBodyAuthStatus()
            self.auth_status = temp_model.from_map(m['AuthStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageScanAuthorizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageScanAuthorizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageScanAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSensitiveFileByKeyRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        scan_range: List[str] = None,
        sensitive_file_key: str = None,
    ):
        # The key of the last data entry.
        self.current_page = current_page
        # The error message returned.
        self.image_uuid = image_uuid
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.lang = lang
        # The HTTP status code returned.
        self.page_size = page_size
        # The number of entries to return on each page. Default value: **20**.
        self.scan_range = scan_range
        # The digest of the image layer.
        self.sensitive_file_key = sensitive_file_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageSensitiveFileByKeyShrinkRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        scan_range_shrink: str = None,
        sensitive_file_key: str = None,
    ):
        # The key of the last data entry.
        self.current_page = current_page
        # The error message returned.
        self.image_uuid = image_uuid
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.lang = lang
        # The HTTP status code returned.
        self.page_size = page_size
        # The number of entries to return on each page. Default value: **20**.
        self.scan_range_shrink = scan_range_shrink
        # The digest of the image layer.
        self.sensitive_file_key = sensitive_file_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageSensitiveFileByKeyResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        last_row_key: str = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.current_page = current_page
        self.last_row_key = last_row_key
        # Queries the sensitive files in an image.
        self.page_size = page_size
        # DescribeImageSensitiveFileByKey
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList(TeaModel):
    def __init__(
        self,
        advice: str = None,
        file_path: str = None,
        first_scan_time: int = None,
        last_scan_time: int = None,
        layer_digest: str = None,
        promt: str = None,
        risk_level: str = None,
        sensitive_file_key: str = None,
        sensitive_file_name: str = None,
    ):
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.advice = advice
        # The UUID of the image.
        self.file_path = file_path
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github_ssh_key**: Github SSH Key
        # *   **msbuild_publish_profile**: MSBuild publish profile
        # *   **fastly_cdn_token**: Fastly CDN Token
        # *   **ssh_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common_database_cfg**: Common Database Config
        # *   **wordpress_database_cfg**: Wordpress Database Config
        # *   **googlecloud_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful_preview_token**: Contentful Preview Token
        # *   **php_database_cfg**: PHP Database Config
        # *   **atom_remote_sync**: Atom Remote Sync Config
        # *   **aws_session_token**: AWS Session Token
        # *   **atom_sftp_cfg**: Atom SFTP Config
        # *   **asana_client_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa_private_key**: RSA Private Key
        # *   **github_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: MacOS Keychain
        # *   **amazon_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab_personal_token**: GitLab Personal Token
        # *   **rails_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github_app_token**: Github App Token
        # *   **hashicorp_vault_token**: Hashicorp Vault Token
        # *   **pgp_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix_web_passwd**: Phoenix Web Credential
        # *   **puttygen_private_key**: PuTTYgen Private Key
        # *   **google_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr_private_key**: OTR Private Key
        # *   **contentful_delivery_token**: Contentful Delivery Token
        # *   **digital_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa_private_key**: DSA Private Key
        # *   **rails_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.first_scan_time = first_scan_time
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.last_scan_time = last_scan_time
        # The type of the asset that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.layer_digest = layer_digest
        # The number of entries returned on the current page.
        self.promt = promt
        # The suggestion.
        self.risk_level = risk_level
        # The pagination information.
        self.sensitive_file_key = sensitive_file_key
        # The alert type name of the sensitive file.
        self.sensitive_file_name = sensitive_file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.layer_digest is not None:
            result['LayerDigest'] = self.layer_digest
        if self.promt is not None:
            result['Promt'] = self.promt
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        if self.sensitive_file_name is not None:
            result['SensitiveFileName'] = self.sensitive_file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LayerDigest') is not None:
            self.layer_digest = m.get('LayerDigest')
        if m.get('Promt') is not None:
            self.promt = m.get('Promt')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        if m.get('SensitiveFileName') is not None:
            self.sensitive_file_name = m.get('SensitiveFileName')
        return self


class DescribeImageSensitiveFileByKeyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        page_info: DescribeImageSensitiveFileByKeyResponseBodyPageInfo = None,
        request_id: str = None,
        sensitive_file_list: List[DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList] = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        # The risk level of the sensitive file. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.page_info = page_info
        self.request_id = request_id
        # An array that consists of the sensitive files.
        self.sensitive_file_list = sensitive_file_list
        self.success = success

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.sensitive_file_list:
            for k in self.sensitive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveFileList'] = []
        if self.sensitive_file_list is not None:
            for k in self.sensitive_file_list:
                result['SensitiveFileList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageSensitiveFileByKeyResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_file_list = []
        if m.get('SensitiveFileList') is not None:
            for k in m.get('SensitiveFileList'):
                temp_model = DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList()
                self.sensitive_file_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageSensitiveFileByKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageSensitiveFileByKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSensitiveFileByKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSensitiveFileListRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        risk_level: str = None,
        scan_range: List[str] = None,
    ):
        # The value of the sensitive file type.
        self.criteria = criteria
        # The number of scans that are performed on the sensitive file.
        self.criteria_type = criteria_type
        # The UUID of the image.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.
        self.current_page = current_page
        # The query type of sensitive files. Valid values:
        # 
        # *   **SensitiveFileKey**: the alert type for sensitive files. Valid values:
        # 
        #     *   **npm_token**: npm access token
        #     *   **ftp_cfg**: FTP configuration
        #     *   **google_oauth_key**: Google OAuth key
        #     *   **planetscale_passwd**: PlanetScale password
        #     *   **github_ssh_key**: GitHub SSH key
        #     *   **msbuild_publish_profile**: MSBuild publish profile
        #     *   **fastly_cdn_token**: Fastly CDN token
        #     *   **ssh_private_key**: SSH private key
        #     *   **aws_cli**: AWS CLI credential
        #     *   **cpanel_proftpd**: cPanel ProFTPD credential
        #     *   **postgresql_passwd**: PostgreSQL password file
        #     *   **discord_client_cred**: Discord client credential
        #     *   **rails_database**: Rails database configuration
        #     *   **aws_access_key**: AWS access key
        #     *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
        #     *   **docker_registry_cfg**: configuration of a Docker image repository
        #     *   **pem**: Privacy-Enhanced Mail (PEM)
        #     *   **common_cred**: common credential
        #     *   **sftp_cfg**: SFTP connection configuration
        #     *   **grafana_token**: Grafana token
        #     *   **slack_token**: Slack token
        #     *   **ec_private_key**: EC private key
        #     *   **pypi_token**: upload token for the Python Package Index (PyPI)
        #     *   **finicity_token**: Finicity token
        #     *   **k8s_client_key**: Kubernetes private key
        #     *   **git_cfg**: Git configuration
        #     *   **django_key**: Django key
        #     *   **jenkins_ssh**: Jenkins SSH configuration file
        #     *   **openssh_private_key**: OpenSSL private key
        #     *   **square_oauth**: OAuth credential for Square
        #     *   **typeform_token**: Typeform token
        #     *   **common_database_cfg**: general database connection configuration
        #     *   **wordpress_database_cfg**: WordPress database configuration
        #     *   **googlecloud_api_key**: API key for Google Cloud
        #     *   **vscode_sftp**: VSCode SFTP configuration
        #     *   **apache_htpasswd**: Apache htpasswd
        #     *   **planetscale_token**: PlanetScale token
        #     *   **contentful_preview_token**: preview token for Contentful
        #     *   **php_database_cfg**: database password for a PHP application
        #     *   **atom_remote_sync**: Atom remote synchronization configuration
        #     *   **aws_session_token**: AWS session token
        #     *   **atom_sftp_cfg**: Atom SFTP configuration
        #     *   **tencentcloud_ak**: Asana client key
        #     *   **tencentcloud_ak**: secret ID of a third-party cloud
        #     *   **rsa_private_key**: RSA private key
        #     *   **github_personal_token**: personal access token for GitHub
        #     *   **pgp**: Pretty Good Privacy (PGP) encrypted file
        #     *   **stripe_skpk**: Stripe secret key
        #     *   **square_token**: Square access token
        #     *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        #     *   **dbeaver_database_cfg**: DBeaver database configuration
        #     *   **robomongo_cred**: credential for RoboMongo
        #     *   **github_oauth_token**: OAuth access token for GitHub
        #     *   **pulumi_token**: Pulumi token
        #     *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        #     *   **macos_keychain**: macOS keychain
        #     *   **amazon_mws_token**: Amazon MWS token
        #     *   **dynatrace_token**: Dynatrace token
        #     *   **java_keystore**: Java KeyStore (JKS)
        #     *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
        #     *   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard
        #     *   **atlassian_token**: Atlassian token
        #     *   **rdp**: remote desktop protocol (RDP)
        #     *   **mailgun_key**: Mailgun webhook signing key
        #     *   **mailchimp_api_key**: API key for Mailchimp
        #     *   **netrc_cfg**: .netrc configuration file
        #     *   **openvpn_cfg**: OpenVPN configuration
        #     *   **github_refresh_token**: GitHub refresh token
        #     *   **salesforce**: Salesforce credential
        #     *   **salesforce**: Sendinblue credential
        #     *   **pkcs_private_key**: PKCS#12 key
        #     *   **rubyonrails_passwd**: Ruby on Rails password file
        #     *   **filezilla_ftp**: FileZilla FTP configuration
        #     *   **databricks_token**: Databricks token
        #     *   **gitLab_personal_toke**: personal access token for GitLab
        #     *   **rails_master_key**: Rails master key
        #     *   **sqlite**: SQLite3 or SQLite database
        #     *   **firefox_logins**: Firefox logon configuration
        #     *   **mailgun_private_token**: Mailgun private token
        #     *   **joomla_cfg**: Joomla configuration
        #     *   **hashicorp_terraform_token**: HashiCorp Terraform token
        #     *   **jetbrains_ides**: JetBrains IDEs configuration
        #     *   **heroku_api_key**: Heroku API key
        #     *   **messagebird_token**: MessageBird token
        #     *   **messagebird_token**: MessageBird token
        #     *   **hashicorp_vault_token**: HashiCorp Vault token
        #     *   **pgp_private_key**: PGP private key
        #     *   **sshpasswd**: SSH password
        #     *   **huaweicloud_ak**: secret access key of a third-party cloud
        #     *   **aws_s3cmd**: AWS S3cmd configuration
        #     *   **php_config**: PHP configuration
        #     *   **common_private_key**: private key of a common type
        #     *   **microsoft_mdf**: Microsoft SQL Server database
        #     *   **mediawiki_cfg**: MediaWiki configuration
        #     *   **jenkins_cred**: Jenkins credential
        #     *   **rubygems_cred**: RubyGems credential
        #     *   **clojars_token**: Clojars token
        #     *   **phoenix_web_passwd**: Phoenix web credential
        #     *   **puttygen_private_key**: PuTTYgen private key
        #     *   **google_oauth_token**: Google OAuth access token
        #     *   **rubyonrails_cfg**: Ruby On Rails database configuration
        #     *   **lob_api_key**: Lob API key
        #     *   **pkcs_cred**: PKCS#12 certificate
        #     *   **otr_private_key**: Off-the-Record Messaging (OTR) private key
        #     *   **contentful_delivery_token**: delivery token for Contentful
        #     *   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
        #     *   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
        #     *   **rails_app_token**: Rails app token
        #     *   **git_cred**: Git user credential
        #     *   **newrelic_api_key**: User API key for New Relic
        #     *   **github_hub**: hub configuration for storing GitHub tokens
        #     *   **rubygem**: RubyGem token
        # 
        # *   **SensitiveFileName**: the name of the alert type for sensitive files.
        self.image_uuid = image_uuid
        # An array that consists of the information about the sensitive files.
        self.lang = lang
        # The returned information about the sensitive files.
        self.page_size = page_size
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.risk_level = risk_level
        # The key of the last data entry.
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageSensitiveFileListShrinkRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        image_uuid: str = None,
        lang: str = None,
        page_size: int = None,
        risk_level: str = None,
        scan_range_shrink: str = None,
    ):
        # The value of the sensitive file type.
        self.criteria = criteria
        # The number of scans that are performed on the sensitive file.
        self.criteria_type = criteria_type
        # The UUID of the image.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.
        self.current_page = current_page
        # The query type of sensitive files. Valid values:
        # 
        # *   **SensitiveFileKey**: the alert type for sensitive files. Valid values:
        # 
        #     *   **npm_token**: npm access token
        #     *   **ftp_cfg**: FTP configuration
        #     *   **google_oauth_key**: Google OAuth key
        #     *   **planetscale_passwd**: PlanetScale password
        #     *   **github_ssh_key**: GitHub SSH key
        #     *   **msbuild_publish_profile**: MSBuild publish profile
        #     *   **fastly_cdn_token**: Fastly CDN token
        #     *   **ssh_private_key**: SSH private key
        #     *   **aws_cli**: AWS CLI credential
        #     *   **cpanel_proftpd**: cPanel ProFTPD credential
        #     *   **postgresql_passwd**: PostgreSQL password file
        #     *   **discord_client_cred**: Discord client credential
        #     *   **rails_database**: Rails database configuration
        #     *   **aws_access_key**: AWS access key
        #     *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
        #     *   **docker_registry_cfg**: configuration of a Docker image repository
        #     *   **pem**: Privacy-Enhanced Mail (PEM)
        #     *   **common_cred**: common credential
        #     *   **sftp_cfg**: SFTP connection configuration
        #     *   **grafana_token**: Grafana token
        #     *   **slack_token**: Slack token
        #     *   **ec_private_key**: EC private key
        #     *   **pypi_token**: upload token for the Python Package Index (PyPI)
        #     *   **finicity_token**: Finicity token
        #     *   **k8s_client_key**: Kubernetes private key
        #     *   **git_cfg**: Git configuration
        #     *   **django_key**: Django key
        #     *   **jenkins_ssh**: Jenkins SSH configuration file
        #     *   **openssh_private_key**: OpenSSL private key
        #     *   **square_oauth**: OAuth credential for Square
        #     *   **typeform_token**: Typeform token
        #     *   **common_database_cfg**: general database connection configuration
        #     *   **wordpress_database_cfg**: WordPress database configuration
        #     *   **googlecloud_api_key**: API key for Google Cloud
        #     *   **vscode_sftp**: VSCode SFTP configuration
        #     *   **apache_htpasswd**: Apache htpasswd
        #     *   **planetscale_token**: PlanetScale token
        #     *   **contentful_preview_token**: preview token for Contentful
        #     *   **php_database_cfg**: database password for a PHP application
        #     *   **atom_remote_sync**: Atom remote synchronization configuration
        #     *   **aws_session_token**: AWS session token
        #     *   **atom_sftp_cfg**: Atom SFTP configuration
        #     *   **tencentcloud_ak**: Asana client key
        #     *   **tencentcloud_ak**: secret ID of a third-party cloud
        #     *   **rsa_private_key**: RSA private key
        #     *   **github_personal_token**: personal access token for GitHub
        #     *   **pgp**: Pretty Good Privacy (PGP) encrypted file
        #     *   **stripe_skpk**: Stripe secret key
        #     *   **square_token**: Square access token
        #     *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        #     *   **dbeaver_database_cfg**: DBeaver database configuration
        #     *   **robomongo_cred**: credential for RoboMongo
        #     *   **github_oauth_token**: OAuth access token for GitHub
        #     *   **pulumi_token**: Pulumi token
        #     *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        #     *   **macos_keychain**: macOS keychain
        #     *   **amazon_mws_token**: Amazon MWS token
        #     *   **dynatrace_token**: Dynatrace token
        #     *   **java_keystore**: Java KeyStore (JKS)
        #     *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
        #     *   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard
        #     *   **atlassian_token**: Atlassian token
        #     *   **rdp**: remote desktop protocol (RDP)
        #     *   **mailgun_key**: Mailgun webhook signing key
        #     *   **mailchimp_api_key**: API key for Mailchimp
        #     *   **netrc_cfg**: .netrc configuration file
        #     *   **openvpn_cfg**: OpenVPN configuration
        #     *   **github_refresh_token**: GitHub refresh token
        #     *   **salesforce**: Salesforce credential
        #     *   **salesforce**: Sendinblue credential
        #     *   **pkcs_private_key**: PKCS#12 key
        #     *   **rubyonrails_passwd**: Ruby on Rails password file
        #     *   **filezilla_ftp**: FileZilla FTP configuration
        #     *   **databricks_token**: Databricks token
        #     *   **gitLab_personal_toke**: personal access token for GitLab
        #     *   **rails_master_key**: Rails master key
        #     *   **sqlite**: SQLite3 or SQLite database
        #     *   **firefox_logins**: Firefox logon configuration
        #     *   **mailgun_private_token**: Mailgun private token
        #     *   **joomla_cfg**: Joomla configuration
        #     *   **hashicorp_terraform_token**: HashiCorp Terraform token
        #     *   **jetbrains_ides**: JetBrains IDEs configuration
        #     *   **heroku_api_key**: Heroku API key
        #     *   **messagebird_token**: MessageBird token
        #     *   **messagebird_token**: MessageBird token
        #     *   **hashicorp_vault_token**: HashiCorp Vault token
        #     *   **pgp_private_key**: PGP private key
        #     *   **sshpasswd**: SSH password
        #     *   **huaweicloud_ak**: secret access key of a third-party cloud
        #     *   **aws_s3cmd**: AWS S3cmd configuration
        #     *   **php_config**: PHP configuration
        #     *   **common_private_key**: private key of a common type
        #     *   **microsoft_mdf**: Microsoft SQL Server database
        #     *   **mediawiki_cfg**: MediaWiki configuration
        #     *   **jenkins_cred**: Jenkins credential
        #     *   **rubygems_cred**: RubyGems credential
        #     *   **clojars_token**: Clojars token
        #     *   **phoenix_web_passwd**: Phoenix web credential
        #     *   **puttygen_private_key**: PuTTYgen private key
        #     *   **google_oauth_token**: Google OAuth access token
        #     *   **rubyonrails_cfg**: Ruby On Rails database configuration
        #     *   **lob_api_key**: Lob API key
        #     *   **pkcs_cred**: PKCS#12 certificate
        #     *   **otr_private_key**: Off-the-Record Messaging (OTR) private key
        #     *   **contentful_delivery_token**: delivery token for Contentful
        #     *   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
        #     *   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
        #     *   **rails_app_token**: Rails app token
        #     *   **git_cred**: Git user credential
        #     *   **newrelic_api_key**: User API key for New Relic
        #     *   **github_hub**: hub configuration for storing GitHub tokens
        #     *   **rubygem**: RubyGem token
        # 
        # *   **SensitiveFileName**: the name of the alert type for sensitive files.
        self.image_uuid = image_uuid
        # An array that consists of the information about the sensitive files.
        self.lang = lang
        # The returned information about the sensitive files.
        self.page_size = page_size
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.risk_level = risk_level
        # The key of the last data entry.
        self.scan_range_shrink = scan_range_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        return self


class DescribeImageSensitiveFileListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        last_row_key: str = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.current_page = current_page
        self.last_row_key = last_row_key
        # Queries information about sensitive files.
        self.page_size = page_size
        # DescribeImageSensitiveFileList
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSensitiveFileListResponseBodySensitiveFileList(TeaModel):
    def __init__(
        self,
        count: int = None,
        first_scan_time: int = None,
        last_scan_time: int = None,
        risk_level: str = None,
        sensitive_file_key: str = None,
        sensitive_file_name: str = None,
    ):
        # The type of the asset that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.count = count
        # The alert type for the sensitive file. Valid values:
        # 
        # *   **npm_token**: npm access token
        # *   **ftp_cfg**: FTP configuration
        # *   **google_oauth_key**: Google OAuth key
        # *   **planetscale_passwd**: PlanetScale password
        # *   **github_ssh_key**: GitHub SSH key
        # *   **msbuild_publish_profile**: MSBuild publish profile
        # *   **fastly_cdn_token**: Fastly CDN token
        # *   **ssh_private_key**: SSH private key
        # *   **aws_cli**: AWS CLI credential
        # *   **cpanel_proftpd**: cPanel ProFTPD credential
        # *   **postgresql_passwd**: PostgreSQL password file
        # *   **discord_client_cred**: Discord client credential
        # *   **rails_database**: Rails database configuration
        # *   **aws_access_key**: AWS access key
        # *   **esmtp_cfg** :configuration of ESMTP
        # *   **docker_registry_cfg**: configuration of a Docker image repository
        # *   **pem**: PEM
        # *   **common_cred**: common credential
        # *   **sftp_cfg**: SFTP connection configuration
        # *   **grafana_token**: Grafana token
        # *   **slack_token**: Slack token
        # *   **ec_private_key**: EC private key
        # *   **pypi_token**: upload token for the PyPI
        # *   **finicity_token**: Finicity token
        # *   **k8s_client_key**: Kubernetes private key
        # *   **git_cfg**: Git configuration
        # *   **django_key**: Django key
        # *   **jenkins_ssh**: Jenkins SSH configuration file
        # *   **openssh_private_key**: OpenSSL private key
        # *   **square_oauth**: OAuth credential for Square
        # *   **typeform_token**: Typeform token
        # *   **common_database_cfg**: general database connection configuration
        # *   **wordpress_database_cfg**: WordPress database configuration
        # *   **googlecloud_api_key**: API key for Google Cloud
        # *   **vscode_sftp**: VSCode SFTP configuration
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: PlanetScale token
        # *   **contentful_preview_token**: preview token for Contentful
        # *   **php_database_cfg**: database password for a PHP application
        # *   **atom_remote_sync**: Atom remote synchronization configuration
        # *   **aws_session_token**: AWS session token
        # *   **atom_sftp_cfg**: Atom SFTP configuration
        # *   **tencentcloud_ak**: Asana client key
        # *   **tencentcloud_ak**: secret ID of a third-party cloud
        # *   **rsa_private_key**: RSA private key
        # *   **github_personal_token**: personal access token for GitHub
        # *   **pgp**: PGP encrypted file
        # *   **stripe_skpk**: Stripe secret key
        # *   **square_token**: Square access token
        # *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        # *   **dbeaver_database_cfg**: DBeaver database configuration
        # *   **robomongo_cred**: credential for RoboMongo
        # *   **github_oauth_token**: OAuth access token for GitHub
        # *   **pulumi_token**: Pulumi token
        # *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        # *   **macos_keychain**: macOS keychain
        # *   **amazon_mws_token**: Amazon MWS token
        # *   **dynatrace_token**: Dynatrace token
        # *   **java_keystore**: JKS
        # *   **microsoft_sdf**: Microsoft SQL Server CE database
        # *   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard
        # *   **atlassian_token**: Atlassian token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun webhook signing key
        # *   **mailchimp_api_key**: API key for Mailchimp
        # *   **netrc_cfg**: .netrc configuration file
        # *   **openvpn_cfg**: OpenVPN configuration
        # *   **github_refresh_token**: GitHub refresh token
        # *   **salesforce**: Salesforce credential
        # *   **salesforce**: Sendinblue credential
        # *   **pkcs_private_key**: PKCS#12 key
        # *   **rubyonrails_passwd**: Ruby on Rails password file
        # *   **filezilla_ftp**: FileZilla FTP configuration
        # *   **databricks_token**: Databricks token
        # *   **gitLab_personal_toke**: personal access token for GitLab
        # *   **rails_master_key**: Rails master key
        # *   **sqlite**: SQLite3 or SQLite database
        # *   **firefox_logins**: Firefox logon configuration
        # *   **mailgun_private_token**: Mailgun private token
        # *   **joomla_cfg**: Joomla configuration
        # *   **hashicorp_terraform_token**: HashiCorp Terraform token
        # *   **jetbrains_ides**: JetBrains IDEs configuration
        # *   **heroku_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird token
        # *   **messagebird_token**: MessageBird token
        # *   **hashicorp_vault_token**: HashiCorp Vault token
        # *   **pgp_private_key**: PGP private key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: secret access key of a third-party cloud
        # *   **aws_s3cmd**: AWS S3cmd configuration
        # *   **php_config**: PHP configuration
        # *   **common_private_key**: private key of a common type
        # *   **microsoft_mdf**: Microsoft SQL Server database
        # *   **mediawiki_cfg**: MediaWiki configuration
        # *   **jenkins_cred**: Jenkins credential
        # *   **rubygems_cred**: RubyGems credential
        # *   **clojars_token**: Clojars token
        # *   **phoenix_web_passwd**: Phoenix web credential
        # *   **puttygen_private_key**: PuTTYgen private key
        # *   **google_oauth_token**: Google OAuth access token
        # *   **rubyonrails_cfg**: Ruby On Rails database configuration
        # *   **lob_api_key**: Lob API key
        # *   **pkcs_cred**: PKCS#12 certificate
        # *   **otr_private_key**: OTR private key
        # *   **contentful_delivery_token**: delivery token for Contentful
        # *   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
        # *   **dsa_private_key**: Digital DSA private key
        # *   **rails_app_token**: Rails app token
        # *   **git_cred**: Git user credential
        # *   **newrelic_api_key**: User API key for New Relic
        # *   **github_hub**: hub configuration for storing GitHub tokens
        # *   **rubygem**: RubyGem token
        self.first_scan_time = first_scan_time
        # An array that consists of the types of the assets that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.last_scan_time = last_scan_time
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.risk_level = risk_level
        # The pagination information.
        self.sensitive_file_key = sensitive_file_key
        # The name of the alert type for the sensitive file.
        self.sensitive_file_name = sensitive_file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        if self.sensitive_file_name is not None:
            result['SensitiveFileName'] = self.sensitive_file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        if m.get('SensitiveFileName') is not None:
            self.sensitive_file_name = m.get('SensitiveFileName')
        return self


class DescribeImageSensitiveFileListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        page_info: DescribeImageSensitiveFileListResponseBodyPageInfo = None,
        request_id: str = None,
        sensitive_file_list: List[DescribeImageSensitiveFileListResponseBodySensitiveFileList] = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        # The risk level. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.page_info = page_info
        self.request_id = request_id
        # The number of entries to return on each page. Default value: 20.
        self.sensitive_file_list = sensitive_file_list
        self.success = success

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.sensitive_file_list:
            for k in self.sensitive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveFileList'] = []
        if self.sensitive_file_list is not None:
            for k in self.sensitive_file_list:
                result['SensitiveFileList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageSensitiveFileListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_file_list = []
        if m.get('SensitiveFileList') is not None:
            for k in m.get('SensitiveFileList'):
                temp_model = DescribeImageSensitiveFileListResponseBodySensitiveFileList()
                self.sensitive_file_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageSensitiveFileListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageSensitiveFileListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSensitiveFileListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        instance_count: int = None,
        request_id: str = None,
        risk_instance_count: int = None,
    ):
        self.instance_count = instance_count
        self.request_id = request_id
        self.risk_instance_count = risk_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        return self


class DescribeImageStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageVulListRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        current_page: int = None,
        dealed: str = None,
        digest: str = None,
        image: str = None,
        instance_id: str = None,
        lang: str = None,
        name: str = None,
        namespace: str = None,
        necessity: str = None,
        page_size: int = None,
        pod: str = None,
        region_id: str = None,
        repo_id: str = None,
        repo_instance_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_region_id: str = None,
        scan_range: List[str] = None,
        status_list: str = None,
        tag: str = None,
        type: str = None,
        uuids: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The ID of the cluster to which the container belongs.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The ID of the container.
        self.container_id = container_id
        # The number of the page to return. Default value: **1**\
        self.current_page = current_page
        # Specifies whether the vulnerability is handled. Valid values:
        # 
        # *   **y**: handled
        # *   **n**: unhandled
        self.dealed = dealed
        # The digest of the image.
        self.digest = digest
        # The name of the image.
        self.image = image
        # The instance ID of the asset.
        self.instance_id = instance_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The name of the vulnerability.
        self.name = name
        # The namespace.
        self.namespace = namespace
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity
        # The number of entries to return on each page. Default value: **10**\
        self.page_size = page_size
        # The pod.
        self.pod = pod
        # The region ID of the instance.
        self.region_id = region_id
        # The ID of the image repository.
        self.repo_id = repo_id
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id
        # The types of the assets that you want to scan.
        self.scan_range = scan_range
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **4**: being fixed
        # *   **7**: fixed
        self.status_list = status_list
        # The tag that is added to the image.
        self.tag = tag
        # The type of the vulnerability. Set the value to **cve**, which indicates image vulnerabilities.
        self.type = type
        # The UUIDs of the assets. Separate multiple UUIDs with commas (,).
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.image is not None:
            result['Image'] = self.image
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(TeaModel):
    def __init__(
        self,
        full_version: str = None,
        layer: str = None,
        match_detail: str = None,
        match_list: List[str] = None,
        name: str = None,
        path: str = None,
        update_cmd: str = None,
        version: str = None,
    ):
        # The complete version number of the package.
        self.full_version = full_version
        # The SHA-256 value of the digest of the image layer.
        self.layer = layer
        # The reason why the vulnerability is detected.
        self.match_detail = match_detail
        # The details of the rules that are used to detect the vulnerability.
        self.match_list = match_list
        # The name of the software package.
        self.name = name
        # The path to the software that has the vulnerability.
        self.path = path
        # The command that is used to fix the vulnerability.
        self.update_cmd = update_cmd
        # The version number of the package.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_version is not None:
            result['FullVersion'] = self.full_version
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.match_detail is not None:
            result['MatchDetail'] = self.match_detail
        if self.match_list is not None:
            result['MatchList'] = self.match_list
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.update_cmd is not None:
            result['UpdateCmd'] = self.update_cmd
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FullVersion') is not None:
            self.full_version = m.get('FullVersion')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('MatchDetail') is not None:
            self.match_detail = m.get('MatchDetail')
        if m.get('MatchList') is not None:
            self.match_list = m.get('MatchList')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('UpdateCmd') is not None:
            self.update_cmd = m.get('UpdateCmd')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeImageVulListResponseBodyVulRecordsExtendContentJson(TeaModel):
    def __init__(
        self,
        os: str = None,
        os_release: str = None,
        rpm_entity_list: List[DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList] = None,
    ):
        # The name of the operating system.
        self.os = os
        # The version of the operating system in the image.
        self.os_release = os_release
        # The details of the packages of the software that has the vulnerability.
        self.rpm_entity_list = rpm_entity_list

    def validate(self):
        if self.rpm_entity_list:
            for k in self.rpm_entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.os is not None:
            result['Os'] = self.os
        if self.os_release is not None:
            result['OsRelease'] = self.os_release
        result['RpmEntityList'] = []
        if self.rpm_entity_list is not None:
            for k in self.rpm_entity_list:
                result['RpmEntityList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsRelease') is not None:
            self.os_release = m.get('OsRelease')
        self.rpm_entity_list = []
        if m.get('RpmEntityList') is not None:
            for k in m.get('RpmEntityList'):
                temp_model = DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList()
                self.rpm_entity_list.append(temp_model.from_map(k))
        return self


class DescribeImageVulListResponseBodyVulRecords(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        can_fix: str = None,
        can_update: bool = None,
        cluster_id: str = None,
        cluster_name: str = None,
        container_id: str = None,
        extend_content_json: DescribeImageVulListResponseBodyVulRecordsExtendContentJson = None,
        first_ts: int = None,
        image: str = None,
        image_digest: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        last_ts: int = None,
        layers: List[str] = None,
        malicious_source: str = None,
        modify_ts: int = None,
        name: str = None,
        namespace: str = None,
        necessity: str = None,
        pod: str = None,
        primary_id: int = None,
        related: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        scan_time: int = None,
        status: int = None,
        tag: str = None,
        target_id: str = None,
        target_name: str = None,
        target_type: str = None,
        type: str = None,
        uuid: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # Indicates whether the vulnerability can be fixed in the Security Center console. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.can_fix = can_fix
        # Indicates whether the packages of the software that has the vulnerability can be upgraded by using Security Center. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.can_update = can_update
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The ID of the container.
        self.container_id = container_id
        # The extended information about the vulnerability.
        self.extend_content_json = extend_content_json
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.first_ts = first_ts
        # The name of the image.
        self.image = image
        # The digest of the image.
        self.image_digest = image_digest
        # The name of the asset.
        self.instance_name = instance_name
        # The public IP address of the server.
        self.internet_ip = internet_ip
        # The private IP address of the server.
        self.intranet_ip = intranet_ip
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_ts = last_ts
        # The image layers.
        self.layers = layers
        # The source of the malicious file. Valid values:
        # 
        # *   **agentless**: agentless detection
        # *   **image**: image
        # *   **container**: container
        self.malicious_source = malicious_source
        # The timestamp when the information about the vulnerability was updated. Unit: milliseconds.
        self.modify_ts = modify_ts
        # The name of the vulnerability.
        self.name = name
        # The namespace.
        self.namespace = namespace
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity
        # The pod.
        self.pod = pod
        # The ID of the vulnerability.
        self.primary_id = primary_id
        # The Common Vulnerabilities and Exposures (CVE) ID of the associated vulnerability.
        self.related = related
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The time at which the scan was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.scan_time = scan_time
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **7**: fixed
        self.status = status
        # The tag that is added to the vulnerability.
        self.tag = tag
        # The ID of the asset on which the vulnerability is detected.
        self.target_id = target_id
        # The name of the asset on which the vulnerability is detected.
        self.target_name = target_name
        # The type of the asset on which the vulnerability is detected. Valid values:
        # 
        # *   **ECS_IMAGE**: image
        # *   **ECS_SNAPSHOT**: snapshot
        self.target_type = target_type
        # The type of the vulnerability. The value is fixed as cve, which indicates image vulnerabilities.
        self.type = type
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        if self.extend_content_json:
            self.extend_content_json.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.can_fix is not None:
            result['CanFix'] = self.can_fix
        if self.can_update is not None:
            result['CanUpdate'] = self.can_update
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.extend_content_json is not None:
            result['ExtendContentJson'] = self.extend_content_json.to_map()
        if self.first_ts is not None:
            result['FirstTs'] = self.first_ts
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.layers is not None:
            result['Layers'] = self.layers
        if self.malicious_source is not None:
            result['MaliciousSource'] = self.malicious_source
        if self.modify_ts is not None:
            result['ModifyTs'] = self.modify_ts
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        if self.related is not None:
            result['Related'] = self.related
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.scan_time is not None:
            result['ScanTime'] = self.scan_time
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CanFix') is not None:
            self.can_fix = m.get('CanFix')
        if m.get('CanUpdate') is not None:
            self.can_update = m.get('CanUpdate')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ExtendContentJson') is not None:
            temp_model = DescribeImageVulListResponseBodyVulRecordsExtendContentJson()
            self.extend_content_json = temp_model.from_map(m['ExtendContentJson'])
        if m.get('FirstTs') is not None:
            self.first_ts = m.get('FirstTs')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('Layers') is not None:
            self.layers = m.get('Layers')
        if m.get('MaliciousSource') is not None:
            self.malicious_source = m.get('MaliciousSource')
        if m.get('ModifyTs') is not None:
            self.modify_ts = m.get('ModifyTs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        if m.get('Related') is not None:
            self.related = m.get('Related')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('ScanTime') is not None:
            self.scan_time = m.get('ScanTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageVulListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        vul_records: List[DescribeImageVulListResponseBodyVulRecords] = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **10**\
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count
        # The vulnerabilities.
        self.vul_records = vul_records

    def validate(self):
        if self.vul_records:
            for k in self.vul_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulRecords'] = []
        if self.vul_records is not None:
            for k in self.vul_records:
                result['VulRecords'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_records = []
        if m.get('VulRecords') is not None:
            for k in m.get('VulRecords'):
                temp_model = DescribeImageVulListResponseBodyVulRecords()
                self.vul_records.append(temp_model.from_map(k))
        return self


class DescribeImageVulListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageVulListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCaptchaRequest(TeaModel):
    def __init__(
        self,
        deadline: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        # The ID of the request.
        self.deadline = deadline
        # The validity period of the installation verification code. If this parameter is not specified, the validity period is 1 hour.
        # 
        # >  The installation verification code is valid only within the validity period. An expired installation verification code cannot be used to install the agent.
        self.lang = lang
        # zh
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deadline is not None:
            result['Deadline'] = self.deadline
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Deadline') is not None:
            self.deadline = m.get('Deadline')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeInstallCaptchaResponseBody(TeaModel):
    def __init__(
        self,
        captcha_code: str = None,
        deadline: str = None,
        request_id: str = None,
    ):
        # Queries the verification code for you to manually install the Security Center agent.
        self.captcha_code = captcha_code
        # The source IP address of the request.
        self.deadline = deadline
        # 192.168.XX.XX
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        if self.deadline is not None:
            result['Deadline'] = self.deadline
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        if m.get('Deadline') is not None:
            self.deadline = m.get('Deadline')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCaptchaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstallCaptchaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCaptchaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstallCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCodesResponseBodyInstallCodes(TeaModel):
    def __init__(
        self,
        captcha_code: str = None,
        expired_date: int = None,
        group_id: int = None,
        group_name: str = None,
        only_image: bool = None,
        os: str = None,
        vendor_name: str = None,
    ):
        # DescribeInstallCodes
        self.captcha_code = captcha_code
        self.expired_date = expired_date
        self.group_id = group_id
        self.group_name = group_name
        # Queries the commands that are used to manually install the Security Center Agent.
        self.only_image = only_image
        self.os = os
        self.vendor_name = vendor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        if self.expired_date is not None:
            result['ExpiredDate'] = self.expired_date
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.only_image is not None:
            result['OnlyImage'] = self.only_image
        if self.os is not None:
            result['Os'] = self.os
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        if m.get('ExpiredDate') is not None:
            self.expired_date = m.get('ExpiredDate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('OnlyImage') is not None:
            self.only_image = m.get('OnlyImage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class DescribeInstallCodesResponseBody(TeaModel):
    def __init__(
        self,
        install_codes: List[DescribeInstallCodesResponseBodyInstallCodes] = None,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.install_codes = install_codes
        # The installation verification code for you to manually install the Security Center agent.
        self.request_id = request_id

    def validate(self):
        if self.install_codes:
            for k in self.install_codes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstallCodes'] = []
        if self.install_codes is not None:
            for k in self.install_codes:
                result['InstallCodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.install_codes = []
        if m.get('InstallCodes') is not None:
            for k in m.get('InstallCodes'):
                temp_model = DescribeInstallCodesResponseBodyInstallCodes()
                self.install_codes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstallCodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAntiBruteForceRulesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        uuid_list: List[str] = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBodyRules(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        uuid: str = None,
    ):
        self.id = id
        self.name = name
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo = None,
        request_id: str = None,
        rules: List[DescribeInstanceAntiBruteForceRulesResponseBodyRules] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.rules = rules

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeInstanceAntiBruteForceRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeInstanceAntiBruteForceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceAntiBruteForceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAntiBruteForceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceRebootStatusRequest(TeaModel):
    def __init__(
        self,
        uuids: str = None,
    ):
        # Queries the status of the servers that you restart.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeInstanceRebootStatusResponseBodyRebootStatuses(TeaModel):
    def __init__(
        self,
        code: str = None,
        msg: str = None,
        reboot_status: int = None,
        uuid: str = None,
    ):
        self.code = code
        self.msg = msg
        self.reboot_status = reboot_status
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.reboot_status is not None:
            result['RebootStatus'] = self.reboot_status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RebootStatus') is not None:
            self.reboot_status = m.get('RebootStatus')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceRebootStatusResponseBody(TeaModel):
    def __init__(
        self,
        reboot_statuses: List[DescribeInstanceRebootStatusResponseBodyRebootStatuses] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.reboot_statuses = reboot_statuses
        self.request_id = request_id
        # DescribeInstanceRebootStatus
        self.total_count = total_count

    def validate(self):
        if self.reboot_statuses:
            for k in self.reboot_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RebootStatuses'] = []
        if self.reboot_statuses is not None:
            for k in self.reboot_statuses:
                result['RebootStatuses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.reboot_statuses = []
        if m.get('RebootStatuses') is not None:
            for k in m.get('RebootStatuses'):
                temp_model = DescribeInstanceRebootStatusResponseBodyRebootStatuses()
                self.reboot_statuses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceRebootStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceRebootStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceRebootStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceStatisticsRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        self.from_ = from_
        self.lang = lang
        self.source_ip = source_ip
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        account: int = None,
        agentless_all: int = None,
        agentless_baseline: int = None,
        agentless_malicious: int = None,
        agentless_vul_cve: int = None,
        agentless_vul_sca: int = None,
        app_num: int = None,
        cms_num: int = None,
        cspm_num: int = None,
        cve_num: int = None,
        emg_num: int = None,
        health: int = None,
        sca_num: int = None,
        suspicious: int = None,
        sys_num: int = None,
        trojan: int = None,
        uuid: str = None,
        vul: int = None,
        weak_pwnum: int = None,
    ):
        self.account = account
        self.agentless_all = agentless_all
        self.agentless_baseline = agentless_baseline
        self.agentless_malicious = agentless_malicious
        self.agentless_vul_cve = agentless_vul_cve
        self.agentless_vul_sca = agentless_vul_sca
        self.app_num = app_num
        self.cms_num = cms_num
        self.cspm_num = cspm_num
        self.cve_num = cve_num
        self.emg_num = emg_num
        self.health = health
        self.sca_num = sca_num
        self.suspicious = suspicious
        self.sys_num = sys_num
        self.trojan = trojan
        self.uuid = uuid
        self.vul = vul
        self.weak_pwnum = weak_pwnum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.agentless_all is not None:
            result['AgentlessAll'] = self.agentless_all
        if self.agentless_baseline is not None:
            result['AgentlessBaseline'] = self.agentless_baseline
        if self.agentless_malicious is not None:
            result['AgentlessMalicious'] = self.agentless_malicious
        if self.agentless_vul_cve is not None:
            result['AgentlessVulCve'] = self.agentless_vul_cve
        if self.agentless_vul_sca is not None:
            result['AgentlessVulSca'] = self.agentless_vul_sca
        if self.app_num is not None:
            result['AppNum'] = self.app_num
        if self.cms_num is not None:
            result['CmsNum'] = self.cms_num
        if self.cspm_num is not None:
            result['CspmNum'] = self.cspm_num
        if self.cve_num is not None:
            result['CveNum'] = self.cve_num
        if self.emg_num is not None:
            result['EmgNum'] = self.emg_num
        if self.health is not None:
            result['Health'] = self.health
        if self.sca_num is not None:
            result['ScaNum'] = self.sca_num
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        if self.sys_num is not None:
            result['SysNum'] = self.sys_num
        if self.trojan is not None:
            result['Trojan'] = self.trojan
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul is not None:
            result['Vul'] = self.vul
        if self.weak_pwnum is not None:
            result['WeakPWNum'] = self.weak_pwnum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('AgentlessAll') is not None:
            self.agentless_all = m.get('AgentlessAll')
        if m.get('AgentlessBaseline') is not None:
            self.agentless_baseline = m.get('AgentlessBaseline')
        if m.get('AgentlessMalicious') is not None:
            self.agentless_malicious = m.get('AgentlessMalicious')
        if m.get('AgentlessVulCve') is not None:
            self.agentless_vul_cve = m.get('AgentlessVulCve')
        if m.get('AgentlessVulSca') is not None:
            self.agentless_vul_sca = m.get('AgentlessVulSca')
        if m.get('AppNum') is not None:
            self.app_num = m.get('AppNum')
        if m.get('CmsNum') is not None:
            self.cms_num = m.get('CmsNum')
        if m.get('CspmNum') is not None:
            self.cspm_num = m.get('CspmNum')
        if m.get('CveNum') is not None:
            self.cve_num = m.get('CveNum')
        if m.get('EmgNum') is not None:
            self.emg_num = m.get('EmgNum')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('ScaNum') is not None:
            self.sca_num = m.get('ScaNum')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        if m.get('SysNum') is not None:
            self.sys_num = m.get('SysNum')
        if m.get('Trojan') is not None:
            self.trojan = m.get('Trojan')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vul') is not None:
            self.vul = m.get('Vul')
        if m.get('WeakPWNum') is not None:
            self.weak_pwnum = m.get('WeakPWNum')
        return self


class DescribeInstanceStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeInstanceStatisticsResponseBodyData] = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeInstanceStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIpTagsRequest(TeaModel):
    def __init__(
        self,
        ip: str = None,
        security_event_id: str = None,
    ):
        self.ip = ip
        self.security_event_id = security_event_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        return self


class DescribeIpTagsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        tags: str = None,
    ):
        self.request_id = request_id
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeIpTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIpTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIpTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLatestScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        last_check_time: int = None,
        request_id: str = None,
        risk_num: int = None,
        target_info: str = None,
        uuids: List[str] = None,
    ):
        self.last_check_time = last_check_time
        self.request_id = request_id
        self.risk_num = risk_num
        self.target_info = target_info
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.last_check_time is not None:
            result['LastCheckTime'] = self.last_check_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_num is not None:
            result['RiskNum'] = self.risk_num
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LastCheckTime') is not None:
            self.last_check_time = m.get('LastCheckTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskNum') is not None:
            self.risk_num = m.get('RiskNum')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeLatestScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLatestScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLatestScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogMetaRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        # The topic of logs that are delivered.
        self.from_ = from_
        # The category of logs. Valid values:
        # 
        # *   **host**: host logs
        # *   **network**: network logs
        # *   **security**: security logs
        self.lang = lang
        # The ID of the request source. Default value: **aegis**. Valid values:
        # 
        # *   **aegis**: Server Guard
        # *   **sas**: Security Center
        # 
        # >  If you use Server Guard, set the value to **aegis**. If you use Security Center, set the value to **sas**.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeLogMetaResponseBodyLogMetaList(TeaModel):
    def __init__(
        self,
        category: str = None,
        hot_ttl: int = None,
        log_desc: str = None,
        log_store: str = None,
        project: str = None,
        status: str = None,
        topic: str = None,
        ttl: int = None,
        user_log_store: str = None,
        user_project: str = None,
        user_region: str = None,
    ):
        self.category = category
        self.hot_ttl = hot_ttl
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.log_desc = log_desc
        # Queries the configurations of the log analysis feature provided by Security Center.
        self.log_store = log_store
        self.project = project
        # The configurations of the log analysis feature.
        self.status = status
        self.topic = topic
        self.ttl = ttl
        self.user_log_store = user_log_store
        # DescribeLogMeta
        self.user_project = user_project
        self.user_region = user_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.hot_ttl is not None:
            result['HotTtl'] = self.hot_ttl
        if self.log_desc is not None:
            result['LogDesc'] = self.log_desc
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.status is not None:
            result['Status'] = self.status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.user_log_store is not None:
            result['UserLogStore'] = self.user_log_store
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        if self.user_region is not None:
            result['UserRegion'] = self.user_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('HotTtl') is not None:
            self.hot_ttl = m.get('HotTtl')
        if m.get('LogDesc') is not None:
            self.log_desc = m.get('LogDesc')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UserLogStore') is not None:
            self.user_log_store = m.get('UserLogStore')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        if m.get('UserRegion') is not None:
            self.user_region = m.get('UserRegion')
        return self


class DescribeLogMetaResponseBody(TeaModel):
    def __init__(
        self,
        log_meta_list: List[DescribeLogMetaResponseBodyLogMetaList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The name of the dedicated project in which logs are stored.
        self.log_meta_list = log_meta_list
        # The name of the dedicated Logstore in which logs are stored.
        self.request_id = request_id
        # The source IP address of the request.
        self.total_count = total_count

    def validate(self):
        if self.log_meta_list:
            for k in self.log_meta_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogMetaList'] = []
        if self.log_meta_list is not None:
            for k in self.log_meta_list:
                result['LogMetaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_meta_list = []
        if m.get('LogMetaList') is not None:
            for k in m.get('LogMetaList'):
                temp_model = DescribeLogMetaResponseBodyLogMetaList()
                self.log_meta_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLogMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLogMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogShipperStatusRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
    ):
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class DescribeLogShipperStatusResponseBodyLogShipperStatus(TeaModel):
    def __init__(
        self,
        auth_status: str = None,
        buy_status: str = None,
        open_status: str = None,
        post_paid_open_status: str = None,
        post_paid_support_status: str = None,
        sls_project_status: str = None,
        sls_service_status: str = None,
    ):
        # Indicates whether Security Center is authorized to access Log Service. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.auth_status = auth_status
        # Indicates whether the log analysis feature is purchased. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.buy_status = buy_status
        # The status of the log analysis feature. Valid values:
        # 
        # *   **yes**: enabled
        # *   **no**: disabled
        self.open_status = open_status
        # Indicates whether the pay-as-you-go billing method is used. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.post_paid_open_status = post_paid_open_status
        # Indicates whether the log analysis feature supports the pay-as-you-go billing method. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.post_paid_support_status = post_paid_support_status
        # The status of the dedicated Log Service project. Valid values:
        # 
        # *   **Normal**: normal
        # *   **Disable**: disabled
        self.sls_project_status = sls_project_status
        # Indicates whether Log Service is activated. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.sls_service_status = sls_service_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_status is not None:
            result['AuthStatus'] = self.auth_status
        if self.buy_status is not None:
            result['BuyStatus'] = self.buy_status
        if self.open_status is not None:
            result['OpenStatus'] = self.open_status
        if self.post_paid_open_status is not None:
            result['PostPaidOpenStatus'] = self.post_paid_open_status
        if self.post_paid_support_status is not None:
            result['PostPaidSupportStatus'] = self.post_paid_support_status
        if self.sls_project_status is not None:
            result['SlsProjectStatus'] = self.sls_project_status
        if self.sls_service_status is not None:
            result['SlsServiceStatus'] = self.sls_service_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthStatus') is not None:
            self.auth_status = m.get('AuthStatus')
        if m.get('BuyStatus') is not None:
            self.buy_status = m.get('BuyStatus')
        if m.get('OpenStatus') is not None:
            self.open_status = m.get('OpenStatus')
        if m.get('PostPaidOpenStatus') is not None:
            self.post_paid_open_status = m.get('PostPaidOpenStatus')
        if m.get('PostPaidSupportStatus') is not None:
            self.post_paid_support_status = m.get('PostPaidSupportStatus')
        if m.get('SlsProjectStatus') is not None:
            self.sls_project_status = m.get('SlsProjectStatus')
        if m.get('SlsServiceStatus') is not None:
            self.sls_service_status = m.get('SlsServiceStatus')
        return self


class DescribeLogShipperStatusResponseBody(TeaModel):
    def __init__(
        self,
        log_shipper_status: DescribeLogShipperStatusResponseBodyLogShipperStatus = None,
        request_id: str = None,
    ):
        # The status information.
        self.log_shipper_status = log_shipper_status
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.log_shipper_status:
            self.log_shipper_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_shipper_status is not None:
            result['LogShipperStatus'] = self.log_shipper_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogShipperStatus') is not None:
            temp_model = DescribeLogShipperStatusResponseBodyLogShipperStatus()
            self.log_shipper_status = temp_model.from_map(m['LogShipperStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLogShipperStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLogShipperStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogShipperStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoginBaseConfigsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        target: str = None,
        type: str = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: **5**.
        self.page_size = page_size
        # The server to which the configuration is applied. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **Target**: the UUID or group ID of the server to add or delete.
        # 
        # > If targetType is set to uuid, the value of Target is the UUID of the server. If targetType is set to groupId, the value of Target is the group ID of the server. If targetType is set to global, the value of Target is a hyphen (-).
        # 
        # *   **targetType**: the type of the server to which the configuration is applied. Valid values:
        # 
        #     *   **uuid**: a server
        #     *   **groupId**: a server group
        #     *   **global**: all servers
        self.target = target
        # The logon type of the configuration to query. Valid values:
        # 
        # *   **login\_common_location**: common logon location
        # *   **login\_common_ip**: common logon IP address
        # *   **login\_common_time**: common logon time range
        # *   **login\_common_account**: common logon account
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList(TeaModel):
    def __init__(
        self,
        target: str = None,
        target_type: str = None,
    ):
        # The UUID or group ID of the server.
        self.target = target
        # The type of the server to which the configuration is applied. Valid values:
        # 
        # *   **uuid**: a server
        # *   **groupId**: a server group
        # *   **global**: all servers
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeLoginBaseConfigsResponseBodyBaseConfigs(TeaModel):
    def __init__(
        self,
        account: str = None,
        end_time: str = None,
        ip: str = None,
        location: str = None,
        remark: str = None,
        start_time: str = None,
        target_list: List[DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList] = None,
        total_count: int = None,
        uuid_count: int = None,
    ):
        # The common logon account.
        self.account = account
        # The end time of the common logon time range.
        self.end_time = end_time
        # The common logon IP address.
        self.ip = ip
        # The common logon location.
        self.location = location
        self.remark = remark
        # The start time of the common logon time range.
        self.start_time = start_time
        # The details of the servers to which the configuration is applied.
        self.target_list = target_list
        # The total number of servers.
        self.total_count = total_count
        # The number of servers to which the configuration is applied.
        self.uuid_count = uuid_count

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.location is not None:
            result['Location'] = self.location
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.uuid_count is not None:
            result['UuidCount'] = self.uuid_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UuidCount') is not None:
            self.uuid_count = m.get('UuidCount')
        return self


class DescribeLoginBaseConfigsResponseBody(TeaModel):
    def __init__(
        self,
        base_configs: List[DescribeLoginBaseConfigsResponseBodyBaseConfigs] = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # An array that consists of the information about the configurations.
        self.base_configs = base_configs
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.base_configs:
            for k in self.base_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaseConfigs'] = []
        if self.base_configs is not None:
            for k in self.base_configs:
                result['BaseConfigs'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.base_configs = []
        if m.get('BaseConfigs') is not None:
            for k in m.get('BaseConfigs'):
                temp_model = DescribeLoginBaseConfigsResponseBodyBaseConfigs()
                self.base_configs.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLoginBaseConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoginBaseConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoginBaseConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoginSwitchConfigsResponseBodyConfigList(TeaModel):
    def __init__(
        self,
        item: str = None,
        status: int = None,
    ):
        # The type of the alert that you enabled or disabled. Valid values:
        # 
        # *   **login\_common_ip**: alerts for unapproved logon IP addresses
        # *   **login\_common_time**: alerts for unapproved logon time ranges
        # *   **login\_common_account**: alerts for unapproved logon accounts
        self.item = item
        # The status of the Log Service feature. Valid values:
        # 
        # *   **0**: The feature is disabled.
        # *   **1**: The feature is enabled.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLoginSwitchConfigsResponseBody(TeaModel):
    def __init__(
        self,
        config_list: List[DescribeLoginSwitchConfigsResponseBodyConfigList] = None,
        count: int = None,
        request_id: str = None,
    ):
        # The configuration item returned.
        self.config_list = config_list
        # The number of returned configuration items.
        self.count = count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeLoginSwitchConfigsResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLoginSwitchConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoginSwitchConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoginSwitchConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogstoreStorageRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.from_ = from_
        # The purchased log storage capacity, in GB.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeLogstoreStorageResponseBody(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        preserve: int = None,
        request_id: str = None,
        ttl: int = None,
        used: int = None,
        user_project: str = None,
    ):
        # WB01014029
        self.logstore = logstore
        self.preserve = preserve
        # 
        self.request_id = request_id
        # DescribeLogstoreStorage
        self.ttl = ttl
        # Queries the purchased log storage capacity.
        self.used = used
        self.user_project = user_project

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.preserve is not None:
            result['Preserve'] = self.preserve
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.used is not None:
            result['Used'] = self.used
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Preserve') is not None:
            self.preserve = m.get('Preserve')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        return self


class DescribeLogstoreStorageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLogstoreStorageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogstoreStorageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMachineCanRebootRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
        uuid: str = None,
    ):
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeMachineCanRebootResponseBody(TeaModel):
    def __init__(
        self,
        can_reboot: bool = None,
        request_id: str = None,
    ):
        self.can_reboot = can_reboot
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_reboot is not None:
            result['CanReboot'] = self.can_reboot
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanReboot') is not None:
            self.can_reboot = m.get('CanReboot')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMachineCanRebootResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMachineCanRebootResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMachineCanRebootResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeModuleConfigResponseBodyModuleConfigListItems(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        ip: str = None,
        region: str = None,
        uuid: str = None,
    ):
        # The ID of the server group to which the server belongs.
        self.group_id = group_id
        # The ID of the server.
        self.instance_id = instance_id
        # The name of the server.
        self.instance_name = instance_name
        # The IP address of the server.
        self.ip = ip
        # The region in which the server resides.
        self.region = region
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.region is not None:
            result['Region'] = self.region
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeModuleConfigResponseBodyModuleConfigList(TeaModel):
    def __init__(
        self,
        config_name: str = None,
        items: List[DescribeModuleConfigResponseBodyModuleConfigListItems] = None,
        module_name: str = None,
    ):
        # The name of the configuration.
        self.config_name = config_name
        # An array that consists of the configuration items.
        self.items = items
        # The name of the module.
        self.module_name = module_name

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = DescribeModuleConfigResponseBodyModuleConfigListItems()
                self.items.append(temp_model.from_map(k))
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class DescribeModuleConfigResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        http_status_code: int = None,
        module_config_list: List[DescribeModuleConfigResponseBodyModuleConfigList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The number of configurations for the module.
        self.count = count
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # An array that consists of the configurations.
        self.module_config_list = module_config_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.module_config_list:
            for k in self.module_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ModuleConfigList'] = []
        if self.module_config_list is not None:
            for k in self.module_config_list:
                result['ModuleConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.module_config_list = []
        if m.get('ModuleConfigList') is not None:
            for k in m.get('ModuleConfigList'):
                temp_model = DescribeModuleConfigResponseBodyModuleConfigList()
                self.module_config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeModuleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeModuleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeModuleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNoticeConfigRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
    ):
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeNoticeConfigResponseBodyNoticeConfigList(TeaModel):
    def __init__(
        self,
        ali_uid: int = None,
        current_page: int = None,
        project: str = None,
        route: int = None,
        time_limit: int = None,
    ):
        # The ID of the user.
        self.ali_uid = ali_uid
        # The page number of the returned page.
        self.current_page = current_page
        # The identifier of the notification item. Valid values:
        # 
        # *   **yundun\_security_Weekreport**: notification for vulnerabilities
        # *   **yundun\_sas\_antiransomware_task**: notification for results of restoration tasks
        # *   **sas_healthcheck**: notification for baseline checks
        # *   **sas_suspicious**: notification for alerts generated by Security Center
        # *   **yundun\_aegis\_AV_true**: notification for precision defense
        # *   **yundun\_sas\_ak_leakage**: notification for AccessKey pair leaks
        # *   **yundun\_sas\_config_alert**: notification for configuration assessment
        # *   **yundun\_sas\_vul_Emergency**: notification for urgent vulnerabilities
        # *   **yundun\_webguard_event**: notification for web tamper proofing
        # *   **yundun\_sas\_cloud\_native_firewall**: notification for alerts generated by the container firewall feature
        # *   **yundun\_sas\_cloud\_native\_firewall_Defense**: notification for proactive defense implemented by the container firewall feature
        # *   **yundun\_IP_Blocking**: notification for blocked brute-force attacks initiated from malicious IP addresses
        # *   **yundun\_sas\_anti\_virus_config**: notification for virus scan
        # *   **yundun\_sas_log**: notification for excess logs
        # *   **yundun\_honeypot_alarm**: notification for alerts generated by the honeypot feature
        # *   **aliyun\_rasp_alarm**: notification for alerts generated by the application security feature
        # *   **virusScheduleTask**: notification for completion of scheduled virus scans
        # *   **yundun\_anti_Virus**: notification that no security checks are performed
        # *   **sas_vulnerability**: notification for vulnerabilities
        # *   **weeklyreport**: notification for weekly reports
        # *   **agent**: notification that the Security Center agent is offline
        # *   **bruteforcesuccess**: notification for protection against brute-force attacks
        # *   **webshell**: notification for webshells
        # *   **suspicious**: notification for alerts generated by Server Guard
        # *   **patch**: deprecated
        # *   **remotelogin**: notification for remote logons
        # *   **health**: notification for security checks
        # *   **yundun\_sas\_cloudsiem_log**: notifications of insufficient threat analysis log capacity
        # 
        # > If the value is **yundun\_security_Weekreport**, weekly reports are sent to notify you of unhandled vulnerabilities.
        self.project = project
        # The notification method. Valid values:
        # 
        # *   **1**: text message
        # *   **2**: email
        # *   **4**: internal message
        # *   **3**: text message and email
        # *   **5**: text message and internal message
        # *   **6**: email and internal message
        # *   **7**: text message, email, and internal message
        self.route = route
        # The time period during which Security Center sends notifications. Valid values:
        # 
        # *   **0**: any time
        # *   **1**: 08:00 to 22:00
        self.time_limit = time_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.project is not None:
            result['Project'] = self.project
        if self.route is not None:
            result['Route'] = self.route
        if self.time_limit is not None:
            result['TimeLimit'] = self.time_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Route') is not None:
            self.route = m.get('Route')
        if m.get('TimeLimit') is not None:
            self.time_limit = m.get('TimeLimit')
        return self


class DescribeNoticeConfigResponseBody(TeaModel):
    def __init__(
        self,
        notice_config_list: List[DescribeNoticeConfigResponseBodyNoticeConfigList] = None,
        request_id: str = None,
    ):
        # An array that consists of the notification settings.
        self.notice_config_list = notice_config_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.notice_config_list:
            for k in self.notice_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NoticeConfigList'] = []
        if self.notice_config_list is not None:
            for k in self.notice_config_list:
                result['NoticeConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notice_config_list = []
        if m.get('NoticeConfigList') is not None:
            for k in m.get('NoticeConfigList'):
                temp_model = DescribeNoticeConfigResponseBodyNoticeConfigList()
                self.notice_config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNoticeConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNoticeConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNoticeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNsasSuspEventTypeRequest(TeaModel):
    def __init__(
        self,
        container_field_name: str = None,
        container_field_value: str = None,
        from_: str = None,
        lang: str = None,
        name: str = None,
        remark: str = None,
        source_ip: str = None,
        uuids: str = None,
    ):
        self.container_field_name = container_field_name
        self.container_field_value = container_field_value
        self.from_ = from_
        self.lang = lang
        self.name = name
        self.remark = remark
        self.source_ip = source_ip
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeNsasSuspEventTypeResponseBodyEventTypes(TeaModel):
    def __init__(
        self,
        name: str = None,
        susp_event_count: int = None,
        type: str = None,
    ):
        self.name = name
        self.susp_event_count = susp_event_count
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.susp_event_count is not None:
            result['SuspEventCount'] = self.susp_event_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SuspEventCount') is not None:
            self.susp_event_count = m.get('SuspEventCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeNsasSuspEventTypeResponseBody(TeaModel):
    def __init__(
        self,
        event_types: List[DescribeNsasSuspEventTypeResponseBodyEventTypes] = None,
        request_id: str = None,
    ):
        self.event_types = event_types
        self.request_id = request_id

    def validate(self):
        if self.event_types:
            for k in self.event_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventTypes'] = []
        if self.event_types is not None:
            for k in self.event_types:
                result['EventTypes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_types = []
        if m.get('EventTypes') is not None:
            for k in m.get('EventTypes'):
                temp_model = DescribeNsasSuspEventTypeResponseBodyEventTypes()
                self.event_types.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNsasSuspEventTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNsasSuspEventTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNsasSuspEventTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOfflineMachinesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        os: str = None,
        page_size: int = None,
        region_id_str: str = None,
        region_no: str = None,
        remark: str = None,
        source_ip: str = None,
        vendor: int = None,
    ):
        self.current_page = current_page
        self.os = os
        self.page_size = page_size
        self.region_id_str = region_id_str
        self.region_no = region_no
        self.remark = remark
        self.source_ip = source_ip
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.os is not None:
            result['Os'] = self.os
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_str is not None:
            result['RegionIdStr'] = self.region_id_str
        if self.region_no is not None:
            result['RegionNo'] = self.region_no
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdStr') is not None:
            self.region_id_str = m.get('RegionIdStr')
        if m.get('RegionNo') is not None:
            self.region_no = m.get('RegionNo')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class DescribeOfflineMachinesResponseBodyMachineList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        machine_region: str = None,
        os: str = None,
        region_id: str = None,
        uuid: str = None,
        vendor: int = None,
        vendor_name: str = None,
    ):
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.machine_region = machine_region
        self.os = os
        self.region_id = region_id
        self.uuid = uuid
        self.vendor = vendor
        self.vendor_name = vendor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class DescribeOfflineMachinesResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        machine_list: List[DescribeOfflineMachinesResponseBodyMachineList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.machine_list = machine_list
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = DescribeOfflineMachinesResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOfflineMachinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOfflineMachinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOfflineMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOnceTaskRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time_query: int = None,
        page_size: int = None,
        root_task_id: str = None,
        start_time_query: int = None,
        task_id: str = None,
        task_type: str = None,
    ):
        # The pagination information.
        self.current_page = current_page
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.end_time_query = end_time_query
        # The page number of the returned page.
        self.page_size = page_size
        # The ID of the task.
        self.root_task_id = root_task_id
        # The data returned.
        self.start_time_query = start_time_query
        # The number of entries returned per page. Default value: **20**.
        self.task_id = task_id
        # The number of entries to return on each page. Default value: **20**.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time_query is not None:
            result['EndTimeQuery'] = self.end_time_query
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.root_task_id is not None:
            result['RootTaskId'] = self.root_task_id
        if self.start_time_query is not None:
            result['StartTimeQuery'] = self.start_time_query
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTimeQuery') is not None:
            self.end_time_query = m.get('EndTimeQuery')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RootTaskId') is not None:
            self.root_task_id = m.get('RootTaskId')
        if m.get('StartTimeQuery') is not None:
            self.start_time_query = m.get('StartTimeQuery')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The status of the task. Valid values:
        # 
        # *   **1**: started
        # *   **2**: complete
        # *   **3**: failed
        # *   **4**: timed out
        self.count = count
        # The information about the task.
        self.current_page = current_page
        # The type of the task. Valid values:
        # 
        # *   **CLIENT\_PROBLEM_CHECK**: a task of the Security Center agent
        # *   **CLIENT\_DEV_OPS**: an O\&M task of Cloud Assistant
        # *   **ASSET\_SECURITY_CHECK**: a task of asset information collection
        self.page_size = page_size
        # The progress of the task. Unit: percent (%).
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskResponseBodyTaskManageResponseList(TeaModel):
    def __init__(
        self,
        detail_data: str = None,
        fail_count: int = None,
        progress: str = None,
        result_info: str = None,
        success_count: int = None,
        task_end_time: int = None,
        task_id: str = None,
        task_name: str = None,
        task_start_time: int = None,
        task_status: int = None,
        task_status_text: str = None,
        task_type: str = None,
    ):
        # The ID of the task.
        self.detail_data = detail_data
        self.fail_count = fail_count
        # The timestamp when the task starts. Unit: milliseconds.
        self.progress = progress
        self.result_info = result_info
        self.success_count = success_count
        self.task_end_time = task_end_time
        self.task_id = task_id
        # The number of tasks that failed.
        self.task_name = task_name
        # The execution result of the task.
        self.task_start_time = task_start_time
        # The timestamp when the task ends. Unit: milliseconds.
        self.task_status = task_status
        # The number of tasks that succeeded.
        self.task_status_text = task_status_text
        # The name of the task.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail_data is not None:
            result['DetailData'] = self.detail_data
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_info is not None:
            result['ResultInfo'] = self.result_info
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.task_end_time is not None:
            result['TaskEndTime'] = self.task_end_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_start_time is not None:
            result['TaskStartTime'] = self.task_start_time
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_status_text is not None:
            result['TaskStatusText'] = self.task_status_text
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DetailData') is not None:
            self.detail_data = m.get('DetailData')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultInfo') is not None:
            self.result_info = m.get('ResultInfo')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('TaskEndTime') is not None:
            self.task_end_time = m.get('TaskEndTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStartTime') is not None:
            self.task_start_time = m.get('TaskStartTime')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskStatusText') is not None:
            self.task_status_text = m.get('TaskStatusText')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeOnceTaskResponseBodyPageInfo = None,
        request_id: str = None,
        task_manage_response_list: List[DescribeOnceTaskResponseBodyTaskManageResponseList] = None,
    ):
        # An array that consists of the tasks.
        self.page_info = page_info
        # The number of entries returned on the current page.
        self.request_id = request_id
        # The execution details of the task. The value of this parameter is in the JSON format.
        # 
        # *   **causeCode**: the returned code for the cause
        # *   **causeMsg**: the returned information for the cause
        # *   **resCode**: the returned code of troubleshooting
        # *   **resMsg**: the returned information about troubleshooting
        # *   **problemType**: the type of the issue
        # *   **dispatchType**: the task delivery method
        # *   **uuid**: the UUID of the server
        # *   **instanceId**: the instance ID of the server
        # *   **internetIp**: the public IP address of the server
        # *   **intranetIp**: the private IP address of the server
        # *   **instanceName**: the instance name of the server
        # *   **url**: the download link of the troubleshooting log
        self.task_manage_response_list = task_manage_response_list

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.task_manage_response_list:
            for k in self.task_manage_response_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TaskManageResponseList'] = []
        if self.task_manage_response_list is not None:
            for k in self.task_manage_response_list:
                result['TaskManageResponseList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeOnceTaskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task_manage_response_list = []
        if m.get('TaskManageResponseList') is not None:
            for k in m.get('TaskManageResponseList'):
                temp_model = DescribeOnceTaskResponseBodyTaskManageResponseList()
                self.task_manage_response_list.append(temp_model.from_map(k))
        return self


class DescribeOnceTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOnceTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOnceTaskLeafRecordPageRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        page_size: int = None,
        relate_info: bool = None,
        source: str = None,
        start_time: int = None,
        status_list: List[str] = None,
        task_id: str = None,
        task_type: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The end timestamp of the sub-task.
        self.end_time = end_time
        # The number of entries to return on each page. Default value: 20
        self.page_size = page_size
        # Specifies whether extension information is associated.
        self.relate_info = relate_info
        # The source of the request.
        self.source = source
        # The start timestamp of the sub-task.
        self.start_time = start_time
        # The status information.
        self.status_list = status_list
        # The ID of the sub-task.
        self.task_id = task_id
        # The type of the sub-task. Valid values:
        # 
        # *   **IMAGE_SCAN**: image scan task
        # *   **IMAGE_REGISTRY_PULL**: image asset synchronization task
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.relate_info is not None:
            result['RelateInfo'] = self.relate_info
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RelateInfo') is not None:
            self.relate_info = m.get('RelateInfo')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        digest: str = None,
        image: str = None,
        node_instance_id: str = None,
        node_ip: str = None,
        node_name: str = None,
        pod: str = None,
        region_id: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_region_id: str = None,
        tag: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The digest of the image.
        self.digest = digest
        # The image of the container.
        self.image = image
        # The ID of the instance.
        self.node_instance_id = node_instance_id
        # The IP address of the node.
        self.node_ip = node_ip
        # The name of the node.
        self.node_name = node_name
        # The pod of the image.
        self.pod = pod
        # The region of the server image.
        self.region_id = region_id
        # The ID of the image repository.
        self.repo_id = repo_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The name of the namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id
        # The tag that is added to the image.
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.image is not None:
            result['Image'] = self.image
        if self.node_instance_id is not None:
            result['NodeInstanceId'] = self.node_instance_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('NodeInstanceId') is not None:
            self.node_instance_id = m.get('NodeInstanceId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        finish: int = None,
        finish_count: str = None,
        progress: int = None,
        real_run_time: int = None,
        result_info: str = None,
        start_time: int = None,
        status: str = None,
        status_text: str = None,
        target: str = None,
        target_type: str = None,
        task_id: str = None,
        task_image_info: DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo = None,
        task_name: str = None,
        task_type: str = None,
        total_count: str = None,
    ):
        # The time when the sub-task ends.
        self.end_time = end_time
        # Indicates whether the sub-task is complete.
        # 
        # *   **0**: no
        # *   **1**: yes
        self.finish = finish
        # The number of assets that are scanned.
        self.finish_count = finish_count
        # The progress percentage of the sub-task.
        self.progress = progress
        # The execution duration of the sub-task.
        self.real_run_time = real_run_time
        # The execution result of the task.
        self.result_info = result_info
        # The time when the sub-task starts.
        self.start_time = start_time
        # The status information.
        self.status = status
        # The status of the sub-task. Valid values:
        # 
        # *   **INIT**: The sub-task is not started.
        # *   **START**: The sub-task is started.
        # *   **SUCCESS**: The sub-task is complete.
        # *   **TIMEOUT**: The sub-task timed out.
        self.status_text = status_text
        # The objective of the sub-task.
        self.target = target
        # The type of the asset on which the sub-task is performed.
        # 
        # *   **IMAGE_REPO**: image repository
        # *   **IMAGE**: image
        self.target_type = target_type
        # The sub-task ID.
        self.task_id = task_id
        # The information about the image scan.
        self.task_image_info = task_image_info
        # The name of the sub-task.
        self.task_name = task_name
        # The type of the sub-task.
        self.task_type = task_type
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.task_image_info:
            self.task_image_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.finish is not None:
            result['Finish'] = self.finish
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.real_run_time is not None:
            result['RealRunTime'] = self.real_run_time
        if self.result_info is not None:
            result['ResultInfo'] = self.result_info
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.status_text is not None:
            result['StatusText'] = self.status_text
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_image_info is not None:
            result['TaskImageInfo'] = self.task_image_info.to_map()
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Finish') is not None:
            self.finish = m.get('Finish')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RealRunTime') is not None:
            self.real_run_time = m.get('RealRunTime')
        if m.get('ResultInfo') is not None:
            self.result_info = m.get('ResultInfo')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusText') is not None:
            self.status_text = m.get('StatusText')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskImageInfo') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo()
            self.task_image_info = temp_model.from_map(m['TaskImageInfo'])
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskLeafRecordPageResponseBody(TeaModel):
    def __init__(
        self,
        once_tasks: List[DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks] = None,
        page_info: DescribeOnceTaskLeafRecordPageResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The sub-tasks returned.
        self.once_tasks = once_tasks
        # The pagination information.
        self.page_info = page_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.once_tasks:
            for k in self.once_tasks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OnceTasks'] = []
        if self.once_tasks is not None:
            for k in self.once_tasks:
                result['OnceTasks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.once_tasks = []
        if m.get('OnceTasks') is not None:
            for k in m.get('OnceTasks'):
                temp_model = DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks()
                self.once_tasks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOnceTaskLeafRecordPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOnceTaskLeafRecordPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCountRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
        uuid_list: str = None,
    ):
        # The UUIDs of the assets. Separate multiple UUIDs with commas (,).
        self.type = type
        # The number of scheduled tasks.
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribePropertyCountResponseBody(TeaModel):
    def __init__(
        self,
        autorun: int = None,
        cron: int = None,
        database: int = None,
        lkm: int = None,
        port: int = None,
        process: int = None,
        request_id: str = None,
        sca: int = None,
        software: int = None,
        user: int = None,
        web: int = None,
        webserver: int = None,
    ):
        self.autorun = autorun
        # The number of middleware assets.
        self.cron = cron
        # DescribePropertyCount
        self.database = database
        self.lkm = lkm
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.port = port
        # The number of accounts.
        self.process = process
        # The number of processes.
        self.request_id = request_id
        # port,process
        self.sca = sca
        # The number of web services.
        self.software = software
        # The number of websites.
        self.user = user
        # Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
        self.web = web
        self.webserver = webserver

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.autorun is not None:
            result['Autorun'] = self.autorun
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.database is not None:
            result['Database'] = self.database
        if self.lkm is not None:
            result['Lkm'] = self.lkm
        if self.port is not None:
            result['Port'] = self.port
        if self.process is not None:
            result['Process'] = self.process
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sca is not None:
            result['Sca'] = self.sca
        if self.software is not None:
            result['Software'] = self.software
        if self.user is not None:
            result['User'] = self.user
        if self.web is not None:
            result['Web'] = self.web
        if self.webserver is not None:
            result['Webserver'] = self.webserver
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Autorun') is not None:
            self.autorun = m.get('Autorun')
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Lkm') is not None:
            self.lkm = m.get('Lkm')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Process') is not None:
            self.process = m.get('Process')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Sca') is not None:
            self.sca = m.get('Sca')
        if m.get('Software') is not None:
            self.software = m.get('Software')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Web') is not None:
            self.web = m.get('Web')
        if m.get('Webserver') is not None:
            self.webserver = m.get('Webserver')
        return self


class DescribePropertyCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCronDetailRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        extend: str = None,
        page_size: int = None,
        remark: str = None,
        source: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # 1
        self.current_page = current_page
        # The details of the scheduled tasks.
        self.extend = extend
        # 192.168.XX.XX
        self.page_size = page_size
        # The public IP address of the server.
        self.remark = remark
        # Specifies whether fuzzy search by path to the scheduled task is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.source = source
        # The path to the scheduled task.
        self.user = user
        # 50d213b4-3a35-427a-b8a5-04b0c7e1****\
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source is not None:
            result['Source'] = self.source
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyCronDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The path to the scheduled task.
        self.count = count
        # The UUID of the server.
        self.current_page = current_page
        # The interval at which the scheduled task is performed.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyCronDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        cmd: str = None,
        create_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        md_5: str = None,
        period: str = None,
        source: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.cmd = cmd
        # DescribePropertyCronDetail
        self.create_timestamp = create_timestamp
        # The IP addresses of the server.
        self.instance_id = instance_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.instance_name = instance_name
        # The pagination information.
        self.internet_ip = internet_ip
        # The name of the server.
        self.intranet_ip = intranet_ip
        # The ID of the server.
        self.ip = ip
        # Queries the details of scheduled tasks on the Host page.
        self.md_5 = md_5
        # The number of entries returned per page. Default value: **10**.
        self.period = period
        # The MD5 hash value of the path to the scheduled task.
        self.source = source
        # root
        self.user = user
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmd is not None:
            result['Cmd'] = self.cmd
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.period is not None:
            result['Period'] = self.period
        if self.source is not None:
            result['Source'] = self.source
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cmd') is not None:
            self.cmd = m.get('Cmd')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyCronDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyCronDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertyCronDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # The username of the account that runs the scheduled task.
        self.page_info = page_info
        # 10
        self.propertys = propertys
        # The username of the account that runs the scheduled task.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyCronDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyCronDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyCronDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyCronDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCronDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCronItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        force_flush: bool = None,
        page_size: int = None,
        source: str = None,
    ):
        self.current_page = current_page
        self.force_flush = force_flush
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribePropertyCronItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyCronItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        source: str = None,
    ):
        self.count = count
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribePropertyCronItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyCronItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertyCronItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        self.page_info = page_info
        self.property_items = property_items
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyCronItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyCronItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyCronItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyCronItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCronItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyPortDetailRequest(TeaModel):
    def __init__(
        self,
        bind_ip: str = None,
        current_page: int = None,
        extend: str = None,
        page_size: int = None,
        port: str = None,
        proc_name: str = None,
        remark: str = None,
        uuid: str = None,
    ):
        # The network protocol that is used by the listening port.
        self.bind_ip = bind_ip
        # The name of the server process.
        self.current_page = current_page
        # The listening port.
        self.extend = extend
        # 50d213b4-3a35-427a-b8a5-04b0c7e1****\
        self.page_size = page_size
        # The public IP address of the server.
        self.port = port
        # The IP address that is bound to the listening port.
        self.proc_name = proc_name
        # The number of entries to return on each page. Default value: **10**.
        self.remark = remark
        # The listening port of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_ip is not None:
            result['BindIp'] = self.bind_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.port is not None:
            result['Port'] = self.port
        if self.proc_name is not None:
            result['ProcName'] = self.proc_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindIp') is not None:
            self.bind_ip = m.get('BindIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcName') is not None:
            self.proc_name = m.get('ProcName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyPortDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The UUID of the server.
        self.count = count
        # An array that consists of the fingerprints of the ports.
        self.current_page = current_page
        # The ID of the server process that listens on the port.
        self.page_size = page_size
        # The name of the server process.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyPortDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        bind_ip: str = None,
        create_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        pid: str = None,
        port: str = None,
        proc_name: str = None,
        proto: str = None,
        uuid: str = None,
    ):
        # The pagination information.
        self.bind_ip = bind_ip
        # Queries the fingerprints of ports on a specified server.
        self.create_timestamp = create_timestamp
        # The IP address of the network interface controller (NIC) that is bound to the listening port.
        self.instance_id = instance_id
        # The UUID of the server.
        self.instance_name = instance_name
        # The number of entries returned on the current page.
        self.internet_ip = internet_ip
        # The number of the page to return. Default value: **1**.
        self.intranet_ip = intranet_ip
        # The ID of the server.
        self.ip = ip
        # 10
        self.pid = pid
        # The name of the server.
        self.port = port
        # sshd
        self.proc_name = proc_name
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.proto = proto
        # The number of entries returned per page. Default value: **10**.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_ip is not None:
            result['BindIp'] = self.bind_ip
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.proc_name is not None:
            result['ProcName'] = self.proc_name
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindIp') is not None:
            self.bind_ip = m.get('BindIp')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcName') is not None:
            self.proc_name = m.get('ProcName')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyPortDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyPortDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertyPortDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # 192.168.XX.XX
        self.page_info = page_info
        # Specifies whether fuzzy search by port number is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.propertys = propertys
        # 0.0.XX.XX
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyPortDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyPortDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyPortDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyPortDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyPortDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyPortItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        force_flush: bool = None,
        page_size: int = None,
        port: str = None,
    ):
        # The number of entries to return on each page.
        self.current_page = current_page
        # The port number.
        self.force_flush = force_flush
        # The ID of the request.
        self.page_size = page_size
        # The number of the page to return.
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class DescribePropertyPortItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array that consists of the ports returned.
        self.count = count
        # The number of entries returned per page.
        self.current_page = current_page
        # The total number of entries returned.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyPortItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        port: str = None,
        proto: str = None,
    ):
        # The network protocol of the port.
        self.count = count
        # The number of servers that use the port.
        self.port = port
        # Queries information about all ports.
        self.proto = proto

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.port is not None:
            result['Port'] = self.port
        if self.proto is not None:
            result['Proto'] = self.proto
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        return self


class DescribePropertyPortItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyPortItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertyPortItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        # The page number of the returned page.
        self.page_info = page_info
        # The number of the listening port.
        self.property_items = property_items
        # The pagination information.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyPortItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyPortItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyPortItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyPortItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyPortItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyProcDetailRequest(TeaModel):
    def __init__(
        self,
        cmdline: str = None,
        current_page: int = None,
        extend: str = None,
        name: str = None,
        page_size: int = None,
        proc_time_end: int = None,
        proc_time_start: int = None,
        remark: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # The timestamp of last data collection. Unit: milliseconds.
        self.cmdline = cmdline
        # The timestamp when the process starts. Unit: milliseconds.
        self.current_page = current_page
        # The name of the process.
        self.extend = extend
        # The startup parameter of the process.
        self.name = name
        # The name or IP address of the server.
        self.page_size = page_size
        # The public IP address of the server.
        self.proc_time_end = proc_time_end
        # The number of the page to return. Default value: **1**.
        self.proc_time_start = proc_time_start
        # 1648809853000
        self.remark = remark
        # The permission that is required to run the process.
        self.user = user
        # The private IP address of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.proc_time_end is not None:
            result['ProcTimeEnd'] = self.proc_time_end
        if self.proc_time_start is not None:
            result['ProcTimeStart'] = self.proc_time_start
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcTimeEnd') is not None:
            self.proc_time_end = m.get('ProcTimeEnd')
        if m.get('ProcTimeStart') is not None:
            self.proc_time_start = m.get('ProcTimeStart')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyProcDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array that consists of the fingerprints of the processes.
        self.count = count
        # ./8888
        self.current_page = current_page
        # 10
        self.page_size = page_size
        # 192.168.XX.XX
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyProcDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        cmdline: str = None,
        create_timestamp: int = None,
        euid_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        is_package: int = None,
        md_5: str = None,
        name: str = None,
        path: str = None,
        pid: str = None,
        pname: str = None,
        start_time: str = None,
        start_time_dt: int = None,
        state: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # The startup parameter of the process.
        self.cmdline = cmdline
        # root
        self.create_timestamp = create_timestamp
        # The time when the process starts.
        self.euid_name = euid_name
        # The user who runs the process.
        self.instance_id = instance_id
        # The pagination information.
        self.instance_name = instance_name
        # The ID of the process.
        self.internet_ip = internet_ip
        # The timestamp when the process starts. Unit: milliseconds.
        self.intranet_ip = intranet_ip
        # The name of the server that is associated with the process.
        self.is_package = is_package
        # 1649587453000
        self.md_5 = md_5
        # Specifies whether fuzzy search by process name is supported. If you want to use fuzzy search, set the parameter to 1. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.name = name
        # The ID of the server that is associated with the process.
        self.path = path
        # The timestamp when the process ends. Unit: milliseconds.
        self.pid = pid
        # 1
        self.pname = pname
        # The name of the parent process to which the process belongs.
        self.start_time = start_time
        # The MD5 hash value of the process file.
        self.start_time_dt = start_time_dt
        # The UUID of the server.
        self.state = state
        # The user who runs the process.
        self.user = user
        # The number of entries returned on the current page.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.euid_name is not None:
            result['EuidName'] = self.euid_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.is_package is not None:
            result['IsPackage'] = self.is_package
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.pname is not None:
            result['Pname'] = self.pname
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_time_dt is not None:
            result['StartTimeDt'] = self.start_time_dt
        if self.state is not None:
            result['State'] = self.state
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EuidName') is not None:
            self.euid_name = m.get('EuidName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('IsPackage') is not None:
            self.is_package = m.get('IsPackage')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Pname') is not None:
            self.pname = m.get('Pname')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimeDt') is not None:
            self.start_time_dt = m.get('StartTimeDt')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyProcDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyProcDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertyProcDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # The name of the process.
        self.page_info = page_info
        # 1
        self.propertys = propertys
        # The number of entries to return on each page. Default value: **10**.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyProcDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyProcDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyProcDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyProcDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyProcDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyProcItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        force_flush: bool = None,
        name: str = None,
        page_size: int = None,
    ):
        # The number of entries to return on each page.
        self.current_page = current_page
        # The name of the process.
        self.force_flush = force_flush
        # The number of the page to return.
        self.name = name
        # The ID of the request.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertyProcItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array that consists of the processes returned.
        self.count = count
        # The number of entries returned per page.
        self.current_page = current_page
        # The total number of entries returned.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyProcItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        name: str = None,
    ):
        # Queries information about all processes.
        self.count = count
        # The number of servers on which the process runs.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertyProcItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyProcItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertyProcItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        # The page number of the returned page.
        self.page_info = page_info
        # The name of the process.
        self.property_items = property_items
        # The pagination information.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyProcItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyProcItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyProcItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyProcItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyProcItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScaDetailRequest(TeaModel):
    def __init__(
        self,
        biz: str = None,
        biz_type: str = None,
        current_page: int = None,
        lang: str = None,
        name: int = None,
        page_size: int = None,
        pid: str = None,
        port: str = None,
        process_started_end: int = None,
        process_started_start: int = None,
        remark: str = None,
        sca_name: str = None,
        sca_name_pattern: str = None,
        sca_version: str = None,
        search_info: str = None,
        search_info_sub: str = None,
        search_item: str = None,
        search_item_sub: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # The IP address that the process monitors.
        self.biz = biz
        # The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:
        # 
        # *   **sca**: middleware
        # *   **sca_database**: database
        # *   **sca_web**: web service
        # 
        # >  If you do not specify this parameter, the default value **sca** is used, which indicates that middleware fingerprints are queried.
        self.biz_type = biz_type
        # 1
        self.current_page = current_page
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # 10
        self.name = name
        # The type of the middleware, database, or web service. Valid values:
        # 
        # *   **system_service**: system service
        # *   **software_library**: software library
        # *   **docker_component**: container component
        # *   **database**: database
        # *   **web_container**: web container
        # *   **jar**: JAR package
        # *   **web_framework**: web framework
        self.page_size = page_size
        # The search keyword. You must specify this parameter based on the value of the **SearchItem** parameter.
        # 
        # *   If the **SearchItem** parameter is set to **name**, you must enter the name of an asset fingerprint.
        # 
        # *   If the **SearchItem** parameter is set to **type**, you must enter the type of an asset fingerprint. Valid values:
        # 
        #     *   **system_service**: system service
        #     *   **software_library**: software library
        #     *   **docker_component**: container component
        #     *   **database**: database
        #     *   **web_container**: web container
        #     *   **jar**: JAR package
        #     *   **web_framework**: web framework
        # 
        # >  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.pid = pid
        # The type of the search condition. Valid values:
        # 
        # *   **name**: the name of a database, middleware, or web service
        # *   **type**: the type of a database, middleware, or web service
        # 
        # >  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.port = port
        # system_service
        self.process_started_end = process_started_end
        # The number of entries returned on the current page.
        self.process_started_start = process_started_start
        # The port of the middleware, database, or web service.
        self.remark = remark
        # The name of the middleware, database, or web service.
        self.sca_name = sca_name
        # The number of the page to return. Default value: **1**.
        self.sca_name_pattern = sca_name_pattern
        # The number of entries to return on each page. Default value: **10**.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.sca_version = sca_version
        # The public IP address of the server on which the middleware, database, or web service is run.
        self.search_info = search_info
        # 1641110965
        self.search_info_sub = search_info_sub
        # The name of the process.
        self.search_item = search_item
        # root
        self.search_item_sub = search_item_sub
        # The version of the middleware, database, or web service.
        self.user = user
        # The details about the asset fingerprints returned.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.process_started_end is not None:
            result['ProcessStartedEnd'] = self.process_started_end
        if self.process_started_start is not None:
            result['ProcessStartedStart'] = self.process_started_start
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sca_name is not None:
            result['ScaName'] = self.sca_name
        if self.sca_name_pattern is not None:
            result['ScaNamePattern'] = self.sca_name_pattern
        if self.sca_version is not None:
            result['ScaVersion'] = self.sca_version
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_info_sub is not None:
            result['SearchInfoSub'] = self.search_info_sub
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        if self.search_item_sub is not None:
            result['SearchItemSub'] = self.search_item_sub
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcessStartedEnd') is not None:
            self.process_started_end = m.get('ProcessStartedEnd')
        if m.get('ProcessStartedStart') is not None:
            self.process_started_start = m.get('ProcessStartedStart')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScaName') is not None:
            self.sca_name = m.get('ScaName')
        if m.get('ScaNamePattern') is not None:
            self.sca_name_pattern = m.get('ScaNamePattern')
        if m.get('ScaVersion') is not None:
            self.sca_version = m.get('ScaVersion')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchInfoSub') is not None:
            self.search_info_sub = m.get('SearchInfoSub')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        if m.get('SearchItemSub') is not None:
            self.search_item_sub = m.get('SearchItemSub')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyScaDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The name of the server on which the middleware, database, or web service is run.
        self.count = count
        # name
        self.current_page = current_page
        # The public IP address of the server on which the middleware, database, or web service is run.
        self.page_size = page_size
        # The version of the runtime environment.
        # 
        # >  The value of this parameter can be the Java Development Kit (JDK) version of the runtime environment for a Java process.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyScaDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        biz_type_dispaly: str = None,
        cmdline: str = None,
        config_path: str = None,
        container_name: str = None,
        create_timestamp: int = None,
        image_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        listen_ip: str = None,
        listen_protocol: str = None,
        listen_status: str = None,
        name: str = None,
        path: str = None,
        pid: str = None,
        port: str = None,
        ppid: str = None,
        process_started: int = None,
        process_user: str = None,
        proof: str = None,
        runtime_env_version: str = None,
        type: str = None,
        uuid: str = None,
        version: str = None,
        web_path: str = None,
    ):
        # The path to the configuration file.
        self.biz_type = biz_type
        # The UUID of the server on which the middleware, database, or web service is run.
        self.biz_type_dispaly = biz_type_dispaly
        # The latest collection timestamp, which indicates the last timestamp when Security Center collected the information about the middleware, database, or web service. Unit: milliseconds.
        self.cmdline = cmdline
        # The name of the user who runs the process.
        self.config_path = config_path
        # uuid-02ebabe7-1c19-ab****\
        self.container_name = container_name
        # 756
        self.create_timestamp = create_timestamp
        # The search condition, such as a server name or a server IP address.
        # 
        # >  Fuzzy match is supported.
        self.image_name = image_name
        # version
        self.instance_id = instance_id
        # The name of the container.
        self.instance_name = instance_name
        # The total number of entries returned.
        self.internet_ip = internet_ip
        # 1.0.2k
        self.intranet_ip = intranet_ip
        # openssl
        self.ip = ip
        # 68
        self.listen_ip = listen_ip
        # The PID.
        self.listen_protocol = listen_protocol
        # The type of the subquery. Valid values:
        # 
        # *   **port**\
        # *   **pid**\
        # *   **version**\
        # *   **user**\
        self.listen_status = listen_status
        # The version verification information about the middleware, database, or web service.
        self.name = name
        # The version of the middleware, database, or web service.
        self.path = path
        # The command line of the process.
        self.pid = pid
        # 1
        self.port = port
        # The ID of the parent process.
        self.ppid = ppid
        # The user who runs the process.
        self.process_started = process_started
        # The port that the process monitors.
        self.process_user = process_user
        # The type of the middleware, database, or web service.
        self.proof = proof
        # open
        self.runtime_env_version = runtime_env_version
        # The name of the asset fingerprint that you want to query.
        self.type = type
        # The protocol of the traffic on which the process listens. Valid values:
        # 
        # *   **UDP**\
        # *   **TCP**\
        self.uuid = uuid
        # The type of the middleware, database, or web service that you want to query. Valid values:
        # 
        # *   **system_service**: system service
        # *   **software_library**: software library
        # *   **docker_component**: container component
        # *   **database**: database
        # *   **web_container**: web container
        # *   **jar**: JAR package
        # *   **web_framework**: web framework
        self.version = version
        # zh
        self.web_path = web_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.biz_type_dispaly is not None:
            result['BizTypeDispaly'] = self.biz_type_dispaly
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.config_path is not None:
            result['ConfigPath'] = self.config_path
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.listen_ip is not None:
            result['ListenIp'] = self.listen_ip
        if self.listen_protocol is not None:
            result['ListenProtocol'] = self.listen_protocol
        if self.listen_status is not None:
            result['ListenStatus'] = self.listen_status
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.ppid is not None:
            result['Ppid'] = self.ppid
        if self.process_started is not None:
            result['ProcessStarted'] = self.process_started
        if self.process_user is not None:
            result['ProcessUser'] = self.process_user
        if self.proof is not None:
            result['Proof'] = self.proof
        if self.runtime_env_version is not None:
            result['RuntimeEnvVersion'] = self.runtime_env_version
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('BizTypeDispaly') is not None:
            self.biz_type_dispaly = m.get('BizTypeDispaly')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('ConfigPath') is not None:
            self.config_path = m.get('ConfigPath')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('ListenIp') is not None:
            self.listen_ip = m.get('ListenIp')
        if m.get('ListenProtocol') is not None:
            self.listen_protocol = m.get('ListenProtocol')
        if m.get('ListenStatus') is not None:
            self.listen_status = m.get('ListenStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Ppid') is not None:
            self.ppid = m.get('Ppid')
        if m.get('ProcessStarted') is not None:
            self.process_started = m.get('ProcessStarted')
        if m.get('ProcessUser') is not None:
            self.process_user = m.get('ProcessUser')
        if m.get('Proof') is not None:
            self.proof = m.get('Proof')
        if m.get('RuntimeEnvVersion') is not None:
            self.runtime_env_version = m.get('RuntimeEnvVersion')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class DescribePropertyScaDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyScaDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertyScaDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # 192.168
        self.page_info = page_info
        # The listening status of the process. Valid values:
        # 
        # *   **NONE**: not listening
        # *   **LISTEN**: listening
        self.propertys = propertys
        # 1641024565
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyScaDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyScaDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScaDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyScaDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScaDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScaItemRequest(TeaModel):
    def __init__(
        self,
        biz: str = None,
        current_page: int = None,
        force_flush: bool = None,
        lang: str = None,
        page_size: int = None,
        search_info: str = None,
        search_item: str = None,
    ):
        # The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:
        # 
        # *   **sca**: middleware
        # *   **sca_database**: database
        # *   **sca_web**: web service
        # 
        # > If you do not specify this parameter, the default value **sca** is used, which indicates that middleware fingerprints are queried.
        self.biz = biz
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # Specifies whether to forcefully refresh the data that you want to query. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.force_flush = force_flush
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The search keyword. You must specify this parameter based on the value of the **SearchItem** parameter.
        # 
        # *   If the **SearchItem** parameter is set to **name**, you must enter the name of an asset fingerprint.
        # 
        # *   If the **SearchItem** parameter is set to **type**, you must enter the type of an asset fingerprint. Valid values:
        # 
        #     *   **system_service**: system service
        #     *   **software_library**: software library
        #     *   **docker_component**: container component
        #     *   **database**: database
        #     *   **web_container**: web container
        #     *   **jar**: JAR package
        #     *   **web_framework**: web framework
        # 
        # > You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.search_info = search_info
        # The type of the search condition. Valid values:
        # 
        # *   **name**: the name of a database, middleware, or web service
        # *   **type**: the type of a database, middleware, or web service
        # 
        # > You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.search_item = search_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        return self


class DescribePropertyScaItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyScaItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        count: int = None,
        name: str = None,
        type_display: str = None,
    ):
        # The type of the middleware, database, or web service. Valid values:
        # 
        # *   **system_service**: system service
        # *   **software_library**: software library
        # *   **docker_component**: container component
        # *   **database**: database
        # *   **web_container**: web container
        # *   **jar**: JAR package
        # *   **web_framework**: web framework
        self.biz_type = biz_type
        # The number of servers on which the middleware is run.
        self.count = count
        # The name of the middleware.
        self.name = name
        # The display name of the middleware type.
        self.type_display = type_display

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        if self.type_display is not None:
            result['TypeDisplay'] = self.type_display
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TypeDisplay') is not None:
            self.type_display = m.get('TypeDisplay')
        return self


class DescribePropertyScaItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyScaItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertyScaItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # An array that consists of the information about middleware fingerprints.
        self.property_items = property_items
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyScaItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyScaItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScaItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyScaItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScaItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScheduleConfigRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyScheduleConfigResponseBody(TeaModel):
    def __init__(
        self,
        config: str = None,
        request_id: str = None,
    ):
        self.config = config
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScheduleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyScheduleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertySoftwareDetailRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        extend: str = None,
        install_time_end: int = None,
        install_time_start: int = None,
        name: str = None,
        page_size: int = None,
        path: str = None,
        remark: str = None,
        software_version: str = None,
        uuid: str = None,
    ):
        # The name of the software.
        self.current_page = current_page
        # 10
        self.extend = extend
        # 3.10.0
        self.install_time_end = install_time_end
        # The name of the software.
        self.install_time_start = install_time_start
        # The details of the software asset.
        self.name = name
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The name or IP address of the server.
        self.path = path
        # The private IP address of the server.
        self.remark = remark
        # The number of the page to return. Default value: **1**.
        self.software_version = software_version
        # The public IP address of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.install_time_end is not None:
            result['InstallTimeEnd'] = self.install_time_end
        if self.install_time_start is not None:
            result['InstallTimeStart'] = self.install_time_start
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.path is not None:
            result['Path'] = self.path
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.software_version is not None:
            result['SoftwareVersion'] = self.software_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('InstallTimeEnd') is not None:
            self.install_time_end = m.get('InstallTimeEnd')
        if m.get('InstallTimeStart') is not None:
            self.install_time_start = m.get('InstallTimeStart')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SoftwareVersion') is not None:
            self.software_version = m.get('SoftwareVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertySoftwareDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The version of the software.
        self.count = count
        # 1
        self.current_page = current_page
        # The timestamp at which the software update ends. Unit: milliseconds.
        self.page_size = page_size
        # The installation path of the software.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertySoftwareDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        create_timestamp: int = None,
        install_time: str = None,
        install_time_dt: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        name: str = None,
        path: str = None,
        uuid: str = None,
        version: str = None,
    ):
        # The timestamp at which the software is installed. Unit: milliseconds.
        self.create_timestamp = create_timestamp
        # The ID of the server.
        self.install_time = install_time
        # The UUID of the server.
        self.install_time_dt = install_time_dt
        # 1
        self.instance_id = instance_id
        # /etc/test
        self.instance_name = instance_name
        # The timestamp at which the software update starts. Unit: milliseconds.
        self.internet_ip = internet_ip
        # The pagination information.
        self.intranet_ip = intranet_ip
        # The number of entries returned on the current page.
        self.ip = ip
        # The name of the server.
        self.name = name
        # The IP addresses of the server.
        self.path = path
        # 1650012695000
        self.uuid = uuid
        # Specifies whether fuzzy search by software name is supported. If you want to use fuzzy search, set the parameter to 1. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.install_time is not None:
            result['InstallTime'] = self.install_time
        if self.install_time_dt is not None:
            result['InstallTimeDt'] = self.install_time_dt
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstallTime') is not None:
            self.install_time = m.get('InstallTime')
        if m.get('InstallTimeDt') is not None:
            self.install_time_dt = m.get('InstallTimeDt')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribePropertySoftwareDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertySoftwareDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertySoftwareDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # The details of the software asset.
        self.page_info = page_info
        # The version of the software.
        self.propertys = propertys
        # 192.168.XX.XX
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertySoftwareDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertySoftwareDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertySoftwareDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertySoftwareDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertySoftwareDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertySoftwareItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        force_flush: bool = None,
        name: str = None,
        page_size: int = None,
    ):
        # The name of the software that you want to query.
        self.current_page = current_page
        # The number of servers on which the software is installed.
        self.force_flush = force_flush
        # The pagination information.
        self.name = name
        # 1
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertySoftwareItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # Queries information about all software assets.
        self.count = count
        # The number of entries returned per page.
        self.current_page = current_page
        # The ID of the request.
        self.page_size = page_size
        # true
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertySoftwareItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        name: str = None,
    ):
        self.count = count
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertySoftwareItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertySoftwareItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertySoftwareItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        # 10
        self.page_info = page_info
        # DescribePropertySoftwareItem
        self.property_items = property_items
        # The name of the software.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertySoftwareItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertySoftwareItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertySoftwareItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertySoftwareItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertySoftwareItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyTypeScaItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.lang = lang
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertyTypeScaItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyTypeScaItemResponseBodyPropertyTypeItems(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyTypeScaItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyTypeScaItemResponseBodyPageInfo = None,
        property_type_items: List[DescribePropertyTypeScaItemResponseBodyPropertyTypeItems] = None,
        request_id: str = None,
    ):
        self.page_info = page_info
        self.property_type_items = property_type_items
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_type_items:
            for k in self.property_type_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyTypeItems'] = []
        if self.property_type_items is not None:
            for k in self.property_type_items:
                result['PropertyTypeItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyTypeScaItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_type_items = []
        if m.get('PropertyTypeItems') is not None:
            for k in m.get('PropertyTypeItems'):
                temp_model = DescribePropertyTypeScaItemResponseBodyPropertyTypeItems()
                self.property_type_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyTypeScaItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyTypeScaItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyTypeScaItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUsageNewestRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyUsageNewestResponseBodyNewestStatisticItems(TeaModel):
    def __init__(
        self,
        create: int = None,
        name: str = None,
    ):
        self.create = create
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create is not None:
            result['Create'] = self.create
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Create') is not None:
            self.create = m.get('Create')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertyUsageNewestResponseBody(TeaModel):
    def __init__(
        self,
        item_count: int = None,
        newest_statistic_items: List[DescribePropertyUsageNewestResponseBodyNewestStatisticItems] = None,
        request_id: str = None,
        type: str = None,
    ):
        self.item_count = item_count
        self.newest_statistic_items = newest_statistic_items
        self.request_id = request_id
        self.type = type

    def validate(self):
        if self.newest_statistic_items:
            for k in self.newest_statistic_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_count is not None:
            result['ItemCount'] = self.item_count
        result['NewestStatisticItems'] = []
        if self.newest_statistic_items is not None:
            for k in self.newest_statistic_items:
                result['NewestStatisticItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemCount') is not None:
            self.item_count = m.get('ItemCount')
        self.newest_statistic_items = []
        if m.get('NewestStatisticItems') is not None:
            for k in m.get('NewestStatisticItems'):
                temp_model = DescribePropertyUsageNewestResponseBodyNewestStatisticItems()
                self.newest_statistic_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyUsageNewestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyUsageNewestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUsageNewestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUserDetailRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        extend: str = None,
        is_root: str = None,
        last_login_time_end: int = None,
        last_login_time_start: int = None,
        page_size: int = None,
        remark: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # The number of entries to return on each page. Default value: **10**.
        self.current_page = current_page
        # The details of asset fingerprints for the account.
        self.extend = extend
        # The details of the user groups to which the account belongs.
        self.is_root = is_root
        # The details of the user groups to which the account belongs.
        self.last_login_time_end = last_login_time_end
        # The date on which the account expires.
        self.last_login_time_start = last_login_time_start
        # The name or IP address of the server.
        self.page_size = page_size
        # Indicates whether the password expires. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.remark = remark
        # The number of the page to return. Default value: **1**.
        self.user = user
        # The public IP address of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.is_root is not None:
            result['IsRoot'] = self.is_root
        if self.last_login_time_end is not None:
            result['LastLoginTimeEnd'] = self.last_login_time_end
        if self.last_login_time_start is not None:
            result['LastLoginTimeStart'] = self.last_login_time_start
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('IsRoot') is not None:
            self.is_root = m.get('IsRoot')
        if m.get('LastLoginTimeEnd') is not None:
            self.last_login_time_end = m.get('LastLoginTimeEnd')
        if m.get('LastLoginTimeStart') is not None:
            self.last_login_time_start = m.get('LastLoginTimeStart')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyUserDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # Specifies whether the account has root permissions. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.count = count
        # The timestamp of the last logoff from the account. Unit: milliseconds.
        self.current_page = current_page
        # The name of the account to which the server belongs.
        self.page_size = page_size
        # The name of the account.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyUserDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        accounts_expiration_date: str = None,
        create_timestamp: int = None,
        group_names: List[str] = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        is_could_login: int = None,
        is_passwd_expired: int = None,
        is_passwd_locked: int = None,
        is_root: str = None,
        is_sudoer: int = None,
        is_user_expired: int = None,
        last_login_ip: str = None,
        last_login_time: str = None,
        last_login_time_dt: int = None,
        last_login_timestamp: int = None,
        password_expiration_date: str = None,
        status: str = None,
        user: str = None,
        uuid: str = None,
    ):
        # Indicates whether the account is an interactive logon account. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.accounts_expiration_date = accounts_expiration_date
        # The last logon time of the account.
        self.create_timestamp = create_timestamp
        # Queries the asset fingerprints for an account to which a server belongs.
        self.group_names = group_names
        # The UUID of the server.
        self.instance_id = instance_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.instance_name = instance_name
        # The ID of the server.
        self.internet_ip = internet_ip
        # The number of entries returned per page. Default value: **10**.
        self.intranet_ip = intranet_ip
        # The timestamp of the last logon to the account. Unit: milliseconds.
        self.ip = ip
        self.is_could_login = is_could_login
        self.is_passwd_expired = is_passwd_expired
        self.is_passwd_locked = is_passwd_locked
        # The IP addresses of the server.
        self.is_root = is_root
        self.is_sudoer = is_sudoer
        self.is_user_expired = is_user_expired
        # The pagination information.
        self.last_login_ip = last_login_ip
        # Specifies whether the fuzzy search by account name is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.last_login_time = last_login_time
        self.last_login_time_dt = last_login_time_dt
        # The source IP address of the last logon to the account.
        self.last_login_timestamp = last_login_timestamp
        # Indicates whether the account expires. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.password_expiration_date = password_expiration_date
        # This parameter is deprecated. You can ignore it.
        self.status = status
        # The name of the server.
        self.user = user
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accounts_expiration_date is not None:
            result['AccountsExpirationDate'] = self.accounts_expiration_date
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.group_names is not None:
            result['GroupNames'] = self.group_names
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.is_could_login is not None:
            result['IsCouldLogin'] = self.is_could_login
        if self.is_passwd_expired is not None:
            result['IsPasswdExpired'] = self.is_passwd_expired
        if self.is_passwd_locked is not None:
            result['IsPasswdLocked'] = self.is_passwd_locked
        if self.is_root is not None:
            result['IsRoot'] = self.is_root
        if self.is_sudoer is not None:
            result['IsSudoer'] = self.is_sudoer
        if self.is_user_expired is not None:
            result['IsUserExpired'] = self.is_user_expired
        if self.last_login_ip is not None:
            result['LastLoginIp'] = self.last_login_ip
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.last_login_time_dt is not None:
            result['LastLoginTimeDt'] = self.last_login_time_dt
        if self.last_login_timestamp is not None:
            result['LastLoginTimestamp'] = self.last_login_timestamp
        if self.password_expiration_date is not None:
            result['PasswordExpirationDate'] = self.password_expiration_date
        if self.status is not None:
            result['Status'] = self.status
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountsExpirationDate') is not None:
            self.accounts_expiration_date = m.get('AccountsExpirationDate')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('GroupNames') is not None:
            self.group_names = m.get('GroupNames')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IsCouldLogin') is not None:
            self.is_could_login = m.get('IsCouldLogin')
        if m.get('IsPasswdExpired') is not None:
            self.is_passwd_expired = m.get('IsPasswdExpired')
        if m.get('IsPasswdLocked') is not None:
            self.is_passwd_locked = m.get('IsPasswdLocked')
        if m.get('IsRoot') is not None:
            self.is_root = m.get('IsRoot')
        if m.get('IsSudoer') is not None:
            self.is_sudoer = m.get('IsSudoer')
        if m.get('IsUserExpired') is not None:
            self.is_user_expired = m.get('IsUserExpired')
        if m.get('LastLoginIp') is not None:
            self.last_login_ip = m.get('LastLoginIp')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('LastLoginTimeDt') is not None:
            self.last_login_time_dt = m.get('LastLoginTimeDt')
        if m.get('LastLoginTimestamp') is not None:
            self.last_login_timestamp = m.get('LastLoginTimestamp')
        if m.get('PasswordExpirationDate') is not None:
            self.password_expiration_date = m.get('PasswordExpirationDate')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyUserDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyUserDetailResponseBodyPageInfo = None,
        propertys: List[DescribePropertyUserDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # Indicates whether the password is locked. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.page_info = page_info
        # The timestamp of the last logon to the account. Unit: milliseconds.
        self.propertys = propertys
        # The date on which the password of the account expires.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyUserDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyUserDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyUserDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyUserDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUserDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUserItemRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        force_flush: bool = None,
        page_size: int = None,
        user: str = None,
    ):
        # The number of entries to return on each page.
        self.current_page = current_page
        # The information about the account.
        self.force_flush = force_flush
        # The ID of the request.
        self.page_size = page_size
        # The number of the page to return.
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribePropertyUserItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array that consists of the account information returned.
        self.count = count
        # The number of entries returned per page.
        self.current_page = current_page
        # The total number of entries returned.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyUserItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        user: str = None,
    ):
        # Queries information about an account.
        self.count = count
        # The number of servers that belong to the account.
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribePropertyUserItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribePropertyUserItemResponseBodyPageInfo = None,
        property_items: List[DescribePropertyUserItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        # The page number of the returned page.
        self.page_info = page_info
        # The name of the account.
        self.property_items = property_items
        # The pagination information.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyUserItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyUserItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyUserItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePropertyUserItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUserItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQuaraFileDownloadInfoRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        quara_file_id: int = None,
    ):
        # The ID of the request source. Set the value to sas.
        self.from_ = from_
        # The ID of the quarantined file.
        # 
        # > If you do not specify this parameter, you cannot call the RollbackSuspEventQuaraFile operation to restore a quarantined file. You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.
        self.quara_file_id = quara_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        return self


class DescribeQuaraFileDownloadInfoResponseBody(TeaModel):
    def __init__(
        self,
        download_url: str = None,
        md_5: str = None,
        path: str = None,
        quara_file_id: int = None,
        request_id: str = None,
        tag: str = None,
        uuid: str = None,
    ):
        # The URL that is used to download the file. The URL is valid for five minutes.
        self.download_url = download_url
        # The MD5 hash value of the quarantined file.
        self.md_5 = md_5
        # The file path.
        self.path = path
        # The ID of the quarantined file.
        self.quara_file_id = quara_file_id
        # The ID of the request.
        self.request_id = request_id
        # The tag that is added to the related alert.
        self.tag = tag
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.path is not None:
            result['Path'] = self.path
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeQuaraFileDownloadInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQuaraFileDownloadInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQuaraFileDownloadInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRestoreJobsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        machine_remark: str = None,
        page_size: int = None,
        status: str = None,
    ):
        # The timestamp when the in-progress restoration task is expected to be complete. Unit: seconds.
        self.current_page = current_page
        # The return value of the restoration task.
        self.machine_remark = machine_remark
        # The timestamp when the restoration task was last updated. Unit: milliseconds.
        self.page_size = page_size
        # The type of the file that is restored. Valid values:
        # 
        # *   **ECS_FILE**: files on Elastic Compute Service (ECS) instances
        # *   **FILE**: files on servers in data centers
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRestoreJobsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The hash value of the snapshot that stores backup data when the data is backed up.
        self.count = count
        # The error message returned.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The number of the page to return. Default value: **1**.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRestoreJobsResponseBodyRestoreJobs(TeaModel):
    def __init__(
        self,
        actual_bytes: int = None,
        bytes_done: int = None,
        bytes_total: int = None,
        client_id: str = None,
        complete_time: int = None,
        created_time: int = None,
        duration: int = None,
        error_count: int = None,
        error_file: str = None,
        error_file_url: str = None,
        error_type: str = None,
        eta: int = None,
        excludes: str = None,
        exit_code: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        includes: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        items_done: int = None,
        items_total: int = None,
        message: str = None,
        percentage: int = None,
        request_id: str = None,
        restore_id: str = None,
        restore_name: str = None,
        restore_type: str = None,
        snapshot_hash: str = None,
        snapshot_id: str = None,
        snapshot_version: str = None,
        source: str = None,
        source_client_id: str = None,
        speed: int = None,
        status: str = None,
        target: str = None,
        updated_time: int = None,
        uuid: str = None,
        vault_id: str = None,
    ):
        # The URL to download the CSV file. The CSV file contains the files that fail to be restored.
        self.actual_bytes = actual_bytes
        self.bytes_done = bytes_done
        # The size of backup data. Unit: bytes.
        self.bytes_total = bytes_total
        # The time when the restoration task is updated.
        self.client_id = client_id
        # The ID of the backup vault in which the backup data is stored.
        self.complete_time = complete_time
        # RUNNING
        self.created_time = created_time
        # DescribeRestoreJobs
        self.duration = duration
        # WB01014029
        self.error_count = error_count
        # The included directory based on which the files to restore are located. The value is the directory that you specify for protection when you create the anti-ransomware policy
        self.error_file = error_file
        # The status of the restoration task. Valid values:
        # 
        # *   **RUNNING**: The task is running.
        # *   **COMPLETE**: The task is complete.
        # *   **FAILED**: The task fails.
        # *   **CANCELING**: The task is being canceled.
        # *   **CANCELED**: The task is canceled.
        # *   **PARTIAL_COMPLETE**: The task is partially successful.
        # *   **CREATED**: The task is created but is not run.
        # *   **EXPIRED**: The task is not updated.
        # *   **QUEUED**: The task is waiting to be run.
        # *   **CLIENT_DELETED**: The task fails because the anti-ransomware agent is uninstalled.
        self.error_file_url = error_file_url
        # 1
        self.error_type = error_type
        # Queries the details about restoration tasks.
        self.eta = eta
        # The public IP address of the server whose data you want to restore.
        self.excludes = excludes
        # The total number of restoration tasks returned.
        self.exit_code = exit_code
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.gmt_create = gmt_create
        # The ID of the anti-ransomware agent that is used to back up data.
        self.gmt_modified = gmt_modified
        # The total size of data that you want to restore. Unit: bytes.
        self.includes = includes
        # The speed of data restoration. Unit: byte/s.
        self.instance_id = instance_id
        # The error code that is returned for the restoration task.
        self.instance_name = instance_name
        # 10
        self.internet_ip = internet_ip
        # The timestamp when the restoration task is complete. Unit: milliseconds.
        self.intranet_ip = intranet_ip
        # The number of files that are backed up.
        self.items_done = items_done
        self.items_total = items_total
        # The total number of files that you want to restore.
        self.message = message
        # The ID of the anti-ransomware agent that is used to restore data.
        self.percentage = percentage
        # The internal IP address of the server whose data you want to restore.
        self.request_id = request_id
        # The version of the backup data.
        self.restore_id = restore_id
        # The UUID of the server whose data you want to restore.
        self.restore_name = restore_name
        # The total size of data that is restored. Unit: bytes.
        self.restore_type = restore_type
        # The number of restoration tasks returned on the current page.
        self.snapshot_hash = snapshot_hash
        # The ID of the server whose data you want to restore.
        self.snapshot_id = snapshot_id
        # The time when the restoration task is created.
        self.snapshot_version = snapshot_version
        # The hash value ID of the snapshot that stores backup data when the data is backed up.
        self.source = source
        # An array that consists of the restoration tasks.
        self.source_client_id = source_client_id
        # The pagination information.
        self.speed = speed
        # The path to the source file that you want to restore.
        self.status = status
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.target = target
        # The number of entries returned per page. Default value: **10**.
        self.updated_time = updated_time
        # The name of the restoration task.
        self.uuid = uuid
        # The ID of the restoration task.
        self.vault_id = vault_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_bytes is not None:
            result['ActualBytes'] = self.actual_bytes
        if self.bytes_done is not None:
            result['BytesDone'] = self.bytes_done
        if self.bytes_total is not None:
            result['BytesTotal'] = self.bytes_total
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.error_count is not None:
            result['ErrorCount'] = self.error_count
        if self.error_file is not None:
            result['ErrorFile'] = self.error_file
        if self.error_file_url is not None:
            result['ErrorFileUrl'] = self.error_file_url
        if self.error_type is not None:
            result['ErrorType'] = self.error_type
        if self.eta is not None:
            result['Eta'] = self.eta
        if self.excludes is not None:
            result['Excludes'] = self.excludes
        if self.exit_code is not None:
            result['ExitCode'] = self.exit_code
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.includes is not None:
            result['Includes'] = self.includes
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.items_done is not None:
            result['ItemsDone'] = self.items_done
        if self.items_total is not None:
            result['ItemsTotal'] = self.items_total
        if self.message is not None:
            result['Message'] = self.message
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.restore_id is not None:
            result['RestoreId'] = self.restore_id
        if self.restore_name is not None:
            result['RestoreName'] = self.restore_name
        if self.restore_type is not None:
            result['RestoreType'] = self.restore_type
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_version is not None:
            result['SnapshotVersion'] = self.snapshot_version
        if self.source is not None:
            result['Source'] = self.source
        if self.source_client_id is not None:
            result['SourceClientId'] = self.source_client_id
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualBytes') is not None:
            self.actual_bytes = m.get('ActualBytes')
        if m.get('BytesDone') is not None:
            self.bytes_done = m.get('BytesDone')
        if m.get('BytesTotal') is not None:
            self.bytes_total = m.get('BytesTotal')
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ErrorCount') is not None:
            self.error_count = m.get('ErrorCount')
        if m.get('ErrorFile') is not None:
            self.error_file = m.get('ErrorFile')
        if m.get('ErrorFileUrl') is not None:
            self.error_file_url = m.get('ErrorFileUrl')
        if m.get('ErrorType') is not None:
            self.error_type = m.get('ErrorType')
        if m.get('Eta') is not None:
            self.eta = m.get('Eta')
        if m.get('Excludes') is not None:
            self.excludes = m.get('Excludes')
        if m.get('ExitCode') is not None:
            self.exit_code = m.get('ExitCode')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Includes') is not None:
            self.includes = m.get('Includes')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('ItemsDone') is not None:
            self.items_done = m.get('ItemsDone')
        if m.get('ItemsTotal') is not None:
            self.items_total = m.get('ItemsTotal')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RestoreId') is not None:
            self.restore_id = m.get('RestoreId')
        if m.get('RestoreName') is not None:
            self.restore_name = m.get('RestoreName')
        if m.get('RestoreType') is not None:
            self.restore_type = m.get('RestoreType')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotVersion') is not None:
            self.snapshot_version = m.get('SnapshotVersion')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceClientId') is not None:
            self.source_client_id = m.get('SourceClientId')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeRestoreJobsResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeRestoreJobsResponseBodyPageInfo = None,
        request_id: str = None,
        restore_jobs: List[DescribeRestoreJobsResponseBodyRestoreJobs] = None,
    ):
        # The folder to which the backup data is restored. After you create the restoration task, the backup data is restored to the specified folder.
        self.page_info = page_info
        # The directory excluded from the anti-ransomware policy. The value is the directory that you specify to skip protection when you create the anti-ransomware policy.
        self.request_id = request_id
        # The timestamp when the restoration task is created. Unit: milliseconds.
        self.restore_jobs = restore_jobs

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.restore_jobs:
            for k in self.restore_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RestoreJobs'] = []
        if self.restore_jobs is not None:
            for k in self.restore_jobs:
                result['RestoreJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeRestoreJobsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.restore_jobs = []
        if m.get('RestoreJobs') is not None:
            for k in m.get('RestoreJobs'):
                temp_model = DescribeRestoreJobsResponseBodyRestoreJobs()
                self.restore_jobs.append(temp_model.from_map(k))
        return self


class DescribeRestoreJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRestoreJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRestoreJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRestorePlansRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_name: str = None,
        page_size: int = None,
        status: str = None,
    ):
        self.current_page = current_page
        self.instance_name = instance_name
        self.page_size = page_size
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRestorePlansResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRestorePlansResponseBodyRestorePlans(TeaModel):
    def __init__(
        self,
        created_time: int = None,
        database_name: str = None,
        instance_name: str = None,
        policy_id: int = None,
        policy_name: str = None,
        restore_point: int = None,
        status: str = None,
        target_database_name: str = None,
        target_instance_id: str = None,
        target_instance_name: str = None,
        updated_time: int = None,
    ):
        self.created_time = created_time
        self.database_name = database_name
        self.instance_name = instance_name
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.restore_point = restore_point
        self.status = status
        self.target_database_name = target_database_name
        self.target_instance_id = target_instance_id
        self.target_instance_name = target_instance_name
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.restore_point is not None:
            result['RestorePoint'] = self.restore_point
        if self.status is not None:
            result['Status'] = self.status
        if self.target_database_name is not None:
            result['TargetDatabaseName'] = self.target_database_name
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_instance_name is not None:
            result['TargetInstanceName'] = self.target_instance_name
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RestorePoint') is not None:
            self.restore_point = m.get('RestorePoint')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetDatabaseName') is not None:
            self.target_database_name = m.get('TargetDatabaseName')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetInstanceName') is not None:
            self.target_instance_name = m.get('TargetInstanceName')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class DescribeRestorePlansResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeRestorePlansResponseBodyPageInfo = None,
        request_id: str = None,
        restore_plans: List[DescribeRestorePlansResponseBodyRestorePlans] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.restore_plans = restore_plans

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.restore_plans:
            for k in self.restore_plans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RestorePlans'] = []
        if self.restore_plans is not None:
            for k in self.restore_plans:
                result['RestorePlans'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeRestorePlansResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.restore_plans = []
        if m.get('RestorePlans') is not None:
            for k in m.get('RestorePlans'):
                temp_model = DescribeRestorePlansResponseBodyRestorePlans()
                self.restore_plans.append(temp_model.from_map(k))
        return self


class DescribeRestorePlansResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRestorePlansResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRestorePlansResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckItemResultRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        item_id: int = None,
        lang: str = None,
        page_size: int = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The ID of the check item.
        # 
        # > For more information about the IDs and details of the check items that can be used in configuration assessment, see [DescribeRiskCheckResult](~~DescribeRiskCheckResult~~).
        self.item_id = item_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskCheckItemResultResponseBodyPageContentResource(TeaModel):
    def __init__(
        self,
        content_resource: Dict[str, Any] = None,
        count: int = None,
        current_page: int = None,
        page_count: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The data of the affected assets on each page in a dynamic table.
        self.content_resource = content_resource
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_resource is not None:
            result['ContentResource'] = self.content_resource
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentResource') is not None:
            self.content_resource = m.get('ContentResource')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRiskCheckItemResultResponseBody(TeaModel):
    def __init__(
        self,
        page_content_resource: DescribeRiskCheckItemResultResponseBodyPageContentResource = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.page_content_resource = page_content_resource
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_content_resource:
            self.page_content_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_content_resource is not None:
            result['PageContentResource'] = self.page_content_resource.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageContentResource') is not None:
            temp_model = DescribeRiskCheckItemResultResponseBodyPageContentResource()
            self.page_content_resource = temp_model.from_map(m['PageContentResource'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskCheckItemResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskCheckItemResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckItemResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckResultRequest(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        current_page: int = None,
        group_id: int = None,
        item_ids: List[str] = None,
        lang: str = None,
        name: str = None,
        page_size: int = None,
        query_flag: str = None,
        resource_owner_id: int = None,
        risk_level: str = None,
        source_ip: str = None,
        status: str = None,
    ):
        # The cloud service whose configuration check results you want to query. For more information about the check items for the cloud service, see the check item table in the "Response parameters" section of this topic.
        self.asset_type = asset_type
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The type of the check item that you want to query. Valid values:
        # 
        # *   **1**: identity authentication and permissions
        # *   **2**: network access control
        # *   **3**: log audit
        # *   **4**: data security
        # *   **5**: monitoring and alerting
        # *   **6**: basic security protection
        # 
        # > If you do not specify this parameter, all types of check items are queried.
        self.group_id = group_id
        self.item_ids = item_ids
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The name of the check item. For more information about the check item, see the check item table in the "Response parameters" section of this topic.
        self.name = name
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # Specifies whether the check item is supported by the edition of Security Center that you purchase. Valid values:
        # 
        # *   **enabled**: yes
        # *   **disabled**: no
        self.query_flag = query_flag
        self.resource_owner_id = resource_owner_id
        # The risk level of the check item that you want to query. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level
        # The source IP address of the request.
        self.source_ip = source_ip
        # The status of the check results. Valid values:
        # 
        # *   **pass**\
        # *   **failed**\
        # *   **running**\
        # *   **waiting**\
        # *   **ignored**\
        # *   **falsePositive**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_flag is not None:
            result['QueryFlag'] = self.query_flag
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ItemIds') is not None:
            self.item_ids = m.get('ItemIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryFlag') is not None:
            self.query_flag = m.get('QueryFlag')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRiskCheckResultResponseBodyListRiskItemResources(TeaModel):
    def __init__(
        self,
        content_resource: Dict[str, Any] = None,
        resource_name: str = None,
    ):
        # The details about the check results.
        self.content_resource = content_resource
        # The title in the details. Valid values:
        # 
        # *   **bestPractice**: description
        # *   **influence**: risk
        # *   **suggestion**: solution
        # *   **helpResource**: reference
        self.resource_name = resource_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_resource is not None:
            result['ContentResource'] = self.content_resource
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentResource') is not None:
            self.content_resource = m.get('ContentResource')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        return self


class DescribeRiskCheckResultResponseBodyList(TeaModel):
    def __init__(
        self,
        affected_count: int = None,
        check_time: int = None,
        item_id: int = None,
        remaining_time: int = None,
        repair_status: str = None,
        risk_assert_type: str = None,
        risk_item_resources: List[DescribeRiskCheckResultResponseBodyListRiskItemResources] = None,
        risk_level: str = None,
        sort: int = None,
        start_status: str = None,
        status: str = None,
        task_id: int = None,
        title: str = None,
        type: str = None,
    ):
        # The number of affected assets.
        self.affected_count = affected_count
        # The timestamp when the last check was performed. Unit: milliseconds.
        self.check_time = check_time
        # The ID of the check item. For more information about the check item, see the check item table in the "Response parameters" section of this topic.
        self.item_id = item_id
        # The time when the next check will be performed.
        self.remaining_time = remaining_time
        # Indicates whether the risks that are detected based on the check item can be fixed. Valid values:
        # 
        # *   **enabled**: yes
        # *   **disabled**: no
        self.repair_status = repair_status
        # The type of the affected assets.
        self.risk_assert_type = risk_assert_type
        # An array that consists of the details about the check item.
        self.risk_item_resources = risk_item_resources
        # The risk level of the check item. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level
        # The sequence number in the check results. The check items are sorted based on the sequence number.
        self.sort = sort
        # Indicates whether the check item is supported by the edition of Security Center that you purchase. Valid values:
        # 
        # *   **enabled**: yes
        # *   **disable**: no
        self.start_status = start_status
        # The status of the check results. Valid values:
        # 
        # *   **pass**\
        # *   **failed**\
        # *   **running**\
        # *   **waiting**\
        # *   **ignored**\
        # *   **falsePositive**\
        self.status = status
        # The ID of the check task.
        self.task_id = task_id
        # The name of the check item.
        self.title = title
        # The type of the check item. Valid values:
        # 
        # *   Identity authentication and permissions
        # *   Network access control
        # *   Log audit
        # *   Data security
        # *   Monitoring and alerting
        # *   Basic security protection
        self.type = type

    def validate(self):
        if self.risk_item_resources:
            for k in self.risk_item_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_count is not None:
            result['AffectedCount'] = self.affected_count
        if self.check_time is not None:
            result['CheckTime'] = self.check_time
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.remaining_time is not None:
            result['RemainingTime'] = self.remaining_time
        if self.repair_status is not None:
            result['RepairStatus'] = self.repair_status
        if self.risk_assert_type is not None:
            result['RiskAssertType'] = self.risk_assert_type
        result['RiskItemResources'] = []
        if self.risk_item_resources is not None:
            for k in self.risk_item_resources:
                result['RiskItemResources'].append(k.to_map() if k else None)
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.start_status is not None:
            result['StartStatus'] = self.start_status
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectedCount') is not None:
            self.affected_count = m.get('AffectedCount')
        if m.get('CheckTime') is not None:
            self.check_time = m.get('CheckTime')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('RemainingTime') is not None:
            self.remaining_time = m.get('RemainingTime')
        if m.get('RepairStatus') is not None:
            self.repair_status = m.get('RepairStatus')
        if m.get('RiskAssertType') is not None:
            self.risk_assert_type = m.get('RiskAssertType')
        self.risk_item_resources = []
        if m.get('RiskItemResources') is not None:
            for k in m.get('RiskItemResources'):
                temp_model = DescribeRiskCheckResultResponseBodyListRiskItemResources()
                self.risk_item_resources.append(temp_model.from_map(k))
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('StartStatus') is not None:
            self.start_status = m.get('StartStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeRiskCheckResultResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        list: List[DescribeRiskCheckResultResponseBodyList] = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # An array that consists of the check items.
        self.list = list
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskCheckResultResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRiskCheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskCheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckSummaryRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_directory_account_id: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.lang = lang
        self.resource_directory_account_id = resource_directory_account_id
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus(TeaModel):
    def __init__(
        self,
        count: int = None,
        status: str = None,
    ):
        self.count = count
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups(TeaModel):
    def __init__(
        self,
        count_by_status: List[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus] = None,
        id: int = None,
        remaining_time: int = None,
        sort: int = None,
        status: str = None,
        title: str = None,
    ):
        self.count_by_status = count_by_status
        self.id = id
        self.remaining_time = remaining_time
        self.sort = sort
        self.status = status
        self.title = title

    def validate(self):
        if self.count_by_status:
            for k in self.count_by_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CountByStatus'] = []
        if self.count_by_status is not None:
            for k in self.count_by_status:
                result['CountByStatus'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.remaining_time is not None:
            result['RemainingTime'] = self.remaining_time
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.count_by_status = []
        if m.get('CountByStatus') is not None:
            for k in m.get('CountByStatus'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus()
                self.count_by_status.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RemainingTime') is not None:
            self.remaining_time = m.get('RemainingTime')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount(TeaModel):
    def __init__(
        self,
        count: int = None,
        key: str = None,
    ):
        self.count = count
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummary(TeaModel):
    def __init__(
        self,
        affected_asset_count: int = None,
        disabled_risk_count: int = None,
        enabled_risk_count: int = None,
        groups: List[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups] = None,
        item_count: int = None,
        previous_count: int = None,
        previous_time: int = None,
        risk_count: int = None,
        risk_level_count: List[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount] = None,
        risk_rate: float = None,
    ):
        self.affected_asset_count = affected_asset_count
        self.disabled_risk_count = disabled_risk_count
        self.enabled_risk_count = enabled_risk_count
        self.groups = groups
        self.item_count = item_count
        self.previous_count = previous_count
        self.previous_time = previous_time
        self.risk_count = risk_count
        self.risk_level_count = risk_level_count
        self.risk_rate = risk_rate

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        if self.risk_level_count:
            for k in self.risk_level_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_asset_count is not None:
            result['AffectedAssetCount'] = self.affected_asset_count
        if self.disabled_risk_count is not None:
            result['DisabledRiskCount'] = self.disabled_risk_count
        if self.enabled_risk_count is not None:
            result['EnabledRiskCount'] = self.enabled_risk_count
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.item_count is not None:
            result['ItemCount'] = self.item_count
        if self.previous_count is not None:
            result['PreviousCount'] = self.previous_count
        if self.previous_time is not None:
            result['PreviousTime'] = self.previous_time
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        result['RiskLevelCount'] = []
        if self.risk_level_count is not None:
            for k in self.risk_level_count:
                result['RiskLevelCount'].append(k.to_map() if k else None)
        if self.risk_rate is not None:
            result['RiskRate'] = self.risk_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectedAssetCount') is not None:
            self.affected_asset_count = m.get('AffectedAssetCount')
        if m.get('DisabledRiskCount') is not None:
            self.disabled_risk_count = m.get('DisabledRiskCount')
        if m.get('EnabledRiskCount') is not None:
            self.enabled_risk_count = m.get('EnabledRiskCount')
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('ItemCount') is not None:
            self.item_count = m.get('ItemCount')
        if m.get('PreviousCount') is not None:
            self.previous_count = m.get('PreviousCount')
        if m.get('PreviousTime') is not None:
            self.previous_time = m.get('PreviousTime')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        self.risk_level_count = []
        if m.get('RiskLevelCount') is not None:
            for k in m.get('RiskLevelCount'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount()
                self.risk_level_count.append(temp_model.from_map(k))
        if m.get('RiskRate') is not None:
            self.risk_rate = m.get('RiskRate')
        return self


class DescribeRiskCheckSummaryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        risk_check_summary: DescribeRiskCheckSummaryResponseBodyRiskCheckSummary = None,
    ):
        self.request_id = request_id
        self.risk_check_summary = risk_check_summary

    def validate(self):
        if self.risk_check_summary:
            self.risk_check_summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_check_summary is not None:
            result['RiskCheckSummary'] = self.risk_check_summary.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskCheckSummary') is not None:
            temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummary()
            self.risk_check_summary = temp_model.from_map(m['RiskCheckSummary'])
        return self


class DescribeRiskCheckSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskCheckSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskItemTypeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskItemTypeResponseBodyList(TeaModel):
    def __init__(
        self,
        id: int = None,
        title: str = None,
    ):
        # The ID of the check item.
        self.id = id
        # The name of the check type.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeRiskItemTypeResponseBody(TeaModel):
    def __init__(
        self,
        list: List[DescribeRiskItemTypeResponseBodyList] = None,
        request_id: str = None,
    ):
        # An array that consists of information about the type of the check item.
        self.list = list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskItemTypeResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskItemTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskItemTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskItemTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskListCheckResultRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_ids: List[str] = None,
        lang: str = None,
        page_size: int = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.current_page = current_page
        self.instance_ids = instance_ids
        self.lang = lang
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskListCheckResultResponseBodyList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        risk_count: int = None,
    ):
        self.instance_id = instance_id
        self.risk_count = risk_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.risk_count is not None:
            result['riskCount'] = self.risk_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('riskCount') is not None:
            self.risk_count = m.get('riskCount')
        return self


class DescribeRiskListCheckResultResponseBody(TeaModel):
    def __init__(
        self,
        list: List[DescribeRiskListCheckResultResponseBodyList] = None,
        request_id: str = None,
    ):
        self.list = list
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskListCheckResultResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskListCheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskListCheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskListCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskTypeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
    ):
        # The name of the baseline type.
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList(TeaModel):
    def __init__(
        self,
        enum_value: str = None,
        max_value: int = None,
        min_value: int = None,
        param_default_value: str = None,
        param_desc: str = None,
        param_name: str = None,
        param_type: int = None,
    ):
        self.enum_value = enum_value
        self.max_value = max_value
        self.min_value = min_value
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.param_default_value = param_default_value
        self.param_desc = param_desc
        # Queries baseline types.
        self.param_name = param_name
        self.param_type = param_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules(TeaModel):
    def __init__(
        self,
        optional: int = None,
        param_list: List[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList] = None,
        rule_desc: str = None,
        rule_id: str = None,
    ):
        # The name of the parameter.
        self.optional = optional
        # The description of the baseline.
        self.param_list = param_list
        # An array that consists of the information about baseline subtypes.
        self.rule_desc = rule_desc
        # The maximum value of the parameter.
        self.rule_id = rule_id

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails(TeaModel):
    def __init__(
        self,
        check_desc: str = None,
        check_id: int = None,
        check_item: str = None,
        rules: List[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules] = None,
    ):
        # The alias of the baseline subtype.
        self.check_desc = check_desc
        # The ID of the baseline.
        self.check_id = check_id
        # The name of the baseline subtype.
        self.check_item = check_item
        # The minimum value of the parameter.
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypes(TeaModel):
    def __init__(
        self,
        alias: str = None,
        check_details: List[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails] = None,
        type_name: str = None,
    ):
        # The configuration type of the parameter. Valid values:
        # 
        # *   **1**: input
        # *   **2**: selection
        self.alias = alias
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.check_details = check_details
        # An array that consists of the check details about the baseline subtype.
        self.type_name = type_name

    def validate(self):
        if self.check_details:
            for k in self.check_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['CheckDetails'] = []
        if self.check_details is not None:
            for k in self.check_details:
                result['CheckDetails'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.check_details = []
        if m.get('CheckDetails') is not None:
            for k in m.get('CheckDetails'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails()
                self.check_details.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeRiskTypeResponseBodyRiskTypes(TeaModel):
    def __init__(
        self,
        alias: str = None,
        sub_types: List[DescribeRiskTypeResponseBodyRiskTypesSubTypes] = None,
        type_name: str = None,
    ):
        # The description of the parameter.
        self.alias = alias
        # An array that consists of the rule details about the baseline.
        self.sub_types = sub_types
        # The alias of the baseline type.
        self.type_name = type_name

    def validate(self):
        if self.sub_types:
            for k in self.sub_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['SubTypes'] = []
        if self.sub_types is not None:
            for k in self.sub_types:
                result['SubTypes'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.sub_types = []
        if m.get('SubTypes') is not None:
            for k in m.get('SubTypes'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypes()
                self.sub_types.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeRiskTypeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        risk_types: List[DescribeRiskTypeResponseBodyRiskTypes] = None,
    ):
        # The description of the rule for the baseline.
        self.request_id = request_id
        # An array that consists of the information about baseline types.
        self.risk_types = risk_types

    def validate(self):
        if self.risk_types:
            for k in self.risk_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RiskTypes'] = []
        if self.risk_types is not None:
            for k in self.risk_types:
                result['RiskTypes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.risk_types = []
        if m.get('RiskTypes') is not None:
            for k in m.get('RiskTypes'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypes()
                self.risk_types.append(temp_model.from_map(k))
        return self


class DescribeRiskTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRisksRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        limit: int = None,
        risk_id: int = None,
        risk_name: str = None,
    ):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The maximum number of entries to return. Default value: 20.
        self.limit = limit
        # The ID of the baseline.
        # 
        # > You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of baselines.
        self.risk_id = risk_id
        # The name of the baseline.
        self.risk_name = risk_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class DescribeRisksResponseBodyRisks(TeaModel):
    def __init__(
        self,
        risk_detail: str = None,
        risk_id: int = None,
        risk_name: str = None,
        risk_type: str = None,
        sub_risk_type: str = None,
        sub_type_alias: str = None,
        type_alias: str = None,
    ):
        # The description of the baseline.
        self.risk_detail = risk_detail
        # The ID of the baseline.
        self.risk_id = risk_id
        # The name of the baseline.
        self.risk_name = risk_name
        # The name of the baseline type.
        self.risk_type = risk_type
        # The name of the baseline subtype.
        self.sub_risk_type = sub_risk_type
        # The display name of the baseline subtype.
        self.sub_type_alias = sub_type_alias
        # The display name of the baseline type.
        self.type_alias = type_alias

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_detail is not None:
            result['RiskDetail'] = self.risk_detail
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.sub_risk_type is not None:
            result['SubRiskType'] = self.sub_risk_type
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RiskDetail') is not None:
            self.risk_detail = m.get('RiskDetail')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('SubRiskType') is not None:
            self.sub_risk_type = m.get('SubRiskType')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        return self


class DescribeRisksResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        risks: List[DescribeRisksResponseBodyRisks] = None,
        total_count: int = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array that consists of baselines.
        self.risks = risks
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.risks:
            for k in self.risks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Risks'] = []
        if self.risks is not None:
            for k in self.risks:
                result['Risks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.risks = []
        if m.get('Risks') is not None:
            for k in m.get('Risks'):
                temp_model = DescribeRisksResponseBodyRisks()
                self.risks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRisksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRisksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRisksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSasPmAgentListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        uuids: str = None,
    ):
        self.lang = lang
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeSasPmAgentListResponseBodySasPmAgentList(TeaModel):
    def __init__(
        self,
        aliyun_assist_id: str = None,
        aliyun_monitor_id: str = None,
        assist_install_result: int = None,
        assist_install_status: int = None,
        monitor_install_result: int = None,
        monitor_install_status: int = None,
        uuid: str = None,
    ):
        self.aliyun_assist_id = aliyun_assist_id
        self.aliyun_monitor_id = aliyun_monitor_id
        self.assist_install_result = assist_install_result
        self.assist_install_status = assist_install_status
        self.monitor_install_result = monitor_install_result
        self.monitor_install_status = monitor_install_status
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_assist_id is not None:
            result['AliyunAssistId'] = self.aliyun_assist_id
        if self.aliyun_monitor_id is not None:
            result['AliyunMonitorId'] = self.aliyun_monitor_id
        if self.assist_install_result is not None:
            result['AssistInstallResult'] = self.assist_install_result
        if self.assist_install_status is not None:
            result['AssistInstallStatus'] = self.assist_install_status
        if self.monitor_install_result is not None:
            result['MonitorInstallResult'] = self.monitor_install_result
        if self.monitor_install_status is not None:
            result['MonitorInstallStatus'] = self.monitor_install_status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunAssistId') is not None:
            self.aliyun_assist_id = m.get('AliyunAssistId')
        if m.get('AliyunMonitorId') is not None:
            self.aliyun_monitor_id = m.get('AliyunMonitorId')
        if m.get('AssistInstallResult') is not None:
            self.assist_install_result = m.get('AssistInstallResult')
        if m.get('AssistInstallStatus') is not None:
            self.assist_install_status = m.get('AssistInstallStatus')
        if m.get('MonitorInstallResult') is not None:
            self.monitor_install_result = m.get('MonitorInstallResult')
        if m.get('MonitorInstallStatus') is not None:
            self.monitor_install_status = m.get('MonitorInstallStatus')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSasPmAgentListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sas_pm_agent_list: List[DescribeSasPmAgentListResponseBodySasPmAgentList] = None,
    ):
        self.request_id = request_id
        self.sas_pm_agent_list = sas_pm_agent_list

    def validate(self):
        if self.sas_pm_agent_list:
            for k in self.sas_pm_agent_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SasPmAgentList'] = []
        if self.sas_pm_agent_list is not None:
            for k in self.sas_pm_agent_list:
                result['SasPmAgentList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sas_pm_agent_list = []
        if m.get('SasPmAgentList') is not None:
            for k in m.get('SasPmAgentList'):
                temp_model = DescribeSasPmAgentListResponseBodySasPmAgentList()
                self.sas_pm_agent_list.append(temp_model.from_map(k))
        return self


class DescribeSasPmAgentListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSasPmAgentListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSasPmAgentListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScanTaskProgressRequest(TeaModel):
    def __init__(
        self,
        task_id: int = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeScanTaskProgressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scan_task_progress: str = None,
        target_info: str = None,
    ):
        self.request_id = request_id
        self.scan_task_progress = scan_task_progress
        self.target_info = target_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scan_task_progress is not None:
            result['ScanTaskProgress'] = self.scan_task_progress
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScanTaskProgress') is not None:
            self.scan_task_progress = m.get('ScanTaskProgress')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class DescribeScanTaskProgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScanTaskProgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScanTaskProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScanTaskStatisticsRequest(TeaModel):
    def __init__(
        self,
        levels: str = None,
    ):
        self.levels = levels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.levels is not None:
            result['Levels'] = self.levels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        return self


class DescribeScanTaskStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        dealed_risk_num: int = None,
        personal_task_num: int = None,
        request_id: str = None,
        total_task_num: int = None,
        user_num: int = None,
    ):
        self.dealed_risk_num = dealed_risk_num
        self.personal_task_num = personal_task_num
        self.request_id = request_id
        self.total_task_num = total_task_num
        self.user_num = user_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed_risk_num is not None:
            result['DealedRiskNum'] = self.dealed_risk_num
        if self.personal_task_num is not None:
            result['PersonalTaskNum'] = self.personal_task_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_task_num is not None:
            result['TotalTaskNum'] = self.total_task_num
        if self.user_num is not None:
            result['UserNum'] = self.user_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DealedRiskNum') is not None:
            self.dealed_risk_num = m.get('DealedRiskNum')
        if m.get('PersonalTaskNum') is not None:
            self.personal_task_num = m.get('PersonalTaskNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalTaskNum') is not None:
            self.total_task_num = m.get('TotalTaskNum')
        if m.get('UserNum') is not None:
            self.user_num = m.get('UserNum')
        return self


class DescribeScanTaskStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScanTaskStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScanTaskStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSearchConditionRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        type: str = None,
    ):
        self.lang = lang
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSearchConditionResponseBodyConditionList(TeaModel):
    def __init__(
        self,
        condition_type: str = None,
        filter_conditions: str = None,
        name: str = None,
        name_key: str = None,
    ):
        self.condition_type = condition_type
        self.filter_conditions = filter_conditions
        self.name = name
        self.name_key = name_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_type is not None:
            result['ConditionType'] = self.condition_type
        if self.filter_conditions is not None:
            result['FilterConditions'] = self.filter_conditions
        if self.name is not None:
            result['Name'] = self.name
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionType') is not None:
            self.condition_type = m.get('ConditionType')
        if m.get('FilterConditions') is not None:
            self.filter_conditions = m.get('FilterConditions')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeSearchConditionResponseBody(TeaModel):
    def __init__(
        self,
        condition_list: List[DescribeSearchConditionResponseBodyConditionList] = None,
        request_id: str = None,
    ):
        self.condition_list = condition_list
        self.request_id = request_id

    def validate(self):
        if self.condition_list:
            for k in self.condition_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConditionList'] = []
        if self.condition_list is not None:
            for k in self.condition_list:
                result['ConditionList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.condition_list = []
        if m.get('ConditionList') is not None:
            for k in m.get('ConditionList'):
                temp_model = DescribeSearchConditionResponseBodyConditionList()
                self.condition_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSearchConditionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSearchConditionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSearchConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecureSuggestionRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.lang = lang
        # An array that consists of the unhandled security risks.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecureSuggestionResponseBodySuggestionsDetail(TeaModel):
    def __init__(
        self,
        description: str = None,
        sub_type: str = None,
        title: str = None,
    ):
        self.description = description
        self.sub_type = sub_type
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.sub_type is not None:
            result['SubType'] = self.sub_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SubType') is not None:
            self.sub_type = m.get('SubType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeSecureSuggestionResponseBodySuggestions(TeaModel):
    def __init__(
        self,
        detail: List[DescribeSecureSuggestionResponseBodySuggestionsDetail] = None,
        points: int = None,
        suggest_type: str = None,
    ):
        self.detail = detail
        # DescribeSecureSuggestion
        self.points = points
        self.suggest_type = suggest_type

    def validate(self):
        if self.detail:
            for k in self.detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Detail'] = []
        if self.detail is not None:
            for k in self.detail:
                result['Detail'].append(k.to_map() if k else None)
        if self.points is not None:
            result['Points'] = self.points
        if self.suggest_type is not None:
            result['SuggestType'] = self.suggest_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.detail = []
        if m.get('Detail') is not None:
            for k in m.get('Detail'):
                temp_model = DescribeSecureSuggestionResponseBodySuggestionsDetail()
                self.detail.append(temp_model.from_map(k))
        if m.get('Points') is not None:
            self.points = m.get('Points')
        if m.get('SuggestType') is not None:
            self.suggest_type = m.get('SuggestType')
        return self


class DescribeSecureSuggestionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        suggestions: List[DescribeSecureSuggestionResponseBodySuggestions] = None,
        total_count: int = None,
    ):
        # 192.168.XX.XX
        self.request_id = request_id
        # Queries suggestions on how to handle the security risks that affect the security score.
        self.suggestions = suggestions
        # The source IP address of the request.
        self.total_count = total_count

    def validate(self):
        if self.suggestions:
            for k in self.suggestions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Suggestions'] = []
        if self.suggestions is not None:
            for k in self.suggestions:
                result['Suggestions'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.suggestions = []
        if m.get('Suggestions') is not None:
            for k in m.get('Suggestions'):
                temp_model = DescribeSecureSuggestionResponseBodySuggestions()
                self.suggestions.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecureSuggestionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecureSuggestionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecureSuggestionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityCheckScheduleConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig(TeaModel):
    def __init__(
        self,
        days_of_week: str = None,
        end_time: int = None,
        start_time: int = None,
    ):
        # The day of the week when the check tasks are performed. Multiple days can be specified. Multiple days are separated by commas (,).
        # 
        # *   **1**: Monday
        # *   **2**: Tuesday
        # *   **3**: Wednesday
        # *   **4**: Thursday
        # *   **5**: Friday
        # *   **6**: Saturday
        # *   **7**: Sunday
        self.days_of_week = days_of_week
        # The time range during which check tasks end. Valid values:
        # 
        # *   **6**: 00:00 to 06:00
        # *   **12**: 06:00 to 12:00
        # *   **18**: 12:00 to 18:00
        # *   **24**: 18:00 to 24:00
        self.end_time = end_time
        # The time range during which check tasks start. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSecurityCheckScheduleConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        risk_check_job_config: DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The configurations of custom check tasks.
        self.risk_check_job_config = risk_check_job_config

    def validate(self):
        if self.risk_check_job_config:
            self.risk_check_job_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_check_job_config is not None:
            result['RiskCheckJobConfig'] = self.risk_check_job_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskCheckJobConfig') is not None:
            temp_model = DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig()
            self.risk_check_job_config = temp_model.from_map(m['RiskCheckJobConfig'])
        return self


class DescribeSecurityCheckScheduleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityCheckScheduleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityCheckScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationStatusRequest(TeaModel):
    def __init__(
        self,
        resource_owner_id: int = None,
        security_event_ids: List[str] = None,
        source_ip: str = None,
        task_id: int = None,
    ):
        self.resource_owner_id = resource_owner_id
        # The code that indicates the handling result of the alert event.
        self.security_event_ids = security_event_ids
        # An array consisting of the status of the alert events handled by the task.
        self.source_ip = source_ip
        # The information about the task that handles the alert events.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        security_event_id: str = None,
        status: str = None,
    ):
        self.error_code = error_code
        self.security_event_id = security_event_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse(TeaModel):
    def __init__(
        self,
        security_event_operation_statuses: List[DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses] = None,
        task_status: str = None,
    ):
        # DescribeSecurityEventOperationStatus
        self.security_event_operation_statuses = security_event_operation_statuses
        # Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
        self.task_status = task_status

    def validate(self):
        if self.security_event_operation_statuses:
            for k in self.security_event_operation_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SecurityEventOperationStatuses'] = []
        if self.security_event_operation_statuses is not None:
            for k in self.security_event_operation_statuses:
                result['SecurityEventOperationStatuses'].append(k.to_map() if k else None)
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.security_event_operation_statuses = []
        if m.get('SecurityEventOperationStatuses') is not None:
            for k in m.get('SecurityEventOperationStatuses'):
                temp_model = DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses()
                self.security_event_operation_statuses.append(temp_model.from_map(k))
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeSecurityEventOperationStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_event_operation_status_response: DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse = None,
    ):
        # The source IP address of the request.
        self.request_id = request_id
        # 192.168.XX.XX
        self.security_event_operation_status_response = security_event_operation_status_response

    def validate(self):
        if self.security_event_operation_status_response:
            self.security_event_operation_status_response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event_operation_status_response is not None:
            result['SecurityEventOperationStatusResponse'] = self.security_event_operation_status_response.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEventOperationStatusResponse') is not None:
            temp_model = DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse()
            self.security_event_operation_status_response = temp_model.from_map(m['SecurityEventOperationStatusResponse'])
        return self


class DescribeSecurityEventOperationStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityEventOperationStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_owner_id: int = None,
        security_event_id: int = None,
        source_ip: str = None,
    ):
        # The value of the field that can be used in the whitelist rule.
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The field that can be used in the whitelist rule.
        self.security_event_id = security_event_id
        # The operation that is supported in the whitelist rule. Valid values:
        # 
        # *   **contains**: contains
        # *   **notContains**: does not contain
        # *   **regex**: regular expression
        # *   **strEqual**: equals
        # *   **strNotEqual**: does not equal
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(TeaModel):
    def __init__(
        self,
        filed_alias_name: str = None,
        filed_name: str = None,
        mark_mis_type: str = None,
        mark_mis_value: str = None,
        supported_mis_type: List[str] = None,
        uuid: str = None,
    ):
        # 61352054
        self.filed_alias_name = filed_alias_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.filed_name = filed_name
        # An array consisting of the operations that you can perform to handle the alert event.
        self.mark_mis_type = mark_mis_type
        # An array consisting of the configuration information that is used when the value of the OperationCode parameter is **advance_mark_mis_info**.
        self.mark_mis_value = mark_mis_value
        # An array consisting of the operations that are supported by the method to add the alert event to the whitelist.
        self.supported_mis_type = supported_mis_type
        # The alias of the field that can be used in the whitelist rule.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_type is not None:
            result['MarkMisType'] = self.mark_mis_type
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisType') is not None:
            self.mark_mis_type = m.get('MarkMisType')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(TeaModel):
    def __init__(
        self,
        filed_alias_name: str = None,
        filed_name: str = None,
        mark_mis_value: str = None,
        supported_mis_type: List[str] = None,
    ):
        # DescribeSecurityEventOperations
        self.filed_alias_name = filed_alias_name
        # Queries the operations that you can perform to handle an alert event.
        self.filed_name = filed_name
        self.mark_mis_value = mark_mis_value
        self.supported_mis_type = supported_mis_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse(TeaModel):
    def __init__(
        self,
        mark_field: List[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField] = None,
        mark_fields_source: List[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource] = None,
        operation_code: str = None,
        operation_params: str = None,
        user_can_operate: bool = None,
    ):
        # The source IP address of the request.
        self.mark_field = mark_field
        # 192.168.XX.XX
        self.mark_fields_source = mark_fields_source
        # The operation that you can perform to handle the alert. Valid values:
        # 
        # *   **block_ip**: blocks the source IP address.
        # *   **advance_mark_mis_info**: adds the alert to the whitelist.
        # *   **ignore**: ignores the alert.
        # *   **manual_handled**: marks the alert as manually handled.
        # *   **kill_process**: terminates the malicious process.
        # *   **cleanup**: performs in-depth virus detection and removal.
        # *   **kill_and_quara**: terminates the malicious process and quarantines the source file.
        # *   **disable_malicious_defense**: stops the container on which the alerting files or processes exist.
        # *   **client_problem_check**: performs troubleshooting.
        # *   **quara**: quarantines the source file of the malicious process.
        self.operation_code = operation_code
        # Indicates whether you can handle the alert event in the current edition of Security Center. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.operation_params = operation_params
        # The UUID of the server on which the alert event is detected.
        self.user_can_operate = user_can_operate

    def validate(self):
        if self.mark_field:
            for k in self.mark_field:
                if k:
                    k.validate()
        if self.mark_fields_source:
            for k in self.mark_fields_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MarkField'] = []
        if self.mark_field is not None:
            for k in self.mark_field:
                result['MarkField'].append(k.to_map() if k else None)
        result['MarkFieldsSource'] = []
        if self.mark_fields_source is not None:
            for k in self.mark_fields_source:
                result['MarkFieldsSource'].append(k.to_map() if k else None)
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.user_can_operate is not None:
            result['UserCanOperate'] = self.user_can_operate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mark_field = []
        if m.get('MarkField') is not None:
            for k in m.get('MarkField'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField()
                self.mark_field.append(temp_model.from_map(k))
        self.mark_fields_source = []
        if m.get('MarkFieldsSource') is not None:
            for k in m.get('MarkFieldsSource'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource()
                self.mark_fields_source.append(temp_model.from_map(k))
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('UserCanOperate') is not None:
            self.user_can_operate = m.get('UserCanOperate')
        return self


class DescribeSecurityEventOperationsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_event_operations_response: List[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse] = None,
    ):
        # The configuration of the operation that you can perform to handle the alert event.
        # 
        # >  If the value of the OperationCode parameter is `kill_and_quara` or `block_ip`, the OperationParams parameter is required. If the value of the OperationCode parameter is a different value, the OperationParams parameter can be left empty.
        self.request_id = request_id
        # The operation that is used and can be modified in the whitelist rule. Valid values:
        # 
        # *   **contains**: contains
        # *   **notContains**: does not contain
        # *   **regex**: regular expression
        # *   **strEqual**: equals
        # *   **strNotEqual**: does not equal
        self.security_event_operations_response = security_event_operations_response

    def validate(self):
        if self.security_event_operations_response:
            for k in self.security_event_operations_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperationsResponse'] = []
        if self.security_event_operations_response is not None:
            for k in self.security_event_operations_response:
                result['SecurityEventOperationsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operations_response = []
        if m.get('SecurityEventOperationsResponse') is not None:
            for k in m.get('SecurityEventOperationsResponse'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse()
                self.security_event_operations_response.append(temp_model.from_map(k))
        return self


class DescribeSecurityEventOperationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityEventOperationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityStatInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_directory_account_id: str = None,
        source_ip: str = None,
    ):
        # The numbers of low-risk unfixed vulnerabilities at all points in time.
        self.lang = lang
        # The number of **high-risk** unfixed vulnerabilities at each point in time.
        self.resource_directory_account_id = resource_directory_account_id
        # The total number of baseline risk items on the current day.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityStatInfoResponseBodyAttackEvent(TeaModel):
    def __init__(
        self,
        date_array: List[str] = None,
        total_count: int = None,
        value_array: List[str] = None,
    ):
        # The total number of baseline risk items at all points in time.
        self.date_array = date_array
        # The time periods during which data of the same alert is collected.
        self.total_count = total_count
        # The number of **medium-risk** unfixed vulnerabilities on the current day.
        self.value_array = value_array

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodyHealthCheck(TeaModel):
    def __init__(
        self,
        date_array: List[str] = None,
        high_count: int = None,
        high_list: List[str] = None,
        levels_on: List[str] = None,
        low_count: int = None,
        low_list: List[str] = None,
        medium_count: int = None,
        medium_list: List[str] = None,
        time_array: List[str] = None,
        total_count: int = None,
        value_array: List[str] = None,
    ):
        # The number of **medium-risk** unfixed vulnerabilities at each point in time.
        self.date_array = date_array
        # The risk level of the unhandled alert. Valid values:
        # 
        # *   **remind**\
        # *   **suspicious**\
        # *   **serious**\
        self.high_count = high_count
        # The point in time when data of unfixed vulnerabilities is collected in the trend chart.
        self.high_list = high_list
        # The time periods during which data of baseline risk items is collected.
        self.levels_on = levels_on
        # The total number of unhandled alerts on the current day.
        self.low_count = low_count
        # The numbers of suspicious alerts at all points in time.
        self.low_list = low_list
        # The numbers of attacks at all points in time.
        self.medium_count = medium_count
        # The number of baseline risk items that have the high-risk level on the current day.
        self.medium_list = medium_list
        # The risk level of the unfixed vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **Nntf**: low
        self.time_array = time_array
        # The detailed statistics of attacks.
        self.total_count = total_count
        # The numbers of baseline risk items that have the low-risk level at all points in time.
        self.value_array = value_array

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.high_count is not None:
            result['HighCount'] = self.high_count
        if self.high_list is not None:
            result['HighList'] = self.high_list
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.low_count is not None:
            result['LowCount'] = self.low_count
        if self.low_list is not None:
            result['LowList'] = self.low_list
        if self.medium_count is not None:
            result['MediumCount'] = self.medium_count
        if self.medium_list is not None:
            result['MediumList'] = self.medium_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('HighCount') is not None:
            self.high_count = m.get('HighCount')
        if m.get('HighList') is not None:
            self.high_list = m.get('HighList')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('LowCount') is not None:
            self.low_count = m.get('LowCount')
        if m.get('LowList') is not None:
            self.low_list = m.get('LowList')
        if m.get('MediumCount') is not None:
            self.medium_count = m.get('MediumCount')
        if m.get('MediumList') is not None:
            self.medium_list = m.get('MediumList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodySecurityEvent(TeaModel):
    def __init__(
        self,
        date_array: List[str] = None,
        levels_on: List[str] = None,
        remind_count: int = None,
        remind_list: List[str] = None,
        serious_count: int = None,
        serious_list: List[str] = None,
        suspicious_count: int = None,
        suspicious_list: List[str] = None,
        time_array: List[str] = None,
        total_count: int = None,
        value_array: List[str] = None,
    ):
        # The numbers of high-risk unfixed vulnerabilities at all points in time.
        self.date_array = date_array
        # The point in time when the number of attacks is collected in the trend chart.
        self.levels_on = levels_on
        # The points in time when data of unhandled alerts is collected in the trend chart.
        self.remind_count = remind_count
        # The numbers of unhandled alerts at all points in time.
        self.remind_list = remind_list
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.serious_count = serious_count
        # The number of **low-risk** unfixed vulnerabilities on the current day.
        self.serious_list = serious_list
        # The number of baseline risk items that have the high-risk level at each point in time.
        self.suspicious_count = suspicious_count
        # The number of **remind** alerts on the current day.
        self.suspicious_list = suspicious_list
        # The numbers of medium-risk unfixed vulnerabilities at all points in time.
        self.time_array = time_array
        # The number of baseline risk items that have the low-risk level on the current day.
        self.total_count = total_count
        # The total number of unfixed vulnerabilities on the current day.
        self.value_array = value_array

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.remind_count is not None:
            result['RemindCount'] = self.remind_count
        if self.remind_list is not None:
            result['RemindList'] = self.remind_list
        if self.serious_count is not None:
            result['SeriousCount'] = self.serious_count
        if self.serious_list is not None:
            result['SeriousList'] = self.serious_list
        if self.suspicious_count is not None:
            result['SuspiciousCount'] = self.suspicious_count
        if self.suspicious_list is not None:
            result['SuspiciousList'] = self.suspicious_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('RemindCount') is not None:
            self.remind_count = m.get('RemindCount')
        if m.get('RemindList') is not None:
            self.remind_list = m.get('RemindList')
        if m.get('SeriousCount') is not None:
            self.serious_count = m.get('SeriousCount')
        if m.get('SeriousList') is not None:
            self.serious_list = m.get('SeriousList')
        if m.get('SuspiciousCount') is not None:
            self.suspicious_count = m.get('SuspiciousCount')
        if m.get('SuspiciousList') is not None:
            self.suspicious_list = m.get('SuspiciousList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodyVulnerability(TeaModel):
    def __init__(
        self,
        asap_count: int = None,
        asap_list: List[str] = None,
        date_array: List[str] = None,
        later_count: int = None,
        later_list: List[str] = None,
        levels_on: List[str] = None,
        nntf_count: int = None,
        nntf_list: List[str] = None,
        time_array: List[str] = None,
        total_count: int = None,
        value_array: List[str] = None,
    ):
        # The points in time when the number of attacks is collected in the trend chart.
        self.asap_count = asap_count
        # The risk levels of unhandled alerts.
        self.asap_list = asap_list
        self.date_array = date_array
        # The number of **suspicious** alerts on the current day.
        self.later_count = later_count
        self.later_list = later_list
        self.levels_on = levels_on
        # The points in time when data of baseline risk items is collected in the trend chart.
        self.nntf_count = nntf_count
        # The time periods during which data of unfixed vulnerabilities is collected.
        self.nntf_list = nntf_list
        # Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
        self.time_array = time_array
        # The numbers of remind alerts at all points in time.
        self.total_count = total_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.value_array = value_array

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.asap_list is not None:
            result['AsapList'] = self.asap_list
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.later_list is not None:
            result['LaterList'] = self.later_list
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.nntf_list is not None:
            result['NntfList'] = self.nntf_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('AsapList') is not None:
            self.asap_list = m.get('AsapList')
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('LaterList') is not None:
            self.later_list = m.get('LaterList')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('NntfList') is not None:
            self.nntf_list = m.get('NntfList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBody(TeaModel):
    def __init__(
        self,
        attack_event: DescribeSecurityStatInfoResponseBodyAttackEvent = None,
        health_check: DescribeSecurityStatInfoResponseBodyHealthCheck = None,
        request_id: str = None,
        security_event: DescribeSecurityStatInfoResponseBodySecurityEvent = None,
        success: bool = None,
        vulnerability: DescribeSecurityStatInfoResponseBodyVulnerability = None,
    ):
        # The numbers of baseline risk items that have the high-risk level at all points in time.
        self.attack_event = attack_event
        # The number of **serious** alerts at each point in time.
        self.health_check = health_check
        # The points in time when data of unfixed vulnerabilities is collected in the trend chart.
        self.request_id = request_id
        # The risk levels of baseline risk items.
        self.security_event = security_event
        # The number of baseline risk items that have the medium-risk level at each point in time.
        self.success = success
        # The number of baseline risk items that have the low-risk level at each point in time.
        self.vulnerability = vulnerability

    def validate(self):
        if self.attack_event:
            self.attack_event.validate()
        if self.health_check:
            self.health_check.validate()
        if self.security_event:
            self.security_event.validate()
        if self.vulnerability:
            self.vulnerability.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attack_event is not None:
            result['AttackEvent'] = self.attack_event.to_map()
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event is not None:
            result['SecurityEvent'] = self.security_event.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.vulnerability is not None:
            result['Vulnerability'] = self.vulnerability.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttackEvent') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyAttackEvent()
            self.attack_event = temp_model.from_map(m['AttackEvent'])
        if m.get('HealthCheck') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyHealthCheck()
            self.health_check = temp_model.from_map(m['HealthCheck'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEvent') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodySecurityEvent()
            self.security_event = temp_model.from_map(m['SecurityEvent'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Vulnerability') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyVulnerability()
            self.vulnerability = temp_model.from_map(m['Vulnerability'])
        return self


class DescribeSecurityStatInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityStatInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityStatInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServiceLinkedRoleStatusRequest(TeaModel):
    def __init__(
        self,
        service_linked_role: str = None,
    ):
        # The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:
        # 
        # *   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
        # *   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.
        self.service_linked_role = service_linked_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_linked_role is not None:
            result['ServiceLinkedRole'] = self.service_linked_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServiceLinkedRole') is not None:
            self.service_linked_role = m.get('ServiceLinkedRole')
        return self


class DescribeServiceLinkedRoleStatusResponseBodyRoleStatus(TeaModel):
    def __init__(
        self,
        status: bool = None,
    ):
        # Indicates whether the service-linked role is created. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeServiceLinkedRoleStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        role_status: DescribeServiceLinkedRoleStatusResponseBodyRoleStatus = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The status information about the service-linked role.
        self.role_status = role_status

    def validate(self):
        if self.role_status:
            self.role_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role_status is not None:
            result['RoleStatus'] = self.role_status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RoleStatus') is not None:
            temp_model = DescribeServiceLinkedRoleStatusResponseBodyRoleStatus()
            self.role_status = temp_model.from_map(m['RoleStatus'])
        return self


class DescribeServiceLinkedRoleStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServiceLinkedRoleStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServiceLinkedRoleStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimilarEventScenariosRequest(TeaModel):
    def __init__(
        self,
        resource_owner_id: int = None,
        security_event_id: int = None,
        source_ip: str = None,
    ):
        self.resource_owner_id = resource_owner_id
        self.security_event_id = security_event_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSimilarEventScenariosResponseBodyScenarios(TeaModel):
    def __init__(
        self,
        code: str = None,
    ):
        self.code = code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        return self


class DescribeSimilarEventScenariosResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scenarios: List[DescribeSimilarEventScenariosResponseBodyScenarios] = None,
    ):
        self.request_id = request_id
        self.scenarios = scenarios

    def validate(self):
        if self.scenarios:
            for k in self.scenarios:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Scenarios'] = []
        if self.scenarios is not None:
            for k in self.scenarios:
                result['Scenarios'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scenarios = []
        if m.get('Scenarios') is not None:
            for k in m.get('Scenarios'):
                temp_model = DescribeSimilarEventScenariosResponseBodyScenarios()
                self.scenarios.append(temp_model.from_map(k))
        return self


class DescribeSimilarEventScenariosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSimilarEventScenariosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimilarEventScenariosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimilarSecurityEventsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        task_id: int = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip
        # The ID of the task. You can call the [CreateSimilarSecurityEventsQueryTask](~~CreateSimilarSecurityEventsQueryTask~~) operation to query the IDs of tasks.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSimilarSecurityEventsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        event_type: str = None,
        last_time: int = None,
        occurrence_time: int = None,
        security_event_id: int = None,
        uuid: str = None,
    ):
        # The name of the alert event.
        self.event_name = event_name
        # The alert type of the alert event. Valid values:
        # 
        # *   Suspicious process
        # *   Webshell
        # *   Unusual logon
        # *   Exception
        # *   Sensitive file tampering
        # *   Malicious process (cloud threat detection)
        # *   Suspicious network connection
        # *   Other
        # *   Abnormal account
        # *   Application intrusion event
        # *   Cloud threat detection
        # *   Precise defense
        # *   Application whitelist
        # *   Persistent webshell
        # *   Web application threat detection
        # *   Malicious script
        # *   Threat intelligence
        # *   Malicious network activity
        # *   Cluster exception
        # *   Webshell (on-premises threat detection)
        # *   Vulnerability exploitation
        # *   Malicious process (on-premises threat detection)
        # *   Trusted exception
        # 
        # For more information about alert types, see [Alerts](https://www.alibabacloud.com/help/en/security-center/latest/events-overview).
        self.event_type = event_type
        # The timestamp when the alert event was last detected. Unit: milliseconds.
        self.last_time = last_time
        # The timestamp when the alert event was first detected. Unit: milliseconds.
        self.occurrence_time = occurrence_time
        # The ID of the alert event.
        self.security_event_id = security_event_id
        # The UUID of the server that is affected by the alert event.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSimilarSecurityEventsResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeSimilarSecurityEventsResponseBodyPageInfo = None,
        request_id: str = None,
        security_events_response: List[DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse] = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array consisting of the alert events that are triggered by the same rule or of the same alert type.
        self.security_events_response = security_events_response

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.security_events_response:
            for k in self.security_events_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventsResponse'] = []
        if self.security_events_response is not None:
            for k in self.security_events_response:
                result['SecurityEventsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeSimilarSecurityEventsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_events_response = []
        if m.get('SecurityEventsResponse') is not None:
            for k in m.get('SecurityEventsResponse'):
                temp_model = DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse()
                self.security_events_response.append(temp_model.from_map(k))
        return self


class DescribeSimilarSecurityEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSimilarSecurityEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimilarSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsRequest(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        current_page: int = None,
        is_ali_yun_ecs: str = None,
        machine_region: str = None,
        machine_remark: str = None,
        next_token: str = None,
        page_size: int = None,
        status_list: str = None,
        uuid: str = None,
    ):
        self.api_version = api_version
        self.current_page = current_page
        self.is_ali_yun_ecs = is_ali_yun_ecs
        self.machine_region = machine_region
        self.machine_remark = machine_remark
        self.next_token = next_token
        self.page_size = page_size
        self.status_list = status_list
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_version is not None:
            result['ApiVersion'] = self.api_version
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_ali_yun_ecs is not None:
            result['IsAliYunEcs'] = self.is_ali_yun_ecs
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiVersion') is not None:
            self.api_version = m.get('ApiVersion')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsAliYunEcs') is not None:
            self.is_ali_yun_ecs = m.get('IsAliYunEcs')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSnapshotsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        next_token: str = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.next_token = next_token
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotsResponseBodySnapshots(TeaModel):
    def __init__(
        self,
        actual_bytes: int = None,
        actual_items: int = None,
        bytes_done: int = None,
        bytes_total: int = None,
        client_id: str = None,
        client_version: str = None,
        created_time: int = None,
        error_file: str = None,
        instance_id: str = None,
        items_done: int = None,
        items_total: int = None,
        job_id: str = None,
        parent_snapshot_hash: str = None,
        path: str = None,
        paths: List[str] = None,
        plan_id: str = None,
        region_id: str = None,
        retention: int = None,
        snapshot_hash: str = None,
        snapshot_id: str = None,
        source_type: str = None,
        status: str = None,
        uuid: str = None,
        vault_id: str = None,
    ):
        self.actual_bytes = actual_bytes
        self.actual_items = actual_items
        self.bytes_done = bytes_done
        self.bytes_total = bytes_total
        self.client_id = client_id
        self.client_version = client_version
        self.created_time = created_time
        self.error_file = error_file
        self.instance_id = instance_id
        self.items_done = items_done
        self.items_total = items_total
        self.job_id = job_id
        self.parent_snapshot_hash = parent_snapshot_hash
        self.path = path
        self.paths = paths
        self.plan_id = plan_id
        self.region_id = region_id
        self.retention = retention
        self.snapshot_hash = snapshot_hash
        self.snapshot_id = snapshot_id
        self.source_type = source_type
        self.status = status
        self.uuid = uuid
        self.vault_id = vault_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_bytes is not None:
            result['ActualBytes'] = self.actual_bytes
        if self.actual_items is not None:
            result['ActualItems'] = self.actual_items
        if self.bytes_done is not None:
            result['BytesDone'] = self.bytes_done
        if self.bytes_total is not None:
            result['BytesTotal'] = self.bytes_total
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.error_file is not None:
            result['ErrorFile'] = self.error_file
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.items_done is not None:
            result['ItemsDone'] = self.items_done
        if self.items_total is not None:
            result['ItemsTotal'] = self.items_total
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.parent_snapshot_hash is not None:
            result['ParentSnapshotHash'] = self.parent_snapshot_hash
        if self.path is not None:
            result['Path'] = self.path
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.plan_id is not None:
            result['PlanId'] = self.plan_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualBytes') is not None:
            self.actual_bytes = m.get('ActualBytes')
        if m.get('ActualItems') is not None:
            self.actual_items = m.get('ActualItems')
        if m.get('BytesDone') is not None:
            self.bytes_done = m.get('BytesDone')
        if m.get('BytesTotal') is not None:
            self.bytes_total = m.get('BytesTotal')
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('ErrorFile') is not None:
            self.error_file = m.get('ErrorFile')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemsDone') is not None:
            self.items_done = m.get('ItemsDone')
        if m.get('ItemsTotal') is not None:
            self.items_total = m.get('ItemsTotal')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ParentSnapshotHash') is not None:
            self.parent_snapshot_hash = m.get('ParentSnapshotHash')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('PlanId') is not None:
            self.plan_id = m.get('PlanId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeSnapshotsResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeSnapshotsResponseBodyPageInfo = None,
        request_id: str = None,
        snapshots: List[DescribeSnapshotsResponseBodySnapshots] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.snapshots = snapshots

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.snapshots:
            for k in self.snapshots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Snapshots'] = []
        if self.snapshots is not None:
            for k in self.snapshots:
                result['Snapshots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeSnapshotsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.snapshots = []
        if m.get('Snapshots') is not None:
            for k in m.get('Snapshots'):
                temp_model = DescribeSnapshotsResponseBodySnapshots()
                self.snapshots.append(temp_model.from_map(k))
        return self


class DescribeSnapshotsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSnapshotsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyRequest(TeaModel):
    def __init__(
        self,
        custom_type: str = None,
        lang: str = None,
        source_ip: str = None,
        strategy_ids: str = None,
    ):
        self.custom_type = custom_type
        self.lang = lang
        self.source_ip = source_ip
        self.strategy_ids = strategy_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_ids is not None:
            result['StrategyIds'] = self.strategy_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyIds') is not None:
            self.strategy_ids = m.get('StrategyIds')
        return self


class DescribeStrategyResponseBodyStrategiesConfigTargets(TeaModel):
    def __init__(
        self,
        flag: str = None,
        target: str = None,
        target_type: str = None,
    ):
        self.flag = flag
        self.target = target
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeStrategyResponseBodyStrategies(TeaModel):
    def __init__(
        self,
        config_targets: List[DescribeStrategyResponseBodyStrategiesConfigTargets] = None,
        custom_type: str = None,
        cycle_days: int = None,
        cycle_start_time: int = None,
        ecs_count: int = None,
        end_time: str = None,
        exec_status: int = None,
        id: int = None,
        name: str = None,
        pass_rate: int = None,
        process_rate: int = None,
        risk_count: int = None,
        start_time: str = None,
        type: int = None,
    ):
        self.config_targets = config_targets
        self.custom_type = custom_type
        self.cycle_days = cycle_days
        self.cycle_start_time = cycle_start_time
        self.ecs_count = ecs_count
        self.end_time = end_time
        self.exec_status = exec_status
        self.id = id
        self.name = name
        self.pass_rate = pass_rate
        self.process_rate = process_rate
        self.risk_count = risk_count
        self.start_time = start_time
        self.type = type

    def validate(self):
        if self.config_targets:
            for k in self.config_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigTargets'] = []
        if self.config_targets is not None:
            for k in self.config_targets:
                result['ConfigTargets'].append(k.to_map() if k else None)
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.ecs_count is not None:
            result['EcsCount'] = self.ecs_count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_status is not None:
            result['ExecStatus'] = self.exec_status
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.pass_rate is not None:
            result['PassRate'] = self.pass_rate
        if self.process_rate is not None:
            result['ProcessRate'] = self.process_rate
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_targets = []
        if m.get('ConfigTargets') is not None:
            for k in m.get('ConfigTargets'):
                temp_model = DescribeStrategyResponseBodyStrategiesConfigTargets()
                self.config_targets.append(temp_model.from_map(k))
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EcsCount') is not None:
            self.ecs_count = m.get('EcsCount')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecStatus') is not None:
            self.exec_status = m.get('ExecStatus')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PassRate') is not None:
            self.pass_rate = m.get('PassRate')
        if m.get('ProcessRate') is not None:
            self.process_rate = m.get('ProcessRate')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategies: List[DescribeStrategyResponseBodyStrategies] = None,
    ):
        self.request_id = request_id
        self.strategies = strategies

    def validate(self):
        if self.strategies:
            for k in self.strategies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Strategies'] = []
        if self.strategies is not None:
            for k in self.strategies:
                result['Strategies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.strategies = []
        if m.get('Strategies') is not None:
            for k in m.get('Strategies'):
                temp_model = DescribeStrategyResponseBodyStrategies()
                self.strategies.append(temp_model.from_map(k))
        return self


class DescribeStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyDetailRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        # The alias of the check item.
        self.id = id
        # The default value of the rule.
        self.lang = lang
        # The minimum value of the rule parameter.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList(TeaModel):
    def __init__(
        self,
        enum_value: str = None,
        max_value: int = None,
        min_value: int = None,
        param_default_value: str = None,
        param_desc: str = None,
        param_name: str = None,
        param_type: int = None,
        value: str = None,
    ):
        self.enum_value = enum_value
        # Queries the details of a baseline check policy.
        self.max_value = max_value
        self.min_value = min_value
        # Indicates whether the rule is included in the policy. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.param_default_value = param_default_value
        self.param_desc = param_desc
        # The time when the baseline check based on the baseline check policy ends.
        self.param_name = param_name
        # WB01224678
        self.param_type = param_type
        # An array that consists of sub-risk items.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules(TeaModel):
    def __init__(
        self,
        default_value: int = None,
        optional: int = None,
        param_list: List[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList] = None,
        rule_desc: str = None,
        rule_id: str = None,
    ):
        # The description of the check item.
        self.default_value = default_value
        # Indicates whether the sub-risk item is selected. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.optional = optional
        # The specified value of the rule parameter.
        self.param_list = param_list
        # The check item.
        self.rule_desc = rule_desc
        # Indicates whether the risk item is selected. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.rule_id = rule_id

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails(TeaModel):
    def __init__(
        self,
        check_desc: str = None,
        check_id: int = None,
        check_item: str = None,
        rules: List[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules] = None,
    ):
        # The name of the baseline check policy.
        self.check_desc = check_desc
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.check_id = check_id
        # The maximum value of the rule parameter.
        self.check_item = check_item
        # The ID of the baseline check policy.
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes(TeaModel):
    def __init__(
        self,
        alias: str = None,
        check_details: List[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails] = None,
        on: bool = None,
        type_name: str = None,
    ):
        # The type of the baseline check policy. Valid values:
        # 
        # *   **common**: standard baseline check policy
        # *   **custom**: custom baseline check policy
        self.alias = alias
        # The data returned.
        self.check_details = check_details
        # If the value of paramType is 2, this parameter provides the options that can be selected for the rule parameter.
        self.on = on
        # The description of the rule.
        self.type_name = type_name

    def validate(self):
        if self.check_details:
            for k in self.check_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['CheckDetails'] = []
        if self.check_details is not None:
            for k in self.check_details:
                result['CheckDetails'].append(k.to_map() if k else None)
        if self.on is not None:
            result['On'] = self.on
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.check_details = []
        if m.get('CheckDetails') is not None:
            for k in m.get('CheckDetails'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails()
                self.check_details.append(temp_model.from_map(k))
        if m.get('On') is not None:
            self.on = m.get('On')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList(TeaModel):
    def __init__(
        self,
        alias: str = None,
        on: bool = None,
        sub_types: List[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes] = None,
        type_name: str = None,
    ):
        # The condition by which the baseline check policy is applied to the asset. Valid values:
        # 
        # *   **groupId**: the ID of the asset group
        # *   **uuid**: the UUID of the asset
        self.alias = alias
        # The ID of the check item.
        self.on = on
        # The information about the rule parameter.
        self.sub_types = sub_types
        # An array that consists of the details of custom check items.
        self.type_name = type_name

    def validate(self):
        if self.sub_types:
            for k in self.sub_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.on is not None:
            result['On'] = self.on
        result['SubTypes'] = []
        if self.sub_types is not None:
            for k in self.sub_types:
                result['SubTypes'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('On') is not None:
            self.on = m.get('On')
        self.sub_types = []
        if m.get('SubTypes') is not None:
            for k in m.get('SubTypes'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes()
                self.sub_types.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeStrategyDetailResponseBodyStrategy(TeaModel):
    def __init__(
        self,
        custom_type: str = None,
        cycle_days: int = None,
        cycle_start_time: int = None,
        end_time: str = None,
        id: int = None,
        name: str = None,
        risk_sub_type_name: str = None,
        risk_type_white_list_query_result_list: List[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList] = None,
        start_time: str = None,
        target_type: str = None,
        type: int = None,
    ):
        self.custom_type = custom_type
        # The alias of the sub-check item.
        self.cycle_days = cycle_days
        # The details of the rule.
        self.cycle_start_time = cycle_start_time
        self.end_time = end_time
        # The time period during which the check starts. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.id = id
        # The ID of the rule.
        self.name = name
        self.risk_sub_type_name = risk_sub_type_name
        # The check item.
        self.risk_type_white_list_query_result_list = risk_type_white_list_query_result_list
        self.start_time = start_time
        self.target_type = target_type
        # The name of the rule parameter.
        self.type = type

    def validate(self):
        if self.risk_type_white_list_query_result_list:
            for k in self.risk_type_white_list_query_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.risk_sub_type_name is not None:
            result['RiskSubTypeName'] = self.risk_sub_type_name
        result['RiskTypeWhiteListQueryResultList'] = []
        if self.risk_type_white_list_query_result_list is not None:
            for k in self.risk_type_white_list_query_result_list:
                result['RiskTypeWhiteListQueryResultList'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RiskSubTypeName') is not None:
            self.risk_sub_type_name = m.get('RiskSubTypeName')
        self.risk_type_white_list_query_result_list = []
        if m.get('RiskTypeWhiteListQueryResultList') is not None:
            for k in m.get('RiskTypeWhiteListQueryResultList'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList()
                self.risk_type_white_list_query_result_list.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy: DescribeStrategyDetailResponseBodyStrategy = None,
    ):
        # An array that consists of the whitelist of risk items.
        self.request_id = request_id
        # The source IP address of the request.
        self.strategy = strategy

    def validate(self):
        if self.strategy:
            self.strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategy') is not None:
            temp_model = DescribeStrategyDetailResponseBodyStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        return self


class DescribeStrategyDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStrategyDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyExecDetailRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        source_ip: str = None,
        strategy_id: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.source_ip = source_ip
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeStrategyExecDetailResponseBodyFailedEcsList(TeaModel):
    def __init__(
        self,
        ip: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        reason: str = None,
    ):
        self.ip = ip
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['IP'] = self.ip
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class DescribeStrategyExecDetailResponseBody(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        fail_count: int = None,
        failed_ecs_list: List[DescribeStrategyExecDetailResponseBodyFailedEcsList] = None,
        in_process_count: int = None,
        percent: str = None,
        request_id: str = None,
        source: str = None,
        start_time: str = None,
        success_count: int = None,
    ):
        self.end_time = end_time
        self.fail_count = fail_count
        self.failed_ecs_list = failed_ecs_list
        self.in_process_count = in_process_count
        self.percent = percent
        self.request_id = request_id
        self.source = source
        self.start_time = start_time
        self.success_count = success_count

    def validate(self):
        if self.failed_ecs_list:
            for k in self.failed_ecs_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        result['FailedEcsList'] = []
        if self.failed_ecs_list is not None:
            for k in self.failed_ecs_list:
                result['FailedEcsList'].append(k.to_map() if k else None)
        if self.in_process_count is not None:
            result['InProcessCount'] = self.in_process_count
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        self.failed_ecs_list = []
        if m.get('FailedEcsList') is not None:
            for k in m.get('FailedEcsList'):
                temp_model = DescribeStrategyExecDetailResponseBodyFailedEcsList()
                self.failed_ecs_list.append(temp_model.from_map(k))
        if m.get('InProcessCount') is not None:
            self.in_process_count = m.get('InProcessCount')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DescribeStrategyExecDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStrategyExecDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyExecDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyTargetRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        source_ip: str = None,
        type: str = None,
    ):
        # WB01014029
        self.config = config
        # Queries the information about the assets to which a baseline check policy is applied.
        self.source_ip = source_ip
        # DescribeStrategyTarget
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyTargetResponseBodyStrategyTargets(TeaModel):
    def __init__(
        self,
        bind_uuid_count: int = None,
        flag: str = None,
        target: str = None,
        target_type: str = None,
    ):
        self.bind_uuid_count = bind_uuid_count
        self.flag = flag
        self.target = target
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_uuid_count is not None:
            result['BindUuidCount'] = self.bind_uuid_count
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindUuidCount') is not None:
            self.bind_uuid_count = m.get('BindUuidCount')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeStrategyTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy_targets: List[DescribeStrategyTargetResponseBodyStrategyTargets] = None,
    ):
        self.request_id = request_id
        self.strategy_targets = strategy_targets

    def validate(self):
        if self.strategy_targets:
            for k in self.strategy_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StrategyTargets'] = []
        if self.strategy_targets is not None:
            for k in self.strategy_targets:
                result['StrategyTargets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.strategy_targets = []
        if m.get('StrategyTargets') is not None:
            for k in m.get('StrategyTargets'):
                temp_model = DescribeStrategyTargetResponseBodyStrategyTargets()
                self.strategy_targets.append(temp_model.from_map(k))
        return self


class DescribeStrategyTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStrategyTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSummaryInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
    ):
        # 192.168.XX.XX
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSummaryInfoResponseBody(TeaModel):
    def __init__(
        self,
        aegis_client_offline_count: int = None,
        aegis_client_online_count: int = None,
        request_id: str = None,
        security_score: int = None,
        success: bool = None,
    ):
        # WB01014029
        self.aegis_client_offline_count = aegis_client_offline_count
        self.aegis_client_online_count = aegis_client_online_count
        # Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
        self.request_id = request_id
        self.security_score = security_score
        # DescribeSummaryInfo
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aegis_client_offline_count is not None:
            result['AegisClientOfflineCount'] = self.aegis_client_offline_count
        if self.aegis_client_online_count is not None:
            result['AegisClientOnlineCount'] = self.aegis_client_online_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_score is not None:
            result['SecurityScore'] = self.security_score
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AegisClientOfflineCount') is not None:
            self.aegis_client_offline_count = m.get('AegisClientOfflineCount')
        if m.get('AegisClientOnlineCount') is not None:
            self.aegis_client_online_count = m.get('AegisClientOnlineCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityScore') is not None:
            self.security_score = m.get('SecurityScore')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSummaryInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSummaryInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSummaryInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSupportRegionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        support_region: List[str] = None,
    ):
        self.request_id = request_id
        self.support_region = support_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_region is not None:
            result['SupportRegion'] = self.support_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportRegion') is not None:
            self.support_region = m.get('SupportRegion')
        return self


class DescribeSupportRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSupportRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSupportRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventDetailRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        source_ip: str = None,
        suspicious_event_id: int = None,
    ):
        # The data source of the exception. Set the value to sas.
        self.from_ = from_
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # The ID of the exception.
        self.suspicious_event_id = suspicious_event_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.suspicious_event_id is not None:
            result['SuspiciousEventId'] = self.suspicious_event_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SuspiciousEventId') is not None:
            self.suspicious_event_id = m.get('SuspiciousEventId')
        return self


class DescribeSuspEventDetailResponseBodyDetails(TeaModel):
    def __init__(
        self,
        name_display: str = None,
        type: str = None,
        value: str = None,
    ):
        # The display name of the alert event.
        self.name_display = name_display
        # The format in which the details of the exception are displayed.
        # 
        # Valid values:
        # 
        # *   **text**\
        # *   **html**\
        self.type = type
        # The attribute information about the exception. For example, if the exception is associated with an alert that is triggered by an unusual logon, the information can include the time when the logon is initiated and the location from which the logon is initiated. If the exception is associated with an alert that is triggered by a webshell file, the information can include the path of the trojan file and the type of the trojan.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_display is not None:
            result['NameDisplay'] = self.name_display
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameDisplay') is not None:
            self.name_display = m.get('NameDisplay')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSuspEventDetailResponseBody(TeaModel):
    def __init__(
        self,
        can_be_deal_on_line: bool = None,
        data_source: str = None,
        details: List[DescribeSuspEventDetailResponseBodyDetails] = None,
        event_desc: str = None,
        event_name: str = None,
        event_status: str = None,
        event_type_desc: str = None,
        id: int = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        last_time: str = None,
        level: str = None,
        operate_error_code: str = None,
        operate_msg: str = None,
        request_id: str = None,
        sale_version: str = None,
        uuid: str = None,
    ):
        # Indicates whether the online processing of exceptions is supported, such as blocking an exception, adding an exception to the whitelist, and ignoring an exception. Valid values:
        # 
        # *   **true**: The online processing of exceptions is supported.
        # *   **false**: The online processing of exceptions is not supported.
        self.can_be_deal_on_line = can_be_deal_on_line
        # The data source of the exception.
        self.data_source = data_source
        # An array that consists of the details of the exception.
        self.details = details
        # The description of the exception.
        self.event_desc = event_desc
        # The name of the exception.
        self.event_name = event_name
        # The status of the exception. Valid values:
        # 
        # *   **1**: pending handling
        # *   **2**: ignored
        # *   **4**: confirmed
        # *   **8**: marked as a false positive
        # *   **16**: handling
        # *   **32**: handled
        # *   **64**: expired
        self.event_status = event_status
        # The type of the exception.
        self.event_type_desc = event_type_desc
        # The ID of the exception.
        self.id = id
        # The name of the server on which the exception was detected.
        self.instance_name = instance_name
        # The public IP address of the server on which the exception was detected.
        self.internet_ip = internet_ip
        # The private IP address of the server on which the exception was detected.
        self.intranet_ip = intranet_ip
        # The time when the exception was last detected.
        self.last_time = last_time
        # The risk level of the exception. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level
        # The code that indicates the handling result of the exception.
        self.operate_error_code = operate_error_code
        # The message that indicates the handling result of the exception.
        self.operate_msg = operate_msg
        # The ID of the request.
        self.request_id = request_id
        # The edition of Security Center in which the exception can be detected. Valid values:
        # 
        # *   **0**: Basic edition
        # *   **1**: Advanced edition
        # *   **2**: Enterprise edition
        self.sale_version = sale_version
        # The UUID of the server on which the exception was detected.
        self.uuid = uuid

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.event_desc is not None:
            result['EventDesc'] = self.event_desc
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_type_desc is not None:
            result['EventTypeDesc'] = self.event_type_desc
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.level is not None:
            result['Level'] = self.level
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_msg is not None:
            result['OperateMsg'] = self.operate_msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DescribeSuspEventDetailResponseBodyDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('EventDesc') is not None:
            self.event_desc = m.get('EventDesc')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventTypeDesc') is not None:
            self.event_type_desc = m.get('EventTypeDesc')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateMsg') is not None:
            self.operate_msg = m.get('OperateMsg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSuspEventDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspEventDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventExportInfoRequest(TeaModel):
    def __init__(
        self,
        export_id: int = None,
    ):
        # The ID of the export task.
        # 
        # > You can call the [ExportSuspEvents](~~ExportSuspEvents~~) operation to query the ID.
        self.export_id = export_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeSuspEventExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        export_status: str = None,
        file_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        link: str = None,
        progress: int = None,
        properties: str = None,
        request_id: str = None,
        total_count: int = None,
        type: str = None,
    ):
        # The handling status for the exception. Valid values:
        # 
        # *   **processing**: in progress
        # *   **success**: successful
        # *   **failed**: failed
        # *   **pending**: pending
        self.export_status = export_status
        # The name of the exported file.
        self.file_name = file_name
        # The time when the export task was created.
        self.gmt_create = gmt_create
        # The time when the export task was modified.
        self.gmt_modified = gmt_modified
        # The ID of the export task.
        self.id = id
        # The URL at which you can download the exported Excel file.
        self.link = link
        # The progress percentage of the export task.
        self.progress = progress
        # The exported parameters of exceptions.
        self.properties = properties
        # The ID of the request.
        self.request_id = request_id
        # The total number of exceptions exported.
        self.total_count = total_count
        # The type of the export task. The value is fixed as suspiciousEvent.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.properties is not None:
            result['Properties'] = self.properties
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Properties') is not None:
            self.properties = m.get('Properties')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspEventExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspEventExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventQuaraFilesRequest(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        from_: str = None,
        group_id: str = None,
        grouping_id: int = None,
        page_size: str = None,
        quara_tag: str = None,
        source_ip: str = None,
        status: str = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.from_ = from_
        # The ID of the request source. Set the value to **sas**.
        self.group_id = group_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.grouping_id = grouping_id
        # The unique ID of the quarantined file.
        self.page_size = page_size
        # The ID of the server group to which the server belongs. The quarantined file is located on the server.
        self.quara_tag = quara_tag
        # The ID of the asset group.
        self.source_ip = source_ip
        # The number of the page to return.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.grouping_id is not None:
            result['GroupingId'] = self.grouping_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.quara_tag is not None:
            result['QuaraTag'] = self.quara_tag
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupingId') is not None:
            self.grouping_id = m.get('GroupingId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QuaraTag') is not None:
            self.quara_tag = m.get('QuaraTag')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        event_type: str = None,
        id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        link: str = None,
        md_5: str = None,
        modify_time: str = None,
        path: str = None,
        status: str = None,
        tag: str = None,
        uuid: str = None,
    ):
        # The unique ID of the event.
        self.event_name = event_name
        # The MD5 hash value of the quarantined file.
        self.event_type = event_type
        # 172.16.XX.XX
        self.id = id
        # The name of the server on which the quarantined file is located.
        self.instance_id = instance_id
        # The ID of the quarantined file.
        self.instance_name = instance_name
        # The instance ID of the asset.
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        # The UUID of the server.
        self.ip = ip
        # The public IP address of the server on which the quarantined file is located.
        self.link = link
        # The private IP address of the server on which the quarantined file is located.
        self.md_5 = md_5
        self.modify_time = modify_time
        # The time when the quarantined file was last modified.
        self.path = path
        # The public IP address of the server on which the quarantined file is located.
        self.status = status
        # The type of the event.
        self.tag = tag
        # The path to the quarantined file on the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.link is not None:
            result['Link'] = self.link
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.path is not None:
            result['Path'] = self.path
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSuspEventQuaraFilesResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        quara_files: List[DescribeSuspEventQuaraFilesResponseBodyQuaraFiles] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The download link of the quarantined file.
        self.count = count
        # The total number of entries returned.
        self.current_page = current_page
        # The number of entries returned on the current page.
        self.page_size = page_size
        # The status of the quarantined file. Valid values:
        # 
        # *   **quaraFailed**: The file fails to be quarantined.
        # *   **quaraDone**: The file is quarantined.
        # *   **quaraing**: The file is being quarantined.
        # *   **rollbackFailed**: The system fails to cancel quarantining the file.
        # *   **rollbackDone**: The system cancelled quarantining the file.
        # *   **rollbacking**: The system is cancelling quarantining the file.
        self.quara_files = quara_files
        # An array that consists of the quarantined files.
        self.request_id = request_id
        # The quarantined file.
        self.total_count = total_count

    def validate(self):
        if self.quara_files:
            for k in self.quara_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['QuaraFiles'] = []
        if self.quara_files is not None:
            for k in self.quara_files:
                result['QuaraFiles'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.quara_files = []
        if m.get('QuaraFiles') is not None:
            for k in m.get('QuaraFiles'):
                temp_model = DescribeSuspEventQuaraFilesResponseBodyQuaraFiles()
                self.quara_files.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventQuaraFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspEventQuaraFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventQuaraFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventUserSettingRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        id: int = None,
        source_ip: str = None,
    ):
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_
        # The ID. You do not need to specify this parameter.
        self.id = id
        # The IP address of the request. You do not need to specify this parameter.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.id is not None:
            result['Id'] = self.id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSuspEventUserSettingResponseBody(TeaModel):
    def __init__(
        self,
        levels_on: List[str] = None,
        request_id: str = None,
    ):
        # An array that consists of the risk levels of alert notifications. Valid values:
        # 
        # *   **remind**\
        # *   **suspicious**\
        # *   **serious**\
        self.levels_on = levels_on
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSuspEventUserSettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspEventUserSettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventsRequest(TeaModel):
    def __init__(
        self,
        alarm_unique_info: str = None,
        assets_type_list: List[str] = None,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: str = None,
        dealed: str = None,
        event_names: str = None,
        from_: str = None,
        group_id: int = None,
        id: int = None,
        lang: str = None,
        levels: str = None,
        name: str = None,
        operate_error_code_list: List[str] = None,
        operate_time_end: str = None,
        operate_time_start: str = None,
        page_size: str = None,
        parent_event_types: str = None,
        remark: str = None,
        sort_column: str = None,
        sort_type: str = None,
        source: str = None,
        source_ip: str = None,
        status: str = None,
        tactic_id: str = None,
        target_type: str = None,
        time_end: str = None,
        time_start: str = None,
        unique_info: str = None,
        uuids: str = None,
    ):
        # The ID of the alert event.
        # 
        # >  To query the details about the exceptions of an alert event, you must specify the ID of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the IDs of alert events.
        self.alarm_unique_info = alarm_unique_info
        # The types of assets.
        self.assets_type_list = assets_type_list
        # The ID of the cluster of whose alert events you want to query.
        self.cluster_id = cluster_id
        # The key of the condition that is used to query alert events on containers. Valid values:
        # 
        # *   **instanceId**: the ID of the asset
        # *   **appName**: the name of the application
        # *   **clusterId**: the ID of the cluster
        # *   **regionId**: the ID of the region
        # *   **nodeName**: the name of the node
        # *   **namespace**: the namespace
        # *   **clusterName**: the name of the cluster
        # *   **image**: the name of the image
        # *   **imageRepoName**: the name of the image repository
        # *   **imageRepoNamespace**: the namespace to which the image repository belongs
        # *   **imageRepoTag**: the tag that is added to the image
        # *   **imageDigest**: the digest of the image
        self.container_field_name = container_field_name
        # The value of the condition that is used to query alert events on containers.
        self.container_field_value = container_field_value
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # Specifies whether the alert event is handled. Valid values:
        # 
        # *   **N**: unhandled
        # *   **Y**: handled
        self.dealed = dealed
        # The subtype of the alert event. Separate multiple subtypes with commas (,).
        self.event_names = event_names
        # The data source of the alert event. Set the value to sas.
        self.from_ = from_
        # The ID of the asset group to which the affected asset belongs.
        self.group_id = group_id
        # The ID of the alert event.
        self.id = id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The severity of the alert event. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.levels = levels
        # The name of the asset that is affected by the alert event.
        self.name = name
        # An array that consists of the handling result codes of alert events.
        self.operate_error_code_list = operate_error_code_list
        # The timestamp when the handling operation ends.
        self.operate_time_end = operate_time_end
        # The timestamp when the handling operation starts.
        self.operate_time_start = operate_time_start
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # The alert type of the alert event. Valid values:
        # 
        # *   **Suspicious process**\
        # *   **Webshell**\
        # *   **Unusual logon**\
        # *   **Exception**\
        # *   **Sensitive file tampering**\
        # *   **Malicious process (cloud threat detection)**\
        # *   **Suspicious network connection**\
        # *   **Suspicious account**\
        # *   **Application intrusion event**\
        # *   **Cloud threat detection**\
        # *   **Precise defense**\
        # *   **Application whitelist**\
        # *   **Persistent webshell**\
        # *   **Web application threat detection**\
        # *   **Malicious script**\
        # *   **Threat intelligence**\
        # *   **Malicious network activity**\
        # *   **Cluster exception**\
        # *   **Webshell (on-premises threat detection)**\
        # *   **Vulnerability exploitation**\
        # *   **Malicious process (on-premises threat detection)**\
        # *   **Trusted exception**\
        # *   **Operations to manage other resources**\
        self.parent_event_types = parent_event_types
        # The name of the alert or the information about the asset.
        # 
        # >  Fuzzy search is supported. The asset information includes the name, public IP address, and private IP address of an asset.
        self.remark = remark
        # The custom sorting field. Default value: **operateTime**. Valid values:
        # 
        # *   **lastTime**: the latest occurrence time.
        # *   **operateTime**: the handling time.
        # 
        # >  This parameter takes effect if you set the **Dealed** parameter to Y.
        self.sort_column = sort_column
        # The custom sorting order. Default value: **desc**. Valid values:
        # 
        # *   **asc**: the ascending order
        # *   **desc**: the descending order
        # 
        # >  This parameter takes effect if you set the **Dealed** parameter to Y.
        self.sort_type = sort_type
        # The source of the alert.
        self.source = source
        # The source IP address of the request.
        self.source_ip = source_ip
        # The status of the alert event. Valid values:
        # 
        # *   **0**: all
        # *   **1**: pending handling
        # *   **2**: ignored
        # *   **4**: confirmed
        # *   **8**: marked as a false positive
        # *   **16**: being handled
        # *   **32**: handled
        # *   **64**: expired
        # *   **128**: deleted
        # *   **512**: being automatically blocked
        # *   **513**: automatically blocked
        self.status = status
        # The tactic ID of ATT\&CK.
        self.tactic_id = tactic_id
        # The item that is used to search for the container. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the UUID of the server
        # *   **imageUuid**: the UUID of the image
        self.target_type = target_type
        # The end time when the alert event was last detected.
        self.time_end = time_end
        # The start time when the alert event was last detected.
        self.time_start = time_start
        # The unique key of the alert.
        self.unique_info = unique_info
        # The UUID of the server on which the alert is detected. Separate multiple UUIDs with commas (,).
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.assets_type_list is not None:
            result['AssetsTypeList'] = self.assets_type_list
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.event_names is not None:
            result['EventNames'] = self.event_names
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.name is not None:
            result['Name'] = self.name
        if self.operate_error_code_list is not None:
            result['OperateErrorCodeList'] = self.operate_error_code_list
        if self.operate_time_end is not None:
            result['OperateTimeEnd'] = self.operate_time_end
        if self.operate_time_start is not None:
            result['OperateTimeStart'] = self.operate_time_start
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_event_types is not None:
            result['ParentEventTypes'] = self.parent_event_types
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.source is not None:
            result['Source'] = self.source
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.time_end is not None:
            result['TimeEnd'] = self.time_end
        if self.time_start is not None:
            result['TimeStart'] = self.time_start
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AssetsTypeList') is not None:
            self.assets_type_list = m.get('AssetsTypeList')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('EventNames') is not None:
            self.event_names = m.get('EventNames')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OperateErrorCodeList') is not None:
            self.operate_error_code_list = m.get('OperateErrorCodeList')
        if m.get('OperateTimeEnd') is not None:
            self.operate_time_end = m.get('OperateTimeEnd')
        if m.get('OperateTimeStart') is not None:
            self.operate_time_start = m.get('OperateTimeStart')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentEventTypes') is not None:
            self.parent_event_types = m.get('ParentEventTypes')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TimeEnd') is not None:
            self.time_end = m.get('TimeEnd')
        if m.get('TimeStart') is not None:
            self.time_start = m.get('TimeStart')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeSuspEventsResponseBodySuspEventsDetails(TeaModel):
    def __init__(
        self,
        name_display: str = None,
        type: str = None,
        value: str = None,
        value_display: str = None,
    ):
        # The display name of the alert event.
        self.name_display = name_display
        # The type of the alert event.
        self.type = type
        # The path of the alert event.
        self.value = value
        # The display path of the alert event.
        self.value_display = value_display

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_display is not None:
            result['NameDisplay'] = self.name_display
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.value_display is not None:
            result['ValueDisplay'] = self.value_display
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameDisplay') is not None:
            self.name_display = m.get('NameDisplay')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueDisplay') is not None:
            self.value_display = m.get('ValueDisplay')
        return self


class DescribeSuspEventsResponseBodySuspEventsEventNotes(TeaModel):
    def __init__(
        self,
        note: str = None,
        note_id: int = None,
        note_time: str = None,
    ):
        # The remarks.
        self.note = note
        # The ID of the event record.
        self.note_id = note_id
        # The time when the event record was created.
        self.note_time = note_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.note is not None:
            result['Note'] = self.note
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        if self.note_time is not None:
            result['NoteTime'] = self.note_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Note') is not None:
            self.note = m.get('Note')
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        if m.get('NoteTime') is not None:
            self.note_time = m.get('NoteTime')
        return self


class DescribeSuspEventsResponseBodySuspEventsTacticItems(TeaModel):
    def __init__(
        self,
        tactic_display_name: str = None,
        tactic_id: str = None,
    ):
        # The tactic name of ATT\&CK.
        self.tactic_display_name = tactic_display_name
        # The stage information about ATT\&CK.
        self.tactic_id = tactic_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tactic_display_name is not None:
            result['TacticDisplayName'] = self.tactic_display_name
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TacticDisplayName') is not None:
            self.tactic_display_name = m.get('TacticDisplayName')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        return self


class DescribeSuspEventsResponseBodySuspEvents(TeaModel):
    def __init__(
        self,
        advanced: bool = None,
        alarm_event_name: str = None,
        alarm_event_name_display: str = None,
        alarm_event_type: str = None,
        alarm_event_type_display: str = None,
        alarm_unique_info: str = None,
        app_name: str = None,
        auto_breaking: bool = None,
        can_be_deal_on_line: bool = None,
        can_cancel_fault: bool = None,
        contain_hw_mode: bool = None,
        container_id: str = None,
        container_image_id: str = None,
        container_image_name: str = None,
        data_source: str = None,
        desc: str = None,
        details: List[DescribeSuspEventsResponseBodySuspEventsDetails] = None,
        display_sandbox_result: bool = None,
        event_notes: List[DescribeSuspEventsResponseBodySuspEventsEventNotes] = None,
        event_status: int = None,
        event_sub_type: str = None,
        has_trace_info: bool = None,
        id: int = None,
        image_uuid: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        k_8s_cluster_id: str = None,
        k_8s_cluster_name: str = None,
        k_8s_namespace: str = None,
        k_8s_node_id: str = None,
        k_8s_node_name: str = None,
        k_8s_pod_name: str = None,
        last_time: str = None,
        last_time_stamp: int = None,
        level: str = None,
        malicious_rule_status: str = None,
        mark_mis_rules: str = None,
        name: str = None,
        occurrence_time: str = None,
        occurrence_time_stamp: int = None,
        operate_error_code: str = None,
        operate_msg: str = None,
        operate_time: int = None,
        sale_version: str = None,
        security_event_ids: str = None,
        stages: str = None,
        tactic_items: List[DescribeSuspEventsResponseBodySuspEventsTacticItems] = None,
        unique_info: str = None,
        uuid: str = None,
        cluster_id: str = None,
    ):
        # Indicates whether the alert was analyzed offline.
        self.advanced = advanced
        # The name of the alert event.
        self.alarm_event_name = alarm_event_name
        # The description of the alert event to which the alert event is associated.
        self.alarm_event_name_display = alarm_event_name_display
        # The type of the alert event.
        self.alarm_event_type = alarm_event_type
        # The type of the alert event.
        self.alarm_event_type_display = alarm_event_type_display
        # The ID of the alert event.
        self.alarm_unique_info = alarm_unique_info
        # The name of the application to which the alert event belongs.
        self.app_name = app_name
        # Indicates whether the exception is automatically blocked.
        self.auto_breaking = auto_breaking
        # Indicates whether the online handling of the alert event is supported, such as quarantining the source file of the malicious process. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_be_deal_on_line = can_be_deal_on_line
        # Indicates whether you can cancel marking the alert event as a false positive.
        self.can_cancel_fault = can_cancel_fault
        # Indicates whether the Safeguard Mode For Major Activities mode is enabled for the server. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.contain_hw_mode = contain_hw_mode
        # The ID of the container.
        self.container_id = container_id
        # The ID of the image to which the container belongs.
        self.container_image_id = container_image_id
        # The name of the container image.
        self.container_image_name = container_image_name
        # The source of data. This parameter can be ignored.
        self.data_source = data_source
        # The impact of the alert event.
        self.desc = desc
        # The details of the alert event.
        self.details = details
        # Indicates whether the exception can be detected by cloud sandbox. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.display_sandbox_result = display_sandbox_result
        # An array that consists of the remarks on the exception.
        self.event_notes = event_notes
        # The status of the alert event. Valid values:
        # 
        # *   **1**: pending handling
        # *   **2**: ignored
        # *   **4**: confirmed
        # *   **8**: marked as a false positive
        # *   **16**: being handled
        # *   **32**: handled
        # *   **64**: expired
        self.event_status = event_status
        # The name of the alert event.
        self.event_sub_type = event_sub_type
        # Indicates whether the alert event has trace information. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.has_trace_info = has_trace_info
        # The ID of the alert event.
        self.id = id
        self.image_uuid = image_uuid
        # The ID of the affected asset.
        self.instance_id = instance_id
        # The name of the associated instance.
        self.instance_name = instance_name
        # The public IP address of the associated instance.
        self.internet_ip = internet_ip
        # The private IP address of the associated instance.
        self.intranet_ip = intranet_ip
        # The ID of the Kubernetes cluster.
        self.k_8s_cluster_id = k_8s_cluster_id
        # The name of the Kubernetes cluster.
        self.k_8s_cluster_name = k_8s_cluster_name
        # The namespace of the Kubernetes cluster.
        self.k_8s_namespace = k_8s_namespace
        # The ID of the Kubernetes cluster node.
        self.k_8s_node_id = k_8s_node_id
        # The name of the Kubernetes cluster node.
        self.k_8s_node_name = k_8s_node_name
        # The name of the Kubernetes pod.
        self.k_8s_pod_name = k_8s_pod_name
        # The time when the alert event was last generated.
        self.last_time = last_time
        # The timestamp when the exception was last detected. Unit: milliseconds.
        self.last_time_stamp = last_time_stamp
        # The severity of the alert event. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level
        # The status of the malicious behavior defense rule. Valid values:
        # 
        # *   **open**: enabled
        # *   **close**: disabled
        self.malicious_rule_status = malicious_rule_status
        # The advanced whitelist rule.
        self.mark_mis_rules = mark_mis_rules
        # The complete name of the alert event.
        self.name = name
        # The time when the alert event was first detected.
        self.occurrence_time = occurrence_time
        # The timestamp when the exception was first detected. Unit: milliseconds.
        self.occurrence_time_stamp = occurrence_time_stamp
        # The handling result code of the alert event.
        self.operate_error_code = operate_error_code
        # The description of the handing result of the alert event.
        self.operate_msg = operate_msg
        # The handling timestamp of the alert event. Unit: milliseconds.
        self.operate_time = operate_time
        # The edition of Security Center in which the exception can be detected. Valid values:
        # 
        # *   **0**: Basic edition
        # *   **1**: Enterprise edition
        self.sale_version = sale_version
        # The IDs of the associated alert events.
        self.security_event_ids = security_event_ids
        # The stage at which the attack is detected.
        self.stages = stages
        # The display name of the attack stage.
        self.tactic_items = tactic_items
        # The unique key of the alert.
        self.unique_info = unique_info
        # The ID of the associated instance.
        self.uuid = uuid
        # The ID of the cluster.
        self.cluster_id = cluster_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.event_notes:
            for k in self.event_notes:
                if k:
                    k.validate()
        if self.tactic_items:
            for k in self.tactic_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced is not None:
            result['Advanced'] = self.advanced
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_name_display is not None:
            result['AlarmEventNameDisplay'] = self.alarm_event_name_display
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_event_type_display is not None:
            result['AlarmEventTypeDisplay'] = self.alarm_event_type_display
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_breaking is not None:
            result['AutoBreaking'] = self.auto_breaking
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        if self.contain_hw_mode is not None:
            result['ContainHwMode'] = self.contain_hw_mode
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_image_id is not None:
            result['ContainerImageId'] = self.container_image_id
        if self.container_image_name is not None:
            result['ContainerImageName'] = self.container_image_name
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.desc is not None:
            result['Desc'] = self.desc
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.display_sandbox_result is not None:
            result['DisplaySandboxResult'] = self.display_sandbox_result
        result['EventNotes'] = []
        if self.event_notes is not None:
            for k in self.event_notes:
                result['EventNotes'].append(k.to_map() if k else None)
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_sub_type is not None:
            result['EventSubType'] = self.event_sub_type
        if self.has_trace_info is not None:
            result['HasTraceInfo'] = self.has_trace_info
        if self.id is not None:
            result['Id'] = self.id
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.k_8s_cluster_id is not None:
            result['K8sClusterId'] = self.k_8s_cluster_id
        if self.k_8s_cluster_name is not None:
            result['K8sClusterName'] = self.k_8s_cluster_name
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.k_8s_node_id is not None:
            result['K8sNodeId'] = self.k_8s_node_id
        if self.k_8s_node_name is not None:
            result['K8sNodeName'] = self.k_8s_node_name
        if self.k_8s_pod_name is not None:
            result['K8sPodName'] = self.k_8s_pod_name
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.last_time_stamp is not None:
            result['LastTimeStamp'] = self.last_time_stamp
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_rule_status is not None:
            result['MaliciousRuleStatus'] = self.malicious_rule_status
        if self.mark_mis_rules is not None:
            result['MarkMisRules'] = self.mark_mis_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.occurrence_time_stamp is not None:
            result['OccurrenceTimeStamp'] = self.occurrence_time_stamp
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_msg is not None:
            result['OperateMsg'] = self.operate_msg
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.stages is not None:
            result['Stages'] = self.stages
        result['TacticItems'] = []
        if self.tactic_items is not None:
            for k in self.tactic_items:
                result['TacticItems'].append(k.to_map() if k else None)
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Advanced') is not None:
            self.advanced = m.get('Advanced')
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventNameDisplay') is not None:
            self.alarm_event_name_display = m.get('AlarmEventNameDisplay')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmEventTypeDisplay') is not None:
            self.alarm_event_type_display = m.get('AlarmEventTypeDisplay')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoBreaking') is not None:
            self.auto_breaking = m.get('AutoBreaking')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        if m.get('ContainHwMode') is not None:
            self.contain_hw_mode = m.get('ContainHwMode')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerImageId') is not None:
            self.container_image_id = m.get('ContainerImageId')
        if m.get('ContainerImageName') is not None:
            self.container_image_name = m.get('ContainerImageName')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('DisplaySandboxResult') is not None:
            self.display_sandbox_result = m.get('DisplaySandboxResult')
        self.event_notes = []
        if m.get('EventNotes') is not None:
            for k in m.get('EventNotes'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsEventNotes()
                self.event_notes.append(temp_model.from_map(k))
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventSubType') is not None:
            self.event_sub_type = m.get('EventSubType')
        if m.get('HasTraceInfo') is not None:
            self.has_trace_info = m.get('HasTraceInfo')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('K8sClusterId') is not None:
            self.k_8s_cluster_id = m.get('K8sClusterId')
        if m.get('K8sClusterName') is not None:
            self.k_8s_cluster_name = m.get('K8sClusterName')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('K8sNodeId') is not None:
            self.k_8s_node_id = m.get('K8sNodeId')
        if m.get('K8sNodeName') is not None:
            self.k_8s_node_name = m.get('K8sNodeName')
        if m.get('K8sPodName') is not None:
            self.k_8s_pod_name = m.get('K8sPodName')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('LastTimeStamp') is not None:
            self.last_time_stamp = m.get('LastTimeStamp')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousRuleStatus') is not None:
            self.malicious_rule_status = m.get('MaliciousRuleStatus')
        if m.get('MarkMisRules') is not None:
            self.mark_mis_rules = m.get('MarkMisRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('OccurrenceTimeStamp') is not None:
            self.occurrence_time_stamp = m.get('OccurrenceTimeStamp')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateMsg') is not None:
            self.operate_msg = m.get('OperateMsg')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('Stages') is not None:
            self.stages = m.get('Stages')
        self.tactic_items = []
        if m.get('TacticItems') is not None:
            for k in m.get('TacticItems'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsTacticItems()
                self.tactic_items.append(temp_model.from_map(k))
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        return self


class DescribeSuspEventsResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        susp_events: List[DescribeSuspEventsResponseBodySuspEvents] = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # An array that consists of the information about the alert event.
        self.susp_events = susp_events
        # The total number of alert events.
        self.total_count = total_count

    def validate(self):
        if self.susp_events:
            for k in self.susp_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspEvents'] = []
        if self.susp_events is not None:
            for k in self.susp_events:
                result['SuspEvents'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_events = []
        if m.get('SuspEvents') is not None:
            for k in m.get('SuspEvents'):
                temp_model = DescribeSuspEventsResponseBodySuspEvents()
                self.susp_events.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspiciousOverallConfigRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        type: str = None,
    ):
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousOverallConfigResponseBodyOverallConfig(TeaModel):
    def __init__(
        self,
        config: str = None,
        type: str = None,
    ):
        self.config = config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousOverallConfigResponseBody(TeaModel):
    def __init__(
        self,
        overall_config: DescribeSuspiciousOverallConfigResponseBodyOverallConfig = None,
        request_id: str = None,
    ):
        self.overall_config = overall_config
        self.request_id = request_id

    def validate(self):
        if self.overall_config:
            self.overall_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OverallConfig') is not None:
            temp_model = DescribeSuspiciousOverallConfigResponseBodyOverallConfig()
            self.overall_config = temp_model.from_map(m['OverallConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSuspiciousOverallConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspiciousOverallConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspiciousOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspiciousUUIDConfigRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousUUIDConfigResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        request_id: str = None,
        uuidlist: List[str] = None,
    ):
        self.count = count
        self.request_id = request_id
        self.uuidlist = uuidlist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uuidlist is not None:
            result['UUIDList'] = self.uuidlist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UUIDList') is not None:
            self.uuidlist = m.get('UUIDList')
        return self


class DescribeSuspiciousUUIDConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSuspiciousUUIDConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspiciousUUIDConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTargetRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        type: str = None,
    ):
        self.config = config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTargetResponseBodyTargets(TeaModel):
    def __init__(
        self,
        flag: str = None,
        target: str = None,
        target_type: str = None,
    ):
        self.flag = flag
        self.target = target
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        targets: List[DescribeTargetResponseBodyTargets] = None,
        total_count: int = None,
    ):
        self.request_id = request_id
        self.targets = targets
        self.total_count = total_count

    def validate(self):
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = DescribeTargetResponseBodyTargets()
                self.targets.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTaskErrorLogRequest(TeaModel):
    def __init__(
        self,
        build_task_id: str = None,
    ):
        self.build_task_id = build_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_task_id is not None:
            result['BuildTaskId'] = self.build_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildTaskId') is not None:
            self.build_task_id = m.get('BuildTaskId')
        return self


class DescribeTaskErrorLogResponseBodyLogs(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class DescribeTaskErrorLogResponseBody(TeaModel):
    def __init__(
        self,
        logs: List[DescribeTaskErrorLogResponseBodyLogs] = None,
        request_id: str = None,
    ):
        self.logs = logs
        self.request_id = request_id

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribeTaskErrorLogResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTaskErrorLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTaskErrorLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTaskErrorLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTotalStatisticsRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        group_id: int = None,
        remark: str = None,
    ):
        # The source of data. Default value: **aqs**. Valid values:
        # 
        # *   **sas**: Security Center
        # *   **aqs**: Server Guard
        self.from_ = from_
        # The ID of the asset group.
        # 
        # > You can call the [DescribeAllGroups](~~130972~~) operation to query the IDs of asset groups.
        self.group_id = group_id
        # The name or public IP address of the asset.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class DescribeTotalStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        account: int = None,
        health: int = None,
        health_total: int = None,
        healthdealed_total: int = None,
        healthhigh_total: int = None,
        healthlow_total: int = None,
        healthmedium_total: int = None,
        healthserious_total: int = None,
        newsuspicious: int = None,
        online: bool = None,
        patch: int = None,
        request_id: str = None,
        suspicious: int = None,
        suspicious_total: int = None,
        suspiciousdealed_total: int = None,
        suspicioushigh_total: int = None,
        suspiciouslow_total: int = None,
        suspiciousmedium_total: int = None,
        suspiciousserious_total: int = None,
        trojan: int = None,
        vul: int = None,
        vul_asap_sum: int = None,
        vul_dealed_total: int = None,
        vul_later_sum: int = None,
        vul_nntf_sum: int = None,
        vul_total: int = None,
    ):
        # The number of logons to the asset.
        self.account = account
        # The total number of unfixed baseline risks.
        self.health = health
        # The total number of baseline risks.
        self.health_total = health_total
        # The total number of fixed baseline risks.
        self.healthdealed_total = healthdealed_total
        # The number of baselines whose risk level is high.
        self.healthhigh_total = healthhigh_total
        # The number of baseline risks whose risk level is low.
        self.healthlow_total = healthlow_total
        # The number of baseline risks whose risk level is medium.
        self.healthmedium_total = healthmedium_total
        # This parameter is deprecated.
        self.healthserious_total = healthserious_total
        # The number of alerts that are generated by Server Guard or Security Center.
        # 
        # > 
        # 
        # > *   If you set the **Type** parameter to **sas**, this parameter indicates the number of alerts that are generated by Security Center.
        # 
        # > *   If you set the **Type** parameter to **aqs**, this parameter indicates the number of alerts that are generated by Server Guard.
        self.newsuspicious = newsuspicious
        # Indicates whether the Security Center agent is online. Valid values:
        # 
        # *   **true**: The service is online.
        # *   **false**: The service is offline.
        self.online = online
        # The number of Web-CMS vulnerabilities.
        self.patch = patch
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The number of alerts that are generated by Server Guard.
        self.suspicious = suspicious
        # This parameter is deprecated.
        self.suspicious_total = suspicious_total
        # The number of handled alerts.
        self.suspiciousdealed_total = suspiciousdealed_total
        # This parameter is deprecated.
        self.suspicioushigh_total = suspicioushigh_total
        # The number of alerts whose risk level is reminder.
        self.suspiciouslow_total = suspiciouslow_total
        # The number of alerts whose risk level is suspicious.
        self.suspiciousmedium_total = suspiciousmedium_total
        # The number of alerts whose risk level is urgent.
        self.suspiciousserious_total = suspiciousserious_total
        # The number of webshell alerts.
        self.trojan = trojan
        # The number of unfixed vulnerabilities.
        self.vul = vul
        # The number of vulnerabilities whose severity level is high.
        self.vul_asap_sum = vul_asap_sum
        # The total number of fixed vulnerabilities.
        self.vul_dealed_total = vul_dealed_total
        # The number of vulnerabilities whose severity level is medium.
        self.vul_later_sum = vul_later_sum
        # The number of unfixed vulnerabilities whose severity level is medium.
        self.vul_nntf_sum = vul_nntf_sum
        # The total number of vulnerabilities.
        self.vul_total = vul_total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.health is not None:
            result['Health'] = self.health
        if self.health_total is not None:
            result['HealthTotal'] = self.health_total
        if self.healthdealed_total is not None:
            result['HealthdealedTotal'] = self.healthdealed_total
        if self.healthhigh_total is not None:
            result['HealthhighTotal'] = self.healthhigh_total
        if self.healthlow_total is not None:
            result['HealthlowTotal'] = self.healthlow_total
        if self.healthmedium_total is not None:
            result['HealthmediumTotal'] = self.healthmedium_total
        if self.healthserious_total is not None:
            result['HealthseriousTotal'] = self.healthserious_total
        if self.newsuspicious is not None:
            result['Newsuspicious'] = self.newsuspicious
        if self.online is not None:
            result['Online'] = self.online
        if self.patch is not None:
            result['Patch'] = self.patch
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        if self.suspicious_total is not None:
            result['SuspiciousTotal'] = self.suspicious_total
        if self.suspiciousdealed_total is not None:
            result['SuspiciousdealedTotal'] = self.suspiciousdealed_total
        if self.suspicioushigh_total is not None:
            result['SuspicioushighTotal'] = self.suspicioushigh_total
        if self.suspiciouslow_total is not None:
            result['SuspiciouslowTotal'] = self.suspiciouslow_total
        if self.suspiciousmedium_total is not None:
            result['SuspiciousmediumTotal'] = self.suspiciousmedium_total
        if self.suspiciousserious_total is not None:
            result['SuspiciousseriousTotal'] = self.suspiciousserious_total
        if self.trojan is not None:
            result['Trojan'] = self.trojan
        if self.vul is not None:
            result['Vul'] = self.vul
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_dealed_total is not None:
            result['VulDealedTotal'] = self.vul_dealed_total
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        if self.vul_total is not None:
            result['VulTotal'] = self.vul_total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('HealthTotal') is not None:
            self.health_total = m.get('HealthTotal')
        if m.get('HealthdealedTotal') is not None:
            self.healthdealed_total = m.get('HealthdealedTotal')
        if m.get('HealthhighTotal') is not None:
            self.healthhigh_total = m.get('HealthhighTotal')
        if m.get('HealthlowTotal') is not None:
            self.healthlow_total = m.get('HealthlowTotal')
        if m.get('HealthmediumTotal') is not None:
            self.healthmedium_total = m.get('HealthmediumTotal')
        if m.get('HealthseriousTotal') is not None:
            self.healthserious_total = m.get('HealthseriousTotal')
        if m.get('Newsuspicious') is not None:
            self.newsuspicious = m.get('Newsuspicious')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('Patch') is not None:
            self.patch = m.get('Patch')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        if m.get('SuspiciousTotal') is not None:
            self.suspicious_total = m.get('SuspiciousTotal')
        if m.get('SuspiciousdealedTotal') is not None:
            self.suspiciousdealed_total = m.get('SuspiciousdealedTotal')
        if m.get('SuspicioushighTotal') is not None:
            self.suspicioushigh_total = m.get('SuspicioushighTotal')
        if m.get('SuspiciouslowTotal') is not None:
            self.suspiciouslow_total = m.get('SuspiciouslowTotal')
        if m.get('SuspiciousmediumTotal') is not None:
            self.suspiciousmedium_total = m.get('SuspiciousmediumTotal')
        if m.get('SuspiciousseriousTotal') is not None:
            self.suspiciousserious_total = m.get('SuspiciousseriousTotal')
        if m.get('Trojan') is not None:
            self.trojan = m.get('Trojan')
        if m.get('Vul') is not None:
            self.vul = m.get('Vul')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulDealedTotal') is not None:
            self.vul_dealed_total = m.get('VulDealedTotal')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        if m.get('VulTotal') is not None:
            self.vul_total = m.get('VulTotal')
        return self


class DescribeTotalStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTotalStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTotalStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTraceInfoDetailRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        incident_time: int = None,
        lang: str = None,
        source_ip: str = None,
        type: str = None,
        uuid: str = None,
        vertex_id: str = None,
    ):
        self.from_ = from_
        self.incident_time = incident_time
        self.lang = lang
        self.source_ip = source_ip
        self.type = type
        self.uuid = uuid
        self.vertex_id = vertex_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.incident_time is not None:
            result['IncidentTime'] = self.incident_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vertex_id is not None:
            result['VertexId'] = self.vertex_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('IncidentTime') is not None:
            self.incident_time = m.get('IncidentTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VertexId') is not None:
            self.vertex_id = m.get('VertexId')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList(TeaModel):
    def __init__(
        self,
        count: int = None,
        end_id: str = None,
        start_id: str = None,
        time: str = None,
        type: str = None,
    ):
        self.count = count
        self.end_id = end_id
        self.start_id = start_id
        self.time = time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.end_id is not None:
            result['EndId'] = self.end_id
        if self.start_id is not None:
            result['StartId'] = self.start_id
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('EndId') is not None:
            self.end_id = m.get('EndId')
        if m.get('StartId') is not None:
            self.start_id = m.get('StartId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        display_color: str = None,
        display_icon: str = None,
        display_template: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: str = None,
        limit: int = None,
        name: str = None,
        namespace: str = None,
        offset: int = None,
    ):
        self.db_id = db_id
        self.display_color = display_color
        self.display_icon = display_icon
        self.display_template = display_template
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.limit = limit
        self.name = name
        self.namespace = namespace
        self.offset = offset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.display_color is not None:
            result['DisplayColor'] = self.display_color
        if self.display_icon is not None:
            result['DisplayIcon'] = self.display_icon
        if self.display_template is not None:
            result['DisplayTemplate'] = self.display_template
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.offset is not None:
            result['Offset'] = self.offset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DisplayColor') is not None:
            self.display_color = m.get('DisplayColor')
        if m.get('DisplayIcon') is not None:
            self.display_icon = m.get('DisplayIcon')
        if m.get('DisplayTemplate') is not None:
            self.display_template = m.get('DisplayTemplate')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList(TeaModel):
    def __init__(
        self,
        directed: int = None,
        display_color: str = None,
        name: str = None,
        relation_type_id: str = None,
        show_type: str = None,
    ):
        self.directed = directed
        self.display_color = display_color
        self.name = name
        self.relation_type_id = relation_type_id
        self.show_type = show_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed is not None:
            result['Directed'] = self.directed
        if self.display_color is not None:
            result['DisplayColor'] = self.display_color
        if self.name is not None:
            result['Name'] = self.name
        if self.relation_type_id is not None:
            result['RelationTypeId'] = self.relation_type_id
        if self.show_type is not None:
            result['ShowType'] = self.show_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Directed') is not None:
            self.directed = m.get('Directed')
        if m.get('DisplayColor') is not None:
            self.display_color = m.get('DisplayColor')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RelationTypeId') is not None:
            self.relation_type_id = m.get('RelationTypeId')
        if m.get('ShowType') is not None:
            self.show_type = m.get('ShowType')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList(TeaModel):
    def __init__(
        self,
        count: int = None,
        has_more: bool = None,
        type: str = None,
    ):
        self.count = count
        self.has_more = has_more
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList(TeaModel):
    def __init__(
        self,
        count: int = None,
        id: str = None,
        name: str = None,
        neighbor_list: List[DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList] = None,
        time: str = None,
        type: str = None,
    ):
        self.count = count
        self.id = id
        self.name = name
        self.neighbor_list = neighbor_list
        self.time = time
        self.type = type

    def validate(self):
        if self.neighbor_list:
            for k in self.neighbor_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['NeighborList'] = []
        if self.neighbor_list is not None:
            for k in self.neighbor_list:
                result['NeighborList'].append(k.to_map() if k else None)
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.neighbor_list = []
        if m.get('NeighborList') is not None:
            for k in m.get('NeighborList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList()
                self.neighbor_list.append(temp_model.from_map(k))
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetail(TeaModel):
    def __init__(
        self,
        edge_list: List[DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList] = None,
        entity_type_list: List[DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList] = None,
        relation_type_list: List[DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList] = None,
        vertex_list: List[DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList] = None,
    ):
        self.edge_list = edge_list
        self.entity_type_list = entity_type_list
        self.relation_type_list = relation_type_list
        self.vertex_list = vertex_list

    def validate(self):
        if self.edge_list:
            for k in self.edge_list:
                if k:
                    k.validate()
        if self.entity_type_list:
            for k in self.entity_type_list:
                if k:
                    k.validate()
        if self.relation_type_list:
            for k in self.relation_type_list:
                if k:
                    k.validate()
        if self.vertex_list:
            for k in self.vertex_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EdgeList'] = []
        if self.edge_list is not None:
            for k in self.edge_list:
                result['EdgeList'].append(k.to_map() if k else None)
        result['EntityTypeList'] = []
        if self.entity_type_list is not None:
            for k in self.entity_type_list:
                result['EntityTypeList'].append(k.to_map() if k else None)
        result['RelationTypeList'] = []
        if self.relation_type_list is not None:
            for k in self.relation_type_list:
                result['RelationTypeList'].append(k.to_map() if k else None)
        result['VertexList'] = []
        if self.vertex_list is not None:
            for k in self.vertex_list:
                result['VertexList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge_list = []
        if m.get('EdgeList') is not None:
            for k in m.get('EdgeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList()
                self.edge_list.append(temp_model.from_map(k))
        self.entity_type_list = []
        if m.get('EntityTypeList') is not None:
            for k in m.get('EntityTypeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList()
                self.entity_type_list.append(temp_model.from_map(k))
        self.relation_type_list = []
        if m.get('RelationTypeList') is not None:
            for k in m.get('RelationTypeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList()
                self.relation_type_list.append(temp_model.from_map(k))
        self.vertex_list = []
        if m.get('VertexList') is not None:
            for k in m.get('VertexList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList()
                self.vertex_list.append(temp_model.from_map(k))
        return self


class DescribeTraceInfoDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        trace_info_detail: DescribeTraceInfoDetailResponseBodyTraceInfoDetail = None,
    ):
        self.request_id = request_id
        self.success = success
        self.trace_info_detail = trace_info_detail

    def validate(self):
        if self.trace_info_detail:
            self.trace_info_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_info_detail is not None:
            result['TraceInfoDetail'] = self.trace_info_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceInfoDetail') is not None:
            temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetail()
            self.trace_info_detail = temp_model.from_map(m['TraceInfoDetail'])
        return self


class DescribeTraceInfoDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTraceInfoDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTraceInfoDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTraceInfoNodeRequest(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        from_: str = None,
        incident_time: int = None,
        lang: str = None,
        source_ip: str = None,
        type: str = None,
        uuid: str = None,
        vertex_id: str = None,
    ):
        # The name of the alert event.
        # 
        # > You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of alerts events.
        self.event_name = event_name
        # The ID of the request source. Set the value to sas.
        self.from_ = from_
        # The time when the alert event was first detected.
        self.incident_time = incident_time
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request. The value of this parameter is specified by the system.
        self.source_ip = source_ip
        # The type of the vertex. You can call the [DescribeTraceInfoDetail](~~DescribeTraceInfoDetail~~) operation to query the types of vertexes.
        self.type = type
        # The UUID of the server. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.
        self.uuid = uuid
        # The ID of the vertex.
        self.vertex_id = vertex_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.incident_time is not None:
            result['IncidentTime'] = self.incident_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vertex_id is not None:
            result['VertexId'] = self.vertex_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('IncidentTime') is not None:
            self.incident_time = m.get('IncidentTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VertexId') is not None:
            self.vertex_id = m.get('VertexId')
        return self


class DescribeTraceInfoNodeResponseBodyNodePropertyList(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the property.
        self.name = name
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeTraceInfoNodeResponseBodyNode(TeaModel):
    def __init__(
        self,
        name: str = None,
        property_list: List[DescribeTraceInfoNodeResponseBodyNodePropertyList] = None,
        type: str = None,
    ):
        # The name of the node.
        self.name = name
        # An array that consists of the properties of the node.
        self.property_list = property_list
        # The type of the node.
        self.type = type

    def validate(self):
        if self.property_list:
            for k in self.property_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['PropertyList'] = []
        if self.property_list is not None:
            for k in self.property_list:
                result['PropertyList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.property_list = []
        if m.get('PropertyList') is not None:
            for k in m.get('PropertyList'):
                temp_model = DescribeTraceInfoNodeResponseBodyNodePropertyList()
                self.property_list.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoNodeResponseBody(TeaModel):
    def __init__(
        self,
        node: DescribeTraceInfoNodeResponseBodyNode = None,
        request_id: str = None,
    ):
        # The details about the node.
        self.node = node
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Node') is not None:
            temp_model = DescribeTraceInfoNodeResponseBodyNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTraceInfoNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTraceInfoNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTraceInfoNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupDatabaseRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        database_type: str = None,
        instance_name: str = None,
        page_size: int = None,
        query_type: str = None,
        uni_region_id: str = None,
    ):
        self.current_page = current_page
        self.database_type = database_type
        self.instance_name = instance_name
        self.page_size = page_size
        self.query_type = query_type
        self.uni_region_id = uni_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class DescribeUniBackupDatabaseResponseBodyDatabaseList(TeaModel):
    def __init__(
        self,
        agent_status: str = None,
        created_by_product: str = None,
        database_name: str = None,
        database_type: str = None,
        database_version: str = None,
        instance_id: str = None,
        instance_name: str = None,
        instance_uuid: str = None,
        policy_id: int = None,
        status: str = None,
    ):
        self.agent_status = agent_status
        self.created_by_product = created_by_product
        self.database_name = database_name
        self.database_type = database_type
        self.database_version = database_version
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.instance_uuid = instance_uuid
        self.policy_id = policy_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.created_by_product is not None:
            result['CreatedByProduct'] = self.created_by_product
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.database_version is not None:
            result['DatabaseVersion'] = self.database_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('CreatedByProduct') is not None:
            self.created_by_product = m.get('CreatedByProduct')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('DatabaseVersion') is not None:
            self.database_version = m.get('DatabaseVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeUniBackupDatabaseResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniBackupDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database_list: List[DescribeUniBackupDatabaseResponseBodyDatabaseList] = None,
        page_info: DescribeUniBackupDatabaseResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.database_list = database_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = DescribeUniBackupDatabaseResponseBodyDatabaseList()
                self.database_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeUniBackupDatabaseResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUniBackupDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUniBackupDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupPoliciesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        policy_name: str = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The name of the anti-ransomware policy.
        self.policy_name = policy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        return self


class DescribeUniBackupPoliciesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniBackupPoliciesResponseBodyUniBackupPolicies(TeaModel):
    def __init__(
        self,
        agent_error_message: str = None,
        agent_status: str = None,
        database_name: str = None,
        database_type: str = None,
        error_code: str = None,
        error_message: str = None,
        instance_id: str = None,
        instance_name: str = None,
        instance_status: str = None,
        instance_uuid: str = None,
        latest_back_result: str = None,
        latest_backup_time: str = None,
        plan_status: str = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_status: str = None,
        uni_region_id: str = None,
    ):
        # The error message for the anti-ransomware agent.
        self.agent_error_message = agent_error_message
        # The status of the agent. Valid values:
        # 
        # *   **UNKNOWN**: unknown
        # *   **INSTALLED**: installed
        # *   **INSTALL_FAILED**: installation failed
        # *   **UNINSTALL_FAILED**: uninstallation failed
        self.agent_status = agent_status
        # The name of the database.
        self.database_name = database_name
        # The type of the database. Valid values:
        # 
        # *   **MYSQL**\
        # *   **MSSQL**\
        # *   **Oracle**\
        self.database_type = database_type
        # The error code returned when the backup task fails.
        self.error_code = error_code
        # The error message for the anti-ransomware policy.
        self.error_message = error_message
        # The ID of the server.
        self.instance_id = instance_id
        # The name of the server.
        self.instance_name = instance_name
        # The status of the Elastic Compute Service (ECS) instance. Valid values:
        # 
        # *   **Stopped**\
        # *   **Running**\
        self.instance_status = instance_status
        # The UUID of the agent that is used to back up the data of the database.
        self.instance_uuid = instance_uuid
        # The execution result of the last backup task.
        self.latest_back_result = latest_back_result
        # The time when the last backup task was executed.
        self.latest_backup_time = latest_backup_time
        # The status of the backup task. Valid values:
        # 
        # *   **init**: initializing
        # *   **running**: running
        # *   **completed**: complete
        # *   **restoring**: restoring
        # *   **creating**: creating
        # *   **created**: created
        self.plan_status = plan_status
        # The ID of the anti-ransomware policy.
        self.policy_id = policy_id
        # The name of the anti-ransomware policy.
        self.policy_name = policy_name
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **initiating**: initializing
        # *   **opening**: enabled
        # *   **closing**: disabled
        # *   **deleting**: deleting
        self.policy_status = policy_status
        # The region ID of the server that hosts the database.
        self.uni_region_id = uni_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_error_message is not None:
            result['AgentErrorMessage'] = self.agent_error_message
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.latest_back_result is not None:
            result['LatestBackResult'] = self.latest_back_result
        if self.latest_backup_time is not None:
            result['LatestBackupTime'] = self.latest_backup_time
        if self.plan_status is not None:
            result['PlanStatus'] = self.plan_status
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentErrorMessage') is not None:
            self.agent_error_message = m.get('AgentErrorMessage')
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('LatestBackResult') is not None:
            self.latest_back_result = m.get('LatestBackResult')
        if m.get('LatestBackupTime') is not None:
            self.latest_backup_time = m.get('LatestBackupTime')
        if m.get('PlanStatus') is not None:
            self.plan_status = m.get('PlanStatus')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class DescribeUniBackupPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeUniBackupPoliciesResponseBodyPageInfo = None,
        request_id: str = None,
        uni_backup_policies: List[DescribeUniBackupPoliciesResponseBodyUniBackupPolicies] = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array that consists of the anti-ransomware policies.
        self.uni_backup_policies = uni_backup_policies

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.uni_backup_policies:
            for k in self.uni_backup_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UniBackupPolicies'] = []
        if self.uni_backup_policies is not None:
            for k in self.uni_backup_policies:
                result['UniBackupPolicies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeUniBackupPoliciesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.uni_backup_policies = []
        if m.get('UniBackupPolicies') is not None:
            for k in m.get('UniBackupPolicies'):
                temp_model = DescribeUniBackupPoliciesResponseBodyUniBackupPolicies()
                self.uni_backup_policies.append(temp_model.from_map(k))
        return self


class DescribeUniBackupPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUniBackupPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupPolicyDetailRequest(TeaModel):
    def __init__(
        self,
        policy_id: str = None,
    ):
        # $.parameters[2].schema.enumValueTitles
        self.policy_id = policy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan(TeaModel):
    def __init__(
        self,
        days: List[str] = None,
        interval: int = None,
        plan_type: str = None,
        start_time: str = None,
    ):
        # The interval of backup tasks.
        self.days = days
        # The unit of the interval. Valid values:
        # 
        # *   **hourly**: hour
        # *   **daily**: day
        # *   **weekly**: week
        self.interval = interval
        # The time when the full backup started. The time is in the HH:mm:ss format.
        self.plan_type = plan_type
        # The details of the policy for full backup.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan(TeaModel):
    def __init__(
        self,
        days: List[str] = None,
        interval: int = None,
        plan_type: str = None,
        start_time: str = None,
    ):
        # The interval of backup tasks.
        self.days = days
        # The unit of the interval. Valid values:
        # 
        # *   **hourly**: hour
        # *   **daily**: day
        # *   **weekly**: week
        self.interval = interval
        # The time when the incremental backup started. The time is in the HH:mm:ss format.
        self.plan_type = plan_type
        # The details of the policy for incremental backup.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO(TeaModel):
    def __init__(
        self,
        account_name: str = None,
        agent_status: str = None,
        database_type: str = None,
        full_plan: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan = None,
        inc_plan: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan = None,
        instance_id: str = None,
        instance_name: str = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_status: str = None,
        retention: int = None,
        speed_limiter: int = None,
    ):
        # The status of the database client. Valid values:
        # 
        # *   **UNKNOWN**: unknown
        # *   **INSTALLED**: installed
        # *   **INSTALL_FAILED**: installation failed
        # *   **UNINSTALL_FAILED**: uninstallation failed
        self.account_name = account_name
        # The ID of the anti-ransomware policy.
        self.agent_status = agent_status
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **initiating**: initializing
        # *   **opening**: enabled
        # *   **closing**: disabled
        # *   **deleting**: deleting
        self.database_type = database_type
        # The name of the database account.
        self.full_plan = full_plan
        # The day of a week on which the backup is performed. Valid values:
        # 
        # *   **0**: Sunday
        # *   **1**: Monday
        # *   **2**: Tuesday
        # *   **3**: Wednesday
        # *   **4**: Thursday
        # *   **5**: Friday
        # *   **6**: Saturday
        self.inc_plan = inc_plan
        # The name of the anti-ransomware policy.
        self.instance_id = instance_id
        # The type of the database. Valid values:
        # 
        # *   **MYSQL**\
        # *   **MSSQL**\
        # *   **Oracle**\
        self.instance_name = instance_name
        # The ID of the server.
        self.policy_id = policy_id
        # The maximum network bandwidth that is allowed during data backup. Unit: bytes.
        self.policy_name = policy_name
        # The details of the anti-ransomware policy.
        self.policy_status = policy_status
        # The name of the server.
        self.retention = retention
        # The retention period of the backup snapshot.
        self.speed_limiter = speed_limiter

    def validate(self):
        if self.full_plan:
            self.full_plan.validate()
        if self.inc_plan:
            self.inc_plan.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan.to_map()
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan()
            self.full_plan = temp_model.from_map(m['FullPlan'])
        if m.get('IncPlan') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan()
            self.inc_plan = temp_model.from_map(m['IncPlan'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class DescribeUniBackupPolicyDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        uni_backup_policy_dto: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO = None,
    ):
        # The data returned.
        self.request_id = request_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.uni_backup_policy_dto = uni_backup_policy_dto

    def validate(self):
        if self.uni_backup_policy_dto:
            self.uni_backup_policy_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uni_backup_policy_dto is not None:
            result['UniBackupPolicyDTO'] = self.uni_backup_policy_dto.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UniBackupPolicyDTO') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO()
            self.uni_backup_policy_dto = temp_model.from_map(m['UniBackupPolicyDTO'])
        return self


class DescribeUniBackupPolicyDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUniBackupPolicyDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniRecoverableListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        database: str = None,
        page_size: int = None,
        policy_id: int = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The name of the database.
        self.database = database
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The ID of the anti-ransomware policy.
        # 
        # > You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.policy_id = policy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database is not None:
            result['Database'] = self.database
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class DescribeUniRecoverableListResponseBodyRecoverableInfoList(TeaModel):
    def __init__(
        self,
        first_time: int = None,
        last_time: int = None,
        reset_scn: str = None,
        reset_time: int = None,
        restore_info: str = None,
    ):
        # The timestamp of the first backup. Unit: milliseconds.
        self.first_time = first_time
        # The timestamp of the last backup. Unit: milliseconds.
        self.last_time = last_time
        # The identifier of the point in time for restoration in the backup version that is used. The database is an Oracle database.
        self.reset_scn = reset_scn
        # The point in time for restoration in the backup version that is used. The database is an Oracle database.
        self.reset_time = reset_time
        # The information about the database. This parameter is available when the database is a Microsoft SQL Server (MSSQL) database. The value is a JSON string. Valid values:
        # 
        # *   **name**: the name of the database
        # *   **files**: the path to the database files
        self.restore_info = restore_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.reset_scn is not None:
            result['ResetScn'] = self.reset_scn
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.restore_info is not None:
            result['RestoreInfo'] = self.restore_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('ResetScn') is not None:
            self.reset_scn = m.get('ResetScn')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('RestoreInfo') is not None:
            self.restore_info = m.get('RestoreInfo')
        return self


class DescribeUniRecoverableListResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        database: str = None,
        page_size: int = None,
        recoverable_info_list: List[DescribeUniRecoverableListResponseBodyRecoverableInfoList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The name of the database.
        self.database = database
        # The number of entries returned per page.
        self.page_size = page_size
        # An array that consists of the backup snapshots.
        self.recoverable_info_list = recoverable_info_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.recoverable_info_list:
            for k in self.recoverable_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database is not None:
            result['Database'] = self.database
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RecoverableInfoList'] = []
        if self.recoverable_info_list is not None:
            for k in self.recoverable_info_list:
                result['RecoverableInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.recoverable_info_list = []
        if m.get('RecoverableInfoList') is not None:
            for k in m.get('RecoverableInfoList'):
                temp_model = DescribeUniRecoverableListResponseBodyRecoverableInfoList()
                self.recoverable_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniRecoverableListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUniRecoverableListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniRecoverableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniSupportRegionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        uni_support_region: List[str] = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array consisting of the region that is supported by anti-ransomware for databases.
        self.uni_support_region = uni_support_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uni_support_region is not None:
            result['UniSupportRegion'] = self.uni_support_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UniSupportRegion') is not None:
            self.uni_support_region = m.get('UniSupportRegion')
        return self


class DescribeUniSupportRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUniSupportRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniSupportRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBackupMachinesResponseBodyMachines(TeaModel):
    def __init__(
        self,
        id: int = None,
        policy_name: str = None,
        uuid: str = None,
    ):
        self.id = id
        self.policy_name = policy_name
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeUserBackupMachinesResponseBody(TeaModel):
    def __init__(
        self,
        machines: List[DescribeUserBackupMachinesResponseBodyMachines] = None,
        request_id: str = None,
    ):
        self.machines = machines
        self.request_id = request_id

    def validate(self):
        if self.machines:
            for k in self.machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Machines'] = []
        if self.machines is not None:
            for k in self.machines:
                result['Machines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.machines = []
        if m.get('Machines') is not None:
            for k in m.get('Machines'):
                temp_model = DescribeUserBackupMachinesResponseBodyMachines()
                self.machines.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserBackupMachinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserBackupMachinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBackupMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBaselineAuthorizationRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # ID
        self.resource_owner_id = resource_owner_id
        # The ID of the asset owner.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization(TeaModel):
    def __init__(
        self,
        status: int = None,
    ):
        # Indicates whether Security Center is authorized to run configuration checks on cloud services.
        # 
        # *   **0**: no. Security Center is not authorized to run configuration checks on cloud services.
        # *   **1**: yes. Security Center is authorized to run configuration checks on cloud services.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeUserBaselineAuthorizationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_baseline_authorization: DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The information about whether Security Center is authorized to run configuration checks on cloud services.
        self.user_baseline_authorization = user_baseline_authorization

    def validate(self):
        if self.user_baseline_authorization:
            self.user_baseline_authorization.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_baseline_authorization is not None:
            result['UserBaselineAuthorization'] = self.user_baseline_authorization.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserBaselineAuthorization') is not None:
            temp_model = DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization()
            self.user_baseline_authorization = temp_model.from_map(m['UserBaselineAuthorization'])
        return self


class DescribeUserBaselineAuthorizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserBaselineAuthorizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBaselineAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserLayoutAuthorizationRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
    ):
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeUserLayoutAuthorizationResponseBody(TeaModel):
    def __init__(
        self,
        authorized: bool = None,
        request_id: str = None,
    ):
        self.authorized = authorized
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserLayoutAuthorizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserLayoutAuthorizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserLayoutAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUuidsByVulNamesRequest(TeaModel):
    def __init__(
        self,
        dealed: str = None,
        field_name: str = None,
        field_value: str = None,
        group_id: int = None,
        lang: str = None,
        level: str = None,
        necessity: str = None,
        remark: str = None,
        search_tags: str = None,
        status_list: str = None,
        tag: str = None,
        target_type: str = None,
        type: str = None,
        vpc_instance_ids: str = None,
        vul_names: List[str] = None,
    ):
        # Specifies whether the vulnerability is handled. Valid values:
        # 
        # **y**: The vulnerability is handled. **n**: The vulnerability is not handled.
        self.dealed = dealed
        # The name of the search field that is used to query containers.
        self.field_name = field_name
        # The value of the search field that is used to query containers.
        self.field_value = field_value
        # The ID of the asset group.
        self.group_id = group_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The severity of the vulnerability. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.level = level
        # The priority based on which the vulnerability is fixed. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity
        # The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset. Fuzzy match is supported.
        self.remark = remark
        # The tags that are used to search for the vulnerability.
        self.search_tags = search_tags
        # The status of the vulnerability. Separate multiple states with commas (,). Valid values:
        # 
        # *   **1**: unfixed
        # *   **4**: being fixed
        # *   **7**: fixed
        self.status_list = status_list
        # The tag of the vulnerability.
        self.tag = tag
        # The type of the query condition. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the ID of the asset
        self.target_type = target_type
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        # *   **sca**: vulnerability that is detected based on software component analysis
        self.type = type
        # The ID of the virtual private cloud (VPC) in which the vulnerability is detected. Separate multiple IDs with commas (,).
        self.vpc_instance_ids = vpc_instance_ids
        # An array that consists of the names of vulnerabilities.
        # 
        # >  You can call the [DescribeGroupedVul](~~DescribeGroupedVul~~) operation to obtain the names of vulnerabilities.
        self.vul_names = vul_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        if self.vul_names is not None:
            result['VulNames'] = self.vul_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        if m.get('VulNames') is not None:
            self.vul_names = m.get('VulNames')
        return self


class DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics(TeaModel):
    def __init__(
        self,
        machine_instance_id: str = None,
        machine_ip: str = None,
        machine_name: str = None,
        os: str = None,
        region_id: str = None,
        uuid: str = None,
    ):
        # The ID of the server.
        self.machine_instance_id = machine_instance_id
        # The IP address of the server.
        self.machine_ip = machine_ip
        # The name of the server.
        self.machine_name = machine_name
        # The name of the operating system that the server runs.
        self.os = os
        # The ID of the region in which the server resides.
        self.region_id = region_id
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_instance_id is not None:
            result['MachineInstanceId'] = self.machine_instance_id
        if self.machine_ip is not None:
            result['MachineIp'] = self.machine_ip
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineInstanceId') is not None:
            self.machine_instance_id = m.get('MachineInstanceId')
        if m.get('MachineIp') is not None:
            self.machine_ip = m.get('MachineIp')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeUuidsByVulNamesResponseBody(TeaModel):
    def __init__(
        self,
        machine_info_statistics: List[DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics] = None,
        request_id: str = None,
    ):
        # An array that consists of the statistics about the assets.
        self.machine_info_statistics = machine_info_statistics
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.machine_info_statistics:
            for k in self.machine_info_statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MachineInfoStatistics'] = []
        if self.machine_info_statistics is not None:
            for k in self.machine_info_statistics:
                result['MachineInfoStatistics'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.machine_info_statistics = []
        if m.get('MachineInfoStatistics') is not None:
            for k in m.get('MachineInfoStatistics'):
                temp_model = DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics()
                self.machine_info_statistics.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUuidsByVulNamesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUuidsByVulNamesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUuidsByVulNamesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVendorListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_name_list: List[str] = None,
    ):
        self.request_id = request_id
        self.vendor_name_list = vendor_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vendor_name_list is not None:
            result['VendorNameList'] = self.vendor_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VendorNameList') is not None:
            self.vendor_name_list = m.get('VendorNameList')
        return self


class DescribeVendorListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVendorListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVendorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVersionConfigRequest(TeaModel):
    def __init__(
        self,
        resource_directory_account_id: str = None,
        source_ip: str = None,
    ):
        # The ID of the Alibaba Cloud account that uses Security Center.
        # 
        # > You can call the [GetUser](~~28681~~) operation to query the IDs of Alibaba Cloud accounts.
        self.resource_directory_account_id = resource_directory_account_id
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeVersionConfigResponseBody(TeaModel):
    def __init__(
        self,
        allow_partial_buy: int = None,
        app_white_list: int = None,
        app_white_list_auth_count: int = None,
        asset_level: int = None,
        highest_version: int = None,
        honeypot_capacity: int = None,
        image_scan_capacity: int = None,
        instance_id: str = None,
        is_new_container_version: bool = None,
        is_new_multi_version: bool = None,
        is_over_balance: bool = None,
        is_trial_version: int = None,
        last_trail_end_time: int = None,
        mvauth_count: int = None,
        mvunused_auth_count: int = None,
        open_time: int = None,
        release_time: int = None,
        request_id: str = None,
        sas_log: int = None,
        sas_screen: int = None,
        sls_capacity: int = None,
        threat_analysis_capacity: int = None,
        user_defined_alarms: int = None,
        version: int = None,
        vm_cores: int = None,
        web_lock: int = None,
        web_lock_auth_count: int = None,
    ):
        # Indicates whether the pay-as-you-go billing method is supported.
        # 
        # *   **0**: no
        # *   **1**: yes
        self.allow_partial_buy = allow_partial_buy
        # Indicates whether the application whitelist feature is enabled. Valid values:
        # 
        # *   **0**: no
        # *   **2**: yes
        self.app_white_list = app_white_list
        # The quota for the application whitelist feature.
        # 
        # > The quantity of servers that are allowed by the quota is deducted by one each time you apply an application whitelist to a server. After you enable the application whitelist feature, the quota is 20 by default.
        self.app_white_list_auth_count = app_white_list_auth_count
        # The quota for servers that can be protected.
        self.asset_level = asset_level
        # The most advanced edition that is used. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **3**: Enterprise edition
        # *   **5**: Advanced edition
        # *   **6**: Anti-virus edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        # 
        # > If you purchase the Multi-version edition of Security Center, the value indicates the most advanced edition that is used in the Multi-version edition. If you do not purchase the Multi-version edition of Security Center, the value indicates the edition of Security Center.
        self.highest_version = highest_version
        # The number of honeypots.
        self.honeypot_capacity = honeypot_capacity
        # The quota for the container image scan feature.
        self.image_scan_capacity = image_scan_capacity
        # The ID of purchased Security Center.
        self.instance_id = instance_id
        # Indicates whether Security Center runs the latest version of the Ultimate edition.
        # 
        # *   **true**: yes
        # *   **false**: no
        self.is_new_container_version = is_new_container_version
        # Indicates whether Security Center runs the latest version of the Multi-version edition.
        # 
        # *   **true**: yes
        # *   **false**: no
        self.is_new_multi_version = is_new_multi_version
        # Indicates whether the number of existing servers exceeds the purchased quota. Valid values:
        # 
        # *   **false**: no
        # *   **true**: yes
        self.is_over_balance = is_over_balance
        # Indicates whether Security Center runs the free trial edition. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_trial_version = is_trial_version
        # The timestamp when the last trial ends. Unit: milliseconds.
        self.last_trail_end_time = last_trail_end_time
        # The total quota in the Multi-version edition of purchased Security Center.
        self.mvauth_count = mvauth_count
        # The total remaining quota in the Multi-version edition of purchased Security Center.
        self.mvunused_auth_count = mvunused_auth_count
        # The timestamp when Security Center is purchased. Unit: milliseconds.
        self.open_time = open_time
        # The timestamp when Security Center is released. Unit: milliseconds. The value of this parameter is seven days after Security Center expires.
        # 
        # > If you do not renew the subscription within seven days after the expiration date, the Value-added Plan, Anti-virus, Advanced, or Enterprise edition is downgraded to the Basic edition. In this case, you can no longer view the existing configurations or statistics such as DDoS alerts. You must purchase the Anti-virus, Advanced, or Enterprise edition to continue using relevant features. For more information, see [Purchase Security Center](~~42308~~).
        self.release_time = release_time
        # The request ID.
        self.request_id = request_id
        # Indicates whether the log analysis feature is purchased. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.sas_log = sas_log
        # Indicates whether the security screen feature is purchased. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.sas_screen = sas_screen
        # The log storage capacity that you purchase. Unit: GB. Valid values: 0 to 200000.
        self.sls_capacity = sls_capacity
        # The purchased log storage capacity for threat analysis. Unit: GB.
        self.threat_analysis_capacity = threat_analysis_capacity
        # Indicates whether the custom alerting feature is enabled. Valid values:
        # 
        # *   **0**: no
        # *   **2**: yes
        self.user_defined_alarms = user_defined_alarms
        # The edition of purchased Security Center. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **3**: Enterprise edition
        # *   **5**: Advanced edition
        # *   **6**: Anti-virus edition
        # *   **7**: Ultimate edition
        # *   **8**: Multi-version edition
        # *   **10**: Value-added Plan edition
        self.version = version
        # The quota for the cores of servers that can be protected.
        self.vm_cores = vm_cores
        # Indicates whether the web tamper proofing feature is enabled. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.web_lock = web_lock
        # The quota for the web tamper proofing feature. The quantity of servers that are allowed by the quota is deducted by one each time you enable the web tamper proofing feature for a server. Valid values: 0 to N.
        # 
        # > N indicates the number of servers that you own.
        self.web_lock_auth_count = web_lock_auth_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_partial_buy is not None:
            result['AllowPartialBuy'] = self.allow_partial_buy
        if self.app_white_list is not None:
            result['AppWhiteList'] = self.app_white_list
        if self.app_white_list_auth_count is not None:
            result['AppWhiteListAuthCount'] = self.app_white_list_auth_count
        if self.asset_level is not None:
            result['AssetLevel'] = self.asset_level
        if self.highest_version is not None:
            result['HighestVersion'] = self.highest_version
        if self.honeypot_capacity is not None:
            result['HoneypotCapacity'] = self.honeypot_capacity
        if self.image_scan_capacity is not None:
            result['ImageScanCapacity'] = self.image_scan_capacity
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_new_container_version is not None:
            result['IsNewContainerVersion'] = self.is_new_container_version
        if self.is_new_multi_version is not None:
            result['IsNewMultiVersion'] = self.is_new_multi_version
        if self.is_over_balance is not None:
            result['IsOverBalance'] = self.is_over_balance
        if self.is_trial_version is not None:
            result['IsTrialVersion'] = self.is_trial_version
        if self.last_trail_end_time is not None:
            result['LastTrailEndTime'] = self.last_trail_end_time
        if self.mvauth_count is not None:
            result['MVAuthCount'] = self.mvauth_count
        if self.mvunused_auth_count is not None:
            result['MVUnusedAuthCount'] = self.mvunused_auth_count
        if self.open_time is not None:
            result['OpenTime'] = self.open_time
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sas_log is not None:
            result['SasLog'] = self.sas_log
        if self.sas_screen is not None:
            result['SasScreen'] = self.sas_screen
        if self.sls_capacity is not None:
            result['SlsCapacity'] = self.sls_capacity
        if self.threat_analysis_capacity is not None:
            result['ThreatAnalysisCapacity'] = self.threat_analysis_capacity
        if self.user_defined_alarms is not None:
            result['UserDefinedAlarms'] = self.user_defined_alarms
        if self.version is not None:
            result['Version'] = self.version
        if self.vm_cores is not None:
            result['VmCores'] = self.vm_cores
        if self.web_lock is not None:
            result['WebLock'] = self.web_lock
        if self.web_lock_auth_count is not None:
            result['WebLockAuthCount'] = self.web_lock_auth_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowPartialBuy') is not None:
            self.allow_partial_buy = m.get('AllowPartialBuy')
        if m.get('AppWhiteList') is not None:
            self.app_white_list = m.get('AppWhiteList')
        if m.get('AppWhiteListAuthCount') is not None:
            self.app_white_list_auth_count = m.get('AppWhiteListAuthCount')
        if m.get('AssetLevel') is not None:
            self.asset_level = m.get('AssetLevel')
        if m.get('HighestVersion') is not None:
            self.highest_version = m.get('HighestVersion')
        if m.get('HoneypotCapacity') is not None:
            self.honeypot_capacity = m.get('HoneypotCapacity')
        if m.get('ImageScanCapacity') is not None:
            self.image_scan_capacity = m.get('ImageScanCapacity')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsNewContainerVersion') is not None:
            self.is_new_container_version = m.get('IsNewContainerVersion')
        if m.get('IsNewMultiVersion') is not None:
            self.is_new_multi_version = m.get('IsNewMultiVersion')
        if m.get('IsOverBalance') is not None:
            self.is_over_balance = m.get('IsOverBalance')
        if m.get('IsTrialVersion') is not None:
            self.is_trial_version = m.get('IsTrialVersion')
        if m.get('LastTrailEndTime') is not None:
            self.last_trail_end_time = m.get('LastTrailEndTime')
        if m.get('MVAuthCount') is not None:
            self.mvauth_count = m.get('MVAuthCount')
        if m.get('MVUnusedAuthCount') is not None:
            self.mvunused_auth_count = m.get('MVUnusedAuthCount')
        if m.get('OpenTime') is not None:
            self.open_time = m.get('OpenTime')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SasLog') is not None:
            self.sas_log = m.get('SasLog')
        if m.get('SasScreen') is not None:
            self.sas_screen = m.get('SasScreen')
        if m.get('SlsCapacity') is not None:
            self.sls_capacity = m.get('SlsCapacity')
        if m.get('ThreatAnalysisCapacity') is not None:
            self.threat_analysis_capacity = m.get('ThreatAnalysisCapacity')
        if m.get('UserDefinedAlarms') is not None:
            self.user_defined_alarms = m.get('UserDefinedAlarms')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VmCores') is not None:
            self.vm_cores = m.get('VmCores')
        if m.get('WebLock') is not None:
            self.web_lock = m.get('WebLock')
        if m.get('WebLockAuthCount') is not None:
            self.web_lock_auth_count = m.get('WebLockAuthCount')
        return self


class DescribeVersionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVersionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVersionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcHoneyPotCriteriaRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.name = name
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeVpcHoneyPotCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        self.criteria_list = criteria_list
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVpcHoneyPotCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVpcHoneyPotCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcHoneyPotCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcHoneyPotListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        honey_pot_existence: bool = None,
        page_size: int = None,
        vpc_id: str = None,
        vpc_name: str = None,
        vpc_region_id: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # Specifies whether the cloud honeypot feature is enabled for the VPCs. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.honey_pot_existence = honey_pot_existence
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The ID of the VPC on which the honeypot is deployed.
        # 
        # > You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the IDs of VPCs.
        self.vpc_id = vpc_id
        # The name of the VPC.
        # 
        # > You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the names of VPCs.
        self.vpc_name = vpc_name
        # The region ID of the VPC.
        # 
        # > You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the region IDs of VPCs.
        self.vpc_region_id = vpc_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honey_pot_existence is not None:
            result['HoneyPotExistence'] = self.honey_pot_existence
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        if self.vpc_region_id is not None:
            result['VpcRegionId'] = self.vpc_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneyPotExistence') is not None:
            self.honey_pot_existence = m.get('HoneyPotExistence')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        if m.get('VpcRegionId') is not None:
            self.vpc_region_id = m.get('VpcRegionId')
        return self


class DescribeVpcHoneyPotListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList(TeaModel):
    def __init__(
        self,
        vpc_switch_id: str = None,
        vpc_switch_name: str = None,
        zone_id: str = None,
    ):
        # The ID of the vSwitch.
        self.vpc_switch_id = vpc_switch_id
        # The name of the vSwitch.
        self.vpc_switch_name = vpc_switch_name
        # The zone ID of the vSwitch.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_switch_id is not None:
            result['VpcSwitchId'] = self.vpc_switch_id
        if self.vpc_switch_name is not None:
            result['VpcSwitchName'] = self.vpc_switch_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VpcSwitchId') is not None:
            self.vpc_switch_id = m.get('VpcSwitchId')
        if m.get('VpcSwitchName') is not None:
            self.vpc_switch_name = m.get('VpcSwitchName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        create_time: int = None,
        honey_pot_ecs_instance_status: str = None,
        honey_pot_eni_instance_id: str = None,
        honey_pot_existence: bool = None,
        honey_pot_instance_status: str = None,
        honey_pot_vpc_switch_id: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
        vpc_region_id: str = None,
        vpc_status: str = None,
        vpc_switch_id_list: List[DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList] = None,
    ):
        # The CIDR block of the VPC.
        self.cidr_block = cidr_block
        # The time at which the VPC was created. Unit: milliseconds.
        self.create_time = create_time
        # The status of the server on which the honeypot is deployed. Valid values:
        # 
        # *   **Pending**: The server is being created.
        # *   **Running**: The server is running.
        # *   **Starting**: The server is being started.
        # *   **Stopping**: The server is being stopped.
        # *   **Stopped**: The server is stopped.
        self.honey_pot_ecs_instance_status = honey_pot_ecs_instance_status
        # The ID of the elastic network interface (ENI) used by the honeypot in the VPC.
        self.honey_pot_eni_instance_id = honey_pot_eni_instance_id
        # Indicates whether the cloud honeypot feature is enabled for the VPC. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.honey_pot_existence = honey_pot_existence
        # The status of the honeypot. Valid values:
        # 
        # *   **pending**: The honeypot is being created.
        # *   **deleting**: The honeypot is being deleted.
        # *   **off**: The honeypot is disabled.
        # *   **suspending**: The honeypot is suspended.
        # *   **on**: The honeypot is enabled.
        self.honey_pot_instance_status = honey_pot_instance_status
        # The ID of the vSwitch to which the ENI used by the honeypot is connected.
        self.honey_pot_vpc_switch_id = honey_pot_vpc_switch_id
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name
        # The region ID of the VPC.
        # 
        # > For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.vpc_region_id = vpc_region_id
        # The status of the VPC. Valid values:
        # 
        # *   **Available**: The VPC is normal and available.
        # *   **Pending**: The VPC is being configured.
        self.vpc_status = vpc_status
        # An array that consists of the vSwitches in the VPC.
        self.vpc_switch_id_list = vpc_switch_id_list

    def validate(self):
        if self.vpc_switch_id_list:
            for k in self.vpc_switch_id_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.honey_pot_ecs_instance_status is not None:
            result['HoneyPotEcsInstanceStatus'] = self.honey_pot_ecs_instance_status
        if self.honey_pot_eni_instance_id is not None:
            result['HoneyPotEniInstanceId'] = self.honey_pot_eni_instance_id
        if self.honey_pot_existence is not None:
            result['HoneyPotExistence'] = self.honey_pot_existence
        if self.honey_pot_instance_status is not None:
            result['HoneyPotInstanceStatus'] = self.honey_pot_instance_status
        if self.honey_pot_vpc_switch_id is not None:
            result['HoneyPotVpcSwitchId'] = self.honey_pot_vpc_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        if self.vpc_region_id is not None:
            result['VpcRegionId'] = self.vpc_region_id
        if self.vpc_status is not None:
            result['VpcStatus'] = self.vpc_status
        result['VpcSwitchIdList'] = []
        if self.vpc_switch_id_list is not None:
            for k in self.vpc_switch_id_list:
                result['VpcSwitchIdList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HoneyPotEcsInstanceStatus') is not None:
            self.honey_pot_ecs_instance_status = m.get('HoneyPotEcsInstanceStatus')
        if m.get('HoneyPotEniInstanceId') is not None:
            self.honey_pot_eni_instance_id = m.get('HoneyPotEniInstanceId')
        if m.get('HoneyPotExistence') is not None:
            self.honey_pot_existence = m.get('HoneyPotExistence')
        if m.get('HoneyPotInstanceStatus') is not None:
            self.honey_pot_instance_status = m.get('HoneyPotInstanceStatus')
        if m.get('HoneyPotVpcSwitchId') is not None:
            self.honey_pot_vpc_switch_id = m.get('HoneyPotVpcSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        if m.get('VpcRegionId') is not None:
            self.vpc_region_id = m.get('VpcRegionId')
        if m.get('VpcStatus') is not None:
            self.vpc_status = m.get('VpcStatus')
        self.vpc_switch_id_list = []
        if m.get('VpcSwitchIdList') is not None:
            for k in m.get('VpcSwitchIdList'):
                temp_model = DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList()
                self.vpc_switch_id_list.append(temp_model.from_map(k))
        return self


class DescribeVpcHoneyPotListResponseBody(TeaModel):
    def __init__(
        self,
        page_info: DescribeVpcHoneyPotListResponseBodyPageInfo = None,
        request_id: str = None,
        vpc_honey_pot_dtolist: List[DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList] = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # The ID of the request.
        self.request_id = request_id
        # An array that consists of the honeypots.
        self.vpc_honey_pot_dtolist = vpc_honey_pot_dtolist

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.vpc_honey_pot_dtolist:
            for k in self.vpc_honey_pot_dtolist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VpcHoneyPotDTOList'] = []
        if self.vpc_honey_pot_dtolist is not None:
            for k in self.vpc_honey_pot_dtolist:
                result['VpcHoneyPotDTOList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeVpcHoneyPotListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vpc_honey_pot_dtolist = []
        if m.get('VpcHoneyPotDTOList') is not None:
            for k in m.get('VpcHoneyPotDTOList'):
                temp_model = DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList()
                self.vpc_honey_pot_dtolist.append(temp_model.from_map(k))
        return self


class DescribeVpcHoneyPotListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVpcHoneyPotListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcHoneyPotListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcListResponseBodyVpcList(TeaModel):
    def __init__(
        self,
        ecs_count: int = None,
        instance_desc: str = None,
        instance_id: str = None,
        instance_name: str = None,
        region_id: str = None,
    ):
        self.ecs_count = ecs_count
        self.instance_desc = instance_desc
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_count is not None:
            result['EcsCount'] = self.ecs_count
        if self.instance_desc is not None:
            result['InstanceDesc'] = self.instance_desc
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EcsCount') is not None:
            self.ecs_count = m.get('EcsCount')
        if m.get('InstanceDesc') is not None:
            self.instance_desc = m.get('InstanceDesc')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeVpcListResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        request_id: str = None,
        vpc_list: List[DescribeVpcListResponseBodyVpcList] = None,
    ):
        # Queries the information about virtual private clouds (VPCs).
        self.count = count
        # DescribeVpcList
        self.request_id = request_id
        self.vpc_list = vpc_list

    def validate(self):
        if self.vpc_list:
            for k in self.vpc_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VpcList'] = []
        if self.vpc_list is not None:
            for k in self.vpc_list:
                result['VpcList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vpc_list = []
        if m.get('VpcList') is not None:
            for k in m.get('VpcList'):
                temp_model = DescribeVpcListResponseBodyVpcList()
                self.vpc_list.append(temp_model.from_map(k))
        return self


class DescribeVpcListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVpcListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulCheckTaskStatusDetailRequest(TeaModel):
    def __init__(
        self,
        task_ids: List[str] = None,
        types: List[str] = None,
        uuid: str = None,
    ):
        self.task_ids = task_ids
        self.types = types
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.types is not None:
            result['Types'] = self.types
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList(TeaModel):
    def __init__(
        self,
        code: str = None,
        status: str = None,
        type: str = None,
    ):
        self.code = code
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        task_status_list: List[DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList] = None,
    ):
        self.task_id = task_id
        self.task_status_list = task_status_list

    def validate(self):
        if self.task_status_list:
            for k in self.task_status_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        result['TaskStatusList'] = []
        if self.task_status_list is not None:
            for k in self.task_status_list:
                result['TaskStatusList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        self.task_status_list = []
        if m.get('TaskStatusList') is not None:
            for k in m.get('TaskStatusList'):
                temp_model = DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList()
                self.task_status_list.append(temp_model.from_map(k))
        return self


class DescribeVulCheckTaskStatusDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_statuses: List[DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses] = None,
        total_count: int = None,
    ):
        self.request_id = request_id
        self.task_statuses = task_statuses
        self.total_count = total_count

    def validate(self):
        if self.task_statuses:
            for k in self.task_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TaskStatuses'] = []
        if self.task_statuses is not None:
            for k in self.task_statuses:
                result['TaskStatuses'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task_statuses = []
        if m.get('TaskStatuses') is not None:
            for k in m.get('TaskStatuses'):
                temp_model = DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses()
                self.task_statuses.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulCheckTaskStatusDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulCheckTaskStatusDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulCheckTaskStatusDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulConfigRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        type: str = None,
    ):
        # The source IP address of the request.
        self.source_ip = source_ip
        # The type of configuration. By default, all types of configurations are queried. Valid values:
        # 
        # *   **cve**: Linux software vulnerability.
        # *   **sys**: Windows system vulnerability.
        # *   **cms**: Web-CMS vulnerability.
        # *   **app**: application vulnerability that is detected by using web scanner.
        # *   **emg**: urgent vulnerability.
        # *   **scanMode**: displays easily exploitable vulnerability.
        # *   **imageVulClean**: vulnerability retention duration.
        # *   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulConfigResponseBodyTargetConfigs(TeaModel):
    def __init__(
        self,
        config: str = None,
        over_all_config: str = None,
        type: str = None,
    ):
        # The configuration of vulnerability scan.
        # 
        # > Valid values when you set the Type parameter to **cve**, **sys**, **cms**, **app**, **emg**, or **yum**:
        # 
        # *   **on**: enabled
        # 
        # *   **off**: disabled
        # 
        # Valid values when you set the Type parameter to **scanMode**:
        # 
        # *   **real**: displays easily exploitable vulnerability.
        # 
        # *   **all**: displays all vulnerabilities.
        # 
        # When you set the Type parameter to **imageVulClean**, the value of this parameter indicates the vulnerability retention period in days.
        self.config = config
        # Indicates whether the vulnerability management feature is enabled for all servers. Valid values:
        # 
        # *   **off**: disabled
        # *   **on**: enabled
        self.over_all_config = over_all_config
        # The type of configuration. Valid values:
        # 
        # *   **cve**: Linux software vulnerability.
        # *   **sys**: Windows system vulnerability.
        # *   **cms**: Web-CMS vulnerability.
        # *   **app**: application vulnerability that is detected by using web scanner.
        # *   **emg**: urgent vulnerability.
        # *   **scanMode**: displays easily exploitable vulnerability.
        # *   **imageVulClean**: vulnerability retention duration.
        # *   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.over_all_config is not None:
            result['OverAllConfig'] = self.over_all_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('OverAllConfig') is not None:
            self.over_all_config = m.get('OverAllConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        target_configs: List[DescribeVulConfigResponseBodyTargetConfigs] = None,
        total_count: int = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array that consists of the configurations of vulnerability management.
        self.target_configs = target_configs
        # The total number of configurations.
        self.total_count = total_count

    def validate(self):
        if self.target_configs:
            for k in self.target_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetConfigs'] = []
        if self.target_configs is not None:
            for k in self.target_configs:
                result['TargetConfigs'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_configs = []
        if m.get('TargetConfigs') is not None:
            for k in m.get('TargetConfigs'):
                temp_model = DescribeVulConfigResponseBodyTargetConfigs()
                self.target_configs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulDetailsRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        lang: str = None,
        name: str = None,
        type: str = None,
    ):
        self.alias_name = alias_name
        self.lang = lang
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulDetailsResponseBodyCvesClassifys(TeaModel):
    def __init__(
        self,
        classify: str = None,
        demo_video_url: str = None,
        description: str = None,
    ):
        self.classify = classify
        self.demo_video_url = demo_video_url
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.demo_video_url is not None:
            result['DemoVideoUrl'] = self.demo_video_url
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('DemoVideoUrl') is not None:
            self.demo_video_url = m.get('DemoVideoUrl')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class DescribeVulDetailsResponseBodyCves(TeaModel):
    def __init__(
        self,
        classify: str = None,
        classifys: List[DescribeVulDetailsResponseBodyCvesClassifys] = None,
        cnvd_id: str = None,
        complexity: str = None,
        content: str = None,
        cve_id: str = None,
        cvss_score: str = None,
        cvss_vector: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        poc: str = None,
        poc_create_time: int = None,
        poc_disclosure_time: int = None,
        product: str = None,
        reference: str = None,
        release_time: int = None,
        solution: str = None,
        summary: str = None,
        target_id: str = None,
        target_name: str = None,
        title: str = None,
        vendor: str = None,
        vul_level: str = None,
    ):
        self.classify = classify
        self.classifys = classifys
        self.cnvd_id = cnvd_id
        self.complexity = complexity
        self.content = content
        self.cve_id = cve_id
        self.cvss_score = cvss_score
        self.cvss_vector = cvss_vector
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.poc = poc
        self.poc_create_time = poc_create_time
        self.poc_disclosure_time = poc_disclosure_time
        self.product = product
        self.reference = reference
        self.release_time = release_time
        self.solution = solution
        self.summary = summary
        self.target_id = target_id
        self.target_name = target_name
        self.title = title
        self.vendor = vendor
        self.vul_level = vul_level

    def validate(self):
        if self.classifys:
            for k in self.classifys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['Classifys'] = []
        if self.classifys is not None:
            for k in self.classifys:
                result['Classifys'].append(k.to_map() if k else None)
        if self.cnvd_id is not None:
            result['CnvdId'] = self.cnvd_id
        if self.complexity is not None:
            result['Complexity'] = self.complexity
        if self.content is not None:
            result['Content'] = self.content
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.cvss_score is not None:
            result['CvssScore'] = self.cvss_score
        if self.cvss_vector is not None:
            result['CvssVector'] = self.cvss_vector
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.poc is not None:
            result['Poc'] = self.poc
        if self.poc_create_time is not None:
            result['PocCreateTime'] = self.poc_create_time
        if self.poc_disclosure_time is not None:
            result['PocDisclosureTime'] = self.poc_disclosure_time
        if self.product is not None:
            result['Product'] = self.product
        if self.reference is not None:
            result['Reference'] = self.reference
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.title is not None:
            result['Title'] = self.title
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vul_level is not None:
            result['VulLevel'] = self.vul_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.classifys = []
        if m.get('Classifys') is not None:
            for k in m.get('Classifys'):
                temp_model = DescribeVulDetailsResponseBodyCvesClassifys()
                self.classifys.append(temp_model.from_map(k))
        if m.get('CnvdId') is not None:
            self.cnvd_id = m.get('CnvdId')
        if m.get('Complexity') is not None:
            self.complexity = m.get('Complexity')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('CvssScore') is not None:
            self.cvss_score = m.get('CvssScore')
        if m.get('CvssVector') is not None:
            self.cvss_vector = m.get('CvssVector')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Poc') is not None:
            self.poc = m.get('Poc')
        if m.get('PocCreateTime') is not None:
            self.poc_create_time = m.get('PocCreateTime')
        if m.get('PocDisclosureTime') is not None:
            self.poc_disclosure_time = m.get('PocDisclosureTime')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('Reference') is not None:
            self.reference = m.get('Reference')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VulLevel') is not None:
            self.vul_level = m.get('VulLevel')
        return self


class DescribeVulDetailsResponseBody(TeaModel):
    def __init__(
        self,
        cves: List[DescribeVulDetailsResponseBodyCves] = None,
        request_id: str = None,
    ):
        self.cves = cves
        self.request_id = request_id

    def validate(self):
        if self.cves:
            for k in self.cves:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cves'] = []
        if self.cves is not None:
            for k in self.cves:
                result['Cves'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cves = []
        if m.get('Cves') is not None:
            for k in m.get('Cves'):
                temp_model = DescribeVulDetailsResponseBodyCves()
                self.cves.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulExportInfoRequest(TeaModel):
    def __init__(
        self,
        export_id: int = None,
    ):
        # The ID of the task.
        self.export_id = export_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeVulExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        current_count: int = None,
        export_status: str = None,
        file_name: str = None,
        id: int = None,
        link: str = None,
        message: str = None,
        progress: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The number of exported entries.
        self.current_count = current_count
        # The status of the export task. Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **exporting**: The task is in progress.
        # *   **success**: The task is complete.
        self.export_status = export_status
        # The name of the exported Excel file.
        self.file_name = file_name
        # The ID of the task.
        self.id = id
        # The URL at which you can download the exported Excel file.
        self.link = link
        # The message that shows the results of the task. The value is fixed as **success**, which indicates that the task is complete.
        self.message = message
        # The progress percentage of the task.
        self.progress = progress
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of entries in the exported Excel file.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulFixStatisticsResponseBodyFixStat(TeaModel):
    def __init__(
        self,
        fixed_today_num: int = None,
        fixed_total_num: int = None,
        fixing_num: int = None,
        need_fix_num: int = None,
        type: str = None,
    ):
        self.fixed_today_num = fixed_today_num
        self.fixed_total_num = fixed_total_num
        self.fixing_num = fixing_num
        self.need_fix_num = need_fix_num
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_today_num is not None:
            result['FixedTodayNum'] = self.fixed_today_num
        if self.fixed_total_num is not None:
            result['FixedTotalNum'] = self.fixed_total_num
        if self.fixing_num is not None:
            result['FixingNum'] = self.fixing_num
        if self.need_fix_num is not None:
            result['NeedFixNum'] = self.need_fix_num
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedTodayNum') is not None:
            self.fixed_today_num = m.get('FixedTodayNum')
        if m.get('FixedTotalNum') is not None:
            self.fixed_total_num = m.get('FixedTotalNum')
        if m.get('FixingNum') is not None:
            self.fixing_num = m.get('FixingNum')
        if m.get('NeedFixNum') is not None:
            self.need_fix_num = m.get('NeedFixNum')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulFixStatisticsResponseBodyFixTotal(TeaModel):
    def __init__(
        self,
        fixed_today_num: int = None,
        fixed_total_num: int = None,
        fixing_num: int = None,
        need_fix_num: int = None,
    ):
        self.fixed_today_num = fixed_today_num
        self.fixed_total_num = fixed_total_num
        self.fixing_num = fixing_num
        self.need_fix_num = need_fix_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_today_num is not None:
            result['FixedTodayNum'] = self.fixed_today_num
        if self.fixed_total_num is not None:
            result['FixedTotalNum'] = self.fixed_total_num
        if self.fixing_num is not None:
            result['FixingNum'] = self.fixing_num
        if self.need_fix_num is not None:
            result['NeedFixNum'] = self.need_fix_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedTodayNum') is not None:
            self.fixed_today_num = m.get('FixedTodayNum')
        if m.get('FixedTotalNum') is not None:
            self.fixed_total_num = m.get('FixedTotalNum')
        if m.get('FixingNum') is not None:
            self.fixing_num = m.get('FixingNum')
        if m.get('NeedFixNum') is not None:
            self.need_fix_num = m.get('NeedFixNum')
        return self


class DescribeVulFixStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        fix_stat: List[DescribeVulFixStatisticsResponseBodyFixStat] = None,
        fix_total: DescribeVulFixStatisticsResponseBodyFixTotal = None,
        request_id: str = None,
    ):
        self.fix_stat = fix_stat
        self.fix_total = fix_total
        self.request_id = request_id

    def validate(self):
        if self.fix_stat:
            for k in self.fix_stat:
                if k:
                    k.validate()
        if self.fix_total:
            self.fix_total.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FixStat'] = []
        if self.fix_stat is not None:
            for k in self.fix_stat:
                result['FixStat'].append(k.to_map() if k else None)
        if self.fix_total is not None:
            result['FixTotal'] = self.fix_total.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fix_stat = []
        if m.get('FixStat') is not None:
            for k in m.get('FixStat'):
                temp_model = DescribeVulFixStatisticsResponseBodyFixStat()
                self.fix_stat.append(temp_model.from_map(k))
        if m.get('FixTotal') is not None:
            temp_model = DescribeVulFixStatisticsResponseBodyFixTotal()
            self.fix_total = temp_model.from_map(m['FixTotal'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulFixStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulFixStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulFixStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulListRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        attach_types: str = None,
        current_page: int = None,
        dealed: str = None,
        group_id: str = None,
        lang: str = None,
        name: str = None,
        necessity: str = None,
        page_size: int = None,
        remark: str = None,
        type: str = None,
        uuids: str = None,
        vpc_instance_ids: str = None,
    ):
        # The name of the vulnerability.
        self.alias_name = alias_name
        # The additional type of the vulnerabilities. You need to specify this parameter when you query application vulnerabilities. Set the value to **sca**. If you set **Type** to **app**, you must specify this parameter.
        # 
        # > If you set this parameter to **sca**, application vulnerabilities and the vulnerabilities that are detected based on software component analysis are queried. If you do not specify this parameter, only application vulnerabilities are queried.
        self.attach_types = attach_types
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # Specifies whether the vulnerabilities are fixed. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.dealed = dealed
        # The ID of the asset group.
        # 
        # > You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.
        self.group_id = group_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The alias of the vulnerability.
        self.name = name
        # The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset.
        self.remark = remark
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability that is detected by using web scanner
        # *   **emg**: urgent vulnerability
        # *   **sca**: application vulnerability that is detected by using software component analysis
        self.type = type
        # The UUIDs of the servers on which you want to query the vulnerabilities. Separate multiple UUIDs with commas (,).
        self.uuids = uuids
        # The IDs of the virtual private clouds (VPCs) in which the vulnerability is detected. Separate multiple IDs with commas (,).
        self.vpc_instance_ids = vpc_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity(TeaModel):
    def __init__(
        self,
        assets_factor: str = None,
        cvss_factor: str = None,
        enviroment_factor: str = None,
        is_calc: str = None,
        status: str = None,
        time_factor: str = None,
        total_score: str = None,
    ):
        # The asset importance score. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.assets_factor = assets_factor
        # The Common Vulnerability Scoring System (CVSS) score.
        self.cvss_factor = cvss_factor
        # The environment score.
        self.enviroment_factor = enviroment_factor
        # Indicates whether the score of urgency to fix a vulnerability is calculated. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_calc = is_calc
        # The status of the score of urgency to fix a vulnerability. Valid values:
        # 
        # *   **none**: No score is generated.
        # *   **pending**: The score is pending calculation.
        # *   **normal**: The calculation is normal.
        self.status = status
        # The time score.
        self.time_factor = time_factor
        # The score of urgency to fix a vulnerability.
        # 
        # The following list describes scores and related fixing suggestions:
        # 
        # *   If the score is from **13.5 to 15**, the vulnerability is a high-risk vulnerability. You must fix the vulnerability at the earliest opportunity.
        # *   If the score is **greater than or equal to 7 but less than 13.5**, the vulnerability is a medium-risk vulnerability. You can fix the vulnerability at your convenience.
        # *   If the score is **less than 7**, the vulnerability is a low-risk vulnerability. You can ignore the vulnerability.
        self.total_score = total_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_factor is not None:
            result['Assets_factor'] = self.assets_factor
        if self.cvss_factor is not None:
            result['Cvss_factor'] = self.cvss_factor
        if self.enviroment_factor is not None:
            result['Enviroment_factor'] = self.enviroment_factor
        if self.is_calc is not None:
            result['Is_calc'] = self.is_calc
        if self.status is not None:
            result['Status'] = self.status
        if self.time_factor is not None:
            result['Time_factor'] = self.time_factor
        if self.total_score is not None:
            result['Total_score'] = self.total_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assets_factor') is not None:
            self.assets_factor = m.get('Assets_factor')
        if m.get('Cvss_factor') is not None:
            self.cvss_factor = m.get('Cvss_factor')
        if m.get('Enviroment_factor') is not None:
            self.enviroment_factor = m.get('Enviroment_factor')
        if m.get('Is_calc') is not None:
            self.is_calc = m.get('Is_calc')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Time_factor') is not None:
            self.time_factor = m.get('Time_factor')
        if m.get('Total_score') is not None:
            self.total_score = m.get('Total_score')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(TeaModel):
    def __init__(
        self,
        container_name: str = None,
        full_version: str = None,
        image_name: str = None,
        match_detail: str = None,
        match_list: List[str] = None,
        name: str = None,
        path: str = None,
        pid: str = None,
        update_cmd: str = None,
        version: str = None,
    ):
        # The name of the container.
        self.container_name = container_name
        # The complete version number.
        self.full_version = full_version
        # The name of the image.
        self.image_name = image_name
        # The reason why the vulnerability is detected.
        self.match_detail = match_detail
        # The rule that is used to detect the vulnerability.
        self.match_list = match_list
        # The name of the RPM package.
        self.name = name
        # The path of the software that has the vulnerability.
        self.path = path
        # The process ID.
        self.pid = pid
        # The command that is used to fix the vulnerability.
        self.update_cmd = update_cmd
        # The package version number of the software that has the vulnerability.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.full_version is not None:
            result['FullVersion'] = self.full_version
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.match_detail is not None:
            result['MatchDetail'] = self.match_detail
        if self.match_list is not None:
            result['MatchList'] = self.match_list
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.update_cmd is not None:
            result['UpdateCmd'] = self.update_cmd
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('FullVersion') is not None:
            self.full_version = m.get('FullVersion')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('MatchDetail') is not None:
            self.match_detail = m.get('MatchDetail')
        if m.get('MatchList') is not None:
            self.match_list = m.get('MatchList')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('UpdateCmd') is not None:
            self.update_cmd = m.get('UpdateCmd')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJson(TeaModel):
    def __init__(
        self,
        absolute_path: str = None,
        alias_name: str = None,
        description: str = None,
        ip: str = None,
        last_ts: int = None,
        necessity: DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity = None,
        os: str = None,
        os_release: str = None,
        primary_id: int = None,
        rpm_entity_list: List[DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList] = None,
        status: str = None,
        tag: str = None,
        cve_list: List[str] = None,
    ):
        # The package path of the software that has the vulnerability.
        self.absolute_path = absolute_path
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The description of the vulnerability.
        self.description = description
        # The public IP address of the asset that is associated with the vulnerability.
        self.ip = ip
        # The timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.last_ts = last_ts
        # Indicates whether the vulnerability needs to be fixed.
        self.necessity = necessity
        # The name of the operating system.
        self.os = os
        # The release of the operating system.
        self.os_release = os_release
        # The ID of the vulnerability.
        self.primary_id = primary_id
        # The RPM Package Manager (RPM) packages.
        self.rpm_entity_list = rpm_entity_list
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **2**: fix failed
        # *   3: rollback failed
        # *   **4**: fixing
        # *   **5**: being rolled back
        # *   **6**: being verified
        # *   **7**: fixed
        # *   **8**: fixed and to be restarted
        # *   **9**: rolled back
        # *   **10**: ignored
        # *   **11**: rolled back and to be restarted
        # *   **12**: not found
        # *   **20**: expired
        self.status = status
        # The tag that is added to the vulnerability.
        self.tag = tag
        # The CVE list.
        self.cve_list = cve_list

    def validate(self):
        if self.necessity:
            self.necessity.validate()
        if self.rpm_entity_list:
            for k in self.rpm_entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.absolute_path is not None:
            result['AbsolutePath'] = self.absolute_path
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.description is not None:
            result['Description'] = self.description
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.necessity is not None:
            result['Necessity'] = self.necessity.to_map()
        if self.os is not None:
            result['Os'] = self.os
        if self.os_release is not None:
            result['OsRelease'] = self.os_release
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        result['RpmEntityList'] = []
        if self.rpm_entity_list is not None:
            for k in self.rpm_entity_list:
                result['RpmEntityList'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.cve_list is not None:
            result['cveList'] = self.cve_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbsolutePath') is not None:
            self.absolute_path = m.get('AbsolutePath')
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('Necessity') is not None:
            temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity()
            self.necessity = temp_model.from_map(m['Necessity'])
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsRelease') is not None:
            self.os_release = m.get('OsRelease')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        self.rpm_entity_list = []
        if m.get('RpmEntityList') is not None:
            for k in m.get('RpmEntityList'):
                temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList()
                self.rpm_entity_list.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('cveList') is not None:
            self.cve_list = m.get('cveList')
        return self


class DescribeVulListResponseBodyVulRecords(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        auth_version: str = None,
        bind: bool = None,
        extend_content_json: DescribeVulListResponseBodyVulRecordsExtendContentJson = None,
        first_ts: int = None,
        group_id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        last_ts: int = None,
        modify_ts: int = None,
        name: str = None,
        necessity: str = None,
        online: bool = None,
        os_name: str = None,
        os_version: str = None,
        primary_id: int = None,
        rasp_defend: int = None,
        rasp_status: int = None,
        region_id: str = None,
        related: str = None,
        repair_ts: int = None,
        result_code: str = None,
        result_message: str = None,
        status: int = None,
        tag: str = None,
        type: str = None,
        uuid: str = None,
    ):
        # The name of the vulnerability.
        self.alias_name = alias_name
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind
        # The extended information about the vulnerability.
        self.extend_content_json = extend_content_json
        # The timestamp when the vulnerability was first detected. Unit: milliseconds.
        self.first_ts = first_ts
        # The ID of the asset group.
        self.group_id = group_id
        # The instance ID of the asset.
        self.instance_id = instance_id
        # The name of the asset.
        self.instance_name = instance_name
        # The public IP address of the asset.
        self.internet_ip = internet_ip
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip
        # The timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.last_ts = last_ts
        # The timestamp when the vulnerability status was modified. Unit: milliseconds.
        self.modify_ts = modify_ts
        # The name of the vulnerability.
        self.name = name
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        # 
        # > We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.
        self.necessity = necessity
        # Indicates whether the Security Center agent on the asset is online. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.online = online
        # The name of the operating system for your asset.
        self.os_name = os_name
        # The name of the operating system for your asset.
        self.os_version = os_version
        # The ID of the vulnerability.
        self.primary_id = primary_id
        self.rasp_defend = rasp_defend
        self.rasp_status = rasp_status
        # The ID of the region in which the server resides.
        self.region_id = region_id
        # The Common Vulnerabilities and Exposures (CVE) IDs related to the vulnerability. Multiple CVE IDs are separated by commas (,).
        self.related = related
        # The timestamp when the vulnerability was fixed. Unit: milliseconds.
        self.repair_ts = repair_ts
        # The code that indicates the vulnerability fixing result.
        self.result_code = result_code
        # The message that indicates the vulnerability fixing result.
        self.result_message = result_message
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **2**: fix failed
        # *   **3**: rollback failed
        # *   **4**: fixing
        # *   **5**: being rolled back
        # *   **6**: being verified
        # *   **7**: fixed
        # *   **8**: fixed and to be restarted
        # *   **9**: rolled back
        # *   **10**: ignored
        # *   **11**: rolled back and to be restarted
        # *   **12**: not found
        # *   **20**: expired
        self.status = status
        # The tag that is added to the vulnerability.
        self.tag = tag
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **emg**: urgent vulnerability
        # *   **app**: application vulnerability
        # *   **sca**: application vulnerability that is detected by using software component analysis
        self.type = type
        # The UUID of the asset.
        self.uuid = uuid

    def validate(self):
        if self.extend_content_json:
            self.extend_content_json.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.extend_content_json is not None:
            result['ExtendContentJson'] = self.extend_content_json.to_map()
        if self.first_ts is not None:
            result['FirstTs'] = self.first_ts
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.modify_ts is not None:
            result['ModifyTs'] = self.modify_ts
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.online is not None:
            result['Online'] = self.online
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        if self.rasp_defend is not None:
            result['RaspDefend'] = self.rasp_defend
        if self.rasp_status is not None:
            result['RaspStatus'] = self.rasp_status
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.related is not None:
            result['Related'] = self.related
        if self.repair_ts is not None:
            result['RepairTs'] = self.repair_ts
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.result_message is not None:
            result['ResultMessage'] = self.result_message
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ExtendContentJson') is not None:
            temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJson()
            self.extend_content_json = temp_model.from_map(m['ExtendContentJson'])
        if m.get('FirstTs') is not None:
            self.first_ts = m.get('FirstTs')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('ModifyTs') is not None:
            self.modify_ts = m.get('ModifyTs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        if m.get('RaspDefend') is not None:
            self.rasp_defend = m.get('RaspDefend')
        if m.get('RaspStatus') is not None:
            self.rasp_status = m.get('RaspStatus')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Related') is not None:
            self.related = m.get('Related')
        if m.get('RepairTs') is not None:
            self.repair_ts = m.get('RepairTs')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('ResultMessage') is not None:
            self.result_message = m.get('ResultMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        vul_records: List[DescribeVulListResponseBodyVulRecords] = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of vulnerabilities returned.
        self.total_count = total_count
        # An array that consists of the details about the vulnerability.
        self.vul_records = vul_records

    def validate(self):
        if self.vul_records:
            for k in self.vul_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulRecords'] = []
        if self.vul_records is not None:
            for k in self.vul_records:
                result['VulRecords'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_records = []
        if m.get('VulRecords') is not None:
            for k in m.get('VulRecords'):
                temp_model = DescribeVulListResponseBodyVulRecords()
                self.vul_records.append(temp_model.from_map(k))
        return self


class DescribeVulListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulListPageRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        cve_id: str = None,
        page_size: int = None,
        vul_name_like: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.
        self.cve_id = cve_id
        # The number of entries to return on each page.
        self.page_size = page_size
        # The name of the vulnerability.
        self.vul_name_like = vul_name_like

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vul_name_like is not None:
            result['VulNameLike'] = self.vul_name_like
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VulNameLike') is not None:
            self.vul_name_like = m.get('VulNameLike')
        return self


class DescribeVulListPageResponseBodyData(TeaModel):
    def __init__(
        self,
        cve_id: str = None,
        ext_aegis: str = None,
        id: int = None,
        is_aegis: int = None,
        is_sas: int = None,
        other_id: str = None,
        release_time: int = None,
        title: str = None,
    ):
        # The CVE ID of the vulnerability.
        self.cve_id = cve_id
        # The extended field for Server Guard.
        self.ext_aegis = ext_aegis
        # The primary key ID of the database.
        self.id = id
        # Indicates whether the vulnerability was detected based on version comparison. Valid values:
        # 
        # *   1: The vulnerability was detected based on version comparison.
        # *   0: The vulnerability was not detected based on version comparison.
        self.is_aegis = is_aegis
        # Indicates whether the vulnerability was detected based on proof of concept (POC) verification. Valid values:
        # 
        # *   1: The vulnerability was detected based on POC verification.
        # *   0: The vulnerability was not detected based on POC verification.
        self.is_sas = is_sas
        # The ID of the vulnerability.
        self.other_id = other_id
        # The time when the vulnerability was disclosed.
        self.release_time = release_time
        # The name of the vulnerability.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.ext_aegis is not None:
            result['ExtAegis'] = self.ext_aegis
        if self.id is not None:
            result['Id'] = self.id
        if self.is_aegis is not None:
            result['IsAegis'] = self.is_aegis
        if self.is_sas is not None:
            result['IsSas'] = self.is_sas
        if self.other_id is not None:
            result['OtherId'] = self.other_id
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('ExtAegis') is not None:
            self.ext_aegis = m.get('ExtAegis')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsAegis') is not None:
            self.is_aegis = m.get('IsAegis')
        if m.get('IsSas') is not None:
            self.is_sas = m.get('IsSas')
        if m.get('OtherId') is not None:
            self.other_id = m.get('OtherId')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeVulListPageResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeVulListPageResponseBodyData] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The response parameters.
        self.data = data
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeVulListPageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulListPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulListPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulListPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulNumStatisticsRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
    ):
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class DescribeVulNumStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        app_cnt: int = None,
        app_num: int = None,
        cms_dealed_total_num: int = None,
        cms_num: int = None,
        cve_num: int = None,
        emg_num: int = None,
        request_id: str = None,
        sca_num: int = None,
        sys_num: int = None,
        vul_asap_sum: int = None,
        vul_dealed_total_num: int = None,
        vul_later_sum: int = None,
        vul_nntf_sum: int = None,
    ):
        self.app_cnt = app_cnt
        self.app_num = app_num
        self.cms_dealed_total_num = cms_dealed_total_num
        self.cms_num = cms_num
        self.cve_num = cve_num
        self.emg_num = emg_num
        self.request_id = request_id
        self.sca_num = sca_num
        self.sys_num = sys_num
        self.vul_asap_sum = vul_asap_sum
        self.vul_dealed_total_num = vul_dealed_total_num
        self.vul_later_sum = vul_later_sum
        self.vul_nntf_sum = vul_nntf_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_cnt is not None:
            result['AppCnt'] = self.app_cnt
        if self.app_num is not None:
            result['AppNum'] = self.app_num
        if self.cms_dealed_total_num is not None:
            result['CmsDealedTotalNum'] = self.cms_dealed_total_num
        if self.cms_num is not None:
            result['CmsNum'] = self.cms_num
        if self.cve_num is not None:
            result['CveNum'] = self.cve_num
        if self.emg_num is not None:
            result['EmgNum'] = self.emg_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sca_num is not None:
            result['ScaNum'] = self.sca_num
        if self.sys_num is not None:
            result['SysNum'] = self.sys_num
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_dealed_total_num is not None:
            result['VulDealedTotalNum'] = self.vul_dealed_total_num
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppCnt') is not None:
            self.app_cnt = m.get('AppCnt')
        if m.get('AppNum') is not None:
            self.app_num = m.get('AppNum')
        if m.get('CmsDealedTotalNum') is not None:
            self.cms_dealed_total_num = m.get('CmsDealedTotalNum')
        if m.get('CmsNum') is not None:
            self.cms_num = m.get('CmsNum')
        if m.get('CveNum') is not None:
            self.cve_num = m.get('CveNum')
        if m.get('EmgNum') is not None:
            self.emg_num = m.get('EmgNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScaNum') is not None:
            self.sca_num = m.get('ScaNum')
        if m.get('SysNum') is not None:
            self.sys_num = m.get('SysNum')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulDealedTotalNum') is not None:
            self.vul_dealed_total_num = m.get('VulDealedTotalNum')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        return self


class DescribeVulNumStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulNumStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulNumStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulTargetConfigRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
        uuid: str = None,
    ):
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulTargetConfigResponseBodyTargetConfigs(TeaModel):
    def __init__(
        self,
        config: str = None,
        over_all_config: str = None,
        type: str = None,
    ):
        self.config = config
        self.over_all_config = over_all_config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.over_all_config is not None:
            result['OverAllConfig'] = self.over_all_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('OverAllConfig') is not None:
            self.over_all_config = m.get('OverAllConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulTargetConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        target_configs: List[DescribeVulTargetConfigResponseBodyTargetConfigs] = None,
        total_count: int = None,
    ):
        self.request_id = request_id
        self.target_configs = target_configs
        self.total_count = total_count

    def validate(self):
        if self.target_configs:
            for k in self.target_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetConfigs'] = []
        if self.target_configs is not None:
            for k in self.target_configs:
                result['TargetConfigs'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_configs = []
        if m.get('TargetConfigs') is not None:
            for k in m.get('TargetConfigs'):
                temp_model = DescribeVulTargetConfigResponseBodyTargetConfigs()
                self.target_configs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulTargetConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulTargetConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulTargetStatisticsRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        # The type of the vulnerabilities. Valid values:
        # 
        # *   **cve**: Linux software vulnerabilities
        # *   **sys**: Windows system vulnerabilities
        # *   **cms**: Web-CMS vulnerabilities
        # *   **emg**: urgent vulnerabilities
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulTargetStatisticsResponseBodyTargetStatsTargets(TeaModel):
    def __init__(
        self,
        flag: str = None,
        target: str = None,
        target_type: str = None,
    ):
        # Indicates whether the configurations are applied to the server. Valid values:
        # 
        # *   **add**: yes
        # *   **del**: no
        self.flag = flag
        # The group ID or UUID of the server to which the configurations are applied.
        self.target = target
        # The condition by which the configurations are applied to the server. Valid values:
        # 
        # *   **uuid**: the UUID of the server
        # *   **groupId**: the ID of the server group
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeVulTargetStatisticsResponseBodyTargetStats(TeaModel):
    def __init__(
        self,
        targets: List[DescribeVulTargetStatisticsResponseBodyTargetStatsTargets] = None,
        total_count: int = None,
        uuid_count: int = None,
        vul_type: str = None,
    ):
        # An array that consists of available servers.
        self.targets = targets
        # The total number of servers.
        self.total_count = total_count
        # The number of servers to which the configurations are applied.
        self.uuid_count = uuid_count
        # The type of the vulnerabilities. Valid values:
        # 
        # *   cve: Linux software vulnerabilities
        # *   sys: Windows system vulnerabilities
        # *   cms: Web-CMS vulnerabilities
        # *   emg: urgent vulnerabilities
        self.vul_type = vul_type

    def validate(self):
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.uuid_count is not None:
            result['UuidCount'] = self.uuid_count
        if self.vul_type is not None:
            result['VulType'] = self.vul_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = DescribeVulTargetStatisticsResponseBodyTargetStatsTargets()
                self.targets.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UuidCount') is not None:
            self.uuid_count = m.get('UuidCount')
        if m.get('VulType') is not None:
            self.vul_type = m.get('VulType')
        return self


class DescribeVulTargetStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        target_stats: List[DescribeVulTargetStatisticsResponseBodyTargetStats] = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # An array that consists of the configurations of the vulnerability scan feature.
        self.target_stats = target_stats
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.target_stats:
            for k in self.target_stats:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetStats'] = []
        if self.target_stats is not None:
            for k in self.target_stats:
                result['TargetStats'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_stats = []
        if m.get('TargetStats') is not None:
            for k in m.get('TargetStats'):
                temp_model = DescribeVulTargetStatisticsResponseBodyTargetStats()
                self.target_stats.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulTargetStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulTargetStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulTargetStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulWhitelistRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeVulWhitelistResponseBodyVulWhitelists(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        id: str = None,
        name: str = None,
        reason: str = None,
        target_info: str = None,
        type: str = None,
        whitelist: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The ID of the rule.
        self.id = id
        # The name of the vulnerability.
        self.name = name
        # The reason why the vulnerability is added to the whitelist.
        self.reason = reason
        # The application scope of the rule. The value is a JSON string that contains the following fields:
        # 
        # *   **type**: the type of the assets to which the rule is applied. Valid values:
        # 
        #     *   **Uuid**: server
        #     *   **GroupId**: server group
        # 
        # *   **groupIds**: the ID of the server group
        # 
        # *   **uuids**: the UUID of the server
        # 
        # > If this field is empty, the rule is applied to all assets.
        self.target_info = target_info
        # The type of the vulnerability.
        self.type = type
        # The information about the vulnerability. The value of this parameter is in the JSON format. Valid values:
        # 
        # *   **name**: the name of the vulnerability
        # *   **type**: the type of the vulnerability.
        # *   **aliasName**: the alias of the vulnerability
        self.whitelist = whitelist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class DescribeVulWhitelistResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        vul_whitelists: List[DescribeVulWhitelistResponseBodyVulWhitelists] = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count
        # An array that consists of information about the whitelist of vulnerabilities.
        self.vul_whitelists = vul_whitelists

    def validate(self):
        if self.vul_whitelists:
            for k in self.vul_whitelists:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulWhitelists'] = []
        if self.vul_whitelists is not None:
            for k in self.vul_whitelists:
                result['VulWhitelists'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_whitelists = []
        if m.get('VulWhitelists') is not None:
            for k in m.get('VulWhitelists'):
                temp_model = DescribeVulWhitelistResponseBodyVulWhitelists()
                self.vul_whitelists.append(temp_model.from_map(k))
        return self


class DescribeVulWhitelistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVulWhitelistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWarningExportInfoRequest(TeaModel):
    def __init__(
        self,
        export_id: int = None,
    ):
        # The name of the exported Excel file.
        self.export_id = export_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeWarningExportInfoResponseBody(TeaModel):
    def __init__(
        self,
        current_count: int = None,
        export_status: str = None,
        file_name: str = None,
        id: int = None,
        link: str = None,
        message: str = None,
        progress: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_count = current_count
        self.export_status = export_status
        self.file_name = file_name
        self.id = id
        # Queries the progress of a export task for a baseline check result.
        self.link = link
        self.message = message
        # DescribeWarningExportInfo
        self.progress = progress
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWarningExportInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWarningExportInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWarningExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWarningMachinesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: int = None,
        group_id: int = None,
        have_risk: int = None,
        lang: str = None,
        machine_name: str = None,
        page_size: int = None,
        risk_id: int = None,
        source_ip: str = None,
        strategy_id: int = None,
        target_type: str = None,
        uuids: str = None,
    ):
        # The type of the query condition. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the UUID of the asset
        self.cluster_id = cluster_id
        # The number of the page to return. Default value: **1**.
        self.container_field_name = container_field_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.container_field_value = container_field_value
        # The name of the server.
        self.current_page = current_page
        self.group_id = group_id
        # The number of **low-risk** items on the server.
        self.have_risk = have_risk
        # The private IP address of the server.
        self.lang = lang
        # The source IP address of the request.
        self.machine_name = machine_name
        # The number of **medium-risk** items on the server.
        self.page_size = page_size
        # The UUID of the server on which the baseline check is performed.
        self.risk_id = risk_id
        # The ID of the baseline check policy.
        self.source_ip = source_ip
        # The page number of the returned page.
        self.strategy_id = strategy_id
        # Specifies whether risks were detected. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.target_type = target_type
        # The ID of the server.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.have_risk is not None:
            result['HaveRisk'] = self.have_risk
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HaveRisk') is not None:
            self.have_risk = m.get('HaveRisk')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeWarningMachinesResponseBodyWarningMachines(TeaModel):
    def __init__(
        self,
        auth_version: int = None,
        bind: bool = None,
        container_id: str = None,
        container_name: str = None,
        high_warning_count: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        low_warning_count: int = None,
        medium_warning_count: int = None,
        pass_count: int = None,
        port_open: bool = None,
        region_id: str = None,
        status: int = None,
        uuid: str = None,
    ):
        self.auth_version = auth_version
        self.bind = bind
        self.container_id = container_id
        self.container_name = container_name
        # The public IP address of the server.
        self.high_warning_count = high_warning_count
        # The number of entries returned per page. Default value: **10**.
        self.instance_id = instance_id
        self.instance_name = instance_name
        # The UUID of the server on which the baseline check is performed. Separate multiple UUIDs with commas (,).
        self.internet_ip = internet_ip
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.intranet_ip = intranet_ip
        # Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
        self.low_warning_count = low_warning_count
        self.medium_warning_count = medium_warning_count
        self.pass_count = pass_count
        # DescribeWarningMachines
        self.port_open = port_open
        # The number of entries returned on the current page.
        self.region_id = region_id
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.status = status
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.port_open is not None:
            result['PortOpen'] = self.port_open
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('PortOpen') is not None:
            self.port_open = m.get('PortOpen')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWarningMachinesResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        warning_machines: List[DescribeWarningMachinesResponseBodyWarningMachines] = None,
    ):
        # The verification status of the risk item after the risk item is fixed. Valid values:
        # 
        # *   **1**: complete
        # *   **2**: verifying
        self.count = count
        # The name of the server on which the baseline check is performed.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # An array that consists of the servers.
        self.request_id = request_id
        # The value of the field that is used to search for the container.
        self.total_count = total_count
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.warning_machines = warning_machines

    def validate(self):
        if self.warning_machines:
            for k in self.warning_machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WarningMachines'] = []
        if self.warning_machines is not None:
            for k in self.warning_machines:
                result['WarningMachines'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.warning_machines = []
        if m.get('WarningMachines') is not None:
            for k in m.get('WarningMachines'):
                temp_model = DescribeWarningMachinesResponseBodyWarningMachines()
                self.warning_machines.append(temp_model.from_map(k))
        return self


class DescribeWarningMachinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWarningMachinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWarningMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockBindListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        remark: str = None,
        source_ip: str = None,
        status: str = None,
    ):
        # on
        self.current_page = current_page
        # The error code for web tamper proofing. Valid values:
        # 
        # *   **2001**: The Security Center agent is offline.
        # *   **9999**: The connection timed out.
        self.lang = lang
        # The error message for web tamper proofing. Valid values:
        # 
        # *   **client offline**: The Security Center agent is offline.
        # *   **timeout**: The connection timed out.
        self.page_size = page_size
        # The page number of the returned page. Pages start from page 1. Default value: 1.
        self.remark = remark
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.source_ip = source_ip
        # The name of the server.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeWebLockBindListResponseBodyBindList(TeaModel):
    def __init__(
        self,
        audit_count: str = None,
        block_count: str = None,
        dir_count: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        os: str = None,
        percent: int = None,
        service_code: str = None,
        service_detail: str = None,
        service_status: str = None,
        status: str = None,
        uuid: str = None,
    ):
        # The starting progress percentage of web tamper proofing. Valid values: 0 to 100.
        self.audit_count = audit_count
        # Queries the information about the servers that have web tamper proofing enabled.
        self.block_count = block_count
        # The information about the servers that have web tamper proofing enabled.
        self.dir_count = dir_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.instance_name = instance_name
        # The number of alerts.
        self.internet_ip = internet_ip
        # The number of blocked tampering events.
        self.intranet_ip = intranet_ip
        # 20
        self.os = os
        # The protection status of the server. Valid values:
        # 
        # *   **on**: protected
        # *   **off**: unprotected
        self.percent = percent
        # The number of entries returned per page. Default value: 20.
        self.service_code = service_code
        # The protection status of the server that you want to query. Valid values:
        # 
        # *   **on**: protected
        # *   **off**: unprotected
        self.service_detail = service_detail
        # 192.168.XX.XX
        self.service_status = service_status
        # The string that allows you to search for servers in fuzzy match mode. You can enter a server name or IP address.
        self.status = status
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_count is not None:
            result['AuditCount'] = self.audit_count
        if self.block_count is not None:
            result['BlockCount'] = self.block_count
        if self.dir_count is not None:
            result['DirCount'] = self.dir_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.os is not None:
            result['Os'] = self.os
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.service_code is not None:
            result['ServiceCode'] = self.service_code
        if self.service_detail is not None:
            result['ServiceDetail'] = self.service_detail
        if self.service_status is not None:
            result['ServiceStatus'] = self.service_status
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditCount') is not None:
            self.audit_count = m.get('AuditCount')
        if m.get('BlockCount') is not None:
            self.block_count = m.get('BlockCount')
        if m.get('DirCount') is not None:
            self.dir_count = m.get('DirCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('ServiceCode') is not None:
            self.service_code = m.get('ServiceCode')
        if m.get('ServiceDetail') is not None:
            self.service_detail = m.get('ServiceDetail')
        if m.get('ServiceStatus') is not None:
            self.service_status = m.get('ServiceStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockBindListResponseBody(TeaModel):
    def __init__(
        self,
        bind_list: List[DescribeWebLockBindListResponseBodyBindList] = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # 116.30.XX.XX
        self.bind_list = bind_list
        # The private IP address of the server.
        self.current_page = current_page
        # The number of protected directories.
        self.page_size = page_size
        # The operating system that the server runs.
        self.request_id = request_id
        # The information about the servers that have web tamper proofing enabled.
        self.total_count = total_count

    def validate(self):
        if self.bind_list:
            for k in self.bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BindList'] = []
        if self.bind_list is not None:
            for k in self.bind_list:
                result['BindList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bind_list = []
        if m.get('BindList') is not None:
            for k in m.get('BindList'):
                temp_model = DescribeWebLockBindListResponseBodyBindList()
                self.bind_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockBindListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockBindListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockBindListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockConfigListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        self.lang = lang
        self.source_ip = source_ip
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockConfigListResponseBodyConfigList(TeaModel):
    def __init__(
        self,
        defence_mode: str = None,
        dir: str = None,
        exclusive_dir: str = None,
        exclusive_file: str = None,
        exclusive_file_type: str = None,
        id: str = None,
        inclusive_file: str = None,
        inclusive_file_type: str = None,
        local_backup_dir: str = None,
        mode: str = None,
        uuid: str = None,
    ):
        self.defence_mode = defence_mode
        self.dir = dir
        self.exclusive_dir = exclusive_dir
        self.exclusive_file = exclusive_file
        self.exclusive_file_type = exclusive_file_type
        self.id = id
        self.inclusive_file = inclusive_file
        self.inclusive_file_type = inclusive_file_type
        self.local_backup_dir = local_backup_dir
        self.mode = mode
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockConfigListResponseBody(TeaModel):
    def __init__(
        self,
        config_list: List[DescribeWebLockConfigListResponseBodyConfigList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.config_list = config_list
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeWebLockConfigListResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockConfigListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockConfigListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockConfigListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockExclusiveFileTypeResponseBody(TeaModel):
    def __init__(
        self,
        exclusive_file_type: List[str] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # An array that consists of the types of the files that have web tamper proofing disabled.
        self.exclusive_file_type = exclusive_file_type
        # The ID of the request.
        self.request_id = request_id
        # The total number of types of the files that have web tamper proofing disabled.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockExclusiveFileTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockExclusiveFileTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockExclusiveFileTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileChangeStatisticsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeWebLockFileChangeStatisticsResponseBodyList(TeaModel):
    def __init__(
        self,
        count: int = None,
        file: str = None,
    ):
        self.count = count
        self.file = file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            self.file = m.get('File')
        return self


class DescribeWebLockFileChangeStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: List[DescribeWebLockFileChangeStatisticsResponseBodyList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.list = list
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileChangeStatisticsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileChangeStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockFileChangeStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileChangeStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileEventsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        dealed: str = None,
        page_size: int = None,
        process_name: str = None,
        remark: str = None,
        ts_begin: int = None,
        ts_end: int = None,
    ):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # Specifies whether the event on web tamper proofing is handled. Valid values:
        # 
        # *   **n**: The event on web tamper proofing is handled.
        # *   **y**: The event on web tamper proofing is not handled.
        self.dealed = dealed
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The name of the process.
        self.process_name = process_name
        # The name of the asset.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the names of assets.
        self.remark = remark
        # The beginning of the time range to query. The value is a UNIX timestamp.
        self.ts_begin = ts_begin
        # The end of the time range to query. The value is a UNIX timestamp.
        self.ts_end = ts_end

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.ts_begin is not None:
            result['TsBegin'] = self.ts_begin
        if self.ts_end is not None:
            result['TsEnd'] = self.ts_end
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TsBegin') is not None:
            self.ts_begin = m.get('TsBegin')
        if m.get('TsEnd') is not None:
            self.ts_end = m.get('TsEnd')
        return self


class DescribeWebLockFileEventsResponseBodyList(TeaModel):
    def __init__(
        self,
        count: int = None,
        ds: int = None,
        event_name: str = None,
        event_status: str = None,
        event_type: str = None,
        gmt_event: int = None,
        id: int = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        level: str = None,
        path: str = None,
        process_name: str = None,
        process_path: str = None,
        status: str = None,
        uuid: str = None,
    ):
        # The number of attempts.
        self.count = count
        # The timestamp at which the event on web tamper proofing was first detected.
        self.ds = ds
        # The name of the event on web tamper proofing.
        self.event_name = event_name
        # The status of the event on web tamper proofing. Valid values:
        # 
        # *   **1**: unhandled
        # *   **2**: ignored
        # *   **4**: deprecated
        # *   **8**: marked as false positive
        # *   **10**: added to the whitelist
        # *   **16**: handling
        # *   **32**: defended
        # *   **64**: invalid
        # *   **128**: deleted
        # *   **512**: automatically handled
        self.event_status = event_status
        # The prevention mode. Valid values:
        # 
        # *   **audit**: Interception Mode
        # *   **web_lock**: Alert Mode
        self.event_type = event_type
        # The timestamp at which the event on web tamper proofing was last detected.
        self.gmt_event = gmt_event
        # The ID of the event on web tamper proofing.
        self.id = id
        # The name of the asset.
        self.instance_name = instance_name
        # The public IP address of the affected asset.
        self.internet_ip = internet_ip
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip
        # The IP address of the asset.
        self.ip = ip
        # The severity of the event on web tamper proofing. Valid values: **medium**\
        self.level = level
        # The file path.
        self.path = path
        # The name of the process.
        self.process_name = process_name
        # The path to the process.
        self.process_path = process_path
        # The status of the event on web tamper proofing. Valid values:
        # 
        # *   **1**: unhandled
        # *   **2**: ignored
        # *   **4**: deprecated
        # *   **8**: marked as false positive
        # *   **10**: added to the whitelist
        # *   **16**: handling
        # *   **32**: defended
        # *   **64**: invalid
        # *   **128**: deleted
        # *   **512**: automatically handled
        self.status = status
        # The UUID of the asset.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.ds is not None:
            result['Ds'] = self.ds
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.gmt_event is not None:
            result['GmtEvent'] = self.gmt_event
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.level is not None:
            result['Level'] = self.level
        if self.path is not None:
            result['Path'] = self.path
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Ds') is not None:
            self.ds = m.get('Ds')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GmtEvent') is not None:
            self.gmt_event = m.get('GmtEvent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockFileEventsResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: List[DescribeWebLockFileEventsResponseBodyList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # An array that consists of events on web tamper proofing returned.
        self.list = list
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of events on web tamper proofing returned.
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileEventsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockFileEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileTypeSummaryResponseBodyList(TeaModel):
    def __init__(
        self,
        count: int = None,
        type: str = None,
    ):
        self.count = count
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeWebLockFileTypeSummaryResponseBody(TeaModel):
    def __init__(
        self,
        list: List[DescribeWebLockFileTypeSummaryResponseBodyList] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.list = list
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileTypeSummaryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileTypeSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockFileTypeSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileTypeSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockInclusiveFileTypeResponseBody(TeaModel):
    def __init__(
        self,
        inclusive_file_type: List[str] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.inclusive_file_type = inclusive_file_type
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockInclusiveFileTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockInclusiveFileTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockInclusiveFileTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockProcessBlockStatisticsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeWebLockProcessBlockStatisticsResponseBodyList(TeaModel):
    def __init__(
        self,
        count: int = None,
        process: str = None,
    ):
        # The number of processes on the current page.
        self.count = count
        # The process.
        self.process = process

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.process is not None:
            result['Process'] = self.process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Process') is not None:
            self.process = m.get('Process')
        return self


class DescribeWebLockProcessBlockStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: List[DescribeWebLockProcessBlockStatisticsResponseBodyList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # An array consisting of the statistics on processes.
        self.list = list
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of processes.
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockProcessBlockStatisticsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockProcessBlockStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockProcessBlockStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockProcessBlockStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockProcessListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        process_name: str = None,
        status: int = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The name of the process.
        self.process_name = process_name
        # Specifies whether the process is added to the process whitelist. Valid values:
        # 
        # *   **1**: The process is added to the process whitelist.
        # *   **0**: The process is not added to the process whitelist.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeWebLockProcessListResponseBodyList(TeaModel):
    def __init__(
        self,
        count: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        process_name: str = None,
        process_path: str = None,
        status: int = None,
        uuid: str = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The name of the server.
        self.instance_name = instance_name
        # The public IP address of the server.
        self.internet_ip = internet_ip
        # The private IP address of the server.
        self.intranet_ip = intranet_ip
        # The name of the process.
        self.process_name = process_name
        # The path to the process.
        self.process_path = process_path
        # Indicates whether the process is added to the process whitelist. Valid values:
        # 
        # *   **1**: The process is added to the process whitelist.
        # *   **0**: The process is not added to the process whitelist.
        self.status = status
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockProcessListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: List[DescribeWebLockProcessListResponseBodyList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # An array that consists of details about the process.
        self.list = list
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The total number of processes.
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockProcessListResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockProcessListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockProcessListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockProcessListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockStatusRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        self.from_ = from_
        self.lang = lang
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeWebLockStatusResponseBody(TeaModel):
    def __init__(
        self,
        auth_count: int = None,
        bind_count: int = None,
        block_count: int = None,
        dir_count: int = None,
        expire_time: int = None,
        request_id: str = None,
        white_count: int = None,
    ):
        self.auth_count = auth_count
        self.bind_count = bind_count
        self.block_count = block_count
        self.dir_count = dir_count
        self.expire_time = expire_time
        self.request_id = request_id
        self.white_count = white_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_count is not None:
            result['AuthCount'] = self.auth_count
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.block_count is not None:
            result['BlockCount'] = self.block_count
        if self.dir_count is not None:
            result['DirCount'] = self.dir_count
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.white_count is not None:
            result['WhiteCount'] = self.white_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthCount') is not None:
            self.auth_count = m.get('AuthCount')
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('BlockCount') is not None:
            self.block_count = m.get('BlockCount')
        if m.get('DirCount') is not None:
            self.dir_count = m.get('DirCount')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WhiteCount') is not None:
            self.white_count = m.get('WhiteCount')
        return self


class DescribeWebLockStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockTotalFileChangeCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        total_count: int = None,
    ):
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockTotalFileChangeCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebLockTotalFileChangeCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockTotalFileChangeCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebPathRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        type: str = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeWebPathResponseBodyConfigListTargetList(TeaModel):
    def __init__(
        self,
        target: str = None,
        target_type: str = None,
    ):
        self.target = target
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeWebPathResponseBodyConfigList(TeaModel):
    def __init__(
        self,
        target_list: List[DescribeWebPathResponseBodyConfigListTargetList] = None,
        web_path: str = None,
        web_path_type: str = None,
    ):
        self.target_list = target_list
        self.web_path = web_path
        self.web_path_type = web_path_type

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        if self.web_path_type is not None:
            result['WebPathType'] = self.web_path_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeWebPathResponseBodyConfigListTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        if m.get('WebPathType') is not None:
            self.web_path_type = m.get('WebPathType')
        return self


class DescribeWebPathResponseBody(TeaModel):
    def __init__(
        self,
        config_list: List[DescribeWebPathResponseBodyConfigList] = None,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.config_list = config_list
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeWebPathResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableBruteForceRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        id: int = None,
        port: str = None,
        resource_owner_id: int = None,
        uuid: str = None,
    ):
        # The IP address that you want to specify in the policy.
        self.block_ip = block_ip
        # The traffic direction that you want to specify in the policy. Valid values:
        # 
        # *   **in**: inbound
        # *   **out**: outbound
        self.bound = bound
        # The ID of the IP address blocking policy.
        # 
        # > You can call the [DescribeBruteForceRecords](~~DescribeBruteForceRecords~~) operation to query the policy ID.
        self.id = id
        # The port number.
        self.port = port
        self.resource_owner_id = resource_owner_id
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DisableBruteForceRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableBruteForceRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableBruteForceRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableBruteForceRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableCustomBlockRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        resource_owner_id: int = None,
    ):
        self.block_ip = block_ip
        self.bound = bound
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DisableCustomBlockRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableCustomBlockRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableCustomBlockRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableBruteForceRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        id: int = None,
        port: str = None,
        resource_owner_id: int = None,
        uuid: str = None,
    ):
        self.block_ip = block_ip
        self.bound = bound
        self.id = id
        self.port = port
        self.resource_owner_id = resource_owner_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class EnableBruteForceRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableBruteForceRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableBruteForceRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableBruteForceRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableCustomBlockRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        resource_owner_id: int = None,
    ):
        # The IP address that is specified in the policy.
        self.block_ip = block_ip
        # The traffic direction that is specified in the policy. Valid values:
        # 
        # *   **in**: inbound
        # *   **out**: outbound
        self.bound = bound
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class EnableCustomBlockRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableCustomBlockRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableCustomBlockRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: int = None,
    ):
        self.lang = lang
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class ExecStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExecStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportRecordRequest(TeaModel):
    def __init__(
        self,
        export_type: str = None,
        lang: str = None,
        params: str = None,
    ):
        self.export_type = export_type
        self.lang = lang
        self.params = params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.params is not None:
            result['Params'] = self.params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        return self


class ExportRecordResponseBody(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        id: int = None,
        request_id: str = None,
    ):
        self.file_name = file_name
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportSuspEventsRequest(TeaModel):
    def __init__(
        self,
        assets_type_list: List[str] = None,
        cluster_id: str = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: str = None,
        dealed: str = None,
        from_: str = None,
        lang: str = None,
        levels: str = None,
        name: str = None,
        page_size: str = None,
        parent_event_types: str = None,
        remark: str = None,
        source_ip: str = None,
        status: str = None,
        target_type: str = None,
        time_end: str = None,
        time_start: str = None,
    ):
        # The types of assets.
        self.assets_type_list = assets_type_list
        # The ID of the cluster that you want to query.
        # 
        # > You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.
        self.cluster_id = cluster_id
        # The key of the condition that is used to query alert events on containers. Valid values:
        # 
        # *   **instanceId**: the ID of the asset
        # *   **appName**: the name of the application
        # *   **clusterId**: the ID of the cluster
        # *   **regionId**: the ID of the region
        # *   **nodeName**: the name of the node
        # *   **namespace**: the namespace
        # *   **clusterName**: the name of the cluster
        # *   **image**: the name of the image
        # *   **imageRepoName**: the name of the image repository
        # *   **imageRepoNamespace**: the namespace to which the image repository belongs
        # *   **imageRepoTag**: the tag that is added to the image
        # *   **imageDigest**: the digest of the image
        self.container_field_name = container_field_name
        # The value of the condition that is used to query alert events on containers.
        self.container_field_value = container_field_value
        # The number of the page to return.
        self.current_page = current_page
        # The status of the alert event. Valid values:
        # 
        # *   **N**: unhandled
        # *   **Y**: handled
        self.dealed = dealed
        # The data source of the exception. Set the value to sas.
        self.from_ = from_
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The severity of the alert event. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.levels = levels
        # The complete name of the exception.
        self.name = name
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size
        # The alert type of the alert event. Valid values:
        # 
        # *   **Suspicious process**\
        # *   **Webshell**\
        # *   **Unusual logon**\
        # *   **Exception**\
        # *   **Sensitive file tampering**\
        # *   **Malicious process (cloud threat detection)**\
        # *   **Suspicious network connection**\
        # *   **Suspicious account**\
        # *   **Application intrusion event**\
        # *   **Cloud threat detection**\
        # *   **Precise defense**\
        # *   **Application whitelist**\
        # *   **Persistent webshell**\
        # *   **Web application threat detection**\
        # *   **Malicious script**\
        # *   **Threat intelligence**\
        # *   **Malicious network activity**\
        # *   **Cluster exception**\
        # *   **Webshell (on-premises threat detection)**\
        # *   **Vulnerability exploitation**\
        # *   **Malicious process (on-premises threat detection)**\
        # *   **Trusted exception**\
        # *   **Others**\
        self.parent_event_types = parent_event_types
        # The remarks.
        self.remark = remark
        # The source IP address of the request. The value of this parameter is specified by the system.
        self.source_ip = source_ip
        # The handling status of the exception. Valid values:
        # 
        # *   **0**: all status
        # *   **1**: pending handling
        # *   **2**: ignored
        # *   **4**: confirmed
        # *   **8**: marked as false positive
        # *   **16**: handling
        # *   **32**: handled
        # *   **64**: expired
        # *   **128**: deleted
        self.status = status
        # The dimension from which you want to configure the feature. Valid values:
        # 
        # *   **uuid**: the UUID of the asset
        # *   **image_repo**: the ID of the image repository
        # *   **Cluster**: the ID of the cluster
        self.target_type = target_type
        # The end of the time range during which the exception is detected.
        self.time_end = time_end
        # The beginning of the time range during which the exception is detected.
        self.time_start = time_start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_type_list is not None:
            result['AssetsTypeList'] = self.assets_type_list
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_event_types is not None:
            result['ParentEventTypes'] = self.parent_event_types
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.time_end is not None:
            result['TimeEnd'] = self.time_end
        if self.time_start is not None:
            result['TimeStart'] = self.time_start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetsTypeList') is not None:
            self.assets_type_list = m.get('AssetsTypeList')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentEventTypes') is not None:
            self.parent_event_types = m.get('ParentEventTypes')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TimeEnd') is not None:
            self.time_end = m.get('TimeEnd')
        if m.get('TimeStart') is not None:
            self.time_start = m.get('TimeStart')
        return self


class ExportSuspEventsResponseBody(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        id: int = None,
        request_id: str = None,
    ):
        # The name of the exported file.
        self.file_name = file_name
        # The ID of the export record.
        self.id = id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportSuspEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportSuspEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportVulRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        attach_types: str = None,
        dealed: str = None,
        group_id: str = None,
        lang: str = None,
        necessity: str = None,
        search_tags: str = None,
        type: str = None,
        uuids: str = None,
        vpc_instance_ids: str = None,
    ):
        self.alias_name = alias_name
        self.attach_types = attach_types
        self.dealed = dealed
        self.group_id = group_id
        self.lang = lang
        self.necessity = necessity
        self.search_tags = search_tags
        self.type = type
        self.uuids = uuids
        self.vpc_instance_ids = vpc_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        return self


class ExportVulResponseBody(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        id: int = None,
        request_id: str = None,
    ):
        self.file_name = file_name
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportVulResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportVulResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportWarningRequest(TeaModel):
    def __init__(
        self,
        dealed: str = None,
        export_type: str = None,
        is_cleartext_pwd: int = None,
        is_summary_export: int = None,
        lang: str = None,
        risk_ids: str = None,
        risk_levels: str = None,
        risk_name: str = None,
        source_ip: str = None,
        status_list: str = None,
        strategy_id: int = None,
        sub_type_names: str = None,
        type_name: str = None,
        type_names: str = None,
        uuids: str = None,
    ):
        # Specifies whether the baseline risks are handled. Valid values:
        # 
        # *   **Y**: yes
        # *   **N**: no
        self.dealed = dealed
        # The type of the export task. Set the value to **hc_check_warning**, which indicates tasks to export baseline check results.
        self.export_type = export_type
        # The export method of the results for the weak password baseline check. Valid values:
        # 
        # *   **0**: exports the check results after it is masked.
        # *   **1**: exports the check results in plaintext.
        self.is_cleartext_pwd = is_cleartext_pwd
        # Specifies whether the baseline check results are aggregated and exported. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_summary_export = is_summary_export
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the risk item in the baseline check results. Separate multiple IDs with commas (,).
        self.risk_ids = risk_ids
        # The severity of the baseline check item. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_levels = risk_levels
        # The name of the baseline.
        self.risk_name = risk_name
        # The source IP address of the request.
        self.source_ip = source_ip
        # The status of the check item in the baseline check results. Separate multiple statuses with commas (,). Valid values:
        # 
        # *   **3**: passed
        # *   **1**: failed
        self.status_list = status_list
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id
        # The subtypes of the baselines based on which baseline checks are performed. Separate multiple subtypes with commas (,).
        # 
        # > You must set the value of this parameter to the value of the **TypeName** parameter that is contained in the **SubTypes** parameter. You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to obtain the value of the TypeName parameter.
        self.sub_type_names = sub_type_names
        # The type of the baseline based on which baseline checks are performed.
        # 
        # > You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.
        self.type_name = type_name
        # The types of the baselines based on which baseline checks are performed. Separate multiple types with commas (,).
        # 
        # > You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.
        self.type_names = type_names
        # The UUID of the server whose baseline check results you want to export. Separate multiple UUIDs with commas (,).
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.is_cleartext_pwd is not None:
            result['IsCleartextPwd'] = self.is_cleartext_pwd
        if self.is_summary_export is not None:
            result['IsSummaryExport'] = self.is_summary_export
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_ids is not None:
            result['RiskIds'] = self.risk_ids
        if self.risk_levels is not None:
            result['RiskLevels'] = self.risk_levels
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.sub_type_names is not None:
            result['SubTypeNames'] = self.sub_type_names
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.type_names is not None:
            result['TypeNames'] = self.type_names
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('IsCleartextPwd') is not None:
            self.is_cleartext_pwd = m.get('IsCleartextPwd')
        if m.get('IsSummaryExport') is not None:
            self.is_summary_export = m.get('IsSummaryExport')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskIds') is not None:
            self.risk_ids = m.get('RiskIds')
        if m.get('RiskLevels') is not None:
            self.risk_levels = m.get('RiskLevels')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('SubTypeNames') is not None:
            self.sub_type_names = m.get('SubTypeNames')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('TypeNames') is not None:
            self.type_names = m.get('TypeNames')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ExportWarningResponseBody(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        id: int = None,
        request_id: str = None,
    ):
        # The name of the file that contains exported baseline check results.
        self.file_name = file_name
        # The ID of the task to export baseline check results.
        # 
        # > You can call use the value of this parameter to call the [DescribeHcExportInfo](~~DescribeHcExportInfo~~) operation to query the export progress.
        self.id = id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportWarningResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportWarningResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportWarningResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FindContainerNetworkConnectRequestDstNode(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        namespace: str = None,
        node_ids: List[str] = None,
        node_type: str = None,
        pod_name: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.namespace = namespace
        self.node_ids = node_ids
        self.node_type = node_type
        self.pod_name = pod_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class FindContainerNetworkConnectRequestSrcNode(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        namespace: str = None,
        node_ids: List[str] = None,
        node_type: str = None,
        pod_name: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.namespace = namespace
        self.node_ids = node_ids
        self.node_type = node_type
        self.pod_name = pod_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class FindContainerNetworkConnectRequest(TeaModel):
    def __init__(
        self,
        criteria_type: str = None,
        current_page: int = None,
        dst_node: FindContainerNetworkConnectRequestDstNode = None,
        end_time: int = None,
        page_size: int = None,
        src_node: FindContainerNetworkConnectRequestSrcNode = None,
        start_time: int = None,
    ):
        # The number of entries returned per page. Default value: **20**.
        self.criteria_type = criteria_type
        self.current_page = current_page
        self.dst_node = dst_node
        self.end_time = end_time
        self.page_size = page_size
        self.src_node = src_node
        # The page number of the returned page.
        self.start_time = start_time

    def validate(self):
        if self.dst_node:
            self.dst_node.validate()
        if self.src_node:
            self.src_node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dst_node is not None:
            result['DstNode'] = self.dst_node.to_map()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.src_node is not None:
            result['SrcNode'] = self.src_node.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DstNode') is not None:
            temp_model = FindContainerNetworkConnectRequestDstNode()
            self.dst_node = temp_model.from_map(m['DstNode'])
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SrcNode') is not None:
            temp_model = FindContainerNetworkConnectRequestSrcNode()
            self.src_node = temp_model.from_map(m['SrcNode'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class FindContainerNetworkConnectShrinkRequest(TeaModel):
    def __init__(
        self,
        criteria_type: str = None,
        current_page: int = None,
        dst_node_shrink: str = None,
        end_time: int = None,
        page_size: int = None,
        src_node_shrink: str = None,
        start_time: int = None,
    ):
        # The number of entries returned per page. Default value: **20**.
        self.criteria_type = criteria_type
        self.current_page = current_page
        self.dst_node_shrink = dst_node_shrink
        self.end_time = end_time
        self.page_size = page_size
        self.src_node_shrink = src_node_shrink
        # The page number of the returned page.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dst_node_shrink is not None:
            result['DstNode'] = self.dst_node_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.src_node_shrink is not None:
            result['SrcNode'] = self.src_node_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DstNode') is not None:
            self.dst_node_shrink = m.get('DstNode')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SrcNode') is not None:
            self.src_node_shrink = m.get('SrcNode')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class FindContainerNetworkConnectResponseBodyConnectsDstContainer(TeaModel):
    def __init__(
        self,
        container_id: str = None,
    ):
        self.container_id = container_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        return self


class FindContainerNetworkConnectResponseBodyConnectsSrcContainer(TeaModel):
    def __init__(
        self,
        container_id: str = None,
    ):
        self.container_id = container_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        return self


class FindContainerNetworkConnectResponseBodyConnects(TeaModel):
    def __init__(
        self,
        dst_container: FindContainerNetworkConnectResponseBodyConnectsDstContainer = None,
        dst_ip: str = None,
        dst_port: str = None,
        first_time: int = None,
        id: int = None,
        last_time: int = None,
        src_container: FindContainerNetworkConnectResponseBodyConnectsSrcContainer = None,
        src_ip: str = None,
        src_port: str = None,
    ):
        self.dst_container = dst_container
        self.dst_ip = dst_ip
        self.dst_port = dst_port
        self.first_time = first_time
        self.id = id
        self.last_time = last_time
        self.src_container = src_container
        self.src_ip = src_ip
        self.src_port = src_port

    def validate(self):
        if self.dst_container:
            self.dst_container.validate()
        if self.src_container:
            self.src_container.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_container is not None:
            result['DstContainer'] = self.dst_container.to_map()
        if self.dst_ip is not None:
            result['DstIp'] = self.dst_ip
        if self.dst_port is not None:
            result['DstPort'] = self.dst_port
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.id is not None:
            result['Id'] = self.id
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.src_container is not None:
            result['SrcContainer'] = self.src_container.to_map()
        if self.src_ip is not None:
            result['SrcIp'] = self.src_ip
        if self.src_port is not None:
            result['SrcPort'] = self.src_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstContainer') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyConnectsDstContainer()
            self.dst_container = temp_model.from_map(m['DstContainer'])
        if m.get('DstIp') is not None:
            self.dst_ip = m.get('DstIp')
        if m.get('DstPort') is not None:
            self.dst_port = m.get('DstPort')
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('SrcContainer') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyConnectsSrcContainer()
            self.src_container = temp_model.from_map(m['SrcContainer'])
        if m.get('SrcIp') is not None:
            self.src_ip = m.get('SrcIp')
        if m.get('SrcPort') is not None:
            self.src_port = m.get('SrcPort')
        return self


class FindContainerNetworkConnectResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class FindContainerNetworkConnectResponseBody(TeaModel):
    def __init__(
        self,
        connects: List[FindContainerNetworkConnectResponseBodyConnects] = None,
        page_info: FindContainerNetworkConnectResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.connects = connects
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.connects:
            for k in self.connects:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Connects'] = []
        if self.connects is not None:
            for k in self.connects:
                result['Connects'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.connects = []
        if m.get('Connects') is not None:
            for k in m.get('Connects'):
                temp_model = FindContainerNetworkConnectResponseBodyConnects()
                self.connects.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class FindContainerNetworkConnectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FindContainerNetworkConnectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FindContainerNetworkConnectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FixCheckWarningsRequest(TeaModel):
    def __init__(
        self,
        check_params: str = None,
        lang: str = None,
        risk_id: int = None,
        source_ip: str = None,
        uuids: str = None,
    ):
        # 165.225.XX.XX
        self.check_params = check_params
        # The ID of the request.
        self.lang = lang
        # The source IP address of the request.
        self.risk_id = risk_id
        # The UUID of the asset for which you want to fix the baseline risk item. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the UUIDs of assets.
        self.source_ip = source_ip
        # Fixes a baseline risk item.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_params is not None:
            result['CheckParams'] = self.check_params
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckParams') is not None:
            self.check_params = m.get('CheckParams')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class FixCheckWarningsResponseBody(TeaModel):
    def __init__(
        self,
        batch_id: int = None,
        request_id: str = None,
    ):
        # FixCheckWarnings
        self.batch_id = batch_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_id is not None:
            result['BatchId'] = self.batch_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchId') is not None:
            self.batch_id = m.get('BatchId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class FixCheckWarningsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FixCheckWarningsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FixCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateOnceTaskRequest(TeaModel):
    def __init__(
        self,
        param: str = None,
        source: str = None,
        task_name: str = None,
        task_type: str = None,
    ):
        # The collection time.
        self.param = param
        # The total number of scan tasks.
        self.source = source
        # The ID of the last scan task.
        self.task_name = task_name
        # Indicates whether you can create more scan tasks. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # > By default, a maximum of 10 scan tasks can be running at the same time. If 10 image scan tasks are running, you cannot create a scan task by calling this operation. You must wait for at least one of the 10 existing scan tasks to complete before you can create a scan task.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.param is not None:
            result['Param'] = self.param
        if self.source is not None:
            result['Source'] = self.source
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GenerateOnceTaskResponseBody(TeaModel):
    def __init__(
        self,
        can_create: bool = None,
        collect_time: int = None,
        finish_count: int = None,
        last_task: str = None,
        request_id: str = None,
        task_id: str = None,
        total_count: int = None,
    ):
        # The number of scan tasks that are complete.
        self.can_create = can_create
        self.collect_time = collect_time
        self.finish_count = finish_count
        self.last_task = last_task
        # The ID of the scan task.
        self.request_id = request_id
        self.task_id = task_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.last_task is not None:
            result['LastTask'] = self.last_task
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('LastTask') is not None:
            self.last_task = m.get('LastTask')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GenerateOnceTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateOnceTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlarmMachineCountRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
    ):
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class GetAlarmMachineCountResponseBodyData(TeaModel):
    def __init__(
        self,
        machine_count: int = None,
    ):
        self.machine_count = machine_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_count is not None:
            result['MachineCount'] = self.machine_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineCount') is not None:
            self.machine_count = m.get('MachineCount')
        return self


class GetAlarmMachineCountResponseBody(TeaModel):
    def __init__(
        self,
        data: GetAlarmMachineCountResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetAlarmMachineCountResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAlarmMachineCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlarmMachineCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlarmMachineCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAppNetworkRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        end_time: int = None,
        start_time: int = None,
    ):
        self.cluster_id = cluster_id
        self.end_time = end_time
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetAppNetworkResponseBodyAppNetworkEdge(TeaModel):
    def __init__(
        self,
        dst_node_id: str = None,
        dst_node_type: str = None,
        id: str = None,
        port: str = None,
        src_node_id: str = None,
        src_node_type: str = None,
    ):
        self.dst_node_id = dst_node_id
        self.dst_node_type = dst_node_type
        self.id = id
        self.port = port
        self.src_node_id = src_node_id
        self.src_node_type = src_node_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_node_id is not None:
            result['DstNodeId'] = self.dst_node_id
        if self.dst_node_type is not None:
            result['DstNodeType'] = self.dst_node_type
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.src_node_id is not None:
            result['SrcNodeId'] = self.src_node_id
        if self.src_node_type is not None:
            result['SrcNodeType'] = self.src_node_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstNodeId') is not None:
            self.dst_node_id = m.get('DstNodeId')
        if m.get('DstNodeType') is not None:
            self.dst_node_type = m.get('DstNodeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SrcNodeId') is not None:
            self.src_node_id = m.get('SrcNodeId')
        if m.get('SrcNodeType') is not None:
            self.src_node_type = m.get('SrcNodeType')
        return self


class GetAppNetworkResponseBodyAppNetworkNamespace(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetAppNetworkResponseBodyAppNetworkNode(TeaModel):
    def __init__(
        self,
        container_ids: List[str] = None,
        id: str = None,
        name: str = None,
        namespace_id: str = None,
        risk_level: str = None,
        type: str = None,
    ):
        self.container_ids = container_ids
        self.id = id
        self.name = name
        self.namespace_id = namespace_id
        self.risk_level = risk_level
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_ids is not None:
            result['ContainerIds'] = self.container_ids
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerIds') is not None:
            self.container_ids = m.get('ContainerIds')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetAppNetworkResponseBodyAppNetwork(TeaModel):
    def __init__(
        self,
        edge: List[GetAppNetworkResponseBodyAppNetworkEdge] = None,
        namespace: List[GetAppNetworkResponseBodyAppNetworkNamespace] = None,
        node: List[GetAppNetworkResponseBodyAppNetworkNode] = None,
    ):
        self.edge = edge
        self.namespace = namespace
        self.node = node

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()
        if self.namespace:
            for k in self.namespace:
                if k:
                    k.validate()
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        result['Namespace'] = []
        if self.namespace is not None:
            for k in self.namespace:
                result['Namespace'].append(k.to_map() if k else None)
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = GetAppNetworkResponseBodyAppNetworkEdge()
                self.edge.append(temp_model.from_map(k))
        self.namespace = []
        if m.get('Namespace') is not None:
            for k in m.get('Namespace'):
                temp_model = GetAppNetworkResponseBodyAppNetworkNamespace()
                self.namespace.append(temp_model.from_map(k))
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetAppNetworkResponseBodyAppNetworkNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetAppNetworkResponseBody(TeaModel):
    def __init__(
        self,
        app_network: GetAppNetworkResponseBodyAppNetwork = None,
        request_id: str = None,
    ):
        self.app_network = app_network
        self.request_id = request_id

    def validate(self):
        if self.app_network:
            self.app_network.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_network is not None:
            result['AppNetwork'] = self.app_network.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppNetwork') is not None:
            temp_model = GetAppNetworkResponseBodyAppNetwork()
            self.app_network = temp_model.from_map(m['AppNetwork'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAppNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAppNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAppNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssetSelectionConfigRequest(TeaModel):
    def __init__(
        self,
        business_type: str = None,
    ):
        self.business_type = business_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        return self


class GetAssetSelectionConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        selection_key: str = None,
        target_type: str = None,
    ):
        self.selection_key = selection_key
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selection_key is not None:
            result['SelectionKey'] = self.selection_key
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectionKey') is not None:
            self.selection_key = m.get('SelectionKey')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class GetAssetSelectionConfigResponseBody(TeaModel):
    def __init__(
        self,
        data: GetAssetSelectionConfigResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetAssetSelectionConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAssetSelectionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAssetSelectionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssetSelectionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssetsPropertyDetailRequestSearchCriteriaList(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the condition. Valid values:
        # 
        # *   **remarkItemName**: the aggregation item of the asset fingerprints. Fuzzy match is supported.
        # 
        # > 
        # 
        # *   If **Biz** is set to **web_server**, **remarkItemName** specifies a domain name.
        # 
        # *   If **Biz** is set to **lkm**, **remarkItemName** specifies a module name.
        # 
        # *   If **Biz** is set to **autorun**, **remarkItemName** specifies the path to a startup item.
        self.name = name
        # The value of the condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAssetsPropertyDetailRequest(TeaModel):
    def __init__(
        self,
        biz: str = None,
        current_page: int = None,
        item_name: str = None,
        lang: str = None,
        page_size: int = None,
        remark: str = None,
        search_criteria_list: List[GetAssetsPropertyDetailRequestSearchCriteriaList] = None,
        uuid: str = None,
    ):
        # The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:
        # 
        # *   **lkm**: kernel module
        # *   **autorun**: startup item
        # *   **web_server**: website
        self.biz = biz
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page
        # The name of the aggregation item for the asset fingerprint that you want to query.
        # 
        # > You can call the [GetAssetsPropertyItem](~~GetAssetsPropertyItem~~) operation to query the names of aggregation items.
        self.item_name = item_name
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.page_size = page_size
        # The name or IP address of the server.
        self.remark = remark
        # The conditions that are used to query the details about the asset fingerprint.
        self.search_criteria_list = search_criteria_list
        # The UUID of the server.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        if self.search_criteria_list:
            for k in self.search_criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        result['SearchCriteriaList'] = []
        if self.search_criteria_list is not None:
            for k in self.search_criteria_list:
                result['SearchCriteriaList'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        self.search_criteria_list = []
        if m.get('SearchCriteriaList') is not None:
            for k in m.get('SearchCriteriaList'):
                temp_model = GetAssetsPropertyDetailRequestSearchCriteriaList()
                self.search_criteria_list.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetAssetsPropertyDetailResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetAssetsPropertyDetailResponseBodyPropertys(TeaModel):
    def __init__(
        self,
        container_name: str = None,
        create_timestamp: int = None,
        domain: str = None,
        filepath: str = None,
        image_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        ip: str = None,
        listen_protocol: str = None,
        module_name: str = None,
        path: str = None,
        path_mode: str = None,
        pid: str = None,
        port: str = None,
        process_started: int = None,
        region_id: str = None,
        server_type: str = None,
        size: int = None,
        used_by_count: int = None,
        user: str = None,
        uuid: str = None,
        web_path: str = None,
    ):
        # The name of the container.
        self.container_name = container_name
        # The timestamp of the last fingerprint collection. Unit: milliseconds.
        self.create_timestamp = create_timestamp
        # The domain name of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.domain = domain
        # The path to the kernel module file.
        # 
        # > This parameter is returned only when **Biz** is set to **lkm**.
        self.filepath = filepath
        # The name of the image.
        self.image_name = image_name
        # The ID of the server.
        self.instance_id = instance_id
        # The name of the server.
        self.instance_name = instance_name
        # The public IP address of the server.
        self.internet_ip = internet_ip
        # The private IP address of the server.
        self.intranet_ip = intranet_ip
        # The IP address of the server.
        self.ip = ip
        # The listening protocol that the website uses.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.listen_protocol = listen_protocol
        # The name of the module.
        # 
        # > This parameter is returned only when **Biz** is set to **lkm**.
        self.module_name = module_name
        # The path. The value of this parameter varies based on the value of **Biz**.
        # 
        # *   If **Biz** is set to **web_server**, the value of this parameter indicates the path to the website root directory.
        # *   If **Biz** is set to **autorun**, the value of this parameter indicates the path to the startup item.
        self.path = path
        # The permissions on the root directory of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.path_mode = path_mode
        # The process ID (PID) of the process that runs the website service.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.pid = pid
        # The port of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.port = port
        # The timestamp when the process was started. Unit: milliseconds.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.process_started = process_started
        # The ID of the region in which the server resides.
        self.region_id = region_id
        # The type of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.server_type = server_type
        # The size of the kernel module.
        # 
        # > This parameter is returned only when **Biz** is set to **lkm**.
        self.size = size
        # The number of times that the kernel module is referenced.
        # 
        # > This parameter is returned only when **Biz** is set to **lkm**.
        self.used_by_count = used_by_count
        # The user who started the process of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.user = user
        # The UUID of the server.
        self.uuid = uuid
        # The path to the root directory of the website.
        # 
        # > This parameter is returned only when **Biz** is set to **web_server**.
        self.web_path = web_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.filepath is not None:
            result['Filepath'] = self.filepath
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.listen_protocol is not None:
            result['ListenProtocol'] = self.listen_protocol
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.path is not None:
            result['Path'] = self.path
        if self.path_mode is not None:
            result['PathMode'] = self.path_mode
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.process_started is not None:
            result['ProcessStarted'] = self.process_started
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.server_type is not None:
            result['ServerType'] = self.server_type
        if self.size is not None:
            result['Size'] = self.size
        if self.used_by_count is not None:
            result['UsedByCount'] = self.used_by_count
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Filepath') is not None:
            self.filepath = m.get('Filepath')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('ListenProtocol') is not None:
            self.listen_protocol = m.get('ListenProtocol')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('PathMode') is not None:
            self.path_mode = m.get('PathMode')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcessStarted') is not None:
            self.process_started = m.get('ProcessStarted')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServerType') is not None:
            self.server_type = m.get('ServerType')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('UsedByCount') is not None:
            self.used_by_count = m.get('UsedByCount')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class GetAssetsPropertyDetailResponseBody(TeaModel):
    def __init__(
        self,
        page_info: GetAssetsPropertyDetailResponseBodyPageInfo = None,
        propertys: List[GetAssetsPropertyDetailResponseBodyPropertys] = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # An array that consists of the details about the asset fingerprints.
        self.propertys = propertys
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = GetAssetsPropertyDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = GetAssetsPropertyDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAssetsPropertyDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAssetsPropertyDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssetsPropertyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssetsPropertyItemRequest(TeaModel):
    def __init__(
        self,
        biz: str = None,
        current_page: int = None,
        force_flush: bool = None,
        lang: str = None,
        page_size: int = None,
        search_info: str = None,
        search_item: str = None,
    ):
        self.biz = biz
        self.current_page = current_page
        self.force_flush = force_flush
        self.lang = lang
        self.page_size = page_size
        self.search_info = search_info
        self.search_item = search_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        return self


class GetAssetsPropertyItemResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetAssetsPropertyItemResponseBodyPropertyItems(TeaModel):
    def __init__(
        self,
        count: int = None,
        domain: str = None,
        module_name: str = None,
        path: str = None,
    ):
        self.count = count
        self.domain = domain
        self.module_name = module_name
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class GetAssetsPropertyItemResponseBody(TeaModel):
    def __init__(
        self,
        page_info: GetAssetsPropertyItemResponseBodyPageInfo = None,
        property_items: List[GetAssetsPropertyItemResponseBodyPropertyItems] = None,
        request_id: str = None,
    ):
        self.page_info = page_info
        self.property_items = property_items
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = GetAssetsPropertyItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = GetAssetsPropertyItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAssetsPropertyItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAssetsPropertyItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssetsPropertyItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBackupStorageCountResponseBodyBackupStorageCount(TeaModel):
    def __init__(
        self,
        buy_storage_byte: int = None,
        ecs_usage_storage_byte: int = None,
        overflow: int = None,
        uni_usage_storage_byte: int = None,
        usage_storage_byte: int = None,
    ):
        self.buy_storage_byte = buy_storage_byte
        self.ecs_usage_storage_byte = ecs_usage_storage_byte
        self.overflow = overflow
        self.uni_usage_storage_byte = uni_usage_storage_byte
        self.usage_storage_byte = usage_storage_byte

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buy_storage_byte is not None:
            result['BuyStorageByte'] = self.buy_storage_byte
        if self.ecs_usage_storage_byte is not None:
            result['EcsUsageStorageByte'] = self.ecs_usage_storage_byte
        if self.overflow is not None:
            result['Overflow'] = self.overflow
        if self.uni_usage_storage_byte is not None:
            result['UniUsageStorageByte'] = self.uni_usage_storage_byte
        if self.usage_storage_byte is not None:
            result['UsageStorageByte'] = self.usage_storage_byte
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuyStorageByte') is not None:
            self.buy_storage_byte = m.get('BuyStorageByte')
        if m.get('EcsUsageStorageByte') is not None:
            self.ecs_usage_storage_byte = m.get('EcsUsageStorageByte')
        if m.get('Overflow') is not None:
            self.overflow = m.get('Overflow')
        if m.get('UniUsageStorageByte') is not None:
            self.uni_usage_storage_byte = m.get('UniUsageStorageByte')
        if m.get('UsageStorageByte') is not None:
            self.usage_storage_byte = m.get('UsageStorageByte')
        return self


class GetBackupStorageCountResponseBody(TeaModel):
    def __init__(
        self,
        backup_storage_count: GetBackupStorageCountResponseBodyBackupStorageCount = None,
        request_id: str = None,
    ):
        self.backup_storage_count = backup_storage_count
        self.request_id = request_id

    def validate(self):
        if self.backup_storage_count:
            self.backup_storage_count.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_storage_count is not None:
            result['BackupStorageCount'] = self.backup_storage_count.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackupStorageCount') is not None:
            temp_model = GetBackupStorageCountResponseBodyBackupStorageCount()
            self.backup_storage_count = temp_model.from_map(m['BackupStorageCount'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetBackupStorageCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBackupStorageCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBackupStorageCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckConfigResponseBodyStandards(TeaModel):
    def __init__(
        self,
        id: int = None,
        show_name: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the check item.
        self.id = id
        # The name of the check item.
        self.show_name = show_name
        # The status of the check item. Valid values:
        # 
        # *   **ON**: enabled
        # *   **OFF**: disabled
        self.status = status
        # The type of the check item. Valid values:
        # 
        # *   **RISK**: cloud service configuration management
        # *   **IDENTITY_PERMISSION**: identity and permission management
        # *   **COMPLIANCE**: compliance
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCheckConfigResponseBody(TeaModel):
    def __init__(
        self,
        cycle_days: List[int] = None,
        end_time: int = None,
        request_id: str = None,
        standards: List[GetCheckConfigResponseBodyStandards] = None,
        start_time: int = None,
    ):
        # An array that consists of days in a week on which an automatic check is performed.
        self.cycle_days = cycle_days
        # The end time of the check. The value indicates a point in time. The time period that is specified by the start time and end time must be one of the following time periods:
        # 
        # *   **00:00 to 06:00:** The StartTime parameter is set to 0 and the EndTime parameter is set to 6.
        # *   **06:00 to 12:00**: The StartTime parameter is set to 6 and the EndTime parameter is set to 12.
        # *   **12:00 to 18:00**: The StartTime parameter is set to 12 and the EndTime parameter is set to 18.
        # *   **18:00 to 24:00:** The StartTime parameter is set to 18 and the EndTime parameter is set to 24.
        self.end_time = end_time
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # An array that consists of the information about the check items.
        self.standards = standards
        # The start time of the check. The value indicates a point in time.
        self.start_time = start_time

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = GetCheckConfigResponseBodyStandards()
                self.standards.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetCheckConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckDetailRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        lang: str = None,
        region_id: str = None,
    ):
        self.check_id = check_id
        self.lang = lang
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCheckDetailResponseBodyAssistInfo(TeaModel):
    def __init__(
        self,
        link: str = None,
        type: str = None,
        value: str = None,
    ):
        self.link = link
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBodyCustomConfigs(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        name: str = None,
        show_name: str = None,
        type_define: str = None,
        value: str = None,
    ):
        self.default_value = default_value
        self.name = name
        self.show_name = show_name
        self.type_define = type_define
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.name is not None:
            result['Name'] = self.name
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type_define is not None:
            result['TypeDefine'] = self.type_define
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('TypeDefine') is not None:
            self.type_define = m.get('TypeDefine')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBodyDescription(TeaModel):
    def __init__(
        self,
        link: str = None,
        type: str = None,
        value: str = None,
    ):
        self.link = link
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBodySolution(TeaModel):
    def __init__(
        self,
        link: str = None,
        type: str = None,
        value: str = None,
    ):
        self.link = link
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBody(TeaModel):
    def __init__(
        self,
        assist_info: GetCheckDetailResponseBodyAssistInfo = None,
        custom_configs: List[GetCheckDetailResponseBodyCustomConfigs] = None,
        description: GetCheckDetailResponseBodyDescription = None,
        request_id: str = None,
        solution: GetCheckDetailResponseBodySolution = None,
    ):
        self.assist_info = assist_info
        self.custom_configs = custom_configs
        self.description = description
        self.request_id = request_id
        self.solution = solution

    def validate(self):
        if self.assist_info:
            self.assist_info.validate()
        if self.custom_configs:
            for k in self.custom_configs:
                if k:
                    k.validate()
        if self.description:
            self.description.validate()
        if self.solution:
            self.solution.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assist_info is not None:
            result['AssistInfo'] = self.assist_info.to_map()
        result['CustomConfigs'] = []
        if self.custom_configs is not None:
            for k in self.custom_configs:
                result['CustomConfigs'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.solution is not None:
            result['Solution'] = self.solution.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssistInfo') is not None:
            temp_model = GetCheckDetailResponseBodyAssistInfo()
            self.assist_info = temp_model.from_map(m['AssistInfo'])
        self.custom_configs = []
        if m.get('CustomConfigs') is not None:
            for k in m.get('CustomConfigs'):
                temp_model = GetCheckDetailResponseBodyCustomConfigs()
                self.custom_configs.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            temp_model = GetCheckDetailResponseBodyDescription()
            self.description = temp_model.from_map(m['Description'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Solution') is not None:
            temp_model = GetCheckDetailResponseBodySolution()
            self.solution = temp_model.from_map(m['Solution'])
        return self


class GetCheckDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckProcessRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetCheckProcessResponseBody(TeaModel):
    def __init__(
        self,
        finish_count: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.finish_count = finish_count
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetCheckProcessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckProcessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckRiskStatisticsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.lang = lang
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class GetCheckRiskStatisticsResponseBodyDataSubStatistics(TeaModel):
    def __init__(
        self,
        alias: str = None,
        high_warning_count: int = None,
        low_warning_count: int = None,
        medium_warning_count: int = None,
        pass_count: int = None,
        total_count: int = None,
        type_name: str = None,
    ):
        self.alias = alias
        self.high_warning_count = high_warning_count
        self.low_warning_count = low_warning_count
        self.medium_warning_count = medium_warning_count
        self.pass_count = pass_count
        self.total_count = total_count
        self.type_name = type_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetCheckRiskStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        high_warning_count: int = None,
        low_warning_count: int = None,
        medium_warning_count: int = None,
        pass_count: int = None,
        scene_name: str = None,
        sub_statistics: List[GetCheckRiskStatisticsResponseBodyDataSubStatistics] = None,
        total_count: int = None,
    ):
        self.high_warning_count = high_warning_count
        self.low_warning_count = low_warning_count
        self.medium_warning_count = medium_warning_count
        self.pass_count = pass_count
        self.scene_name = scene_name
        self.sub_statistics = sub_statistics
        self.total_count = total_count

    def validate(self):
        if self.sub_statistics:
            for k in self.sub_statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.scene_name is not None:
            result['SceneName'] = self.scene_name
        result['SubStatistics'] = []
        if self.sub_statistics is not None:
            for k in self.sub_statistics:
                result['SubStatistics'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('SceneName') is not None:
            self.scene_name = m.get('SceneName')
        self.sub_statistics = []
        if m.get('SubStatistics') is not None:
            for k in m.get('SubStatistics'):
                temp_model = GetCheckRiskStatisticsResponseBodyDataSubStatistics()
                self.sub_statistics.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetCheckRiskStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        data: List[GetCheckRiskStatisticsResponseBodyData] = None,
        request_id: str = None,
    ):
        self.count = count
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetCheckRiskStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCheckRiskStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckRiskStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckRiskStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckSummaryRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_directory_account_id: str = None,
    ):
        self.lang = lang
        self.resource_directory_account_id = resource_directory_account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        return self


class GetCheckSummaryResponseBodySummarysStandards(TeaModel):
    def __init__(
        self,
        fail_count: int = None,
        id: int = None,
        pass_count: int = None,
        risk_level_high_count: int = None,
        risk_level_low_count: int = None,
        risk_level_medium_count: int = None,
        show_name: str = None,
    ):
        self.fail_count = fail_count
        self.id = id
        self.pass_count = pass_count
        self.risk_level_high_count = risk_level_high_count
        self.risk_level_low_count = risk_level_low_count
        self.risk_level_medium_count = risk_level_medium_count
        self.show_name = show_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.id is not None:
            result['Id'] = self.id
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.risk_level_high_count is not None:
            result['RiskLevelHighCount'] = self.risk_level_high_count
        if self.risk_level_low_count is not None:
            result['RiskLevelLowCount'] = self.risk_level_low_count
        if self.risk_level_medium_count is not None:
            result['RiskLevelMediumCount'] = self.risk_level_medium_count
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('RiskLevelHighCount') is not None:
            self.risk_level_high_count = m.get('RiskLevelHighCount')
        if m.get('RiskLevelLowCount') is not None:
            self.risk_level_low_count = m.get('RiskLevelLowCount')
        if m.get('RiskLevelMediumCount') is not None:
            self.risk_level_medium_count = m.get('RiskLevelMediumCount')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        return self


class GetCheckSummaryResponseBodySummarys(TeaModel):
    def __init__(
        self,
        fail_count: int = None,
        pass_count: int = None,
        standards: List[GetCheckSummaryResponseBodySummarysStandards] = None,
        type: str = None,
    ):
        self.fail_count = fail_count
        self.pass_count = pass_count
        self.standards = standards
        self.type = type

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = GetCheckSummaryResponseBodySummarysStandards()
                self.standards.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCheckSummaryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        summarys: List[GetCheckSummaryResponseBodySummarys] = None,
    ):
        self.request_id = request_id
        self.summarys = summarys

    def validate(self):
        if self.summarys:
            for k in self.summarys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Summarys'] = []
        if self.summarys is not None:
            for k in self.summarys:
                result['Summarys'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.summarys = []
        if m.get('Summarys') is not None:
            for k in m.get('Summarys'):
                temp_model = GetCheckSummaryResponseBodySummarys()
                self.summarys.append(temp_model.from_map(k))
        return self


class GetCheckSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClientUserDefineRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetClientUserDefineRuleResponseBodyUserDefineRuleDetail(TeaModel):
    def __init__(
        self,
        action_type: str = None,
        cmdline: str = None,
        file_path: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        ip: str = None,
        id: int = None,
        md_5list: str = None,
        name: str = None,
        new_file_path: str = None,
        parent_cmdline: str = None,
        parent_proc_path: str = None,
        platform: str = None,
        port: int = None,
        port_str: str = None,
        proc_path: str = None,
        registry_content: str = None,
        registry_key: str = None,
        type: int = None,
    ):
        self.action_type = action_type
        self.cmdline = cmdline
        self.file_path = file_path
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.ip = ip
        self.id = id
        self.md_5list = md_5list
        self.name = name
        self.new_file_path = new_file_path
        self.parent_cmdline = parent_cmdline
        self.parent_proc_path = parent_proc_path
        self.platform = platform
        self.port = port
        self.port_str = port_str
        self.proc_path = proc_path
        self.registry_content = registry_content
        self.registry_key = registry_key
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.ip is not None:
            result['IP'] = self.ip
        if self.id is not None:
            result['Id'] = self.id
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetClientUserDefineRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_define_rule_detail: GetClientUserDefineRuleResponseBodyUserDefineRuleDetail = None,
    ):
        self.request_id = request_id
        self.user_define_rule_detail = user_define_rule_detail

    def validate(self):
        if self.user_define_rule_detail:
            self.user_define_rule_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_detail is not None:
            result['UserDefineRuleDetail'] = self.user_define_rule_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleDetail') is not None:
            temp_model = GetClientUserDefineRuleResponseBodyUserDefineRuleDetail()
            self.user_define_rule_detail = temp_model.from_map(m['UserDefineRuleDetail'])
        return self


class GetClientUserDefineRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClientUserDefineRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudAssetCriteriaRequestCloudAssetTypes(TeaModel):
    def __init__(
        self,
        asset_sub_type: int = None,
        asset_type: int = None,
    ):
        # The type of the asset by source. Valid values:
        # 
        # *   **0**: Elastic Compute Service (ECS)
        # *   **1**: Server Load Balancer (SLB)
        # *   **3**: ApsaraDB RDS
        # *   **4**: ApsaraDB for MongoDB (MongoDB)
        # *   **5**: ApsaraDB for Redis (Redis)
        # *   **6**: Container Registry
        # *   **8**: Container Service for Kubernetes (ACK)
        # *   **9**: Virtual Private Cloud (VPC)
        # *   **11**: ActionTrail
        # *   **12**: Alibaba Cloud CDN (CDN)
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **16**: Anti-DDoS
        # *   **17**: Web Application Firewall (WAF)
        # *   **18**: Object Storage Service (OSS)
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: Microservices Engine (MSE)
        # *   **22**: Apsara File Storage NAS (NAS)
        # *   **23**: Data Security Center (DSC)
        # *   **24**: Elastic IP Address (EIP)
        # *   **25**: IDaaS EIAM
        # *   **26**: PolarDB-X
        # *   **27**: Elasticsearch
        self.asset_sub_type = asset_sub_type
        # The type of the cloud asset.
        self.asset_type = asset_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        return self


class GetCloudAssetCriteriaRequest(TeaModel):
    def __init__(
        self,
        cloud_asset_types: List[GetCloudAssetCriteriaRequestCloudAssetTypes] = None,
        value: str = None,
    ):
        # The name of the filter condition. Valid values:
        # 
        # *   **instanceId**: the ID of the instance
        # *   **instanceName**: the name of an instance
        # *   **internetIp**: the public IP address
        # *   **riskStatus**: the risk status
        # *   **vendorRegionId**: the region ID by service provider
        self.cloud_asset_types = cloud_asset_types
        # The type of the filter condition. Valid values:
        # 
        # *   **input**: The filter condition needs to be specified.
        # *   **select**: The filter condition is an option that can be selected from the drop-down list.
        self.value = value

    def validate(self):
        if self.cloud_asset_types:
            for k in self.cloud_asset_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudAssetTypes'] = []
        if self.cloud_asset_types is not None:
            for k in self.cloud_asset_types:
                result['CloudAssetTypes'].append(k.to_map() if k else None)
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cloud_asset_types = []
        if m.get('CloudAssetTypes') is not None:
            for k in m.get('CloudAssetTypes'):
                temp_model = GetCloudAssetCriteriaRequestCloudAssetTypes()
                self.cloud_asset_types.append(temp_model.from_map(k))
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCloudAssetCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(
        self,
        multi_values: str = None,
        name: str = None,
        type: str = None,
        values: str = None,
    ):
        self.multi_values = multi_values
        self.name = name
        # GetCloudAssetCriteria
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.multi_values is not None:
            result['MultiValues'] = self.multi_values
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MultiValues') is not None:
            self.multi_values = m.get('MultiValues')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class GetCloudAssetCriteriaResponseBody(TeaModel):
    def __init__(
        self,
        criteria_list: List[GetCloudAssetCriteriaResponseBodyCriteriaList] = None,
        request_id: str = None,
    ):
        # The values of the search condition. This parameter is returned only if the value of **Type** is **select**.
        # 
        # >  If the value of **Type** is **input**, the value of this parameter is an empty string.
        self.criteria_list = criteria_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = GetCloudAssetCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudAssetCriteriaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudAssetCriteriaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudAssetCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudAssetDetailRequestCloudAssetInstances(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        region_id: str = None,
    ):
        # The instance ID of the cloud asset.
        self.instance_id = instance_id
        # The region where the cloud asset resides.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCloudAssetDetailRequest(TeaModel):
    def __init__(
        self,
        asset_sub_type: int = None,
        asset_type: int = None,
        cloud_asset_instances: List[GetCloudAssetDetailRequestCloudAssetInstances] = None,
        vendor: int = None,
    ):
        # The subtype of the cloud asset.
        self.asset_sub_type = asset_sub_type
        # The type of the cloud asset. Valid values:
        # 
        # *   **0**: Elastic Compute Service (ECS)
        # *   **1**: Server Load Balancer (SLB)
        # *   **3**: ApsaraDB RDS
        # *   **4**: ApsaraDB for MongoDB (MongoDB)
        # *   **5**: ApsaraDB for Redis (Redis)
        # *   **6**: Container Registry
        # *   **8**: Container Service for Kubernetes (ACK)
        # *   **9**: Virtual Private Cloud (VPC)
        # *   **11**: ActionTrail
        # *   **12**: Alibaba Cloud CDN (CDN)
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **15**: Resource Access Management (RAM)
        # *   **16**: Anti-DDoS
        # *   **17**: Web Application Firewall (WAF)
        # *   **18**: Object Storage Service (OSS)
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: Microservices Engine (MSE)
        # *   **22**: Apsara File Storage NAS (NAS)
        # *   **23**: Data Security Center (DSC)
        # *   **24**: Elastic IP Address (EIP)
        # *   **25**: IDaaS EIAM
        # *   **26**: PolarDB-X
        # *   **27**: Elasticsearch
        self.asset_type = asset_type
        # The details of the assets.
        self.cloud_asset_instances = cloud_asset_instances
        # The service provider of the cloud asset. Valid values:
        # 
        # *   **0**: The asset is provided by Alibaba Cloud.
        # *   **1**: The asset is not provided by Alibaba Cloud.
        # *   **2**: The asset resides in a data center.
        # *   **3**, **4**, **5**, and **7**: other cloud asset.
        # *   **8**: The asset is a simple application server.
        self.vendor = vendor

    def validate(self):
        if self.cloud_asset_instances:
            for k in self.cloud_asset_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        result['CloudAssetInstances'] = []
        if self.cloud_asset_instances is not None:
            for k in self.cloud_asset_instances:
                result['CloudAssetInstances'].append(k.to_map() if k else None)
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        self.cloud_asset_instances = []
        if m.get('CloudAssetInstances') is not None:
            for k in m.get('CloudAssetInstances'):
                temp_model = GetCloudAssetDetailRequestCloudAssetInstances()
                self.cloud_asset_instances.append(temp_model.from_map(k))
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class GetCloudAssetDetailResponseBodyInstances(TeaModel):
    def __init__(
        self,
        alarm_status: str = None,
        asset_sub_type: int = None,
        asset_sub_type_name: str = None,
        asset_type: int = None,
        asset_type_name: str = None,
        created_time: int = None,
        detail_link: str = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        region_id: str = None,
        risk_status: str = None,
        security_info: str = None,
        vendor: int = None,
    ):
        # Indicates whether alerts are generated for the current cloud asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status
        # The subtype of the cloud asset.
        self.asset_sub_type = asset_sub_type
        # The subtype name of the cloud asset.
        self.asset_sub_type_name = asset_sub_type_name
        # The type of the cloud asset. Valid values:
        # 
        # *   **0**: ECS
        # *   **1**: SLB
        # *   **3**: ApsaraDB RDS
        # *   **4**: MongoDB
        # *   **5**: Redis
        # *   **6**: Container Registry
        # *   **8**: ACK
        # *   **9**: VPC
        # *   **11**: ActionTrail
        # *   **12**: CDN
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **15**: RAM
        # *   **16**: Anti-DDoS
        # *   **17**: WAF
        # *   **18**: OSS
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: MSE
        # *   **22**: NAS
        # *   **23**: DSC
        # *   **24**: EIP
        # *   **25**: IDaaS EIAM
        # *   **26**: PolarDB-X
        # *   **27**: Elasticsearch
        self.asset_type = asset_type
        # The type name of the cloud asset.
        self.asset_type_name = asset_type_name
        # The time when the instance was created. The value is a timestamp.
        self.created_time = created_time
        # The detailed address of the cloud asset.
        self.detail_link = detail_link
        # The instance ID of the cloud asset.
        self.instance_id = instance_id
        # The instance name of the cloud asset.
        self.instance_name = instance_name
        # The public IP address of the instance.
        self.internet_ip = internet_ip
        # The region where the cloud asset resides.
        # 
        # > For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id
        # Indicates whether risks are detected on the current cloud asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.risk_status = risk_status
        # The security information about the cloud asset.
        self.security_info = security_info
        # The service provider of the cloud asset. Valid values:
        # 
        # *   **0**: The asset is provided by Alibaba Cloud.
        # *   **1**: The asset is not provided by Alibaba Cloud.
        # *   **2**: The asset resides in a data center.
        # *   **3**, **4**, **5**, and **7**: other cloud asset.
        # *   **8**: The asset is a simple application server.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_sub_type_name is not None:
            result['AssetSubTypeName'] = self.asset_sub_type_name
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.asset_type_name is not None:
            result['AssetTypeName'] = self.asset_type_name
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.detail_link is not None:
            result['DetailLink'] = self.detail_link
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.security_info is not None:
            result['SecurityInfo'] = self.security_info
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetSubTypeName') is not None:
            self.asset_sub_type_name = m.get('AssetSubTypeName')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AssetTypeName') is not None:
            self.asset_type_name = m.get('AssetTypeName')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DetailLink') is not None:
            self.detail_link = m.get('DetailLink')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SecurityInfo') is not None:
            self.security_info = m.get('SecurityInfo')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class GetCloudAssetDetailResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        instances: List[GetCloudAssetDetailResponseBodyInstances] = None,
        request_id: str = None,
    ):
        # The number of instances in the list of cloud assets returned.
        self.count = count
        # An array that consists of the details of the cloud assets.
        self.instances = instances
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = GetCloudAssetDetailResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudAssetDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudAssetDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudAssetDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas(TeaModel):
    def __init__(
        self,
        asset_sub_type: int = None,
        asset_type: int = None,
        instance_count: int = None,
        instance_risk_count: int = None,
    ):
        # The subtype of the cloud service.
        self.asset_sub_type = asset_sub_type
        # The type of the cloud service. Valid values:
        # 
        # *   **0**: Elastic Compute Service (ECS)
        # *   **1**: Server Load Balancer (SLB)
        # *   **3**: ApsaraDB RDS
        # *   **4**: ApsaraDB for MongoDB (MongoDB)
        # *   **5**: ApsaraDB for Redis (Redis)
        # *   **6**: Container Registry
        # *   **8**: Container Service for Kubernetes (ACK)
        # *   **9**: Virtual Private Cloud (VPC)
        # *   **11**: ActionTrail
        # *   **12**: Alibaba Cloud CDN (CDN)
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **15**: Resource Access Management (RAM)
        # *   **16**: Anti-DDoS
        # *   **17**: Web Application Firewall (WAF)
        # *   **18**: Object Storage Service (OSS)
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: Microservices Engine (MSE)
        # *   **22**: Apsara File Storage NAS (NAS)
        # *   **23**: Data Security Center (DSC)
        # *   **24**: Elastic IP Address (EIP)
        # *   **25**: IDaaS EIAM
        # *   **26**: PolarDB-X
        # *   **27**: Elasticsearch
        self.asset_type = asset_type
        # The total number of cloud service instances of this type.
        self.instance_count = instance_count
        # The total number of cloud service instances that are at risk of this type.
        self.instance_risk_count = instance_risk_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_risk_count is not None:
            result['InstanceRiskCount'] = self.instance_risk_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceRiskCount') is not None:
            self.instance_risk_count = m.get('InstanceRiskCount')
        return self


class GetCloudAssetSummaryResponseBodyGroupedFields(TeaModel):
    def __init__(
        self,
        cloud_asset_summary_metas: List[GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas] = None,
        instance_count_total: int = None,
        instance_risk_count_total: int = None,
    ):
        # An array that consists of the statistics of cloud services.
        self.cloud_asset_summary_metas = cloud_asset_summary_metas
        # The total number of instances.
        self.instance_count_total = instance_count_total
        # The total number of instances that are at risk.
        self.instance_risk_count_total = instance_risk_count_total

    def validate(self):
        if self.cloud_asset_summary_metas:
            for k in self.cloud_asset_summary_metas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudAssetSummaryMetas'] = []
        if self.cloud_asset_summary_metas is not None:
            for k in self.cloud_asset_summary_metas:
                result['CloudAssetSummaryMetas'].append(k.to_map() if k else None)
        if self.instance_count_total is not None:
            result['InstanceCountTotal'] = self.instance_count_total
        if self.instance_risk_count_total is not None:
            result['InstanceRiskCountTotal'] = self.instance_risk_count_total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cloud_asset_summary_metas = []
        if m.get('CloudAssetSummaryMetas') is not None:
            for k in m.get('CloudAssetSummaryMetas'):
                temp_model = GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas()
                self.cloud_asset_summary_metas.append(temp_model.from_map(k))
        if m.get('InstanceCountTotal') is not None:
            self.instance_count_total = m.get('InstanceCountTotal')
        if m.get('InstanceRiskCountTotal') is not None:
            self.instance_risk_count_total = m.get('InstanceRiskCountTotal')
        return self


class GetCloudAssetSummaryResponseBody(TeaModel):
    def __init__(
        self,
        grouped_fields: GetCloudAssetSummaryResponseBodyGroupedFields = None,
        request_id: str = None,
    ):
        # The summary of cloud services.
        self.grouped_fields = grouped_fields
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = GetCloudAssetSummaryResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudAssetSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudAssetSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudAssetSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterCheckItemWarningStatisticsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class GetClusterCheckItemWarningStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        high_warning_count: int = None,
        low_warning_count: int = None,
        medium_warning_count: int = None,
    ):
        self.high_warning_count = high_warning_count
        self.low_warning_count = low_warning_count
        self.medium_warning_count = medium_warning_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        return self


class GetClusterCheckItemWarningStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        data: GetClusterCheckItemWarningStatisticsResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetClusterCheckItemWarningStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterCheckItemWarningStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterCheckItemWarningStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterCheckItemWarningStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterRuleSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class GetClusterRuleSummaryResponseBodyClusterRuleSummary(TeaModel):
    def __init__(
        self,
        close_rule_count: int = None,
        interception_count_7day: int = None,
        interception_switch: int = None,
        interception_type: int = None,
        open_rule_count: int = None,
        rule_count: int = None,
        suggest_rule_count: int = None,
    ):
        self.close_rule_count = close_rule_count
        self.interception_count_7day = interception_count_7day
        self.interception_switch = interception_switch
        self.interception_type = interception_type
        self.open_rule_count = open_rule_count
        self.rule_count = rule_count
        self.suggest_rule_count = suggest_rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_rule_count is not None:
            result['CloseRuleCount'] = self.close_rule_count
        if self.interception_count_7day is not None:
            result['InterceptionCount7Day'] = self.interception_count_7day
        if self.interception_switch is not None:
            result['InterceptionSwitch'] = self.interception_switch
        if self.interception_type is not None:
            result['InterceptionType'] = self.interception_type
        if self.open_rule_count is not None:
            result['OpenRuleCount'] = self.open_rule_count
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        if self.suggest_rule_count is not None:
            result['SuggestRuleCount'] = self.suggest_rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloseRuleCount') is not None:
            self.close_rule_count = m.get('CloseRuleCount')
        if m.get('InterceptionCount7Day') is not None:
            self.interception_count_7day = m.get('InterceptionCount7Day')
        if m.get('InterceptionSwitch') is not None:
            self.interception_switch = m.get('InterceptionSwitch')
        if m.get('InterceptionType') is not None:
            self.interception_type = m.get('InterceptionType')
        if m.get('OpenRuleCount') is not None:
            self.open_rule_count = m.get('OpenRuleCount')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        if m.get('SuggestRuleCount') is not None:
            self.suggest_rule_count = m.get('SuggestRuleCount')
        return self


class GetClusterRuleSummaryResponseBody(TeaModel):
    def __init__(
        self,
        cluster_rule_summary: GetClusterRuleSummaryResponseBodyClusterRuleSummary = None,
        request_id: str = None,
    ):
        self.cluster_rule_summary = cluster_rule_summary
        self.request_id = request_id

    def validate(self):
        if self.cluster_rule_summary:
            self.cluster_rule_summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_rule_summary is not None:
            result['ClusterRuleSummary'] = self.cluster_rule_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterRuleSummary') is not None:
            temp_model = GetClusterRuleSummaryResponseBodyClusterRuleSummary()
            self.cluster_rule_summary = temp_model.from_map(m['ClusterRuleSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterRuleSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterRuleSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterRuleSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterSuspEventStatisticsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        from_: str = None,
    ):
        self.cluster_id = cluster_id
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class GetClusterSuspEventStatisticsResponseBodySuspStatistics(TeaModel):
    def __init__(
        self,
        remind: int = None,
        serious: int = None,
        suspicious: int = None,
    ):
        self.remind = remind
        self.serious = serious
        self.suspicious = suspicious

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind is not None:
            result['Remind'] = self.remind
        if self.serious is not None:
            result['Serious'] = self.serious
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Remind') is not None:
            self.remind = m.get('Remind')
        if m.get('Serious') is not None:
            self.serious = m.get('Serious')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        return self


class GetClusterSuspEventStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        susp_statistics: GetClusterSuspEventStatisticsResponseBodySuspStatistics = None,
    ):
        self.request_id = request_id
        self.susp_statistics = susp_statistics

    def validate(self):
        if self.susp_statistics:
            self.susp_statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.susp_statistics is not None:
            result['SuspStatistics'] = self.susp_statistics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuspStatistics') is not None:
            temp_model = GetClusterSuspEventStatisticsResponseBodySuspStatistics()
            self.susp_statistics = temp_model.from_map(m['SuspStatistics'])
        return self


class GetClusterSuspEventStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterSuspEventStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterSuspEventStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileDetectApiInvokeInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        auth_count: int = None,
        expire: int = None,
        flow_rate: int = None,
        remain_auth_count: int = None,
        sale_version: int = None,
        time_unit: str = None,
    ):
        self.auth_count = auth_count
        self.expire = expire
        self.flow_rate = flow_rate
        self.remain_auth_count = remain_auth_count
        self.sale_version = sale_version
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_count is not None:
            result['AuthCount'] = self.auth_count
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.flow_rate is not None:
            result['FlowRate'] = self.flow_rate
        if self.remain_auth_count is not None:
            result['RemainAuthCount'] = self.remain_auth_count
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthCount') is not None:
            self.auth_count = m.get('AuthCount')
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('FlowRate') is not None:
            self.flow_rate = m.get('FlowRate')
        if m.get('RemainAuthCount') is not None:
            self.remain_auth_count = m.get('RemainAuthCount')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        return self


class GetFileDetectApiInvokeInfoResponseBody(TeaModel):
    def __init__(
        self,
        data: GetFileDetectApiInvokeInfoResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetFileDetectApiInvokeInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetFileDetectApiInvokeInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileDetectApiInvokeInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileDetectApiInvokeInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileDetectResultRequest(TeaModel):
    def __init__(
        self,
        hash_key_list: List[str] = None,
        source_ip: str = None,
        type: int = None,
    ):
        self.hash_key_list = hash_key_list
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key_list is not None:
            result['HashKeyList'] = self.hash_key_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HashKeyList') is not None:
            self.hash_key_list = m.get('HashKeyList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetFileDetectResultResponseBodyResultList(TeaModel):
    def __init__(
        self,
        code: str = None,
        ext: str = None,
        hash_key: str = None,
        message: str = None,
        result: int = None,
        score: int = None,
        virus_type: str = None,
    ):
        self.code = code
        self.ext = ext
        self.hash_key = hash_key
        self.message = message
        self.result = result
        self.score = score
        self.virus_type = virus_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result
        if self.score is not None:
            result['Score'] = self.score
        if self.virus_type is not None:
            result['VirusType'] = self.virus_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('VirusType') is not None:
            self.virus_type = m.get('VirusType')
        return self


class GetFileDetectResultResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_list: List[GetFileDetectResultResponseBodyResultList] = None,
    ):
        self.request_id = request_id
        self.result_list = result_list

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = GetFileDetectResultResponseBodyResultList()
                self.result_list.append(temp_model.from_map(k))
        return self


class GetFileDetectResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileDetectResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileDetectResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotNodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        node_id: str = None,
    ):
        self.lang = lang
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class GetHoneypotNodeResponseBodyHoneypotNode(TeaModel):
    def __init__(
        self,
        allow_honeypot_access_internet: bool = None,
        create_time: str = None,
        ecs_instance_id: str = None,
        honeypot_total_count: int = None,
        honeypot_used_count: int = None,
        node_id: str = None,
        node_ip: str = None,
        node_name: str = None,
        probe_total_count: int = None,
        probe_used_count: int = None,
        security_group_probe_ip_list: List[str] = None,
        total_status: int = None,
        upgrade_available: bool = None,
    ):
        self.allow_honeypot_access_internet = allow_honeypot_access_internet
        self.create_time = create_time
        self.ecs_instance_id = ecs_instance_id
        self.honeypot_total_count = honeypot_total_count
        self.honeypot_used_count = honeypot_used_count
        self.node_id = node_id
        self.node_ip = node_ip
        self.node_name = node_name
        self.probe_total_count = probe_total_count
        self.probe_used_count = probe_used_count
        self.security_group_probe_ip_list = security_group_probe_ip_list
        self.total_status = total_status
        self.upgrade_available = upgrade_available

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.honeypot_total_count is not None:
            result['HoneypotTotalCount'] = self.honeypot_total_count
        if self.honeypot_used_count is not None:
            result['HoneypotUsedCount'] = self.honeypot_used_count
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.probe_total_count is not None:
            result['ProbeTotalCount'] = self.probe_total_count
        if self.probe_used_count is not None:
            result['ProbeUsedCount'] = self.probe_used_count
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        if self.total_status is not None:
            result['TotalStatus'] = self.total_status
        if self.upgrade_available is not None:
            result['UpgradeAvailable'] = self.upgrade_available
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('HoneypotTotalCount') is not None:
            self.honeypot_total_count = m.get('HoneypotTotalCount')
        if m.get('HoneypotUsedCount') is not None:
            self.honeypot_used_count = m.get('HoneypotUsedCount')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('ProbeTotalCount') is not None:
            self.probe_total_count = m.get('ProbeTotalCount')
        if m.get('ProbeUsedCount') is not None:
            self.probe_used_count = m.get('ProbeUsedCount')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        if m.get('TotalStatus') is not None:
            self.total_status = m.get('TotalStatus')
        if m.get('UpgradeAvailable') is not None:
            self.upgrade_available = m.get('UpgradeAvailable')
        return self


class GetHoneypotNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        honeypot_node: GetHoneypotNodeResponseBodyHoneypotNode = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.honeypot_node = honeypot_node
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.honeypot_node:
            self.honeypot_node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_node is not None:
            result['HoneypotNode'] = self.honeypot_node.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotNode') is not None:
            temp_model = GetHoneypotNodeResponseBodyHoneypotNode()
            self.honeypot_node = temp_model.from_map(m['HoneypotNode'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHoneypotNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotPresetRequest(TeaModel):
    def __init__(
        self,
        honeypot_preset_id: str = None,
        lang: str = None,
    ):
        # The ID of the honeypot template.
        # 
        # > You can call the [ListHoneypotPreset](~~ListHoneypotPreset~~) operation to query the IDs of honeypot templates.
        self.honeypot_preset_id = honeypot_preset_id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class GetHoneypotPresetResponseBodyDataFileInfoList(TeaModel):
    def __init__(
        self,
        file_id: str = None,
        file_name: str = None,
        oss_url: str = None,
    ):
        # The ID of the uploaded file.
        self.file_id = file_id
        # The name of the uploaded file.
        self.file_name = file_name
        # The download URL.
        self.oss_url = oss_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.oss_url is not None:
            result['OssUrl'] = self.oss_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('OssUrl') is not None:
            self.oss_url = m.get('OssUrl')
        return self


class GetHoneypotPresetResponseBodyData(TeaModel):
    def __init__(
        self,
        control_node_name: str = None,
        file_info_list: List[GetHoneypotPresetResponseBodyDataFileInfoList] = None,
        honeypot_image_display_name: str = None,
        honeypot_image_name: str = None,
        honeypot_preset_id: str = None,
        meta: str = None,
        node_id: str = None,
        preset_name: str = None,
        preset_type: str = None,
    ):
        # The name of the management node.
        self.control_node_name = control_node_name
        # An array that consists of the configurations of the uploaded file.
        self.file_info_list = file_info_list
        # The display name of the honeypot image.
        self.honeypot_image_display_name = honeypot_image_display_name
        # The name of the honeypot image.
        self.honeypot_image_name = honeypot_image_name
        # The ID of the honeypot template.
        self.honeypot_preset_id = honeypot_preset_id
        # The custom configuration of the honeypot template.
        self.meta = meta
        # The ID of the management node.
        self.node_id = node_id
        # The custom name of the honeypot template.
        self.preset_name = preset_name
        # The type of the honeypot template. Valid values:
        # 
        # *   **TEMP**: automatically generated template
        # *   **CUSTOM**: custom template
        # *   **DEFAULT**: default template
        self.preset_type = preset_type

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        if self.preset_type is not None:
            result['PresetType'] = self.preset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetHoneypotPresetResponseBodyDataFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        if m.get('PresetType') is not None:
            self.preset_type = m.get('PresetType')
        return self


class GetHoneypotPresetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHoneypotPresetResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The information about the honeypot template.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHoneypotPresetResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotPresetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHoneypotPresetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotProbeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        probe_id: str = None,
    ):
        # **zh**
        # 
        # - **zh**
        # - **en**
        self.lang = lang
        self.probe_id = probe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class GetHoneypotProbeResponseBodyDataControlNode(TeaModel):
    def __init__(
        self,
        ecs_instance_id: str = None,
        node_id: str = None,
        node_name: str = None,
    ):
        self.ecs_instance_id = ecs_instance_id
        self.node_id = node_id
        self.node_name = node_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        return self


class GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort(TeaModel):
    def __init__(
        self,
        id: int = None,
        ports: str = None,
        probe_id: str = None,
        service_ip_list: List[str] = None,
        status: int = None,
    ):
        self.id = id
        self.ports = ports
        self.probe_id = probe_id
        self.service_ip_list = service_ip_list
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.ports is not None:
            result['Ports'] = self.ports
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ports') is not None:
            self.ports = m.get('Ports')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList(TeaModel):
    def __init__(
        self,
        bind_port: bool = None,
        end_port: int = None,
        err: str = None,
        fixed: bool = None,
        id: int = None,
        msg: str = None,
        proto: str = None,
        start_port: int = None,
        status: int = None,
        target_port: int = None,
    ):
        self.bind_port = bind_port
        self.end_port = end_port
        self.err = err
        self.fixed = fixed
        self.id = id
        self.msg = msg
        self.proto = proto
        self.start_port = start_port
        self.status = status
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_port is not None:
            result['BindPort'] = self.bind_port
        if self.end_port is not None:
            result['EndPort'] = self.end_port
        if self.err is not None:
            result['Err'] = self.err
        if self.fixed is not None:
            result['Fixed'] = self.fixed
        if self.id is not None:
            result['Id'] = self.id
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.start_port is not None:
            result['StartPort'] = self.start_port
        if self.status is not None:
            result['Status'] = self.status
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindPort') is not None:
            self.bind_port = m.get('BindPort')
        if m.get('EndPort') is not None:
            self.end_port = m.get('EndPort')
        if m.get('Err') is not None:
            self.err = m.get('Err')
        if m.get('Fixed') is not None:
            self.fixed = m.get('Fixed')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('StartPort') is not None:
            self.start_port = m.get('StartPort')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class GetHoneypotProbeResponseBodyDataHoneypotProbeBindList(TeaModel):
    def __init__(
        self,
        bind_id: str = None,
        bind_port_list: List[GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList] = None,
        honeypot_id: str = None,
        service_ip_list: List[str] = None,
        status: int = None,
    ):
        self.bind_id = bind_id
        self.bind_port_list = bind_port_list
        self.honeypot_id = honeypot_id
        self.service_ip_list = service_ip_list
        self.status = status

    def validate(self):
        if self.bind_port_list:
            for k in self.bind_port_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_id is not None:
            result['BindId'] = self.bind_id
        result['BindPortList'] = []
        if self.bind_port_list is not None:
            for k in self.bind_port_list:
                result['BindPortList'].append(k.to_map() if k else None)
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindId') is not None:
            self.bind_id = m.get('BindId')
        self.bind_port_list = []
        if m.get('BindPortList') is not None:
            for k in m.get('BindPortList'):
                temp_model = GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList()
                self.bind_port_list.append(temp_model.from_map(k))
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetHoneypotProbeResponseBodyData(TeaModel):
    def __init__(
        self,
        arp: bool = None,
        can_listen_ip_list: List[str] = None,
        cidr_list: List[str] = None,
        control_node: GetHoneypotProbeResponseBodyDataControlNode = None,
        cpu_load: float = None,
        deploy_time: int = None,
        display_name: str = None,
        honey_pot_probe_scan_port: GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort = None,
        honeypot_probe_bind_list: List[GetHoneypotProbeResponseBodyDataHoneypotProbeBindList] = None,
        host_ip: str = None,
        listen_ip_list: List[str] = None,
        memory_load: float = None,
        os_type: str = None,
        ping: bool = None,
        probe_id: str = None,
        probe_type: str = None,
        probe_version: str = None,
        proxy_ip: str = None,
        status: int = None,
        uuid: str = None,
        vpc_id: str = None,
    ):
        self.arp = arp
        self.can_listen_ip_list = can_listen_ip_list
        self.cidr_list = cidr_list
        self.control_node = control_node
        self.cpu_load = cpu_load
        self.deploy_time = deploy_time
        self.display_name = display_name
        self.honey_pot_probe_scan_port = honey_pot_probe_scan_port
        self.honeypot_probe_bind_list = honeypot_probe_bind_list
        self.host_ip = host_ip
        self.listen_ip_list = listen_ip_list
        self.memory_load = memory_load
        self.os_type = os_type
        self.ping = ping
        self.probe_id = probe_id
        self.probe_type = probe_type
        self.probe_version = probe_version
        self.proxy_ip = proxy_ip
        self.status = status
        self.uuid = uuid
        self.vpc_id = vpc_id

    def validate(self):
        if self.control_node:
            self.control_node.validate()
        if self.honey_pot_probe_scan_port:
            self.honey_pot_probe_scan_port.validate()
        if self.honeypot_probe_bind_list:
            for k in self.honeypot_probe_bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.can_listen_ip_list is not None:
            result['CanListenIpList'] = self.can_listen_ip_list
        if self.cidr_list is not None:
            result['CidrList'] = self.cidr_list
        if self.control_node is not None:
            result['ControlNode'] = self.control_node.to_map()
        if self.cpu_load is not None:
            result['CpuLoad'] = self.cpu_load
        if self.deploy_time is not None:
            result['DeployTime'] = self.deploy_time
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.honey_pot_probe_scan_port is not None:
            result['HoneyPotProbeScanPort'] = self.honey_pot_probe_scan_port.to_map()
        result['HoneypotProbeBindList'] = []
        if self.honeypot_probe_bind_list is not None:
            for k in self.honeypot_probe_bind_list:
                result['HoneypotProbeBindList'].append(k.to_map() if k else None)
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.listen_ip_list is not None:
            result['ListenIpList'] = self.listen_ip_list
        if self.memory_load is not None:
            result['MemoryLoad'] = self.memory_load
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.proxy_ip is not None:
            result['ProxyIp'] = self.proxy_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('CanListenIpList') is not None:
            self.can_listen_ip_list = m.get('CanListenIpList')
        if m.get('CidrList') is not None:
            self.cidr_list = m.get('CidrList')
        if m.get('ControlNode') is not None:
            temp_model = GetHoneypotProbeResponseBodyDataControlNode()
            self.control_node = temp_model.from_map(m['ControlNode'])
        if m.get('CpuLoad') is not None:
            self.cpu_load = m.get('CpuLoad')
        if m.get('DeployTime') is not None:
            self.deploy_time = m.get('DeployTime')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('HoneyPotProbeScanPort') is not None:
            temp_model = GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort()
            self.honey_pot_probe_scan_port = temp_model.from_map(m['HoneyPotProbeScanPort'])
        self.honeypot_probe_bind_list = []
        if m.get('HoneypotProbeBindList') is not None:
            for k in m.get('HoneypotProbeBindList'):
                temp_model = GetHoneypotProbeResponseBodyDataHoneypotProbeBindList()
                self.honeypot_probe_bind_list.append(temp_model.from_map(k))
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('ListenIpList') is not None:
            self.listen_ip_list = m.get('ListenIpList')
        if m.get('MemoryLoad') is not None:
            self.memory_load = m.get('MemoryLoad')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('ProxyIp') is not None:
            self.proxy_ip = m.get('ProxyIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetHoneypotProbeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHoneypotProbeResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHoneypotProbeResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotProbeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHoneypotProbeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetImageScanNumInPeriodRequest(TeaModel):
    def __init__(
        self,
        past_day: str = None,
    ):
        self.past_day = past_day

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.past_day is not None:
            result['PastDay'] = self.past_day
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PastDay') is not None:
            self.past_day = m.get('PastDay')
        return self


class GetImageScanNumInPeriodResponseBodyImageScanData(TeaModel):
    def __init__(
        self,
        image_scan_count: int = None,
    ):
        self.image_scan_count = image_scan_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_count is not None:
            result['ImageScanCount'] = self.image_scan_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageScanCount') is not None:
            self.image_scan_count = m.get('ImageScanCount')
        return self


class GetImageScanNumInPeriodResponseBody(TeaModel):
    def __init__(
        self,
        image_scan_data: GetImageScanNumInPeriodResponseBodyImageScanData = None,
        request_id: str = None,
    ):
        self.image_scan_data = image_scan_data
        self.request_id = request_id

    def validate(self):
        if self.image_scan_data:
            self.image_scan_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_data is not None:
            result['ImageScanData'] = self.image_scan_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageScanData') is not None:
            temp_model = GetImageScanNumInPeriodResponseBodyImageScanData()
            self.image_scan_data = temp_model.from_map(m['ImageScanData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetImageScanNumInPeriodResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetImageScanNumInPeriodResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetImageScanNumInPeriodResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterceptionRuleDetailRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        rule_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        ports: List[str] = None,
        rule_type: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.image_list = image_list
        self.namespace = namespace
        self.ports = ports
        self.rule_type = rule_type
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.ports is not None:
            result['Ports'] = self.ports
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Ports') is not None:
            self.ports = m.get('Ports')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        rule_type: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.image_list = image_list
        self.namespace = namespace
        self.rule_type = rule_type
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail(TeaModel):
    def __init__(
        self,
        dst_target: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        rule_type: str = None,
        src_target: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget = None,
    ):
        self.dst_target = dst_target
        self.intercept_type = intercept_type
        self.order_index = order_index
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_switch = rule_switch
        self.rule_type = rule_type
        self.src_target = src_target

    def validate(self):
        if self.dst_target:
            self.dst_target.validate()
        if self.src_target:
            self.src_target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_target is not None:
            result['DstTarget'] = self.dst_target.to_map()
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.src_target is not None:
            result['SrcTarget'] = self.src_target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstTarget') is not None:
            temp_model = GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget()
            self.dst_target = temp_model.from_map(m['DstTarget'])
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('SrcTarget') is not None:
            temp_model = GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget()
            self.src_target = temp_model.from_map(m['SrcTarget'])
        return self


class GetInterceptionRuleDetailResponseBody(TeaModel):
    def __init__(
        self,
        interception_rule_detail: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail = None,
        request_id: str = None,
    ):
        self.interception_rule_detail = interception_rule_detail
        self.request_id = request_id

    def validate(self):
        if self.interception_rule_detail:
            self.interception_rule_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interception_rule_detail is not None:
            result['InterceptionRuleDetail'] = self.interception_rule_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterceptionRuleDetail') is not None:
            temp_model = GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail()
            self.interception_rule_detail = temp_model.from_map(m['InterceptionRuleDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInterceptionRuleDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterceptionRuleDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterceptionRuleDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterceptionSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class GetInterceptionSummaryResponseBodyInterceptionSummary(TeaModel):
    def __init__(
        self,
        close_cluster_count: int = None,
        close_rule_count: int = None,
        cluster_count: int = None,
        interception_count_in_days: int = None,
        open_cluster_count: int = None,
        open_rule_count: int = None,
        risk_count_180day: int = None,
        risk_count_30day: int = None,
        risk_count_today: int = None,
        rule_count: int = None,
    ):
        self.close_cluster_count = close_cluster_count
        self.close_rule_count = close_rule_count
        self.cluster_count = cluster_count
        self.interception_count_in_days = interception_count_in_days
        self.open_cluster_count = open_cluster_count
        self.open_rule_count = open_rule_count
        self.risk_count_180day = risk_count_180day
        self.risk_count_30day = risk_count_30day
        self.risk_count_today = risk_count_today
        self.rule_count = rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_cluster_count is not None:
            result['CloseClusterCount'] = self.close_cluster_count
        if self.close_rule_count is not None:
            result['CloseRuleCount'] = self.close_rule_count
        if self.cluster_count is not None:
            result['ClusterCount'] = self.cluster_count
        if self.interception_count_in_days is not None:
            result['InterceptionCountInDays'] = self.interception_count_in_days
        if self.open_cluster_count is not None:
            result['OpenClusterCount'] = self.open_cluster_count
        if self.open_rule_count is not None:
            result['OpenRuleCount'] = self.open_rule_count
        if self.risk_count_180day is not None:
            result['RiskCount180Day'] = self.risk_count_180day
        if self.risk_count_30day is not None:
            result['RiskCount30Day'] = self.risk_count_30day
        if self.risk_count_today is not None:
            result['RiskCountToday'] = self.risk_count_today
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloseClusterCount') is not None:
            self.close_cluster_count = m.get('CloseClusterCount')
        if m.get('CloseRuleCount') is not None:
            self.close_rule_count = m.get('CloseRuleCount')
        if m.get('ClusterCount') is not None:
            self.cluster_count = m.get('ClusterCount')
        if m.get('InterceptionCountInDays') is not None:
            self.interception_count_in_days = m.get('InterceptionCountInDays')
        if m.get('OpenClusterCount') is not None:
            self.open_cluster_count = m.get('OpenClusterCount')
        if m.get('OpenRuleCount') is not None:
            self.open_rule_count = m.get('OpenRuleCount')
        if m.get('RiskCount180Day') is not None:
            self.risk_count_180day = m.get('RiskCount180Day')
        if m.get('RiskCount30Day') is not None:
            self.risk_count_30day = m.get('RiskCount30Day')
        if m.get('RiskCountToday') is not None:
            self.risk_count_today = m.get('RiskCountToday')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        return self


class GetInterceptionSummaryResponseBody(TeaModel):
    def __init__(
        self,
        interception_summary: GetInterceptionSummaryResponseBodyInterceptionSummary = None,
        request_id: str = None,
    ):
        self.interception_summary = interception_summary
        self.request_id = request_id

    def validate(self):
        if self.interception_summary:
            self.interception_summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interception_summary is not None:
            result['InterceptionSummary'] = self.interception_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterceptionSummary') is not None:
            temp_model = GetInterceptionSummaryResponseBodyInterceptionSummary()
            self.interception_summary = temp_model.from_map(m['InterceptionSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInterceptionSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterceptionSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterceptionSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterceptionTargetDetailRequest(TeaModel):
    def __init__(
        self,
        target_id: int = None,
    ):
        self.target_id = target_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class GetInterceptionTargetDetailResponseBodyRuleTarget(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.image_list = image_list
        self.namespace = namespace
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class GetInterceptionTargetDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_target: GetInterceptionTargetDetailResponseBodyRuleTarget = None,
    ):
        self.request_id = request_id
        self.rule_target = rule_target

    def validate(self):
        if self.rule_target:
            self.rule_target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_target is not None:
            result['RuleTarget'] = self.rule_target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleTarget') is not None:
            temp_model = GetInterceptionTargetDetailResponseBodyRuleTarget()
            self.rule_target = temp_model.from_map(m['RuleTarget'])
        return self


class GetInterceptionTargetDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterceptionTargetDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterceptionTargetDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLastOnceTaskInfoRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
        task_name: str = None,
        task_type: str = None,
    ):
        # The number of tasks that have been completed.
        self.source = source
        # The ID of the latest scan task.
        self.task_name = task_name
        # The total number of entries returned.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetLastOnceTaskInfoResponseBodyTaskInfo(TeaModel):
    def __init__(
        self,
        progress: int = None,
        result: str = None,
        status: str = None,
    ):
        self.progress = progress
        self.result = result
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetLastOnceTaskInfoResponseBody(TeaModel):
    def __init__(
        self,
        collect_time: int = None,
        finish_count: int = None,
        request_id: str = None,
        task_id: int = None,
        task_info: GetLastOnceTaskInfoResponseBodyTaskInfo = None,
        total_count: int = None,
    ):
        # The information about the latest task.
        self.collect_time = collect_time
        self.finish_count = finish_count
        # The status of the task. Valid values:
        # 
        # *   **INIT**: The task is not started.
        # *   **START**: The task is started.
        # *   **SUCCESS**: The task is complete.
        # *   **TIMEOUT**: The task timed out.
        self.request_id = request_id
        # The result of the scan task. Valid values:
        # 
        # *   **SUCCESS**: The task is successful.
        # *   **TASK\_NOT\_SUPPORT_REGION**: The images are deployed in a region that is not supported by container image scan.
        # *   **TASK\_NOT_EXISTS**: The task does not exist.
        self.task_id = task_id
        self.task_info = task_info
        # The progress of the task in percentage.
        self.total_count = total_count

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = GetLastOnceTaskInfoResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetLastOnceTaskInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLastOnceTaskInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLastOnceTaskInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetModuleConfigRequest(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_size: str = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class GetModuleConfigResponseBodyModuleConfigListItems(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        ip: str = None,
        region: str = None,
        uuid: str = None,
    ):
        # The ID of the server group to which the server belongs.
        self.group_id = group_id
        # The instance ID of the server.
        self.instance_id = instance_id
        # The instance name of the server.
        self.instance_name = instance_name
        # The IP address of the server.
        self.ip = ip
        # The region in which the server resides.
        self.region = region
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.region is not None:
            result['Region'] = self.region
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetModuleConfigResponseBodyModuleConfigList(TeaModel):
    def __init__(
        self,
        config_name: str = None,
        items: List[GetModuleConfigResponseBodyModuleConfigListItems] = None,
        module_name: str = None,
    ):
        # The name of the configuration.
        self.config_name = config_name
        # An array that consists of the configuration items.
        self.items = items
        # The name of the module.
        self.module_name = module_name

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = GetModuleConfigResponseBodyModuleConfigListItems()
                self.items.append(temp_model.from_map(k))
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class GetModuleConfigResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetModuleConfigResponseBody(TeaModel):
    def __init__(
        self,
        http_status_code: int = None,
        module_config_list: List[GetModuleConfigResponseBodyModuleConfigList] = None,
        page_info: GetModuleConfigResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response code returned.
        self.http_status_code = http_status_code
        # An array that consists of the configurations of the module.
        self.module_config_list = module_config_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.module_config_list:
            for k in self.module_config_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ModuleConfigList'] = []
        if self.module_config_list is not None:
            for k in self.module_config_list:
                result['ModuleConfigList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.module_config_list = []
        if m.get('ModuleConfigList') is not None:
            for k in m.get('ModuleConfigList'):
                temp_model = GetModuleConfigResponseBodyModuleConfigList()
                self.module_config_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = GetModuleConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetModuleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetModuleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetModuleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnceTaskResultInfoRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        task_name: str = None,
        task_type: str = None,
    ):
        # The number of tasks that were completed.
        self.task_id = task_id
        # The ID of the scan task.
        self.task_name = task_name
        # The total number of entries returned.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetOnceTaskResultInfoResponseBodyTaskInfo(TeaModel):
    def __init__(
        self,
        status: str = None,
    ):
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetOnceTaskResultInfoResponseBody(TeaModel):
    def __init__(
        self,
        collect_time: int = None,
        finish_count: int = None,
        request_id: str = None,
        task_id: int = None,
        task_info: GetOnceTaskResultInfoResponseBodyTaskInfo = None,
        total_count: int = None,
    ):
        # The information about the task.
        self.collect_time = collect_time
        self.finish_count = finish_count
        # The status of the task. Valid values:
        # 
        # *   **INIT**: The task is not started.
        # *   **START**: The task is started.
        # *   **SUCCESS**: The task is complete.
        # *   **TIMEOUT**: The task times out.
        self.request_id = request_id
        self.task_id = task_id
        self.task_info = task_info
        self.total_count = total_count

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = GetOnceTaskResultInfoResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOnceTaskResultInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOnceTaskResultInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnceTaskResultInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPropertyScheduleConfigRequest(TeaModel):
    def __init__(
        self,
        type: str = None,
        uuid: str = None,
    ):
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig(TeaModel):
    def __init__(
        self,
        next_schedule_time: int = None,
        schedule_time: str = None,
        type: str = None,
    ):
        self.next_schedule_time = next_schedule_time
        self.schedule_time = schedule_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_schedule_time is not None:
            result['NextScheduleTime'] = self.next_schedule_time
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextScheduleTime') is not None:
            self.next_schedule_time = m.get('NextScheduleTime')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPropertyScheduleConfigResponseBody(TeaModel):
    def __init__(
        self,
        property_schedule_config: GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig = None,
        request_id: str = None,
    ):
        self.property_schedule_config = property_schedule_config
        self.request_id = request_id

    def validate(self):
        if self.property_schedule_config:
            self.property_schedule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.property_schedule_config is not None:
            result['PropertyScheduleConfig'] = self.property_schedule_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PropertyScheduleConfig') is not None:
            temp_model = GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig()
            self.property_schedule_config = temp_model.from_map(m['PropertyScheduleConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPropertyScheduleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPropertyScheduleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRulesCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        total_system_client_rule_count: int = None,
        total_user_define_rule_count: int = None,
    ):
        self.request_id = request_id
        self.total_system_client_rule_count = total_system_client_rule_count
        self.total_user_define_rule_count = total_user_define_rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_system_client_rule_count is not None:
            result['TotalSystemClientRuleCount'] = self.total_system_client_rule_count
        if self.total_user_define_rule_count is not None:
            result['TotalUserDefineRuleCount'] = self.total_user_define_rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalSystemClientRuleCount') is not None:
            self.total_system_client_rule_count = m.get('TotalSystemClientRuleCount')
        if m.get('TotalUserDefineRuleCount') is not None:
            self.total_user_define_rule_count = m.get('TotalUserDefineRuleCount')
        return self


class GetRulesCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRulesCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRulesCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSuspiciousStatisticsRequest(TeaModel):
    def __init__(
        self,
        group_id_list: str = None,
        source_ip: str = None,
    ):
        # The ID of the asset group. Separate multiple IDs with commas (,).
        # 
        # > You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.
        self.group_id_list = group_id_list
        # The source IP address of the request.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class GetSuspiciousStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        remind_count: int = None,
        request_id: str = None,
        serious_count: int = None,
        suspicious_count: int = None,
        total_count: int = None,
    ):
        # The number of alerts whose Emergency level is Reminder.
        self.remind_count = remind_count
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The number of alerts whose Emergency level is Urgent.
        self.serious_count = serious_count
        # The number of alerts whose Emergency level is Suspicious.
        self.suspicious_count = suspicious_count
        # The total number of alerts.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind_count is not None:
            result['RemindCount'] = self.remind_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.serious_count is not None:
            result['SeriousCount'] = self.serious_count
        if self.suspicious_count is not None:
            result['SuspiciousCount'] = self.suspicious_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RemindCount') is not None:
            self.remind_count = m.get('RemindCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SeriousCount') is not None:
            self.serious_count = m.get('SeriousCount')
        if m.get('SuspiciousCount') is not None:
            self.suspicious_count = m.get('SuspiciousCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetSuspiciousStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSuspiciousStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSuspiciousStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVulStatisticsRequest(TeaModel):
    def __init__(
        self,
        group_id_list: str = None,
        source_ip: str = None,
        type_list: str = None,
    ):
        self.group_id_list = group_id_list
        self.source_ip = source_ip
        self.type_list = type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class GetVulStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vul_asap_sum: int = None,
        vul_later_sum: int = None,
        vul_nntf_sum: int = None,
    ):
        self.request_id = request_id
        self.vul_asap_sum = vul_asap_sum
        self.vul_later_sum = vul_later_sum
        self.vul_nntf_sum = vul_nntf_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        return self


class GetVulStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVulStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVulStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVulWhitelistRequest(TeaModel):
    def __init__(
        self,
        vul_whitelist_id: int = None,
    ):
        # The ID of the whitelist.
        self.vul_whitelist_id = vul_whitelist_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vul_whitelist_id is not None:
            result['VulWhitelistId'] = self.vul_whitelist_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VulWhitelistId') is not None:
            self.vul_whitelist_id = m.get('VulWhitelistId')
        return self


class GetVulWhitelistResponseBodyVulWhitelist(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        id: int = None,
        name: str = None,
        reason: str = None,
        target: str = None,
        type: str = None,
        whitelist: str = None,
    ):
        # The alias of the vulnerability.
        self.alias_name = alias_name
        # The ID of the whitelist.
        self.id = id
        # The name of the vulnerability.
        self.name = name
        # The reason why the vulnerability is added to the whitelist.
        self.reason = reason
        # The application scope of the rule. The value is a JSON string that contains the following fields:
        # 
        # *   **type**: the type of the assets to which the rule is applied. Valid values:
        # 
        #     *   **Uuid**: server
        #     *   **GroupId**: server group
        # 
        # *   **groupIds**: the ID of the server group
        # 
        # *   **uuids**: the UUID of the server
        # 
        # > If this parameter is empty, the rule is applied to all types of assets.
        self.target = target
        # The type of the vulnerability.
        self.type = type
        # The information about the vulnerability that is added to the whitelist. The value is a JSON string that contains the following fields:
        # 
        # *   **Name**: the name of the vulnerability.
        # 
        # *   **Type**: the type of the vulnerability. Valid values:
        # 
        #     *   **cve**: Linux software vulnerability
        #     *   **sys**: Windows system vulnerability
        #     *   **cms**: Web-CMS vulnerability
        #     *   **app**: application vulnerability
        #     *   **emg**: urgent vulnerabilities
        # 
        # *   **AliasName**: the alias of the vulnerability.
        self.whitelist = whitelist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class GetVulWhitelistResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vul_whitelist: GetVulWhitelistResponseBodyVulWhitelist = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The information about the whitelist.
        self.vul_whitelist = vul_whitelist

    def validate(self):
        if self.vul_whitelist:
            self.vul_whitelist.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_whitelist is not None:
            result['VulWhitelist'] = self.vul_whitelist.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulWhitelist') is not None:
            temp_model = GetVulWhitelistResponseBodyVulWhitelist()
            self.vul_whitelist = temp_model.from_map(m['VulWhitelist'])
        return self


class GetVulWhitelistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVulWhitelistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HandleSecurityEventsRequest(TeaModel):
    def __init__(
        self,
        mark_batch: str = None,
        mark_miss_param: str = None,
        operation_code: str = None,
        operation_params: str = None,
        security_event_ids: List[str] = None,
        source_ip: str = None,
    ):
        self.mark_batch = mark_batch
        # HandleSecurityEvents
        self.mark_miss_param = mark_miss_param
        # Specifies whether to add multiple alert events to the whitelist at a time. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.operation_code = operation_code
        # Handles alert events.
        self.operation_params = operation_params
        self.security_event_ids = security_event_ids
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mark_batch is not None:
            result['MarkBatch'] = self.mark_batch
        if self.mark_miss_param is not None:
            result['MarkMissParam'] = self.mark_miss_param
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MarkBatch') is not None:
            self.mark_batch = m.get('MarkBatch')
        if m.get('MarkMissParam') is not None:
            self.mark_miss_param = m.get('MarkMissParam')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class HandleSecurityEventsResponseBodyHandleSecurityEventsResponse(TeaModel):
    def __init__(
        self,
        task_id: int = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class HandleSecurityEventsResponseBody(TeaModel):
    def __init__(
        self,
        handle_security_events_response: HandleSecurityEventsResponseBodyHandleSecurityEventsResponse = None,
        request_id: str = None,
    ):
        self.handle_security_events_response = handle_security_events_response
        self.request_id = request_id

    def validate(self):
        if self.handle_security_events_response:
            self.handle_security_events_response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.handle_security_events_response is not None:
            result['HandleSecurityEventsResponse'] = self.handle_security_events_response.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HandleSecurityEventsResponse') is not None:
            temp_model = HandleSecurityEventsResponseBodyHandleSecurityEventsResponse()
            self.handle_security_events_response = temp_model.from_map(m['HandleSecurityEventsResponse'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HandleSecurityEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: HandleSecurityEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HandleSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HandleSimilarSecurityEventsRequest(TeaModel):
    def __init__(
        self,
        mark_miss_param: str = None,
        operation_code: str = None,
        operation_params: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        task_id: int = None,
    ):
        self.mark_miss_param = mark_miss_param
        self.operation_code = operation_code
        self.operation_params = operation_params
        self.resource_owner_id = resource_owner_id
        # HandleSimilarSecurityEvents
        self.source_ip = source_ip
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mark_miss_param is not None:
            result['MarkMissParam'] = self.mark_miss_param
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MarkMissParam') is not None:
            self.mark_miss_param = m.get('MarkMissParam')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class HandleSimilarSecurityEventsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HandleSimilarSecurityEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: HandleSimilarSecurityEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HandleSimilarSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class IgnoreCheckItemsRequestCheckAndRiskTypeList(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        risk_type: str = None,
    ):
        # The ID of the check item.
        self.check_id = check_id
        # The baseline type of the check item.
        self.risk_type = risk_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        return self


class IgnoreCheckItemsRequest(TeaModel):
    def __init__(
        self,
        check_and_risk_type_list: List[IgnoreCheckItemsRequestCheckAndRiskTypeList] = None,
        lang: str = None,
        reason: str = None,
        type: int = None,
        uuid_list: List[str] = None,
    ):
        # The risk items.
        self.check_and_risk_type_list = check_and_risk_type_list
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The reason why you add the risk item to the whitelist.
        self.reason = reason
        # The operation that you want to perform on the risk item.Valid values:
        # *  **1**: adds the risk item to the whitelist
        # *  **2**: removes the risk item from the whitelist
        self.type = type
        # The UUIDs of the servers.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid_list = uuid_list

    def validate(self):
        if self.check_and_risk_type_list:
            for k in self.check_and_risk_type_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckAndRiskTypeList'] = []
        if self.check_and_risk_type_list is not None:
            for k in self.check_and_risk_type_list:
                result['CheckAndRiskTypeList'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_and_risk_type_list = []
        if m.get('CheckAndRiskTypeList') is not None:
            for k in m.get('CheckAndRiskTypeList'):
                temp_model = IgnoreCheckItemsRequestCheckAndRiskTypeList()
                self.check_and_risk_type_list.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class IgnoreCheckItemsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class IgnoreCheckItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: IgnoreCheckItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = IgnoreCheckItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class IgnoreHcCheckWarningsRequest(TeaModel):
    def __init__(
        self,
        check_ids: str = None,
        check_warning_ids: str = None,
        reason: str = None,
        risk_id: str = None,
        source_ip: str = None,
        type: int = None,
    ):
        self.check_ids = check_ids
        self.check_warning_ids = check_warning_ids
        self.reason = reason
        self.risk_id = risk_id
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.check_warning_ids is not None:
            result['CheckWarningIds'] = self.check_warning_ids
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('CheckWarningIds') is not None:
            self.check_warning_ids = m.get('CheckWarningIds')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class IgnoreHcCheckWarningsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class IgnoreHcCheckWarningsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: IgnoreHcCheckWarningsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = IgnoreHcCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallBackupClientRequest(TeaModel):
    def __init__(
        self,
        policy_version: str = None,
        uuid: str = None,
        uuid_list: List[str] = None,
    ):
        self.policy_version = policy_version
        self.uuid = uuid
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class InstallBackupClientResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallBackupClientResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallBackupClientResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallBackupClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallCloudMonitorRequest(TeaModel):
    def __init__(
        self,
        agent_access_key: str = None,
        agent_secret_key: str = None,
        argus_version: str = None,
        instance_id_list: List[str] = None,
        uuid_list: List[str] = None,
    ):
        # The AccessKey ID that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](~~114948~~) operation to query the AccessKey ID.
        # 
        # > This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.
        self.agent_access_key = agent_access_key
        # The AccessKey secret that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](~~114948~~) operation to query the AccessKey secret.
        # 
        # > This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.
        self.agent_secret_key = agent_secret_key
        # The version of the CloudMonitor agent that you want to install on the servers. For more information about the latest version of the CloudMonitor agent, see [Overview](~~183431~~).
        self.argus_version = argus_version
        # The IDs of the servers on which you want to install the CloudMonitor agent. Separate multiple IDs with commas (,).
        self.instance_id_list = instance_id_list
        # The UUIDs of the servers on which you want to install the CloudMonitor agent. Separate multiple UUIDs with commas (,).
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_access_key is not None:
            result['AgentAccessKey'] = self.agent_access_key
        if self.agent_secret_key is not None:
            result['AgentSecretKey'] = self.agent_secret_key
        if self.argus_version is not None:
            result['ArgusVersion'] = self.argus_version
        if self.instance_id_list is not None:
            result['InstanceIdList'] = self.instance_id_list
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAccessKey') is not None:
            self.agent_access_key = m.get('AgentAccessKey')
        if m.get('AgentSecretKey') is not None:
            self.agent_secret_key = m.get('AgentSecretKey')
        if m.get('ArgusVersion') is not None:
            self.argus_version = m.get('ArgusVersion')
        if m.get('InstanceIdList') is not None:
            self.instance_id_list = m.get('InstanceIdList')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class InstallCloudMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.code = code
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The error message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallCloudMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallCloudMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallCloudMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallPmAgentRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        type: str = None,
        uuids: str = None,
    ):
        self.lang = lang
        self.source_ip = source_ip
        self.type = type
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class InstallPmAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallPmAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallPmAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallPmAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallUniBackupAgentRequest(TeaModel):
    def __init__(
        self,
        policy_id: int = None,
    ):
        # The ID of the anti-ransomware policy.
        # 
        # > You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.policy_id = policy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class InstallUniBackupAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallUniBackupAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallUniBackupAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallUniBackupAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinWebLockProcessWhiteListRequest(TeaModel):
    def __init__(
        self,
        process_paths: List[str] = None,
        uuids: str = None,
    ):
        self.process_paths = process_paths
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.process_paths is not None:
            result['ProcessPaths'] = self.process_paths
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProcessPaths') is not None:
            self.process_paths = m.get('ProcessPaths')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class JoinWebLockProcessWhiteListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinWebLockProcessWhiteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinWebLockProcessWhiteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinWebLockProcessWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAssetSelectionSelectedTargetRequest(TeaModel):
    def __init__(
        self,
        selection_key: str = None,
        target_list: List[str] = None,
    ):
        self.selection_key = selection_key
        self.target_list = target_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selection_key is not None:
            result['SelectionKey'] = self.selection_key
        if self.target_list is not None:
            result['TargetList'] = self.target_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectionKey') is not None:
            self.selection_key = m.get('SelectionKey')
        if m.get('TargetList') is not None:
            self.target_list = m.get('TargetList')
        return self


class ListAssetSelectionSelectedTargetResponseBodyData(TeaModel):
    def __init__(
        self,
        target_id: str = None,
        target_name: str = None,
    ):
        self.target_id = target_id
        self.target_name = target_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        return self


class ListAssetSelectionSelectedTargetResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAssetSelectionSelectedTargetResponseBodyData] = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAssetSelectionSelectedTargetResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAssetSelectionSelectedTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAssetSelectionSelectedTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAssetSelectionSelectedTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAssetSelectionTargetRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        selection_key: str = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.selection_key = selection_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.selection_key is not None:
            result['SelectionKey'] = self.selection_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SelectionKey') is not None:
            self.selection_key = m.get('SelectionKey')
        return self


class ListAssetSelectionTargetResponseBodyData(TeaModel):
    def __init__(
        self,
        target_id: str = None,
        target_name: str = None,
    ):
        self.target_id = target_id
        self.target_name = target_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        return self


class ListAssetSelectionTargetResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAssetSelectionTargetResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAssetSelectionTargetResponseBodyData] = None,
        page_info: ListAssetSelectionTargetResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.data = data
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAssetSelectionTargetResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListAssetSelectionTargetResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAssetSelectionTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAssetSelectionTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAssetSelectionTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAvailableHoneypotRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
    ):
        # The ID of the management node to which the honeypot is deployed.
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ListAvailableHoneypotResponseBodyData(TeaModel):
    def __init__(
        self,
        honeypot_image_display_name: str = None,
        honeypot_image_id: str = None,
        honeypot_image_name: str = None,
        honeypot_image_type: str = None,
        honeypot_image_version: str = None,
        multiports: str = None,
        proto: str = None,
        service_port: str = None,
        template: str = None,
    ):
        # The display name of the image that is used for the honeypot.
        self.honeypot_image_display_name = honeypot_image_display_name
        # The ID of the image that is used for the honeypot.
        self.honeypot_image_id = honeypot_image_id
        # The name of the image that is used for the honeypot.
        self.honeypot_image_name = honeypot_image_name
        # The type of the image that is used for the honeypot.
        self.honeypot_image_type = honeypot_image_type
        # The version of the image that is used for the honeypot.
        self.honeypot_image_version = honeypot_image_version
        # The port that is supported by the honeypot. The value is in the JSON format. The value contains the following fields:
        # 
        # *   **log_type**: the log type
        # *   **proto**: the supported protocol
        # *   **description**: the description
        # *   **ports**: the supported ports
        # *   **port_str**: the supported port number of the string type
        # *   **type**: the type
        self.multiports = multiports
        # The protocol that is supported by the honeypot.
        self.proto = proto
        # The service port of the honeypot.
        self.service_port = service_port
        # The configuration template of the honeypot.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_image_type is not None:
            result['HoneypotImageType'] = self.honeypot_image_type
        if self.honeypot_image_version is not None:
            result['HoneypotImageVersion'] = self.honeypot_image_version
        if self.multiports is not None:
            result['Multiports'] = self.multiports
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.service_port is not None:
            result['ServicePort'] = self.service_port
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotImageType') is not None:
            self.honeypot_image_type = m.get('HoneypotImageType')
        if m.get('HoneypotImageVersion') is not None:
            self.honeypot_image_version = m.get('HoneypotImageVersion')
        if m.get('Multiports') is not None:
            self.multiports = m.get('Multiports')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('ServicePort') is not None:
            self.service_port = m.get('ServicePort')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class ListAvailableHoneypotResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: int = None,
        data: List[ListAvailableHoneypotResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The number of images that are used for the honeypot.
        self.count = count
        # An array consisting of the information about the images that are used for the honeypot.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The error message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAvailableHoneypotResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAvailableHoneypotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAvailableHoneypotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAvailableHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckInstanceResultRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        current_page: int = None,
        instance_id_key: str = None,
        instance_ids: List[str] = None,
        instance_name_key: str = None,
        lang: str = None,
        page_size: int = None,
        region_id_key: str = None,
        sort_types: List[str] = None,
        statuses: List[str] = None,
    ):
        self.check_id = check_id
        self.current_page = current_page
        self.instance_id_key = instance_id_key
        self.instance_ids = instance_ids
        self.instance_name_key = instance_name_key
        self.lang = lang
        self.page_size = page_size
        self.region_id_key = region_id_key
        self.sort_types = sort_types
        self.statuses = statuses

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id_key is not None:
            result['InstanceIdKey'] = self.instance_id_key
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_name_key is not None:
            result['InstanceNameKey'] = self.instance_name_key
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_key is not None:
            result['RegionIdKey'] = self.region_id_key
        if self.sort_types is not None:
            result['SortTypes'] = self.sort_types
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIdKey') is not None:
            self.instance_id_key = m.get('InstanceIdKey')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceNameKey') is not None:
            self.instance_name_key = m.get('InstanceNameKey')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdKey') is not None:
            self.region_id_key = m.get('RegionIdKey')
        if m.get('SortTypes') is not None:
            self.sort_types = m.get('SortTypes')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        return self


class ListCheckInstanceResultResponseBodyBasicData(TeaModel):
    def __init__(
        self,
        id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        region_id: str = None,
        status: str = None,
    ):
        self.id = id
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.region_id = region_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCheckInstanceResultResponseBodyColumnsGrids(TeaModel):
    def __init__(
        self,
        key: str = None,
        show_name: str = None,
        type: str = None,
    ):
        self.key = key
        self.show_name = show_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckInstanceResultResponseBodyColumns(TeaModel):
    def __init__(
        self,
        grids: List[ListCheckInstanceResultResponseBodyColumnsGrids] = None,
        key: str = None,
        search: bool = None,
        search_key: str = None,
        show_name: str = None,
        type: str = None,
    ):
        self.grids = grids
        self.key = key
        self.search = search
        self.search_key = search_key
        self.show_name = show_name
        self.type = type

    def validate(self):
        if self.grids:
            for k in self.grids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Grids'] = []
        if self.grids is not None:
            for k in self.grids:
                result['Grids'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.search is not None:
            result['Search'] = self.search
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.grids = []
        if m.get('Grids') is not None:
            for k in m.get('Grids'):
                temp_model = ListCheckInstanceResultResponseBodyColumnsGrids()
                self.grids.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Search') is not None:
            self.search = m.get('Search')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckInstanceResultResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: str = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckInstanceResultResponseBody(TeaModel):
    def __init__(
        self,
        basic_data: List[ListCheckInstanceResultResponseBodyBasicData] = None,
        checks: List[Dict[str, Any]] = None,
        columns: List[ListCheckInstanceResultResponseBodyColumns] = None,
        page_info: ListCheckInstanceResultResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.basic_data = basic_data
        self.checks = checks
        self.columns = columns
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.basic_data:
            for k in self.basic_data:
                if k:
                    k.validate()
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BasicData'] = []
        if self.basic_data is not None:
            for k in self.basic_data:
                result['BasicData'].append(k.to_map() if k else None)
        if self.checks is not None:
            result['Checks'] = self.checks
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.basic_data = []
        if m.get('BasicData') is not None:
            for k in m.get('BasicData'):
                temp_model = ListCheckInstanceResultResponseBodyBasicData()
                self.basic_data.append(temp_model.from_map(k))
        if m.get('Checks') is not None:
            self.checks = m.get('Checks')
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = ListCheckInstanceResultResponseBodyColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckInstanceResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckInstanceResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckInstanceResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckInstanceResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckItemWarningMachineRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: int = None,
        group_id: int = None,
        lang: str = None,
        page_size: int = None,
        remark: str = None,
        risk_type: str = None,
        status: int = None,
    ):
        self.check_id = check_id
        self.container_field_name = container_field_name
        self.container_field_value = container_field_value
        self.current_page = current_page
        self.group_id = group_id
        self.lang = lang
        self.page_size = page_size
        self.remark = remark
        self.risk_type = risk_type
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCheckItemWarningMachineResponseBodyListFixList(TeaModel):
    def __init__(
        self,
        risk_id: int = None,
        risk_name: str = None,
    ):
        self.risk_id = risk_id
        self.risk_name = risk_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class ListCheckItemWarningMachineResponseBodyListWarningRiskList(TeaModel):
    def __init__(
        self,
        risk_id: int = None,
        risk_name: str = None,
    ):
        self.risk_id = risk_id
        self.risk_name = risk_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class ListCheckItemWarningMachineResponseBodyList(TeaModel):
    def __init__(
        self,
        auth_version: int = None,
        bind: bool = None,
        container_id: str = None,
        container_name: str = None,
        fix_list: List[ListCheckItemWarningMachineResponseBodyListFixList] = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        port_open: bool = None,
        prompt: str = None,
        region_id: str = None,
        status: int = None,
        uuid: str = None,
        warning_risk_list: List[ListCheckItemWarningMachineResponseBodyListWarningRiskList] = None,
    ):
        self.auth_version = auth_version
        self.bind = bind
        self.container_id = container_id
        self.container_name = container_name
        self.fix_list = fix_list
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.port_open = port_open
        self.prompt = prompt
        self.region_id = region_id
        self.status = status
        self.uuid = uuid
        self.warning_risk_list = warning_risk_list

    def validate(self):
        if self.fix_list:
            for k in self.fix_list:
                if k:
                    k.validate()
        if self.warning_risk_list:
            for k in self.warning_risk_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        result['FixList'] = []
        if self.fix_list is not None:
            for k in self.fix_list:
                result['FixList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.port_open is not None:
            result['PortOpen'] = self.port_open
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        result['WarningRiskList'] = []
        if self.warning_risk_list is not None:
            for k in self.warning_risk_list:
                result['WarningRiskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        self.fix_list = []
        if m.get('FixList') is not None:
            for k in m.get('FixList'):
                temp_model = ListCheckItemWarningMachineResponseBodyListFixList()
                self.fix_list.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('PortOpen') is not None:
            self.port_open = m.get('PortOpen')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        self.warning_risk_list = []
        if m.get('WarningRiskList') is not None:
            for k in m.get('WarningRiskList'):
                temp_model = ListCheckItemWarningMachineResponseBodyListWarningRiskList()
                self.warning_risk_list.append(temp_model.from_map(k))
        return self


class ListCheckItemWarningMachineResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckItemWarningMachineResponseBody(TeaModel):
    def __init__(
        self,
        list: List[ListCheckItemWarningMachineResponseBodyList] = None,
        page_info: ListCheckItemWarningMachineResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.list = list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCheckItemWarningMachineResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckItemWarningMachineResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckItemWarningMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckItemWarningMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckItemWarningMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckItemWarningSummaryRequest(TeaModel):
    def __init__(
        self,
        check_item_fuzzy: str = None,
        check_level: str = None,
        check_type: str = None,
        check_warning_status: int = None,
        container_field_name: str = None,
        container_field_value: str = None,
        current_page: int = None,
        group_id: int = None,
        lang: str = None,
        page_size: int = None,
        risk_type: str = None,
    ):
        # The risk level. Default value: null, which indicates that check items at all risk levels are queried.Valid values:
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.check_item_fuzzy = check_item_fuzzy
        # The risk status. Default value: null, which indicates that check items in all states are queried.Valid values:
        # *   **1**: failed
        # *   **3**: passed
        self.check_level = check_level
        # The type of the baseline.
        self.check_type = check_type
        # The type of the check item.
        self.check_warning_status = check_warning_status
        # The name of the check item. Fuzzy match is supported.
        self.container_field_name = container_field_name
        # The name of the field that is used to query containers.
        self.container_field_value = container_field_value
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > We recommend that you do not leave this parameter empty.
        self.group_id = group_id
        # The value of the field that is used to query containers.
        self.lang = lang
        # The number of the page to return. Default value: **1**.
        self.page_size = page_size
        # Queries the risk statistics of check items by page.
        self.risk_type = risk_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_item_fuzzy is not None:
            result['CheckItemFuzzy'] = self.check_item_fuzzy
        if self.check_level is not None:
            result['CheckLevel'] = self.check_level
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.check_warning_status is not None:
            result['CheckWarningStatus'] = self.check_warning_status
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckItemFuzzy') is not None:
            self.check_item_fuzzy = m.get('CheckItemFuzzy')
        if m.get('CheckLevel') is not None:
            self.check_level = m.get('CheckLevel')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('CheckWarningStatus') is not None:
            self.check_warning_status = m.get('CheckWarningStatus')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        return self


class ListCheckItemWarningSummaryResponseBodyList(TeaModel):
    def __init__(
        self,
        advice: str = None,
        alias: str = None,
        check_id: int = None,
        check_item: str = None,
        check_level: str = None,
        check_type: str = None,
        container_check_item: bool = None,
        description: str = None,
        risk_type: str = None,
        status: int = None,
        warning_machine_count: int = None,
    ):
        # The type of the check item.
        self.advice = advice
        # The type of the baseline.
        self.alias = alias
        # The alias of the baseline type.
        self.check_id = check_id
        # The ID of the check item.
        self.check_item = check_item
        # The description of the check item.
        self.check_level = check_level
        # The risk level of the check item.Valid values:
        # *   **high**\
        # *  **medium**\
        # *   **low**\
        self.check_type = check_type
        self.container_check_item = container_check_item
        # The suggestion on the check item.
        self.description = description
        # The risk statistics of the check item.
        self.risk_type = risk_type
        # The description of the check item.
        self.status = status
        # The risk status of the check item.Valid values:
        # *  **1**: failed
        # 
        # *  **3**: passed
        self.warning_machine_count = warning_machine_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        if self.check_level is not None:
            result['CheckLevel'] = self.check_level
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.container_check_item is not None:
            result['ContainerCheckItem'] = self.container_check_item
        if self.description is not None:
            result['Description'] = self.description
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.status is not None:
            result['Status'] = self.status
        if self.warning_machine_count is not None:
            result['WarningMachineCount'] = self.warning_machine_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        if m.get('CheckLevel') is not None:
            self.check_level = m.get('CheckLevel')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('ContainerCheckItem') is not None:
            self.container_check_item = m.get('ContainerCheckItem')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WarningMachineCount') is not None:
            self.warning_machine_count = m.get('WarningMachineCount')
        return self


class ListCheckItemWarningSummaryResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The total number of entries returned.
        self.count = count
        # The pagination information.
        self.current_page = current_page
        # The page number of the returned page.
        self.page_size = page_size
        # The number of entries returned per page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckItemWarningSummaryResponseBody(TeaModel):
    def __init__(
        self,
        list: List[ListCheckItemWarningSummaryResponseBodyList] = None,
        page_info: ListCheckItemWarningSummaryResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The data returned.
        self.list = list
        # The number of servers that are affected by the check item.
        self.page_info = page_info
        # The number of entries returned on the current page.
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCheckItemWarningSummaryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckItemWarningSummaryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckItemWarningSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckItemWarningSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckItemWarningSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckResultRequest(TeaModel):
    def __init__(
        self,
        check_key: str = None,
        current_page: int = None,
        instance_ids: List[str] = None,
        instance_types: List[str] = None,
        lang: str = None,
        page_size: int = None,
        region_id: str = None,
        requirement_ids: List[int] = None,
        risk_levels: List[str] = None,
        sort_types: List[str] = None,
        standard_ids: List[int] = None,
        statuses: List[str] = None,
        types: List[str] = None,
        vendors: List[str] = None,
    ):
        # The key that you want to use to search for check items in fuzzy match mode.
        self.check_key = check_key
        # The number of the page to return.
        self.current_page = current_page
        # The instance IDs of the cloud services that you want to query. Separate multiple IDs with commas (,).
        self.instance_ids = instance_ids
        # The asset type of the cloud service. Valid values:
        # 
        # *   **ECS**: Elastic Compute Service (ECS)
        # *   **SLB**: Server Load Balancer (SLB)
        # *   **RDS**: ApsaraDB RDS
        # *   **MONGODB**: ApsaraDB for MongoDB (MongoDB)
        # *   **KVSTORE**: ApsaraDB for Redis (Redis)
        # *   **ACR**: Container Registry
        # *   **CSK**: Container Service for Kubernetes (ACK)
        # *   **VPC**: Virtual Private Cloud (VPC)
        # *   **ACTIONTRAIL**: ActionTrail
        # *   **CDN**: Alibaba Cloud CDN (CDN)
        # *   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **RDC**: Apsara Devops
        # *   **RAM**: Resource Access Management (RAM)
        # *   **DDOS**: Anti-DDoS
        # *   **WAF**: Web Application Firewall (WAF)
        # *   **OSS**: Object Storage Service (OSS)
        # *   **POLARDB**: PolarDB
        # *   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
        # *   **MSE**: Microservices Engine (MSE)
        # *   **NAS**: Apsara File Storage NAS (NAS)
        # *   **SDDP**: Sensitive Data Discovery and Protection (SDDP)
        # *   **EIP**: Elastic IP Address (EIP)
        self.instance_types = instance_types
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The number of entries to return on each page.
        self.page_size = page_size
        self.region_id = region_id
        # The IDs of requirement items.
        self.requirement_ids = requirement_ids
        # The risk levels of check items. Separate multiple risk levels with commas (,). Valid values:
        # 
        # *   **HIGH**\
        # *   **MEDIUM**\
        # *   **LOW**\
        self.risk_levels = risk_levels
        # The types of the conditions based on which check items are sorted. Valid values:
        # 
        # *   **RISK_LEVEL**: risk level
        # *   **STATUS**: status
        self.sort_types = sort_types
        # The IDs of standards.
        self.standard_ids = standard_ids
        # The status of check items. Separate multiple status with commas (,). Valid values:
        # 
        # *   **PASS**\
        # *   **NOT_PASS**\
        # *   **CHECKING**\
        # *   **NOT_CHECK**\
        # *   **WHITELIST**\
        self.statuses = statuses
        self.types = types
        # The cloud service provider. Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        self.vendors = vendors

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_key is not None:
            result['CheckKey'] = self.check_key
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.requirement_ids is not None:
            result['RequirementIds'] = self.requirement_ids
        if self.risk_levels is not None:
            result['RiskLevels'] = self.risk_levels
        if self.sort_types is not None:
            result['SortTypes'] = self.sort_types
        if self.standard_ids is not None:
            result['StandardIds'] = self.standard_ids
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        if self.types is not None:
            result['Types'] = self.types
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckKey') is not None:
            self.check_key = m.get('CheckKey')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequirementIds') is not None:
            self.requirement_ids = m.get('RequirementIds')
        if m.get('RiskLevels') is not None:
            self.risk_levels = m.get('RiskLevels')
        if m.get('SortTypes') is not None:
            self.sort_types = m.get('SortTypes')
        if m.get('StandardIds') is not None:
            self.standard_ids = m.get('StandardIds')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class ListCheckResultResponseBodyChecksCheckPolicies(TeaModel):
    def __init__(
        self,
        requirement_id: int = None,
        requirement_show_name: str = None,
        section_id: int = None,
        section_show_name: str = None,
        standard_id: int = None,
        standard_show_name: str = None,
    ):
        # The requirement item ID of the check item.
        self.requirement_id = requirement_id
        # The display name of the requirement item for the check item.
        self.requirement_show_name = requirement_show_name
        # The section ID of the check item.
        self.section_id = section_id
        # The section display name of the check item.
        self.section_show_name = section_show_name
        # The standard ID of the check item.
        self.standard_id = standard_id
        # The standard display name of the check item.
        self.standard_show_name = standard_show_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requirement_id is not None:
            result['RequirementId'] = self.requirement_id
        if self.requirement_show_name is not None:
            result['RequirementShowName'] = self.requirement_show_name
        if self.section_id is not None:
            result['SectionId'] = self.section_id
        if self.section_show_name is not None:
            result['SectionShowName'] = self.section_show_name
        if self.standard_id is not None:
            result['StandardId'] = self.standard_id
        if self.standard_show_name is not None:
            result['StandardShowName'] = self.standard_show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequirementId') is not None:
            self.requirement_id = m.get('RequirementId')
        if m.get('RequirementShowName') is not None:
            self.requirement_show_name = m.get('RequirementShowName')
        if m.get('SectionId') is not None:
            self.section_id = m.get('SectionId')
        if m.get('SectionShowName') is not None:
            self.section_show_name = m.get('SectionShowName')
        if m.get('StandardId') is not None:
            self.standard_id = m.get('StandardId')
        if m.get('StandardShowName') is not None:
            self.standard_show_name = m.get('StandardShowName')
        return self


class ListCheckResultResponseBodyChecks(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        check_policies: List[ListCheckResultResponseBodyChecksCheckPolicies] = None,
        check_show_name: str = None,
        instance_sub_type: str = None,
        instance_type: str = None,
        last_check_time: int = None,
        risk_level: str = None,
        status: str = None,
        task_id: str = None,
        trial_permission: bool = None,
        vendor: str = None,
        vendor_show_name: str = None,
    ):
        # The ID of the check item.
        self.check_id = check_id
        # An array that consists of the check policies.
        self.check_policies = check_policies
        # The name of the check item.
        self.check_show_name = check_show_name
        # The asset subtype of the cloud service. Valid values:
        # 
        # *   If the **InstanceType** parameter is set to **ECS**, this parameter supports the following valid values:
        # 
        #     *   **INSTANCE**\
        #     *   **DISK**\
        #     *   **SECURITY_GROUP**\
        # 
        # *   If the **InstanceType** parameter is set to **ACR**, this parameter supports the following valid values:
        # 
        #     *   **REPOSITORY_ENTERPRISE**\
        #     *   **REPOSITORY_PERSON**\
        # 
        # *   If the **InstanceType** parameter is set to **RAM**, this parameter supports the following valid values:
        # 
        #     *   **ALIAS**\
        #     *   **USER**\
        #     *   **POLICY**\
        #     *   **GROUP**\
        # 
        # *   If the **InstanceType** parameter is set to **WAF**, this parameter supports the following valid values:
        # 
        #     *   **DOMAIN**\
        # 
        # *   If the **InstanceType** parameter is set to other values, this parameter supports the following valid values:
        # 
        #     *   **INSTANCE**\
        self.instance_sub_type = instance_sub_type
        # The asset type of the cloud service. Valid values:
        # 
        # *   **ECS**: ECS
        # *   **SLB**: SLB
        # *   **RDS**: ApsaraDB RDS
        # *   **MONGODB**: MongoDB
        # *   **KVSTORE**: Redis
        # *   **ACR**: Container Registry
        # *   **CSK**: ACK
        # *   **VPC**: VPC
        # *   **ACTIONTRAIL**: ActionTrail
        # *   **CDN**: CDN
        # *   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **RDC**: Apsara Devops
        # *   **RAM**: RAM
        # *   **DDOS**: Anti-DDoS
        # *   **WAF**: WAF
        # *   **OSS**: OSS
        # *   **POLARDB**: PolarDB
        # *   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
        # *   **MSE**: MSE
        # *   **NAS**: NAS
        # *   **SDDP**: SDDP
        # *   **EIP**: EIP
        self.instance_type = instance_type
        # The timestamp when the last check was performed. Unit: milliseconds.
        self.last_check_time = last_check_time
        # The risk level of the check item. Valid values:
        # 
        # *   **HIGH**\
        # *   **MEDIUM**\
        # *   **LOW**\
        self.risk_level = risk_level
        # The status of the check item. Valid values:
        # 
        # *   **PASS**\
        # *   **NOT_PASS**\
        # *   **CHECKING**\
        # *   **NOT_CHECK**\
        # *   **WHITELIST**\
        self.status = status
        # The ID of the check task.
        self.task_id = task_id
        # Indicates whether the TRIAL permission is required.
        self.trial_permission = trial_permission
        # The value of the cloud service provider.
        self.vendor = vendor
        # The name of the cloud service provider.
        self.vendor_show_name = vendor_show_name

    def validate(self):
        if self.check_policies:
            for k in self.check_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        result['CheckPolicies'] = []
        if self.check_policies is not None:
            for k in self.check_policies:
                result['CheckPolicies'].append(k.to_map() if k else None)
        if self.check_show_name is not None:
            result['CheckShowName'] = self.check_show_name
        if self.instance_sub_type is not None:
            result['InstanceSubType'] = self.instance_sub_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.last_check_time is not None:
            result['LastCheckTime'] = self.last_check_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trial_permission is not None:
            result['TrialPermission'] = self.trial_permission
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_show_name is not None:
            result['VendorShowName'] = self.vendor_show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        self.check_policies = []
        if m.get('CheckPolicies') is not None:
            for k in m.get('CheckPolicies'):
                temp_model = ListCheckResultResponseBodyChecksCheckPolicies()
                self.check_policies.append(temp_model.from_map(k))
        if m.get('CheckShowName') is not None:
            self.check_show_name = m.get('CheckShowName')
        if m.get('InstanceSubType') is not None:
            self.instance_sub_type = m.get('InstanceSubType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('LastCheckTime') is not None:
            self.last_check_time = m.get('LastCheckTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TrialPermission') is not None:
            self.trial_permission = m.get('TrialPermission')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorShowName') is not None:
            self.vendor_show_name = m.get('VendorShowName')
        return self


class ListCheckResultResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckResultResponseBody(TeaModel):
    def __init__(
        self,
        checks: List[ListCheckResultResponseBodyChecks] = None,
        page_info: ListCheckResultResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the check items.
        self.checks = checks
        # The pagination information.
        self.page_info = page_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.checks:
            for k in self.checks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Checks'] = []
        if self.checks is not None:
            for k in self.checks:
                result['Checks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.checks = []
        if m.get('Checks') is not None:
            for k in m.get('Checks'):
                temp_model = ListCheckResultResponseBodyChecks()
                self.checks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckStandardRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        instance_sub_types: List[str] = None,
        instance_types: List[str] = None,
        lang: str = None,
        vendors: List[str] = None,
    ):
        self.instance_ids = instance_ids
        self.instance_sub_types = instance_sub_types
        self.instance_types = instance_types
        self.lang = lang
        self.vendors = vendors

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_sub_types is not None:
            result['InstanceSubTypes'] = self.instance_sub_types
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceSubTypes') is not None:
            self.instance_sub_types = m.get('InstanceSubTypes')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class ListCheckStandardResponseBodyStandardsRequirements(TeaModel):
    def __init__(
        self,
        id: int = None,
        risk_check_count: int = None,
        show_name: str = None,
    ):
        self.id = id
        self.risk_check_count = risk_check_count
        self.show_name = show_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.risk_check_count is not None:
            result['RiskCheckCount'] = self.risk_check_count
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RiskCheckCount') is not None:
            self.risk_check_count = m.get('RiskCheckCount')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        return self


class ListCheckStandardResponseBodyStandards(TeaModel):
    def __init__(
        self,
        id: int = None,
        requirements: List[ListCheckStandardResponseBodyStandardsRequirements] = None,
        show_name: str = None,
        type: str = None,
    ):
        self.id = id
        self.requirements = requirements
        self.show_name = show_name
        self.type = type

    def validate(self):
        if self.requirements:
            for k in self.requirements:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        result['Requirements'] = []
        if self.requirements is not None:
            for k in self.requirements:
                result['Requirements'].append(k.to_map() if k else None)
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.requirements = []
        if m.get('Requirements') is not None:
            for k in m.get('Requirements'):
                temp_model = ListCheckStandardResponseBodyStandardsRequirements()
                self.requirements.append(temp_model.from_map(k))
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckStandardResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        standards: List[ListCheckStandardResponseBodyStandards] = None,
    ):
        self.request_id = request_id
        self.standards = standards

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = ListCheckStandardResponseBodyStandards()
                self.standards.append(temp_model.from_map(k))
        return self


class ListCheckStandardResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckStandardResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckStandardResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClientUserDefineRuleTypesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_define_rule_types: List[str] = None,
    ):
        self.request_id = request_id
        self.user_define_rule_types = user_define_rule_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_types is not None:
            result['UserDefineRuleTypes'] = self.user_define_rule_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleTypes') is not None:
            self.user_define_rule_types = m.get('UserDefineRuleTypes')
        return self


class ListClientUserDefineRuleTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClientUserDefineRuleTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClientUserDefineRuleTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClientUserDefineRulesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        name: str = None,
        page_size: int = None,
        type: List[int] = None,
    ):
        self.current_page = current_page
        self.name = name
        self.page_size = page_size
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListClientUserDefineRulesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListClientUserDefineRulesResponseBodyUserDefineRuleList(TeaModel):
    def __init__(
        self,
        action_type: int = None,
        id: int = None,
        name: str = None,
        platform: str = None,
        switch_id: str = None,
        type: int = None,
    ):
        self.action_type = action_type
        self.id = id
        self.name = name
        self.platform = platform
        self.switch_id = switch_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListClientUserDefineRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: ListClientUserDefineRulesResponseBodyPageInfo = None,
        request_id: str = None,
        user_define_rule_list: List[ListClientUserDefineRulesResponseBodyUserDefineRuleList] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.user_define_rule_list = user_define_rule_list

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.user_define_rule_list:
            for k in self.user_define_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UserDefineRuleList'] = []
        if self.user_define_rule_list is not None:
            for k in self.user_define_rule_list:
                result['UserDefineRuleList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListClientUserDefineRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.user_define_rule_list = []
        if m.get('UserDefineRuleList') is not None:
            for k in m.get('UserDefineRuleList'):
                temp_model = ListClientUserDefineRulesResponseBodyUserDefineRuleList()
                self.user_define_rule_list.append(temp_model.from_map(k))
        return self


class ListClientUserDefineRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClientUserDefineRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClientUserDefineRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudAssetInstancesRequestCloudAssetTypes(TeaModel):
    def __init__(
        self,
        asset_sub_type: int = None,
        asset_type: int = None,
    ):
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.asset_sub_type = asset_sub_type
        # The subtype of the cloud asset.
        # 
        # You can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query the subtypes of cloud assets from the AssetSubType response parameter.
        self.asset_type = asset_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        return self


class ListCloudAssetInstancesRequest(TeaModel):
    def __init__(
        self,
        cloud_asset_types: List[ListCloudAssetInstancesRequestCloudAssetTypes] = None,
        criteria: str = None,
        current_page: int = None,
        logical_exp: str = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The cloud service asset.
        self.cloud_asset_types = cloud_asset_types
        # The logical relation for multiple search conditions. Valid values:
        # 
        # *   **OR**: The search conditions use a logical **OR**.
        # *   **AND**: The search conditions use a logical **AND**.
        self.criteria = criteria
        # The cloud service assets.
        self.current_page = current_page
        # The number of entries to return on each page. Maximum value: 100. Default value: 20.
        self.logical_exp = logical_exp
        # The number of the page to return.
        self.page_size = page_size
        # The search conditions for assets. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **name**: the name of the search condition.
        # 
        # *   **value**: the value of the search condition.
        # 
        # *   **logicalExp**: the logical relation for multiple search conditions. Valid values:
        # 
        #     *   **OR**: The search conditions use a logical **OR**.
        #     *   **AND**: The search conditions use a logical **AND**.
        # 
        # > You can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query supported search conditions.
        self.region_id = region_id

    def validate(self):
        if self.cloud_asset_types:
            for k in self.cloud_asset_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudAssetTypes'] = []
        if self.cloud_asset_types is not None:
            for k in self.cloud_asset_types:
                result['CloudAssetTypes'].append(k.to_map() if k else None)
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cloud_asset_types = []
        if m.get('CloudAssetTypes') is not None:
            for k in m.get('CloudAssetTypes'):
                temp_model = ListCloudAssetInstancesRequestCloudAssetTypes()
                self.cloud_asset_types.append(temp_model.from_map(k))
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListCloudAssetInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        alarm_status: str = None,
        asset_sub_type: str = None,
        asset_sub_type_name: str = None,
        asset_type: int = None,
        asset_type_name: str = None,
        created_time: int = None,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        region_id: str = None,
        risk_status: str = None,
        security_info: str = None,
        vendor: int = None,
    ):
        # Indicates whether risks are detected on the cloud asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status
        # The instance ID of the cloud asset.
        self.asset_sub_type = asset_sub_type
        # The security information about the cloud asset.
        self.asset_sub_type_name = asset_sub_type_name
        # The subtype of the cloud asset. The subtype of the cloud service. Valid values:
        # 
        # *   **0**: ECS
        #     * **0**: instance
        #     * **1**: disk (storage)
        #     * **2**: security group
        # *   **1**: SLB
        #     * **0**: SLB
        #     * **1**: Application Load Balancer (ALB)
        # *   **3**: ApsaraDB RDS
        #     * **0**: instance
        # *   **4**: MongoDB
        #     * **0**: instance
        # *   **5**: Redis
        #     * **0**: instance
        # *   **6**: Container Registry
        #     * **1**: Enterprise Edition
        #     * **2**: Personal Edition
        # *   **8**: ACK
        #     * **0**: cluster
        # *   **9**: VPC
        #     * **0**: NAT gateway
        #     * **1**:EIP
        #     * **2**:VPN
        #     * **3**:FLOW_LOG
        # *   **11**: ActionTrail
        #     * **0**: trail
        # *   **12**: CDN
        #     * **0**: instance
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        #      * **0**: certificate
        # *   **14**: Apsara Devops
        #     * **0**: organization
        # *   **16**: Anti-DDoS
        #     * **0**: instance
        # *   **17**: WAF
        #     * **0**: domain name
        # *   **18**: OSS
        #     * **0**:Bucket
        # *   **19**: PolarDB
        #     * **0**: cluster
        # *   **20**: ApsaraDB RDS for PostgreSQL
        #     * **0**: instance
        # *   **21**: MSE
        #     * **0**: cluster
        # *   **22**: NAS
        #     * **0**: file system
        # *   **23**: DSC
        #     * **0**: instance
        # *   **24**: EIP
        #     * **0**: Anycast EIP
        # *   **25**: IDaaS EIAM
        #     * **0**: instance
        # *   **26**: PolarDB-X
        #     * **0**: instance
        # *   **27**: Elasticsearch
        #     * **0**: instance
        self.asset_type = asset_type
        # The subtype name of the cloud asset.
        self.asset_type_name = asset_type_name
        # The public IP address of the instance.
        self.created_time = created_time
        # The instance name of the cloud asset.
        self.instance_id = instance_id
        # The time when the instance was created.
        self.instance_name = instance_name
        # Indicates whether alerts are generated for the cloud asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.internet_ip = internet_ip
        # The type of the cloud asset by source. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud
        # *   **1**: a third-party cloud asset
        # *   **2**: an asset in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.region_id = region_id
        # The type name of the cloud asset.
        self.risk_status = risk_status
        self.security_info = security_info
        # The type of the asset. Valid values:
        # 
        # *   **0**: Elastic Compute Service (ECS)
        # *   **1**: Server Load Balancer (SLB)
        # *   **3**: ApsaraDB RDS
        # *   **4**: ApsaraDB for MongoDB (MongoDB)
        # *   **5**: ApsaraDB for Redis (Redis)
        # *   **6**: Container Registry
        # *   **8**: Container Service for Kubernetes (ACK)
        # *   **9**: Virtual Private Cloud (VPC)
        # *   **11**: ActionTrail
        # *   **12**: Alibaba Cloud CDN (CDN)
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **16**: Anti-DDoS
        # *   **17**: Web Application Firewall (WAF)
        # *   **18**: Object Storage Service (OSS)
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: Microservices Engine (MSE)
        # *   **22**: Apsara File Storage NAS (NAS)
        # *   **23**: Data Security Center (DSC)
        # *   **24**: Elastic IP Address (EIP)
        # *   **25**: IDaaS EIAM
        # *   **26**: PolarDB-X
        # *   **27**: Elasticsearch
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_sub_type_name is not None:
            result['AssetSubTypeName'] = self.asset_sub_type_name
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.asset_type_name is not None:
            result['AssetTypeName'] = self.asset_type_name
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.security_info is not None:
            result['SecurityInfo'] = self.security_info
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetSubTypeName') is not None:
            self.asset_sub_type_name = m.get('AssetSubTypeName')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AssetTypeName') is not None:
            self.asset_type_name = m.get('AssetTypeName')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SecurityInfo') is not None:
            self.security_info = m.get('SecurityInfo')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class ListCloudAssetInstancesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # An array that consists of the details of the cloud assets.
        self.count = count
        # The number of entries returned per page.
        self.current_page = current_page
        # The total number of cloud assets.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCloudAssetInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instances: List[ListCloudAssetInstancesResponseBodyInstances] = None,
        page_info: ListCloudAssetInstancesResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the cloud asset.
        self.instances = instances
        # The page number of the returned page.
        self.page_info = page_info
        # The pagination information.
        self.request_id = request_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.success = success

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = ListCloudAssetInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCloudAssetInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCloudAssetInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudAssetInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudAssetInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterCnnfStatusDetailRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: List[str] = None,
    ):
        # An array that consists of the protection status of the container firewall.
        self.cluster_ids = cluster_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        return self


class ListClusterCnnfStatusDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        installed: bool = None,
        instance_id: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        invalid_type: str = None,
        machine_name: str = None,
        machine_type: int = None,
        plugin_name: str = None,
        plugin_version: str = None,
        status: str = None,
        uuid: str = None,
    ):
        # Indicates whether the container firewall plug-in is installed.
        self.cluster_id = cluster_id
        # The machine type of the instance. The value is fixed as **ecs**.
        self.installed = installed
        # The online status of the plug-in. Valid values:
        # 
        # *   **false**: The plug-in is offline.
        # *   **true**: The plug-in is online.
        self.instance_id = instance_id
        # The cause why the plug-in is invalid. Valid values:
        # 
        # *   **PLUGIN_OFFLINE**: The plug-in is offline.
        # *   **PLUGIN\_NOT_INSTALLED**: The plug-in is not installed.
        # *   **PLUGIN\_INVALID_VERSION**: The version of the plug-in is invalid.
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.invalid_type = invalid_type
        # The public IP address of the associated instance.
        self.machine_name = machine_name
        self.machine_type = machine_type
        # The private IP address of the associated instance.
        self.plugin_name = plugin_name
        self.plugin_version = plugin_version
        # The version of the plug-in.
        self.status = status
        # The name of the plug-in. The value is fixed as **alinet**.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.installed is not None:
            result['Installed'] = self.installed
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.invalid_type is not None:
            result['InvalidType'] = self.invalid_type
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.machine_type is not None:
            result['MachineType'] = self.machine_type
        if self.plugin_name is not None:
            result['PluginName'] = self.plugin_name
        if self.plugin_version is not None:
            result['PluginVersion'] = self.plugin_version
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Installed') is not None:
            self.installed = m.get('Installed')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('InvalidType') is not None:
            self.invalid_type = m.get('InvalidType')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('MachineType') is not None:
            self.machine_type = m.get('MachineType')
        if m.get('PluginName') is not None:
            self.plugin_name = m.get('PluginName')
        if m.get('PluginVersion') is not None:
            self.plugin_version = m.get('PluginVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListClusterCnnfStatusDetailResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListClusterCnnfStatusDetailResponseBodyData] = None,
        request_id: str = None,
    ):
        # The ID of the server.
        self.data = data
        # The ID of the cluster.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListClusterCnnfStatusDetailResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterCnnfStatusDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterCnnfStatusDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterCnnfStatusDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterInterceptionConfigRequest(TeaModel):
    def __init__(
        self,
        cluster_cnnfstatus: int = None,
        cluster_id: str = None,
        cluster_name: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        self.cluster_cnnfstatus = cluster_cnnfstatus
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.current_page = current_page
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_cnnfstatus is not None:
            result['ClusterCNNFStatus'] = self.cluster_cnnfstatus
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterCNNFStatus') is not None:
            self.cluster_cnnfstatus = m.get('ClusterCNNFStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListClusterInterceptionConfigResponseBodyClusterConfigList(TeaModel):
    def __init__(
        self,
        cluster_cnnfstatus: int = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        interception_switch: int = None,
        open_rule_count: int = None,
        support_cnnf: bool = None,
        total_rule_count: int = None,
    ):
        self.cluster_cnnfstatus = cluster_cnnfstatus
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.cluster_type = cluster_type
        self.interception_switch = interception_switch
        self.open_rule_count = open_rule_count
        self.support_cnnf = support_cnnf
        self.total_rule_count = total_rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_cnnfstatus is not None:
            result['ClusterCNNFStatus'] = self.cluster_cnnfstatus
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.interception_switch is not None:
            result['InterceptionSwitch'] = self.interception_switch
        if self.open_rule_count is not None:
            result['OpenRuleCount'] = self.open_rule_count
        if self.support_cnnf is not None:
            result['SupportCNNF'] = self.support_cnnf
        if self.total_rule_count is not None:
            result['TotalRuleCount'] = self.total_rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterCNNFStatus') is not None:
            self.cluster_cnnfstatus = m.get('ClusterCNNFStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('InterceptionSwitch') is not None:
            self.interception_switch = m.get('InterceptionSwitch')
        if m.get('OpenRuleCount') is not None:
            self.open_rule_count = m.get('OpenRuleCount')
        if m.get('SupportCNNF') is not None:
            self.support_cnnf = m.get('SupportCNNF')
        if m.get('TotalRuleCount') is not None:
            self.total_rule_count = m.get('TotalRuleCount')
        return self


class ListClusterInterceptionConfigResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        currrent_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.currrent_page = currrent_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.currrent_page is not None:
            result['CurrrentPage'] = self.currrent_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrrentPage') is not None:
            self.currrent_page = m.get('CurrrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListClusterInterceptionConfigResponseBody(TeaModel):
    def __init__(
        self,
        cluster_config_list: List[ListClusterInterceptionConfigResponseBodyClusterConfigList] = None,
        page_info: ListClusterInterceptionConfigResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.cluster_config_list = cluster_config_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.cluster_config_list:
            for k in self.cluster_config_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterConfigList'] = []
        if self.cluster_config_list is not None:
            for k in self.cluster_config_list:
                result['ClusterConfigList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster_config_list = []
        if m.get('ClusterConfigList') is not None:
            for k in m.get('ClusterConfigList'):
                temp_model = ListClusterInterceptionConfigResponseBodyClusterConfigList()
                self.cluster_config_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListClusterInterceptionConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterInterceptionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterInterceptionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterInterceptionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        honeypot_ids: List[str] = None,
        honeypot_name: str = None,
        node_id: str = None,
        node_name: str = None,
        page_size: int = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The IDs of the honeypots.
        self.honeypot_ids = honeypot_ids
        # The name of the honeypot.
        self.honeypot_name = honeypot_name
        # The ID of the management node.
        self.node_id = node_id
        # The name of the management node.
        self.node_name = node_name
        # The number of entries to return on each page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honeypot_ids is not None:
            result['HoneypotIds'] = self.honeypot_ids
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneypotIds') is not None:
            self.honeypot_ids = m.get('HoneypotIds')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListHoneypotResponseBodyList(TeaModel):
    def __init__(
        self,
        control_node_name: str = None,
        honeypot_id: str = None,
        honeypot_image_display_name: str = None,
        honeypot_image_id: str = None,
        honeypot_image_name: str = None,
        honeypot_name: str = None,
        node_id: str = None,
        preset_id: str = None,
        state: List[str] = None,
    ):
        # The name of the management node.
        self.control_node_name = control_node_name
        # The ID of the honeypot.
        self.honeypot_id = honeypot_id
        # The display name of the honeypot image.
        self.honeypot_image_display_name = honeypot_image_display_name
        # The ID of the honeypot image.
        self.honeypot_image_id = honeypot_image_id
        # The name of the honeypot image.
        self.honeypot_image_name = honeypot_image_name
        # The name of the honeypot.
        self.honeypot_name = honeypot_name
        # The ID of the management node.
        self.node_id = node_id
        # The ID of the custom configuration for the honeypot.
        self.preset_id = preset_id
        # An array that consists of the status information about the honeypot.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListHoneypotResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        list: List[ListHoneypotResponseBodyList] = None,
        message: str = None,
        page_info: ListHoneypotResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # An array that consists of the information about the honeypots.
        self.list = list
        # The error message returned.
        self.message = message
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHoneypotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotAlarmEventsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        dealed: str = None,
        dst_ip: str = None,
        page_size: int = None,
        risk_level_list: List[str] = None,
        src_ip: str = None,
    ):
        # The number of entries to return on each page. Default value: **100**\
        self.current_page = current_page
        # The source IP address.
        self.dealed = dealed
        # The risk levels of the alert events.
        self.dst_ip = dst_ip
        # The data returned.
        self.page_size = page_size
        # The risk level. Valid values:
        # 
        # *   **2**: low
        # *   **3**: medium
        # *   **4**: high
        self.risk_level_list = risk_level_list
        # The destination IP address.
        self.src_ip = src_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.dst_ip is not None:
            result['DstIp'] = self.dst_ip
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level_list is not None:
            result['RiskLevelList'] = self.risk_level_list
        if self.src_ip is not None:
            result['SrcIp'] = self.src_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('DstIp') is not None:
            self.dst_ip = m.get('DstIp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevelList') is not None:
            self.risk_level_list = m.get('RiskLevelList')
        if m.get('SrcIp') is not None:
            self.src_ip = m.get('SrcIp')
        return self


class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList(TeaModel):
    def __init__(
        self,
        field_ext_info: str = None,
        field_key: str = None,
        field_type: str = None,
        field_value: str = None,
    ):
        # The pagination information.
        self.field_ext_info = field_ext_info
        # The value that corresponds to the field key.
        self.field_key = field_key
        # The key of the field.
        self.field_type = field_type
        # The extended value that corresponds to the field key.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_ext_info is not None:
            result['FieldExtInfo'] = self.field_ext_info
        if self.field_key is not None:
            result['FieldKey'] = self.field_key
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FieldExtInfo') is not None:
            self.field_ext_info = m.get('FieldExtInfo')
        if m.get('FieldKey') is not None:
            self.field_key = m.get('FieldKey')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        return self


class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents(TeaModel):
    def __init__(
        self,
        alarm_event_id: int = None,
        alarm_event_name: str = None,
        alarm_event_type: str = None,
        alarm_unique_info: str = None,
        event_count: int = None,
        first_time: int = None,
        last_time: int = None,
        merge_field_list: List[ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList] = None,
        operate_status: int = None,
        risk_level: str = None,
    ):
        # The type of the alert event.
        self.alarm_event_id = alarm_event_id
        # The unique identifier of the alert event.
        self.alarm_event_name = alarm_event_name
        # The name of the alert event.
        self.alarm_event_type = alarm_event_type
        # The timestamp when the alert event was first generated. Unit: milliseconds.
        self.alarm_unique_info = alarm_unique_info
        # The handling status of the alert event. Valid values:
        # 
        # *   **1**: pending
        # *   **2**: ignored
        # *   **4**: confirmed
        self.event_count = event_count
        # The timestamp when the alert event was last generated. Unit: milliseconds.
        self.first_time = first_time
        # The risk level of the alert event. Valid values:
        # 
        # *   **2**: low
        # *   **3**: medium
        # *   **4**: high
        self.last_time = last_time
        # The information about the array object.
        self.merge_field_list = merge_field_list
        # The risk information.
        self.operate_status = operate_status
        # The total number of times that the alert event was generated.
        self.risk_level = risk_level

    def validate(self):
        if self.merge_field_list:
            for k in self.merge_field_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_id is not None:
            result['AlarmEventId'] = self.alarm_event_id
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.event_count is not None:
            result['EventCount'] = self.event_count
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        result['MergeFieldList'] = []
        if self.merge_field_list is not None:
            for k in self.merge_field_list:
                result['MergeFieldList'].append(k.to_map() if k else None)
        if self.operate_status is not None:
            result['OperateStatus'] = self.operate_status
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmEventId') is not None:
            self.alarm_event_id = m.get('AlarmEventId')
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('EventCount') is not None:
            self.event_count = m.get('EventCount')
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        self.merge_field_list = []
        if m.get('MergeFieldList') is not None:
            for k in m.get('MergeFieldList'):
                temp_model = ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList()
                self.merge_field_list.append(temp_model.from_map(k))
        if m.get('OperateStatus') is not None:
            self.operate_status = m.get('OperateStatus')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        return self


class ListHoneypotAlarmEventsResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The request ID.
        self.count = count
        # The number of entries returned per page. Default value: **100**\
        self.current_page = current_page
        # The total number of entries returned.
        self.page_size = page_size
        # The number of entries returned on the current page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotAlarmEventsResponseBody(TeaModel):
    def __init__(
        self,
        honeypot_alarm_events: List[ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents] = None,
        page_info: ListHoneypotAlarmEventsResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The information about the array object.
        self.honeypot_alarm_events = honeypot_alarm_events
        # The page number of the returned page.
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.honeypot_alarm_events:
            for k in self.honeypot_alarm_events:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HoneypotAlarmEvents'] = []
        if self.honeypot_alarm_events is not None:
            for k in self.honeypot_alarm_events:
                result['HoneypotAlarmEvents'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.honeypot_alarm_events = []
        if m.get('HoneypotAlarmEvents') is not None:
            for k in m.get('HoneypotAlarmEvents'):
                temp_model = ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents()
                self.honeypot_alarm_events.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotAlarmEventsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHoneypotAlarmEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHoneypotAlarmEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotAlarmEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotNodeRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        node_id: str = None,
        node_name: str = None,
        page_size: int = None,
    ):
        # The allowed CIDR block.
        self.current_page = current_page
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.node_id = node_id
        # The name of the management node.
        self.node_name = node_name
        # The time when the management node was created.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListHoneypotNodeResponseBodyHoneypotNodeList(TeaModel):
    def __init__(
        self,
        allow_honeypot_access_internet: bool = None,
        create_time: str = None,
        default_node: bool = None,
        ecs_instance_id: str = None,
        honeypot_total_count: int = None,
        honeypot_used_count: int = None,
        node_id: str = None,
        node_ip: str = None,
        node_name: str = None,
        probe_total_count: int = None,
        probe_used_count: int = None,
        security_group_probe_ip_list: List[str] = None,
        total_status: int = None,
        upgrade_available: bool = None,
    ):
        # The maximum number of probes that can be used.
        self.allow_honeypot_access_internet = allow_honeypot_access_internet
        # The ID of the management node.
        self.create_time = create_time
        # The number of entries returned on the current page.
        self.default_node = default_node
        # The HTTP status code returned.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the management node.
        self.honeypot_total_count = honeypot_total_count
        # The maximum number of honeypots that can be deployed on the management node.
        self.honeypot_used_count = honeypot_used_count
        # The name of the management node.
        self.node_id = node_id
        # The pagination information.
        self.node_ip = node_ip
        # The ID of the Elastic Compute Service (ECS) instance.
        self.node_name = node_name
        # The type of the management node. Default value: **false**. Valid values:
        # 
        # *   **false**: non-default type
        # *   **true**: default type
        self.probe_total_count = probe_total_count
        # Indicates whether the honeypot is allowed to access the Internet.
        # 
        # *   **true**: The honeypot is allowed to access the Internet.
        # *   **false**: The honeypot is not allowed to access the Internet.
        self.probe_used_count = probe_used_count
        # The status of the management node. Valid values:
        # 
        # *   **1**: normal
        # *   **2**: abnormal
        self.security_group_probe_ip_list = security_group_probe_ip_list
        # The number of honeypots that are deployed on the management node.
        self.total_status = total_status
        # Whether the node is upgradable. Valid values:
        # *   **false**: non-default type
        # *   **true**: default type
        self.upgrade_available = upgrade_available

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.default_node is not None:
            result['DefaultNode'] = self.default_node
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.honeypot_total_count is not None:
            result['HoneypotTotalCount'] = self.honeypot_total_count
        if self.honeypot_used_count is not None:
            result['HoneypotUsedCount'] = self.honeypot_used_count
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.probe_total_count is not None:
            result['ProbeTotalCount'] = self.probe_total_count
        if self.probe_used_count is not None:
            result['ProbeUsedCount'] = self.probe_used_count
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        if self.total_status is not None:
            result['TotalStatus'] = self.total_status
        if self.upgrade_available is not None:
            result['UpgradeAvailable'] = self.upgrade_available
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DefaultNode') is not None:
            self.default_node = m.get('DefaultNode')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('HoneypotTotalCount') is not None:
            self.honeypot_total_count = m.get('HoneypotTotalCount')
        if m.get('HoneypotUsedCount') is not None:
            self.honeypot_used_count = m.get('HoneypotUsedCount')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('ProbeTotalCount') is not None:
            self.probe_total_count = m.get('ProbeTotalCount')
        if m.get('ProbeUsedCount') is not None:
            self.probe_used_count = m.get('ProbeUsedCount')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        if m.get('TotalStatus') is not None:
            self.total_status = m.get('TotalStatus')
        if m.get('UpgradeAvailable') is not None:
            self.upgrade_available = m.get('UpgradeAvailable')
        return self


class ListHoneypotNodeResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The IP address of the management node.
        self.count = count
        # The number of entries to return on each page.
        self.current_page = current_page
        # An array that consists of the information about the management nodes.
        self.page_size = page_size
        # The number of entries returned per page.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        honeypot_node_list: List[ListHoneypotNodeResponseBodyHoneypotNodeList] = None,
        http_status_code: int = None,
        message: str = None,
        page_info: ListHoneypotNodeResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Queries the information about management nodes.
        self.code = code
        # The error message returned.
        self.honeypot_node_list = honeypot_node_list
        self.http_status_code = http_status_code
        # ListHoneypotNode
        self.message = message
        # An array that consists of the allowed CIDR blocks.
        self.page_info = page_info
        # WB01224678
        self.request_id = request_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.success = success

    def validate(self):
        if self.honeypot_node_list:
            for k in self.honeypot_node_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['HoneypotNodeList'] = []
        if self.honeypot_node_list is not None:
            for k in self.honeypot_node_list:
                result['HoneypotNodeList'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.honeypot_node_list = []
        if m.get('HoneypotNodeList') is not None:
            for k in m.get('HoneypotNodeList'):
                temp_model = ListHoneypotNodeResponseBodyHoneypotNodeList()
                self.honeypot_node_list.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotNodeResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHoneypotNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotPresetRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        honeypot_image_name: str = None,
        lang: str = None,
        node_id: str = None,
        node_name: str = None,
        page_size: int = None,
        preset_name: str = None,
    ):
        self.current_page = current_page
        self.honeypot_image_name = honeypot_image_name
        self.lang = lang
        self.node_id = node_id
        self.node_name = node_name
        self.page_size = page_size
        self.preset_name = preset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class ListHoneypotPresetResponseBodyList(TeaModel):
    def __init__(
        self,
        control_node_name: str = None,
        honeypot_image_display_name: str = None,
        honeypot_image_name: str = None,
        honeypot_preset_id: str = None,
        node_id: str = None,
        preset_name: str = None,
        preset_type: str = None,
    ):
        self.control_node_name = control_node_name
        self.honeypot_image_display_name = honeypot_image_display_name
        self.honeypot_image_name = honeypot_image_name
        self.honeypot_preset_id = honeypot_preset_id
        self.node_id = node_id
        self.preset_name = preset_name
        self.preset_type = preset_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        if self.preset_type is not None:
            result['PresetType'] = self.preset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        if m.get('PresetType') is not None:
            self.preset_type = m.get('PresetType')
        return self


class ListHoneypotPresetResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotPresetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        list: List[ListHoneypotPresetResponseBodyList] = None,
        message: str = None,
        page_info: ListHoneypotPresetResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.list = list
        self.message = message
        self.page_info = page_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotPresetResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotPresetResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotPresetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHoneypotPresetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotProbeRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        display_name: str = None,
        lang: str = None,
        page_size: int = None,
        probe_status: str = None,
        probe_type: str = None,
    ):
        self.current_page = current_page
        self.display_name = display_name
        self.lang = lang
        self.page_size = page_size
        self.probe_status = probe_status
        self.probe_type = probe_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.probe_status is not None:
            result['ProbeStatus'] = self.probe_status
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProbeStatus') is not None:
            self.probe_status = m.get('ProbeStatus')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        return self


class ListHoneypotProbeResponseBodyListControlNode(TeaModel):
    def __init__(
        self,
        ecs_instance_id: str = None,
        node_id: str = None,
        node_name: str = None,
    ):
        self.ecs_instance_id = ecs_instance_id
        self.node_id = node_id
        self.node_name = node_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        return self


class ListHoneypotProbeResponseBodyList(TeaModel):
    def __init__(
        self,
        control_node: ListHoneypotProbeResponseBodyListControlNode = None,
        deploy_time: int = None,
        display_name: str = None,
        host_ip: str = None,
        os_type: str = None,
        probe_id: str = None,
        probe_type: str = None,
        probe_version: str = None,
        status: str = None,
        uuid: str = None,
        vpc_id: str = None,
    ):
        self.control_node = control_node
        self.deploy_time = deploy_time
        self.display_name = display_name
        self.host_ip = host_ip
        self.os_type = os_type
        self.probe_id = probe_id
        self.probe_type = probe_type
        self.probe_version = probe_version
        self.status = status
        self.uuid = uuid
        self.vpc_id = vpc_id

    def validate(self):
        if self.control_node:
            self.control_node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node is not None:
            result['ControlNode'] = self.control_node.to_map()
        if self.deploy_time is not None:
            result['DeployTime'] = self.deploy_time
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlNode') is not None:
            temp_model = ListHoneypotProbeResponseBodyListControlNode()
            self.control_node = temp_model.from_map(m['ControlNode'])
        if m.get('DeployTime') is not None:
            self.deploy_time = m.get('DeployTime')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListHoneypotProbeResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotProbeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        list: List[ListHoneypotProbeResponseBodyList] = None,
        message: str = None,
        page_info: ListHoneypotProbeResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.list = list
        self.message = message
        self.page_info = page_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotProbeResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotProbeResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotProbeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHoneypotProbeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListImageRegistryRegionResponseBodyRegions(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        region_name: str = None,
    ):
        # The region ID of the image.
        self.region_id = region_id
        # The name of the region.
        self.region_name = region_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        return self


class ListImageRegistryRegionResponseBody(TeaModel):
    def __init__(
        self,
        regions: List[ListImageRegistryRegionResponseBodyRegions] = None,
        request_id: str = None,
    ):
        # An array that consists of regions.
        self.regions = regions
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['Regions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.regions = []
        if m.get('Regions') is not None:
            for k in m.get('Regions'):
                temp_model = ListImageRegistryRegionResponseBodyRegions()
                self.regions.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListImageRegistryRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListImageRegistryRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListImageRegistryRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListImageRiskRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        current_page: int = None,
        image_name: str = None,
        namespace: str = None,
        page_size: int = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.current_page = current_page
        self.image_name = image_name
        self.namespace = namespace
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListImageRiskResponseBodyImageRiskListEndPointList(TeaModel):
    def __init__(
        self,
        domains: List[str] = None,
        type: str = None,
    ):
        self.domains = domains
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domains is not None:
            result['Domains'] = self.domains
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domains') is not None:
            self.domains = m.get('Domains')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListImageRiskResponseBodyImageRiskList(TeaModel):
    def __init__(
        self,
        digest: str = None,
        end_point_list: List[ListImageRiskResponseBodyImageRiskListEndPointList] = None,
        endpoints: str = None,
        image: str = None,
        image_access_type: str = None,
        image_id: str = None,
        internet_urls: str = None,
        region_id: str = None,
        registry_type: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_type: str = None,
        statistics: str = None,
        tag: str = None,
        tag_immutable: int = None,
        uuid: str = None,
        vpc_urls: str = None,
    ):
        self.digest = digest
        self.end_point_list = end_point_list
        self.endpoints = endpoints
        self.image = image
        self.image_access_type = image_access_type
        self.image_id = image_id
        self.internet_urls = internet_urls
        self.region_id = region_id
        self.registry_type = registry_type
        self.repo_id = repo_id
        self.repo_name = repo_name
        self.repo_namespace = repo_namespace
        self.repo_type = repo_type
        self.statistics = statistics
        self.tag = tag
        self.tag_immutable = tag_immutable
        self.uuid = uuid
        self.vpc_urls = vpc_urls

    def validate(self):
        if self.end_point_list:
            for k in self.end_point_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        result['EndPointList'] = []
        if self.end_point_list is not None:
            for k in self.end_point_list:
                result['EndPointList'].append(k.to_map() if k else None)
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.image is not None:
            result['Image'] = self.image
        if self.image_access_type is not None:
            result['ImageAccessType'] = self.image_access_type
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.internet_urls is not None:
            result['InternetURLs'] = self.internet_urls
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_immutable is not None:
            result['TagImmutable'] = self.tag_immutable
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_urls is not None:
            result['VpcURLs'] = self.vpc_urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        self.end_point_list = []
        if m.get('EndPointList') is not None:
            for k in m.get('EndPointList'):
                temp_model = ListImageRiskResponseBodyImageRiskListEndPointList()
                self.end_point_list.append(temp_model.from_map(k))
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageAccessType') is not None:
            self.image_access_type = m.get('ImageAccessType')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InternetURLs') is not None:
            self.internet_urls = m.get('InternetURLs')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagImmutable') is not None:
            self.tag_immutable = m.get('TagImmutable')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcURLs') is not None:
            self.vpc_urls = m.get('VpcURLs')
        return self


class ListImageRiskResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListImageRiskResponseBody(TeaModel):
    def __init__(
        self,
        image_risk_list: List[ListImageRiskResponseBodyImageRiskList] = None,
        page_info: ListImageRiskResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.image_risk_list = image_risk_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.image_risk_list:
            for k in self.image_risk_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageRiskList'] = []
        if self.image_risk_list is not None:
            for k in self.image_risk_list:
                result['ImageRiskList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_risk_list = []
        if m.get('ImageRiskList') is not None:
            for k in m.get('ImageRiskList'):
                temp_model = ListImageRiskResponseBodyImageRiskList()
                self.image_risk_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListImageRiskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListImageRiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListImageRiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListImageRiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceCatalogRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        region_id: str = None,
        requirement_ids: List[int] = None,
        standard_ids: List[int] = None,
        types: List[str] = None,
    ):
        self.lang = lang
        self.region_id = region_id
        self.requirement_ids = requirement_ids
        self.standard_ids = standard_ids
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.requirement_ids is not None:
            result['RequirementIds'] = self.requirement_ids
        if self.standard_ids is not None:
            result['StandardIds'] = self.standard_ids
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequirementIds') is not None:
            self.requirement_ids = m.get('RequirementIds')
        if m.get('StandardIds') is not None:
            self.standard_ids = m.get('StandardIds')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListInstanceCatalogResponseBodyVendorsInstanceTypes(TeaModel):
    def __init__(
        self,
        instance_sub_types: List[ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes] = None,
        name: str = None,
    ):
        self.instance_sub_types = instance_sub_types
        self.name = name

    def validate(self):
        if self.instance_sub_types:
            for k in self.instance_sub_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceSubTypes'] = []
        if self.instance_sub_types is not None:
            for k in self.instance_sub_types:
                result['InstanceSubTypes'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_sub_types = []
        if m.get('InstanceSubTypes') is not None:
            for k in m.get('InstanceSubTypes'):
                temp_model = ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes()
                self.instance_sub_types.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListInstanceCatalogResponseBodyVendors(TeaModel):
    def __init__(
        self,
        instance_types: List[ListInstanceCatalogResponseBodyVendorsInstanceTypes] = None,
        name: str = None,
    ):
        self.instance_types = instance_types
        self.name = name

    def validate(self):
        if self.instance_types:
            for k in self.instance_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceTypes'] = []
        if self.instance_types is not None:
            for k in self.instance_types:
                result['InstanceTypes'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_types = []
        if m.get('InstanceTypes') is not None:
            for k in m.get('InstanceTypes'):
                temp_model = ListInstanceCatalogResponseBodyVendorsInstanceTypes()
                self.instance_types.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListInstanceCatalogResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendors: List[ListInstanceCatalogResponseBodyVendors] = None,
    ):
        self.request_id = request_id
        self.vendors = vendors

    def validate(self):
        if self.vendors:
            for k in self.vendors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Vendors'] = []
        if self.vendors is not None:
            for k in self.vendors:
                result['Vendors'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vendors = []
        if m.get('Vendors') is not None:
            for k in m.get('Vendors'):
                temp_model = ListInstanceCatalogResponseBodyVendors()
                self.vendors.append(temp_model.from_map(k))
        return self


class ListInstanceCatalogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceCatalogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceCatalogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterceptionHistoryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        current_page: int = None,
        end_time: int = None,
        history_name: str = None,
        interception_types: List[int] = None,
        lang: str = None,
        page_size: int = None,
        start_time: int = None,
    ):
        # The ID of the container cluster.
        self.cluster_id = cluster_id
        # The number of the page to return.
        self.current_page = current_page
        # The end of the time range to query. The value is a UNIX timestamp.
        self.end_time = end_time
        # The name of the alert.
        self.history_name = history_name
        # The types of exceptions.
        self.interception_types = interception_types
        # **zh**
        # 
        # 
        # - **zh**
        # - **en**
        self.lang = lang
        # The number of entries to return on each page.
        self.page_size = page_size
        # The start of the time range to query. The value is a UNIX timestamp.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.history_name is not None:
            result['HistoryName'] = self.history_name
        if self.interception_types is not None:
            result['InterceptionTypes'] = self.interception_types
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('HistoryName') is not None:
            self.history_name = m.get('HistoryName')
        if m.get('InterceptionTypes') is not None:
            self.interception_types = m.get('InterceptionTypes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListInterceptionHistoryResponseBodyInterceptionHistoryList(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        dst_app_name: str = None,
        dst_namespace: str = None,
        dst_port: int = None,
        dst_rule_target_name: str = None,
        first_time: int = None,
        id: int = None,
        interception_name: int = None,
        interception_type: int = None,
        last_time: int = None,
        real_dst_app_name: str = None,
        real_dst_image_name: str = None,
        real_dst_namespace: str = None,
        real_dst_pod_name: str = None,
        real_interception_type: int = None,
        real_src_app_name: str = None,
        real_src_image_name: str = None,
        real_src_namespace: str = None,
        real_src_pod_name: str = None,
        risk_level: int = None,
        rule_id: int = None,
        rule_name: str = None,
        src_app_name: str = None,
        src_namespace: str = None,
        src_rule_target_name: str = None,
        status: int = None,
        try_count: int = None,
    ):
        # The ID of the container cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The name of the destination application.
        self.dst_app_name = dst_app_name
        # The destination namespace.
        self.dst_namespace = dst_namespace
        # The destination port range configured for the defense rule.
        self.dst_port = dst_port
        # The name of the destination network object.
        self.dst_rule_target_name = dst_rule_target_name
        # The timestamp when the alert was first generated on the current day.
        self.first_time = first_time
        # The ID of the alert.
        self.id = id
        # The name of the alert.
        self.interception_name = interception_name
        # The handling type. Valid values:
        # 
        # *   **0**: monitor
        # *   **1**: intercept
        # *   **2**: generate alert
        # *   **3**: allow
        self.interception_type = interception_type
        # The timestamp when the alert was last generated on the current day.
        self.last_time = last_time
        # The name of the destination application.
        self.real_dst_app_name = real_dst_app_name
        # The name of the destination image.
        self.real_dst_image_name = real_dst_image_name
        # The destination namespace.
        self.real_dst_namespace = real_dst_namespace
        # The destination pod.
        self.real_dst_pod_name = real_dst_pod_name
        # The handling type of actual hits. Valid values:
        # 
        # *   **0**: monitor
        # *   **1**: intercept
        # *   **2**: generate alert
        # *   **3**: allow
        self.real_interception_type = real_interception_type
        # The name of the source application.
        self.real_src_app_name = real_src_app_name
        # The name of the source image.
        self.real_src_image_name = real_src_image_name
        # The source namespace.
        self.real_src_namespace = real_src_namespace
        # The source pod.
        self.real_src_pod_name = real_src_pod_name
        # The risk level. Valid values:
        # 
        # *   **-1**: unknown
        # *   **0**: none
        # *   **1**: low
        # *   **2**: medium
        # *   **3**: high
        self.risk_level = risk_level
        # The ID of the defense rule based on which the alert was generated.
        self.rule_id = rule_id
        # The name of the defense rule.
        self.rule_name = rule_name
        # The name of the source application.
        self.src_app_name = src_app_name
        # The source namespace.
        self.src_namespace = src_namespace
        # The name of the source network object.
        self.src_rule_target_name = src_rule_target_name
        # The handling status. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: manually handled
        # *   **3**: ignored
        self.status = status
        # The number of attempts.
        self.try_count = try_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.dst_app_name is not None:
            result['DstAppName'] = self.dst_app_name
        if self.dst_namespace is not None:
            result['DstNamespace'] = self.dst_namespace
        if self.dst_port is not None:
            result['DstPort'] = self.dst_port
        if self.dst_rule_target_name is not None:
            result['DstRuleTargetName'] = self.dst_rule_target_name
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.id is not None:
            result['Id'] = self.id
        if self.interception_name is not None:
            result['InterceptionName'] = self.interception_name
        if self.interception_type is not None:
            result['InterceptionType'] = self.interception_type
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.real_dst_app_name is not None:
            result['RealDstAppName'] = self.real_dst_app_name
        if self.real_dst_image_name is not None:
            result['RealDstImageName'] = self.real_dst_image_name
        if self.real_dst_namespace is not None:
            result['RealDstNamespace'] = self.real_dst_namespace
        if self.real_dst_pod_name is not None:
            result['RealDstPodName'] = self.real_dst_pod_name
        if self.real_interception_type is not None:
            result['RealInterceptionType'] = self.real_interception_type
        if self.real_src_app_name is not None:
            result['RealSrcAppName'] = self.real_src_app_name
        if self.real_src_image_name is not None:
            result['RealSrcImageName'] = self.real_src_image_name
        if self.real_src_namespace is not None:
            result['RealSrcNamespace'] = self.real_src_namespace
        if self.real_src_pod_name is not None:
            result['RealSrcPodName'] = self.real_src_pod_name
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.src_app_name is not None:
            result['SrcAppName'] = self.src_app_name
        if self.src_namespace is not None:
            result['SrcNamespace'] = self.src_namespace
        if self.src_rule_target_name is not None:
            result['SrcRuleTargetName'] = self.src_rule_target_name
        if self.status is not None:
            result['Status'] = self.status
        if self.try_count is not None:
            result['TryCount'] = self.try_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('DstAppName') is not None:
            self.dst_app_name = m.get('DstAppName')
        if m.get('DstNamespace') is not None:
            self.dst_namespace = m.get('DstNamespace')
        if m.get('DstPort') is not None:
            self.dst_port = m.get('DstPort')
        if m.get('DstRuleTargetName') is not None:
            self.dst_rule_target_name = m.get('DstRuleTargetName')
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterceptionName') is not None:
            self.interception_name = m.get('InterceptionName')
        if m.get('InterceptionType') is not None:
            self.interception_type = m.get('InterceptionType')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('RealDstAppName') is not None:
            self.real_dst_app_name = m.get('RealDstAppName')
        if m.get('RealDstImageName') is not None:
            self.real_dst_image_name = m.get('RealDstImageName')
        if m.get('RealDstNamespace') is not None:
            self.real_dst_namespace = m.get('RealDstNamespace')
        if m.get('RealDstPodName') is not None:
            self.real_dst_pod_name = m.get('RealDstPodName')
        if m.get('RealInterceptionType') is not None:
            self.real_interception_type = m.get('RealInterceptionType')
        if m.get('RealSrcAppName') is not None:
            self.real_src_app_name = m.get('RealSrcAppName')
        if m.get('RealSrcImageName') is not None:
            self.real_src_image_name = m.get('RealSrcImageName')
        if m.get('RealSrcNamespace') is not None:
            self.real_src_namespace = m.get('RealSrcNamespace')
        if m.get('RealSrcPodName') is not None:
            self.real_src_pod_name = m.get('RealSrcPodName')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SrcAppName') is not None:
            self.src_app_name = m.get('SrcAppName')
        if m.get('SrcNamespace') is not None:
            self.src_namespace = m.get('SrcNamespace')
        if m.get('SrcRuleTargetName') is not None:
            self.src_rule_target_name = m.get('SrcRuleTargetName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TryCount') is not None:
            self.try_count = m.get('TryCount')
        return self


class ListInterceptionHistoryResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The number of entries returned on the current page.
        self.count = count
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInterceptionHistoryResponseBody(TeaModel):
    def __init__(
        self,
        interception_history_list: List[ListInterceptionHistoryResponseBodyInterceptionHistoryList] = None,
        page_info: ListInterceptionHistoryResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # An array that consists of the alerts generated by defense rules.
        self.interception_history_list = interception_history_list
        # The pagination information.
        self.page_info = page_info
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.interception_history_list:
            for k in self.interception_history_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InterceptionHistoryList'] = []
        if self.interception_history_list is not None:
            for k in self.interception_history_list:
                result['InterceptionHistoryList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.interception_history_list = []
        if m.get('InterceptionHistoryList') is not None:
            for k in m.get('InterceptionHistoryList'):
                temp_model = ListInterceptionHistoryResponseBodyInterceptionHistoryList()
                self.interception_history_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListInterceptionHistoryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInterceptionHistoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterceptionHistoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterceptionHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterceptionRulePageRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        criteria: str = None,
        criteria_type: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        self.cluster_id = cluster_id
        self.criteria = criteria
        self.criteria_type = criteria_type
        self.current_page = current_page
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        ports: List[str] = None,
        rule_type: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.image_list = image_list
        self.namespace = namespace
        self.ports = ports
        self.rule_type = rule_type
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.ports is not None:
            result['Ports'] = self.ports
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Ports') is not None:
            self.ports = m.get('Ports')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        rule_type: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.image_list = image_list
        self.namespace = namespace
        self.rule_type = rule_type
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleList(TeaModel):
    def __init__(
        self,
        dst_target: ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        rule_type: str = None,
        src_target: ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget = None,
    ):
        self.dst_target = dst_target
        self.intercept_type = intercept_type
        self.order_index = order_index
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_switch = rule_switch
        self.rule_type = rule_type
        self.src_target = src_target

    def validate(self):
        if self.dst_target:
            self.dst_target.validate()
        if self.src_target:
            self.src_target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_target is not None:
            result['DstTarget'] = self.dst_target.to_map()
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.src_target is not None:
            result['SrcTarget'] = self.src_target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstTarget') is not None:
            temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget()
            self.dst_target = temp_model.from_map(m['DstTarget'])
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('SrcTarget') is not None:
            temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget()
            self.src_target = temp_model.from_map(m['SrcTarget'])
        return self


class ListInterceptionRulePageResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInterceptionRulePageResponseBody(TeaModel):
    def __init__(
        self,
        interception_rule_list: List[ListInterceptionRulePageResponseBodyInterceptionRuleList] = None,
        page_info: ListInterceptionRulePageResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.interception_rule_list = interception_rule_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.interception_rule_list:
            for k in self.interception_rule_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InterceptionRuleList'] = []
        if self.interception_rule_list is not None:
            for k in self.interception_rule_list:
                result['InterceptionRuleList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.interception_rule_list = []
        if m.get('InterceptionRuleList') is not None:
            for k in m.get('InterceptionRuleList'):
                temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleList()
                self.interception_rule_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListInterceptionRulePageResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInterceptionRulePageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterceptionRulePageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterceptionRulePageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterceptionTargetPageRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        current_page: int = None,
        image_list: List[str] = None,
        namespace: str = None,
        page_size: int = None,
        tag_list: List[str] = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.current_page = current_page
        self.image_list = image_list
        self.namespace = namespace
        self.page_size = page_size
        self.tag_list = tag_list
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionTargetPageResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInterceptionTargetPageResponseBodyRuleTargetList(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        rule_type: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.image_list = image_list
        self.namespace = namespace
        self.rule_type = rule_type
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionTargetPageResponseBody(TeaModel):
    def __init__(
        self,
        page_info: ListInterceptionTargetPageResponseBodyPageInfo = None,
        request_id: str = None,
        rule_target_list: List[ListInterceptionTargetPageResponseBodyRuleTargetList] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.rule_target_list = rule_target_list

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rule_target_list:
            for k in self.rule_target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RuleTargetList'] = []
        if self.rule_target_list is not None:
            for k in self.rule_target_list:
                result['RuleTargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListInterceptionTargetPageResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rule_target_list = []
        if m.get('RuleTargetList') is not None:
            for k in m.get('RuleTargetList'):
                temp_model = ListInterceptionTargetPageResponseBodyRuleTargetList()
                self.rule_target_list.append(temp_model.from_map(k))
        return self


class ListInterceptionTargetPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterceptionTargetPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterceptionTargetPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPluginForUuidRequest(TeaModel):
    def __init__(
        self,
        types: List[str] = None,
        uuid: str = None,
    ):
        # An array that consists of the information about the plug-ins.
        self.types = types
        # The configurations of the plug-in.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types is not None:
            result['Types'] = self.types
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListPluginForUuidShrinkRequest(TeaModel):
    def __init__(
        self,
        types_shrink: str = None,
        uuid: str = None,
    ):
        # An array that consists of the information about the plug-ins.
        self.types_shrink = types_shrink
        # The configurations of the plug-in.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList(TeaModel):
    def __init__(
        self,
        config: bool = None,
        msg: str = None,
        overall_config: bool = None,
        type: str = None,
    ):
        # The name of the plug-in. Valid values:
        # 
        # *   **alihips**: trojan-specific prevention
        # *   **alisecguard**: attack-specific prevention
        # *   **alinet**: defense against attacks on servers
        self.config = config
        # Queries the information about plug-ins on a server.
        self.msg = msg
        # ListPluginForUuid
        self.overall_config = overall_config
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('OverallConfig') is not None:
            self.overall_config = m.get('OverallConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList(TeaModel):
    def __init__(
        self,
        aegis_suspicious_config_list: List[ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList] = None,
        plugin_install_code: str = None,
        plugin_name: str = None,
        plugin_online_installed: bool = None,
        plugin_online_status: bool = None,
        plugin_version: str = None,
    ):
        # The information about the plug-in.
        self.aegis_suspicious_config_list = aegis_suspicious_config_list
        # The installation code of the plug-in.
        self.plugin_install_code = plugin_install_code
        # The UUID of the server.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.plugin_name = plugin_name
        # The version of the plug-in.
        self.plugin_online_installed = plugin_online_installed
        # An array that consists of the configurations of plug-ins.
        self.plugin_online_status = plugin_online_status
        # Indicates whether the plug-in is enabled. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.plugin_version = plugin_version

    def validate(self):
        if self.aegis_suspicious_config_list:
            for k in self.aegis_suspicious_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisSuspiciousConfigList'] = []
        if self.aegis_suspicious_config_list is not None:
            for k in self.aegis_suspicious_config_list:
                result['AegisSuspiciousConfigList'].append(k.to_map() if k else None)
        if self.plugin_install_code is not None:
            result['PluginInstallCode'] = self.plugin_install_code
        if self.plugin_name is not None:
            result['PluginName'] = self.plugin_name
        if self.plugin_online_installed is not None:
            result['PluginOnlineInstalled'] = self.plugin_online_installed
        if self.plugin_online_status is not None:
            result['PluginOnlineStatus'] = self.plugin_online_status
        if self.plugin_version is not None:
            result['PluginVersion'] = self.plugin_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aegis_suspicious_config_list = []
        if m.get('AegisSuspiciousConfigList') is not None:
            for k in m.get('AegisSuspiciousConfigList'):
                temp_model = ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList()
                self.aegis_suspicious_config_list.append(temp_model.from_map(k))
        if m.get('PluginInstallCode') is not None:
            self.plugin_install_code = m.get('PluginInstallCode')
        if m.get('PluginName') is not None:
            self.plugin_name = m.get('PluginName')
        if m.get('PluginOnlineInstalled') is not None:
            self.plugin_online_installed = m.get('PluginOnlineInstalled')
        if m.get('PluginOnlineStatus') is not None:
            self.plugin_online_status = m.get('PluginOnlineStatus')
        if m.get('PluginVersion') is not None:
            self.plugin_version = m.get('PluginVersion')
        return self


class ListPluginForUuidResponseBody(TeaModel):
    def __init__(
        self,
        aegis_uuid_target_plugin_config_list: List[ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList] = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The type of the plug-in. Valid values:
        # 
        # *   **auto_breaking**: antivirus
        # *   **ransomware_breaking**: anti-ransomware (bait capture)
        # *   **webshell_cloud_breaking**: webshell prevention
        # *   **alisecguard**: client protection
        # *   **alinet**: malicious behavior defense
        self.aegis_uuid_target_plugin_config_list = aegis_uuid_target_plugin_config_list
        self.code = code
        self.message = message
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.request_id = request_id

    def validate(self):
        if self.aegis_uuid_target_plugin_config_list:
            for k in self.aegis_uuid_target_plugin_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisUuidTargetPluginConfigList'] = []
        if self.aegis_uuid_target_plugin_config_list is not None:
            for k in self.aegis_uuid_target_plugin_config_list:
                result['AegisUuidTargetPluginConfigList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aegis_uuid_target_plugin_config_list = []
        if m.get('AegisUuidTargetPluginConfigList') is not None:
            for k in m.get('AegisUuidTargetPluginConfigList'):
                temp_model = ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList()
                self.aegis_uuid_target_plugin_config_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPluginForUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPluginForUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPluginForUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPodRiskRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        current_page: int = None,
        namespace: str = None,
        page_size: int = None,
        pod_name: str = None,
    ):
        self.app_name = app_name
        self.cluster_id = cluster_id
        self.current_page = current_page
        self.namespace = namespace
        self.page_size = page_size
        self.pod_name = pod_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class ListPodRiskResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPodRiskResponseBodyPodRiskList(TeaModel):
    def __init__(
        self,
        alarm_count: int = None,
        cluster_id: str = None,
        cluster_name: str = None,
        create_time: int = None,
        hc_count: int = None,
        instance_id: str = None,
        namespace: str = None,
        node_name: str = None,
        pod: str = None,
        pod_ip: str = None,
        vul_count: int = None,
    ):
        self.alarm_count = alarm_count
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.create_time = create_time
        self.hc_count = hc_count
        self.instance_id = instance_id
        self.namespace = namespace
        self.node_name = node_name
        self.pod = pod
        self.pod_ip = pod_ip
        self.vul_count = vul_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        return self


class ListPodRiskResponseBody(TeaModel):
    def __init__(
        self,
        page_info: ListPodRiskResponseBodyPageInfo = None,
        pod_risk_list: List[ListPodRiskResponseBodyPodRiskList] = None,
        request_id: str = None,
    ):
        self.page_info = page_info
        self.pod_risk_list = pod_risk_list
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.pod_risk_list:
            for k in self.pod_risk_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PodRiskList'] = []
        if self.pod_risk_list is not None:
            for k in self.pod_risk_list:
                result['PodRiskList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListPodRiskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.pod_risk_list = []
        if m.get('PodRiskList') is not None:
            for k in m.get('PodRiskList'):
                temp_model = ListPodRiskResponseBodyPodRiskList()
                self.pod_risk_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPodRiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPodRiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPodRiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrivateRegistryListRequest(TeaModel):
    def __init__(
        self,
        registry_type: str = None,
    ):
        # The type of the image repository. Valid values:
        # 
        # *   **acr**: Container Registry
        # *   **harbor**: Harbor
        # *   **quay**: Quay
        # *   **CI/CD**: Jenkins
        self.registry_type = registry_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        return self


class ListPrivateRegistryListResponseBodyImageRegistryInfos(TeaModel):
    def __init__(
        self,
        ali_uid: int = None,
        domain_name: str = None,
        id: int = None,
        jenkins_env: str = None,
        net_type: int = None,
        password: str = None,
        persistence_day: int = None,
        protocol_type: int = None,
        region_id: str = None,
        registry_host_ip: str = None,
        registry_name: str = None,
        registry_type: str = None,
        registry_version: str = None,
        token: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
        white_list: str = None,
    ):
        # The ID of the user.
        self.ali_uid = ali_uid
        # The domain name of the image repository.
        self.domain_name = domain_name
        # The ID of the image repository.
        self.id = id
        # The information about the Jenkins environment.
        self.jenkins_env = jenkins_env
        # The network type. Valid values:
        # 
        # *   **1**: Internet
        # *   **2**: VPC
        self.net_type = net_type
        # The password used to log on to the image repository.
        self.password = password
        # The number of days during which assets can be retained.
        self.persistence_day = persistence_day
        # The type of the protocol. Valid values:
        # 
        # *   **1**: HTTP
        # *   **2**: HTTPS
        self.protocol_type = protocol_type
        # The region ID of the server.
        self.region_id = region_id
        # The IP address of the image repository.
        self.registry_host_ip = registry_host_ip
        # The alias of the image repository.
        self.registry_name = registry_name
        # The type of the image repository. Valid values:
        # 
        # *   **acr**: Container Registry
        # *   **harbor**: Harbor
        # *   **quay**: Quay
        # *   **CI/CD**: Jenkins
        self.registry_type = registry_type
        # The version of the image repository. Valid values:
        # 
        # *   **V1**: V1.0
        # *   **V2**: V2.0
        self.registry_version = registry_version
        # The authentication token of the user.
        self.token = token
        # The number of images that can be scanned per hour.
        self.trans_per_hour = trans_per_hour
        # The username used to log on to the image repository.
        self.user_name = user_name
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The whitelist of IP addresses.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.jenkins_env is not None:
            result['JenkinsEnv'] = self.jenkins_env
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JenkinsEnv') is not None:
            self.jenkins_env = m.get('JenkinsEnv')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class ListPrivateRegistryListResponseBody(TeaModel):
    def __init__(
        self,
        image_registry_infos: List[ListPrivateRegistryListResponseBodyImageRegistryInfos] = None,
        request_id: str = None,
    ):
        # An array that consists of the image repositories.
        self.image_registry_infos = image_registry_infos
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.image_registry_infos:
            for k in self.image_registry_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageRegistryInfos'] = []
        if self.image_registry_infos is not None:
            for k in self.image_registry_infos:
                result['ImageRegistryInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_registry_infos = []
        if m.get('ImageRegistryInfos') is not None:
            for k in m.get('ImageRegistryInfos'):
                temp_model = ListPrivateRegistryListResponseBodyImageRegistryInfos()
                self.image_registry_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrivateRegistryListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrivateRegistryListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrivateRegistryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrivateRegistryTypeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ListPrivateRegistryTypeResponseBodyRegistryTypeInfos(TeaModel):
    def __init__(
        self,
        count: int = None,
        registry_type: str = None,
    ):
        # The number of image repositories.
        self.count = count
        # The name of the image repository type. Valid values:
        # 
        # *   **acr**: Container Registry
        # *   **harbor**: Harbor
        # *   **quay**: Quay
        # *   **CI/CD**: Jenkins
        self.registry_type = registry_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        return self


class ListPrivateRegistryTypeResponseBody(TeaModel):
    def __init__(
        self,
        registry_type_infos: List[ListPrivateRegistryTypeResponseBodyRegistryTypeInfos] = None,
        request_id: str = None,
    ):
        # An array that consists of image repository types.
        self.registry_type_infos = registry_type_infos
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.registry_type_infos:
            for k in self.registry_type_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RegistryTypeInfos'] = []
        if self.registry_type_infos is not None:
            for k in self.registry_type_infos:
                result['RegistryTypeInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.registry_type_infos = []
        if m.get('RegistryTypeInfos') is not None:
            for k in m.get('RegistryTypeInfos'):
                temp_model = ListPrivateRegistryTypeResponseBodyRegistryTypeInfos()
                self.registry_type_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrivateRegistryTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrivateRegistryTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrivateRegistryTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListQueryRaspAppInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        uuids: str = None,
    ):
        self.lang = lang
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ListQueryRaspAppInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        rasp_app_name: str = None,
        rasp_online_status: int = None,
        rasp_status: str = None,
        result: str = None,
        uuid: str = None,
    ):
        self.rasp_app_name = rasp_app_name
        self.rasp_online_status = rasp_online_status
        self.rasp_status = rasp_status
        # 
        self.result = result
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rasp_app_name is not None:
            result['RaspAppName'] = self.rasp_app_name
        if self.rasp_online_status is not None:
            result['RaspOnlineStatus'] = self.rasp_online_status
        if self.rasp_status is not None:
            result['RaspStatus'] = self.rasp_status
        if self.result is not None:
            result['Result'] = self.result
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RaspAppName') is not None:
            self.rasp_app_name = m.get('RaspAppName')
        if m.get('RaspOnlineStatus') is not None:
            self.rasp_online_status = m.get('RaspOnlineStatus')
        if m.get('RaspStatus') is not None:
            self.rasp_status = m.get('RaspStatus')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListQueryRaspAppInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListQueryRaspAppInfoResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListQueryRaspAppInfoResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListQueryRaspAppInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListQueryRaspAppInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListQueryRaspAppInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRuleTargetAllRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class ListRuleTargetAllResponseBodyRuleTargetList(TeaModel):
    def __init__(
        self,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListRuleTargetAllResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_target_list: List[ListRuleTargetAllResponseBodyRuleTargetList] = None,
    ):
        self.request_id = request_id
        self.rule_target_list = rule_target_list

    def validate(self):
        if self.rule_target_list:
            for k in self.rule_target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RuleTargetList'] = []
        if self.rule_target_list is not None:
            for k in self.rule_target_list:
                result['RuleTargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rule_target_list = []
        if m.get('RuleTargetList') is not None:
            for k in m.get('RuleTargetList'):
                temp_model = ListRuleTargetAllResponseBodyRuleTargetList()
                self.rule_target_list.append(temp_model.from_map(k))
        return self


class ListRuleTargetAllResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRuleTargetAllResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRuleTargetAllResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemAggregationRulesRequest(TeaModel):
    def __init__(
        self,
        aggregation_ids: List[int] = None,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        rule_name: str = None,
        rule_types: List[int] = None,
        system_type: int = None,
    ):
        self.aggregation_ids = aggregation_ids
        self.current_page = current_page
        self.lang = lang
        self.page_size = page_size
        self.rule_name = rule_name
        self.rule_types = rule_types
        self.system_type = system_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_ids is not None:
            result['AggregationIds'] = self.aggregation_ids
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AggregationIds') is not None:
            self.aggregation_ids = m.get('AggregationIds')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        return self


class ListSystemAggregationRulesResponseBodyAggregationList(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        rule_count: int = None,
    ):
        self.id = id
        self.name = name
        self.rule_count = rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        return self


class ListSystemAggregationRulesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSystemAggregationRulesResponseBody(TeaModel):
    def __init__(
        self,
        aggregation_list: List[ListSystemAggregationRulesResponseBodyAggregationList] = None,
        page_info: ListSystemAggregationRulesResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.aggregation_list = aggregation_list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.aggregation_list:
            for k in self.aggregation_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AggregationList'] = []
        if self.aggregation_list is not None:
            for k in self.aggregation_list:
                result['AggregationList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aggregation_list = []
        if m.get('AggregationList') is not None:
            for k in m.get('AggregationList'):
                temp_model = ListSystemAggregationRulesResponseBodyAggregationList()
                self.aggregation_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListSystemAggregationRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSystemAggregationRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSystemAggregationRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemAggregationRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemClientRuleTypesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_types: List[str] = None,
    ):
        self.request_id = request_id
        self.rule_types = rule_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        return self


class ListSystemClientRuleTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSystemClientRuleTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemClientRuleTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemClientRulesRequest(TeaModel):
    def __init__(
        self,
        aggregation_ids: List[int] = None,
        current_page: int = None,
        is_container: int = None,
        lang: str = None,
        page_size: int = None,
        rule_name: str = None,
        rule_types: List[int] = None,
        system_type: int = None,
    ):
        self.aggregation_ids = aggregation_ids
        self.current_page = current_page
        self.is_container = is_container
        self.lang = lang
        self.page_size = page_size
        self.rule_name = rule_name
        self.rule_types = rule_types
        self.system_type = system_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_ids is not None:
            result['AggregationIds'] = self.aggregation_ids
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_container is not None:
            result['IsContainer'] = self.is_container
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AggregationIds') is not None:
            self.aggregation_ids = m.get('AggregationIds')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsContainer') is not None:
            self.is_container = m.get('IsContainer')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        return self


class ListSystemClientRulesResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSystemClientRulesResponseBodyRuleListPolicies(TeaModel):
    def __init__(
        self,
        policy_key: str = None,
        policy_name: str = None,
    ):
        self.policy_key = policy_key
        self.policy_name = policy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_key is not None:
            result['PolicyKey'] = self.policy_key
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyKey') is not None:
            self.policy_key = m.get('PolicyKey')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        return self


class ListSystemClientRulesResponseBodyRuleList(TeaModel):
    def __init__(
        self,
        aggregation_name: str = None,
        description: str = None,
        platform: str = None,
        policies: List[ListSystemClientRulesResponseBodyRuleListPolicies] = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_type: int = None,
        status: int = None,
        switch_id: str = None,
    ):
        self.aggregation_name = aggregation_name
        self.description = description
        self.platform = platform
        self.policies = policies
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_type = rule_type
        self.status = status
        self.switch_id = switch_id

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_name is not None:
            result['AggregationName'] = self.aggregation_name
        if self.description is not None:
            result['Description'] = self.description
        if self.platform is not None:
            result['Platform'] = self.platform
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.status is not None:
            result['Status'] = self.status
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AggregationName') is not None:
            self.aggregation_name = m.get('AggregationName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = ListSystemClientRulesResponseBodyRuleListPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        return self


class ListSystemClientRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_info: ListSystemClientRulesResponseBodyPageInfo = None,
        request_id: str = None,
        rule_list: List[ListSystemClientRulesResponseBodyRuleList] = None,
    ):
        self.page_info = page_info
        self.request_id = request_id
        self.rule_list = rule_list

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rule_list:
            for k in self.rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RuleList'] = []
        if self.rule_list is not None:
            for k in self.rule_list:
                result['RuleList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListSystemClientRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rule_list = []
        if m.get('RuleList') is not None:
            for k in m.get('RuleList'):
                temp_model = ListSystemClientRulesResponseBodyRuleList()
                self.rule_list.append(temp_model.from_map(k))
        return self


class ListSystemClientRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSystemClientRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemClientRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemRuleAggregationTypesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ListSystemRuleAggregationTypesResponseBodyAggregationTypeList(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListSystemRuleAggregationTypesResponseBody(TeaModel):
    def __init__(
        self,
        aggregation_type_list: List[ListSystemRuleAggregationTypesResponseBodyAggregationTypeList] = None,
        request_id: str = None,
    ):
        self.aggregation_type_list = aggregation_type_list
        self.request_id = request_id

    def validate(self):
        if self.aggregation_type_list:
            for k in self.aggregation_type_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AggregationTypeList'] = []
        if self.aggregation_type_list is not None:
            for k in self.aggregation_type_list:
                result['AggregationTypeList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aggregation_type_list = []
        if m.get('AggregationTypeList') is not None:
            for k in m.get('AggregationTypeList'):
                temp_model = ListSystemRuleAggregationTypesResponseBodyAggregationTypeList()
                self.aggregation_type_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSystemRuleAggregationTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSystemRuleAggregationTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemRuleAggregationTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUninstallAegisMachinesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        os: str = None,
        page_size: int = None,
        region_id_str: str = None,
        region_no: str = None,
        remark: str = None,
        source_ip: str = None,
        vendor: int = None,
    ):
        self.current_page = current_page
        self.os = os
        self.page_size = page_size
        self.region_id_str = region_id_str
        self.region_no = region_no
        self.remark = remark
        self.source_ip = source_ip
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.os is not None:
            result['Os'] = self.os
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_str is not None:
            result['RegionIdStr'] = self.region_id_str
        if self.region_no is not None:
            result['RegionNo'] = self.region_no
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdStr') is not None:
            self.region_id_str = m.get('RegionIdStr')
        if m.get('RegionNo') is not None:
            self.region_no = m.get('RegionNo')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class ListUninstallAegisMachinesResponseBodyMachineList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_name: str = None,
        internet_ip: str = None,
        intranet_ip: str = None,
        machine_region: str = None,
        os: str = None,
        region_id: str = None,
        uuid: str = None,
        vendor: int = None,
        vendor_name: str = None,
    ):
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.machine_region = machine_region
        self.os = os
        self.region_id = region_id
        self.uuid = uuid
        self.vendor = vendor
        self.vendor_name = vendor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class ListUninstallAegisMachinesResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        machine_list: List[ListUninstallAegisMachinesResponseBodyMachineList] = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.machine_list = machine_list
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = ListUninstallAegisMachinesResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUninstallAegisMachinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUninstallAegisMachinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUninstallAegisMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUuidsByWebPathRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        type: str = None,
        web_path: str = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.type = type
        self.web_path = web_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class ListUuidsByWebPathResponseBodyList(TeaModel):
    def __init__(
        self,
        internet_ip: str = None,
        intranet_ip: str = None,
        machine_name: str = None,
        uuid: str = None,
    ):
        self.internet_ip = internet_ip
        self.intranet_ip = intranet_ip
        self.machine_name = machine_name
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListUuidsByWebPathResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUuidsByWebPathResponseBody(TeaModel):
    def __init__(
        self,
        list: List[ListUuidsByWebPathResponseBodyList] = None,
        page_info: ListUuidsByWebPathResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.list = list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListUuidsByWebPathResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListUuidsByWebPathResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUuidsByWebPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUuidsByWebPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUuidsByWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVulAutoRepairConfigRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        current_page: int = None,
        page_size: int = None,
        type: str = None,
    ):
        self.alias_name = alias_name
        self.current_page = current_page
        self.page_size = page_size
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListVulAutoRepairConfigResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        id: int = None,
        name: str = None,
        reason: str = None,
        type: str = None,
    ):
        self.alias_name = alias_name
        self.id = id
        self.name = name
        self.reason = reason
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListVulAutoRepairConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        page_info: ListVulAutoRepairConfigResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
        vul_auto_repair_config_list: List[ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList] = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.page_info = page_info
        self.request_id = request_id
        self.success = success
        self.vul_auto_repair_config_list = vul_auto_repair_config_list

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.vul_auto_repair_config_list:
            for k in self.vul_auto_repair_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['VulAutoRepairConfigList'] = []
        if self.vul_auto_repair_config_list is not None:
            for k in self.vul_auto_repair_config_list:
                result['VulAutoRepairConfigList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListVulAutoRepairConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.vul_auto_repair_config_list = []
        if m.get('VulAutoRepairConfigList') is not None:
            for k in m.get('VulAutoRepairConfigList'):
                temp_model = ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList()
                self.vul_auto_repair_config_list.append(temp_model.from_map(k))
        return self


class ListVulAutoRepairConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVulAutoRepairConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVulAutoRepairConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAccessKeyLeakDealRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        id_list: List[int] = None,
        remark: str = None,
        type: str = None,
    ):
        # The ID of the AccessKey pair leak.
        # 
        # > You can call the [DescribeAccesskeyLeakList](~~DescribeAccesskeyLeakList~~) operation to query the ID. You must specify at least one of the Id and **IdList** parameters.
        self.id = id
        # The IDs of AccessKey pair leaks.
        self.id_list = id_list
        # The remarks that are added.
        self.remark = remark
        # The method to handle the AccessKey pair leak. Valid values:
        # 
        # *   **manual**: manually handle
        # *   **disable**: disable
        # *   **add-whitelist**: add to the whitelist
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.id_list is not None:
            result['IdList'] = self.id_list
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IdList') is not None:
            self.id_list = m.get('IdList')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyAccessKeyLeakDealResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAccessKeyLeakDealResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAccessKeyLeakDealResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAccessKeyLeakDealResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAntiBruteForceRuleRequest(TeaModel):
    def __init__(
        self,
        default_rule: bool = None,
        fail_count: int = None,
        forbidden_time: int = None,
        id: int = None,
        name: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        span: int = None,
        uuid_list: List[str] = None,
    ):
        self.default_rule = default_rule
        self.fail_count = fail_count
        self.forbidden_time = forbidden_time
        # The threshold of logon failures that you specify. Valid values:
        # 
        # *   **2**\
        # *   **3**\
        # *   **4**\
        # *   **5**\
        # *   **10**\
        # *   **50**\
        # *   **80**\
        # *   **100**\
        self.id = id
        # Modifies a defense rule against brute-force attacks.
        self.name = name
        self.resource_owner_id = resource_owner_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.source_ip = source_ip
        # ModifyAntiBruteForceRule
        self.span = span
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAntiBruteForceRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAntiBruteForceRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppVulScanCycleRequest(TeaModel):
    def __init__(
        self,
        cycle: str = None,
    ):
        self.cycle = cycle

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle is not None:
            result['Cycle'] = self.cycle
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cycle') is not None:
            self.cycle = m.get('Cycle')
        return self


class ModifyAppVulScanCycleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppVulScanCycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppVulScanCycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppVulScanCycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAssetGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        source_ip: str = None,
        uuids: str = None,
    ):
        self.group_id = group_id
        self.source_ip = source_ip
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyAssetGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAssetGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAssetGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAssetGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAssetImportantRequest(TeaModel):
    def __init__(
        self,
        important_code: int = None,
        uuid_list: str = None,
    ):
        self.important_code = important_code
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.important_code is not None:
            result['ImportantCode'] = self.important_code
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImportantCode') is not None:
            self.important_code = m.get('ImportantCode')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyAssetImportantResponseBody(TeaModel):
    def __init__(
        self,
        err_code: str = None,
        err_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.err_code = err_code
        self.err_message = err_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_code is not None:
            result['ErrCode'] = self.err_code
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrCode') is not None:
            self.err_code = m.get('ErrCode')
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyAssetImportantResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAssetImportantResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAssetImportantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoDelConfigRequest(TeaModel):
    def __init__(
        self,
        days: int = None,
    ):
        # The number of days after which a detected vulnerability is automatically deleted. Unit: days. Valid values:
        # 
        # *   7
        # *   30
        # *   90
        self.days = days

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        return self


class ModifyAutoDelConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoDelConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAutoDelConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoDelConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        policy: Dict[str, Any] = None,
        policy_region_id: str = None,
        policy_version: str = None,
        uuid_list: List[str] = None,
    ):
        # The region ID of the server to which the anti-ransomware policy is applied.
        # 
        # You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.
        self.id = id
        # Modifies an anti-ransomware policy.
        self.name = name
        # ModifyBackupPolicy
        self.policy = policy
        self.policy_region_id = policy_region_id
        # WB01014029
        self.policy_version = policy_version
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyBackupPolicyShrinkRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        policy_shrink: str = None,
        policy_region_id: str = None,
        policy_version: str = None,
        uuid_list: List[str] = None,
    ):
        # The region ID of the server to which the anti-ransomware policy is applied.
        # 
        # You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.
        self.id = id
        # Modifies an anti-ransomware policy.
        self.name = name
        # ModifyBackupPolicy
        self.policy_shrink = policy_shrink
        self.policy_region_id = policy_region_id
        # WB01014029
        self.policy_version = policy_version
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy_shrink is not None:
            result['Policy'] = self.policy_shrink
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy_shrink = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBackupPolicyStatusRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        policy_version: str = None,
        status: str = None,
    ):
        # The ID of the anti-ransomware policy.
        self.id = id
        # The version of the anti-ransomware policy. Set the value to **2.0.0**.
        self.policy_version = policy_version
        # Specifies whether to enable or disable the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: enables the anti-ransomware policy. After you enable the anti-ransomware policy, the anti-ransomware feature protects data on your servers. Data on your servers is backed up based on the policy.
        # *   **disabled**: disables the anti-ransomware policy. After you disable the anti-ransomware policy, the data backup task that is running based on the policy stops.
        # 
        # >  When the system runs data backup tasks, your network bandwidth is consumed. We recommend that you enable the anti-ransomware policy during peak-off hours to back up data.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyBackupPolicyStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBackupPolicyStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyBackupPolicyStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBackupPolicyStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClearLogstoreStorageRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        lang: str = None,
        user_log_store: str = None,
        user_project: str = None,
    ):
        self.from_ = from_
        self.lang = lang
        self.user_log_store = user_log_store
        self.user_project = user_project

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.user_log_store is not None:
            result['UserLogStore'] = self.user_log_store
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('UserLogStore') is not None:
            self.user_log_store = m.get('UserLogStore')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        return self


class ModifyClearLogstoreStorageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClearLogstoreStorageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyClearLogstoreStorageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClearLogstoreStorageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientConfSetupRequest(TeaModel):
    def __init__(
        self,
        strategy_config: str = None,
        strategy_tag: str = None,
        strategy_tag_value: str = None,
    ):
        self.strategy_config = strategy_config
        self.strategy_tag = strategy_tag
        self.strategy_tag_value = strategy_tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_config is not None:
            result['StrategyConfig'] = self.strategy_config
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StrategyConfig') is not None:
            self.strategy_config = m.get('StrategyConfig')
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class ModifyClientConfSetupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientConfSetupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyClientConfSetupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientConfSetupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientConfStrategyRequest(TeaModel):
    def __init__(
        self,
        tag: str = None,
        tag_ext: str = None,
        tag_value: str = None,
        uuid: str = None,
        uuids: List[str] = None,
    ):
        # The key of the tag that is added to the agent configuration policy.
        self.tag = tag
        # The extended tag of the agent configuration policy.
        self.tag_ext = tag_ext
        # The value of the tag that is added to the agent configuration policy.
        # 
        # *   major
        # *   advanced
        # *   basic
        self.tag_value = tag_value
        # The UUID of the server that you want to query.
        self.uuid = uuid
        # The UUID of the asset. You can specify a maximum of 500 UUIDs at a time.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_ext is not None:
            result['TagExt'] = self.tag_ext
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagExt') is not None:
            self.tag_ext = m.get('TagExt')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyClientConfStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientConfStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyClientConfStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientConfStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientUserDefineRuleRequest(TeaModel):
    def __init__(
        self,
        action_type: int = None,
        cmdline: str = None,
        file_path: str = None,
        ip: str = None,
        id: int = None,
        md_5list: str = None,
        name: str = None,
        new_file_path: str = None,
        parent_cmdline: str = None,
        parent_proc_path: str = None,
        platform: str = None,
        port: int = None,
        port_str: str = None,
        proc_path: str = None,
        registry_content: str = None,
        registry_key: str = None,
        type: int = None,
    ):
        self.action_type = action_type
        self.cmdline = cmdline
        self.file_path = file_path
        self.ip = ip
        self.id = id
        self.md_5list = md_5list
        self.name = name
        self.new_file_path = new_file_path
        self.parent_cmdline = parent_cmdline
        self.parent_proc_path = parent_proc_path
        self.platform = platform
        self.port = port
        self.port_str = port_str
        self.proc_path = proc_path
        self.registry_content = registry_content
        self.registry_key = registry_key
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.ip is not None:
            result['IP'] = self.ip
        if self.id is not None:
            result['Id'] = self.id
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyClientUserDefineRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientUserDefineRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyClientUserDefineRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClusterCnnfStatusUserConfirmRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: List[str] = None,
        user_confirm: bool = None,
    ):
        self.cluster_ids = cluster_ids
        self.user_confirm = user_confirm

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.user_confirm is not None:
            result['UserConfirm'] = self.user_confirm
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('UserConfirm') is not None:
            self.user_confirm = m.get('UserConfirm')
        return self


class ModifyClusterCnnfStatusUserConfirmResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClusterCnnfStatusUserConfirmResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyClusterCnnfStatusUserConfirmResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClusterCnnfStatusUserConfirmResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyConcernNecessityRequest(TeaModel):
    def __init__(
        self,
        concern_necessity: str = None,
    ):
        # The priorities to fix the vulnerabilities. Valid values:
        # 
        # *   asap: high
        # *   later: medium
        # *   nntf: low
        self.concern_necessity = concern_necessity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.concern_necessity is not None:
            result['ConcernNecessity'] = self.concern_necessity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConcernNecessity') is not None:
            self.concern_necessity = m.get('ConcernNecessity')
        return self


class ModifyConcernNecessityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyConcernNecessityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyConcernNecessityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyConcernNecessityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCreateVulWhitelistRequest(TeaModel):
    def __init__(
        self,
        reason: str = None,
        target_info: str = None,
        whitelist: str = None,
    ):
        self.reason = reason
        self.target_info = target_info
        self.whitelist = whitelist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class ModifyCreateVulWhitelistResponseBodyVulWhitelistList(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ModifyCreateVulWhitelistResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vul_whitelist_list: List[ModifyCreateVulWhitelistResponseBodyVulWhitelistList] = None,
    ):
        self.request_id = request_id
        self.vul_whitelist_list = vul_whitelist_list

    def validate(self):
        if self.vul_whitelist_list:
            for k in self.vul_whitelist_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VulWhitelistList'] = []
        if self.vul_whitelist_list is not None:
            for k in self.vul_whitelist_list:
                result['VulWhitelistList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vul_whitelist_list = []
        if m.get('VulWhitelistList') is not None:
            for k in m.get('VulWhitelistList'):
                temp_model = ModifyCreateVulWhitelistResponseBodyVulWhitelistList()
                self.vul_whitelist_list.append(temp_model.from_map(k))
        return self


class ModifyCreateVulWhitelistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCreateVulWhitelistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCreateVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCustomBlockRecordRequest(TeaModel):
    def __init__(
        self,
        block_ip: str = None,
        bound: str = None,
        expire_time: int = None,
        resource_owner_id: int = None,
        uuids: str = None,
    ):
        self.block_ip = block_ip
        self.bound = bound
        self.expire_time = expire_time
        self.resource_owner_id = resource_owner_id
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyCustomBlockRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCustomBlockRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCustomBlockRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCycleTaskRequest(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        enable: int = None,
        first_date_str: int = None,
        interval_period: int = None,
        param: str = None,
        period_unit: str = None,
        target_end_time: int = None,
        target_start_time: int = None,
        task_name: str = None,
        task_type: str = None,
    ):
        self.config_id = config_id
        self.enable = enable
        self.first_date_str = first_date_str
        self.interval_period = interval_period
        self.param = param
        self.period_unit = period_unit
        self.target_end_time = target_end_time
        self.target_start_time = target_start_time
        self.task_name = task_name
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class ModifyCycleTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCycleTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCycleTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEmgVulSubmitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        name: str = None,
        user_agreement: str = None,
    ):
        self.lang = lang
        self.name = name
        self.user_agreement = user_agreement

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.user_agreement is not None:
            result['UserAgreement'] = self.user_agreement
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserAgreement') is not None:
            self.user_agreement = m.get('UserAgreement')
        return self


class ModifyEmgVulSubmitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEmgVulSubmitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEmgVulSubmitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEmgVulSubmitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyGroupPropertyRequest(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ModifyGroupPropertyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyGroupPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyGroupPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyGroupPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAntiBruteForceRuleRequest(TeaModel):
    def __init__(
        self,
        new_rule_id: int = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        self.new_rule_id = new_rule_id
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_rule_id is not None:
            result['NewRuleId'] = self.new_rule_id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewRuleId') is not None:
            self.new_rule_id = m.get('NewRuleId')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyInstanceAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAntiBruteForceRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceAntiBruteForceRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInterceptionRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        dst_target: Dict[str, Any] = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        src_target: Dict[str, Any] = None,
    ):
        self.cluster_id = cluster_id
        self.dst_target = dst_target
        self.intercept_type = intercept_type
        self.order_index = order_index
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_switch = rule_switch
        self.src_target = src_target

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dst_target is not None:
            result['DstTarget'] = self.dst_target
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.src_target is not None:
            result['SrcTarget'] = self.src_target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DstTarget') is not None:
            self.dst_target = m.get('DstTarget')
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('SrcTarget') is not None:
            self.src_target = m.get('SrcTarget')
        return self


class ModifyInterceptionRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        dst_target_shrink: str = None,
        intercept_type: int = None,
        order_index: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_switch: int = None,
        src_target_shrink: str = None,
    ):
        self.cluster_id = cluster_id
        self.dst_target_shrink = dst_target_shrink
        self.intercept_type = intercept_type
        self.order_index = order_index
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_switch = rule_switch
        self.src_target_shrink = src_target_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dst_target_shrink is not None:
            result['DstTarget'] = self.dst_target_shrink
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.src_target_shrink is not None:
            result['SrcTarget'] = self.src_target_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DstTarget') is not None:
            self.dst_target_shrink = m.get('DstTarget')
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('SrcTarget') is not None:
            self.src_target_shrink = m.get('SrcTarget')
        return self


class ModifyInterceptionRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInterceptionRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInterceptionRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInterceptionRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInterceptionRuleSwitchRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        rule_ids: str = None,
        rule_switch: int = None,
    ):
        self.cluster_id = cluster_id
        self.rule_ids = rule_ids
        self.rule_switch = rule_switch

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        return self


class ModifyInterceptionRuleSwitchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInterceptionRuleSwitchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInterceptionRuleSwitchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInterceptionRuleSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInterceptionTargetRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        image_list: List[str] = None,
        namespace: str = None,
        tag_list: List[str] = None,
        target_id: int = None,
        target_name: str = None,
        target_type: str = None,
    ):
        self.app_name = app_name
        self.image_list = image_list
        self.namespace = namespace
        self.tag_list = tag_list
        self.target_id = target_id
        self.target_name = target_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ModifyInterceptionTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class ModifyInterceptionTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInterceptionTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInterceptionTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLogMetaStatusRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        log_store: str = None,
        project: str = None,
        status: str = None,
    ):
        self.from_ = from_
        self.log_store = log_store
        self.project = project
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyLogMetaStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLogMetaStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLogMetaStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLogMetaStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLoginBaseConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        target: str = None,
        type: str = None,
    ):
        # The details of the configuration that is used to detect unusual logons to your servers. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **totalCount**: the total number of servers.
        # *   **uuidCount**: the number of servers to which the configuration is applied.
        # *   **id**: the ID of the configuration.
        # *   **location**: the common logon location.
        # 
        # > You must specify this field if the Type parameter is set to login_common_location.
        # 
        # *   **ip**: the common logon IP address.
        # 
        # > You must specify this field if the Type parameter is set to login_common_ip.
        # 
        # *   **endTime**: the end time of the common logon time range.
        # 
        # > You must specify this field if the Type parameter is set to login_common_time.
        # 
        # *   **startTime**: the start time of the common logon time range.
        # 
        # > You must specify this field if the Type parameter is set to login_common_time.
        # 
        # *   **account**: the common logon account.
        # 
        # > You must specify this field if the Type parameter is set to login_common_account.
        self.config = config
        # The details of the server to which the configuration is applied. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **Target**: the UUID of the server.
        # 
        # *   **targetType**: the type of the server to which the configuration is applied. Valid values:
        # 
        #     *   **uuid**: a server
        #     *   **groupId**: a server group
        # 
        # *   **flag**: the operation that you want to perform on the server. Valid values:
        # 
        #     *   **del**: removes the server from the configuration.
        #     *   **add**: adds the server to the configuration.
        self.target = target
        # The logon type of the configuration to modify. Valid values:
        # 
        # *   **login\_common_location**: common logon location
        # *   **login\_common_ip**: common logon IP address
        # *   **login\_common_time**: common logon time range
        # *   **login\_common_account**: common logon account
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyLoginBaseConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyLoginBaseConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLoginBaseConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLoginBaseConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLoginSwitchConfigRequest(TeaModel):
    def __init__(
        self,
        item: str = None,
        status: int = None,
    ):
        # The type of the logon security settings that you want to enable or disable. Valid values:
        # 
        # *   **login\_common_ip**: unapproved logon IP addresses
        # *   **login\_common_time**: unapproved logon time ranges
        # *   **login\_common_account**: unapproved logon accounts
        self.item = item
        # Specifies whether to enable the logon security settings. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyLoginSwitchConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLoginSwitchConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLoginSwitchConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLoginSwitchConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNoticeConfigRequest(TeaModel):
    def __init__(
        self,
        project: str = None,
        route: int = None,
        source_ip: str = None,
        time_limit: int = None,
    ):
        # The identifier of the notification item. Valid values:
        # 
        # *   **yundun\_security_Weekreport**: notification for vulnerabilities
        # *   **yundun\_sas\_antiransomware_task**: notification for results of restoration tasks
        # *   **sas_healthcheck**: notification for baseline checks
        # *   **sas_suspicious**: notification for alerts generated by Security Center
        # *   **yundun\_aegis\_AV_true**: notification for precision defense
        # *   **yundun\_sas\_ak_leakage**: notification for AccessKey pair leaks
        # *   **yundun\_sas\_config_alert**: notification for configuration assessment
        # *   **yundun\_sas\_vul_Emergency**: notification for urgent vulnerabilities
        # *   **yundun\_webguard_event**: notification for web tamper proofing
        # *   **yundun\_sas\_cloud\_native_firewall**: notification for alerts generated by the container firewall feature
        # *   **yundun\_sas\_cloud\_native\_firewall_Defense**: notification for proactive defense implemented by the container firewall feature
        # *   **yundun\_IP_Blocking**: notification for blocked brute-force attacks initiated from malicious IP addresses
        # *   **yundun\_sas\_anti\_virus_config**: notification for virus scan
        # *   **yundun\_sas_log**: notification for excess logs
        # *   **yundun\_honeypot_alarm**: notification for alerts generated by the honeypot feature
        # *   **aliyun\_rasp_alarm**: notification for alerts generated by the application security feature
        # *   **virusScheduleTask**: notification for completion of scheduled virus scans
        # *   **yundun\_anti_Virus**: notification that no security checks are performed
        # *   **sas_vulnerability**: notification for vulnerabilities
        # *   **weeklyreport**: notification for weekly reports
        # *   **agent**: notification that the Security Center agent is offline
        # *   **bruteforcesuccess**: notification for protection against brute-force attacks
        # *   **webshell**: notification for webshells
        # *   **suspicious**: notification for alerts generated by Server Guard
        # *   **patch**: deprecated
        # *   **remotelogin**: notification for remote logons
        # *   **health**: notification for security checks
        # *   **yundun\_sas\_cloudsiem_log**: notifications of insufficient threat analysis log capacity
        # 
        # > If the value is **yundun\_security_Weekreport**, weekly reports are sent to notify you of unhandled vulnerabilities.
        self.project = project
        # The notification method. Valid values:
        # 
        # *   **1**: text message
        # *   **2**: email
        # *   **4**: internal message
        # *   **3**: text message and email
        # *   **5**: text message and internal message
        # *   **6**: email and internal message
        # *   **7**: text message, email, and internal message
        self.route = route
        # The source IP address of the request.
        self.source_ip = source_ip
        # The time period during which Security Center sends notifications. Valid values:
        # 
        # *   **0**: any time
        # *   **1**: 08:00 to 22:00
        self.time_limit = time_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project
        if self.route is not None:
            result['Route'] = self.route
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.time_limit is not None:
            result['TimeLimit'] = self.time_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Route') is not None:
            self.route = m.get('Route')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TimeLimit') is not None:
            self.time_limit = m.get('TimeLimit')
        return self


class ModifyNoticeConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNoticeConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyNoticeConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNoticeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOpenLogShipperRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
    ):
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class ModifyOpenLogShipperResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOpenLogShipperResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyOpenLogShipperResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOpenLogShipperResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOperateVulRequest(TeaModel):
    def __init__(
        self,
        info: str = None,
        operate_type: str = None,
        reason: str = None,
        type: str = None,
    ):
        # The operation that you want to perform on the vulnerability. Valid values:
        # 
        # *   **vul_fix**: fixes the vulnerability.
        # *   **vul_verify**: verifies the vulnerability fix.
        # *   **vul_ignore**: ignores the vulnerability.
        # *   **vul_undo_ignore**: cancels ignoring the vulnerability.
        # *   **vul_delete**: deletes the vulnerability.
        self.info = info
        # Handles detected vulnerabilities. You can fix or ignore vulnerabilities. You can also verify the vulnerability fixes.
        self.operate_type = operate_type
        self.reason = reason
        # ModifyOperateVul
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyOperateVulResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOperateVulResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyOperateVulResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOperateVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPropertyScheduleConfigRequest(TeaModel):
    def __init__(
        self,
        schedule_time: str = None,
        type: str = None,
    ):
        self.schedule_time = schedule_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyPropertyScheduleConfigResponseBody(TeaModel):
    def __init__(
        self,
        modify_result: bool = None,
        request_id: str = None,
    ):
        self.modify_result = modify_result
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.modify_result is not None:
            result['ModifyResult'] = self.modify_result
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModifyResult') is not None:
            self.modify_result = m.get('ModifyResult')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPropertyScheduleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyPropertyScheduleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPushAllTaskRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        tasks: str = None,
        uuids: str = None,
    ):
        # The source IP address of the request.
        self.source_ip = source_ip
        # The UUIDs of servers on which you want to perform security check tasks. Separate multiple UUIDs with commas (,).
        self.tasks = tasks
        # The message that describes the security check failure.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tasks is not None:
            result['Tasks'] = self.tasks
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tasks') is not None:
            self.tasks = m.get('Tasks')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        instance_id: str = None,
        instance_name: str = None,
        ip: str = None,
        message: str = None,
        online: bool = None,
        os_version: str = None,
        region: str = None,
        success: bool = None,
        uuid: str = None,
    ):
        # The region in which the server resides.
        self.group_id = group_id
        self.instance_id = instance_id
        # The ID of the server.
        self.instance_name = instance_name
        self.ip = ip
        # ModifyPushAllTask
        self.message = message
        # Performs security check tasks on servers with a few clicks.
        self.online = online
        self.os_version = os_version
        # 1.2.XX.XX
        self.region = region
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.success = success
        # Indicates whether the Security Center agent is online. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  If the Security Center agent of the server is offline, Security Center does not protect the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.message is not None:
            result['Message'] = self.message
        if self.online is not None:
            result['Online'] = self.online
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.region is not None:
            result['Region'] = self.region
        if self.success is not None:
            result['Success'] = self.success
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyPushAllTaskResponseBodyPushTaskRsp(TeaModel):
    def __init__(
        self,
        push_task_result_list: List[ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList] = None,
    ):
        # The UUID of the server.
        self.push_task_result_list = push_task_result_list

    def validate(self):
        if self.push_task_result_list:
            for k in self.push_task_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PushTaskResultList'] = []
        if self.push_task_result_list is not None:
            for k in self.push_task_result_list:
                result['PushTaskResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.push_task_result_list = []
        if m.get('PushTaskResultList') is not None:
            for k in m.get('PushTaskResultList'):
                temp_model = ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList()
                self.push_task_result_list.append(temp_model.from_map(k))
        return self


class ModifyPushAllTaskResponseBody(TeaModel):
    def __init__(
        self,
        push_task_rsp: ModifyPushAllTaskResponseBodyPushTaskRsp = None,
        request_id: str = None,
    ):
        # The ID of the server group to which the server belongs.
        self.push_task_rsp = push_task_rsp
        # HEALTH_CHECK,OVAL_ENTITY
        self.request_id = request_id

    def validate(self):
        if self.push_task_rsp:
            self.push_task_rsp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.push_task_rsp is not None:
            result['PushTaskRsp'] = self.push_task_rsp.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PushTaskRsp') is not None:
            temp_model = ModifyPushAllTaskResponseBodyPushTaskRsp()
            self.push_task_rsp = temp_model.from_map(m['PushTaskRsp'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPushAllTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyPushAllTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPushAllTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRefreshProcessInfoRequest(TeaModel):
    def __init__(
        self,
        uuid: str = None,
    ):
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyRefreshProcessInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRefreshProcessInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyRefreshProcessInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRefreshProcessInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRiskCheckStatusRequest(TeaModel):
    def __init__(
        self,
        item_id: int = None,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        status: str = None,
        task_id: int = None,
    ):
        # The ID of the check item.
        self.item_id = item_id
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip
        # The method to handle the check item. Valid values:
        # 
        # *   **ignored**: ignores the check item
        # *   **reset**: cancels ignoring the check item
        self.status = status
        # The ID of the check task to which the check item belongs.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ModifyRiskCheckStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRiskCheckStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyRiskCheckStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRiskCheckStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRiskSingleResultStatusRequest(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        status: str = None,
        task_id: int = None,
    ):
        # The IDs of the affected assets.
        self.ids = ids
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip
        # The method to handle the risk item. Valid values:
        # 
        # *   **ignored**: ignores the risk item.
        # *   **failed**: cancels ignoring the risk item.
        self.status = status
        # The ID of the check task to which the affected assets belong.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ModifyRiskSingleResultStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRiskSingleResultStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyRiskSingleResultStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRiskSingleResultStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityCheckScheduleConfigRequest(TeaModel):
    def __init__(
        self,
        days_of_week: str = None,
        end_time: int = None,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        start_time: int = None,
    ):
        self.days_of_week = days_of_week
        self.end_time = end_time
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        self.source_ip = source_ip
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifySecurityCheckScheduleConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityCheckScheduleConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySecurityCheckScheduleConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityCheckScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityEventMarkMissIndividuallyRequest(TeaModel):
    def __init__(
        self,
        delete_mark_miss_param: str = None,
        from_: str = None,
        insert_mark_miss_param: str = None,
        lang: str = None,
        source_ip: str = None,
    ):
        self.delete_mark_miss_param = delete_mark_miss_param
        self.from_ = from_
        self.insert_mark_miss_param = insert_mark_miss_param
        self.lang = lang
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_mark_miss_param is not None:
            result['DeleteMarkMissParam'] = self.delete_mark_miss_param
        if self.from_ is not None:
            result['From'] = self.from_
        if self.insert_mark_miss_param is not None:
            result['InsertMarkMissParam'] = self.insert_mark_miss_param
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteMarkMissParam') is not None:
            self.delete_mark_miss_param = m.get('DeleteMarkMissParam')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('InsertMarkMissParam') is not None:
            self.insert_mark_miss_param = m.get('InsertMarkMissParam')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class ModifySecurityEventMarkMissIndividuallyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        time_cost: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class ModifySecurityEventMarkMissIndividuallyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySecurityEventMarkMissIndividuallyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityEventMarkMissIndividuallyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStartVulScanRequest(TeaModel):
    def __init__(
        self,
        types: str = None,
        uuids: str = None,
    ):
        self.types = types
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types is not None:
            result['Types'] = self.types
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyStartVulScanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStartVulScanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyStartVulScanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStartVulScanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStrategyRequest(TeaModel):
    def __init__(
        self,
        custom_type: str = None,
        cycle_days: str = None,
        cycle_start_time: str = None,
        end_time: str = None,
        id: str = None,
        name: str = None,
        risk_custom_params: str = None,
        risk_sub_type_name: str = None,
        source_ip: str = None,
        start_time: str = None,
        target_type: str = None,
    ):
        self.custom_type = custom_type
        self.cycle_days = cycle_days
        self.cycle_start_time = cycle_start_time
        self.end_time = end_time
        self.id = id
        self.name = name
        self.risk_custom_params = risk_custom_params
        self.risk_sub_type_name = risk_sub_type_name
        self.source_ip = source_ip
        self.start_time = start_time
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.risk_custom_params is not None:
            result['RiskCustomParams'] = self.risk_custom_params
        if self.risk_sub_type_name is not None:
            result['RiskSubTypeName'] = self.risk_sub_type_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RiskCustomParams') is not None:
            self.risk_custom_params = m.get('RiskCustomParams')
        if m.get('RiskSubTypeName') is not None:
            self.risk_sub_type_name = m.get('RiskSubTypeName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ModifyStrategyResponseBodyResult(TeaModel):
    def __init__(
        self,
        strategy_id: int = None,
    ):
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class ModifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        http_status_code: int = None,
        request_id: str = None,
        result: ModifyStrategyResponseBodyResult = None,
        success: bool = None,
    ):
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ModifyStrategyResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStrategyTargetRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        source_ip: str = None,
        target: str = None,
        type: str = None,
    ):
        self.config = config
        self.source_ip = source_ip
        self.target = target
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyStrategyTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStrategyTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyStrategyTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStrategyTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTagWithUuidRequest(TeaModel):
    def __init__(
        self,
        machine_types: str = None,
        tag_id: str = None,
        tag_list: str = None,
        uuid_list: str = None,
    ):
        self.machine_types = machine_types
        self.tag_id = tag_id
        self.tag_list = tag_list
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyTagWithUuidResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTagWithUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyTagWithUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUniBackupPolicyRequest(TeaModel):
    def __init__(
        self,
        account_name: str = None,
        account_password: str = None,
        full_plan: Dict[str, Any] = None,
        inc_plan: Dict[str, Any] = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_status: str = None,
        retention: int = None,
        speed_limiter: int = None,
    ):
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**\
        # *   **disabled**\
        self.account_name = account_name
        # The data returned.
        self.account_password = account_password
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.full_plan = full_plan
        self.inc_plan = inc_plan
        # The name of the database account.
        self.policy_id = policy_id
        # The password of the database account.
        self.policy_name = policy_name
        self.policy_status = policy_status
        # The policy for full backup. The value of this parameter is a JSON string that contains the following fields:
        # 
        # *   **start**: the start time of a backup task
        # *   **interval**: the interval of backup tasks
        # *   **type**: the unit of the interval
        # *   **days**: the days of a week on which a backup task is performed
        self.retention = retention
        # The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:
        # 
        # *   **start**: the start time of a backup task
        # *   **interval**: the interval of backup tasks
        # *   **type**: the unit of the interval
        # *   **days**: the days of a week on which a backup task is performed
        self.speed_limiter = speed_limiter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('FullPlan') is not None:
            self.full_plan = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan = m.get('IncPlan')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class ModifyUniBackupPolicyShrinkRequest(TeaModel):
    def __init__(
        self,
        account_name: str = None,
        account_password: str = None,
        full_plan_shrink: str = None,
        inc_plan_shrink: str = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_status: str = None,
        retention: int = None,
        speed_limiter: int = None,
    ):
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**\
        # *   **disabled**\
        self.account_name = account_name
        # The data returned.
        self.account_password = account_password
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.full_plan_shrink = full_plan_shrink
        self.inc_plan_shrink = inc_plan_shrink
        # The name of the database account.
        self.policy_id = policy_id
        # The password of the database account.
        self.policy_name = policy_name
        self.policy_status = policy_status
        # The policy for full backup. The value of this parameter is a JSON string that contains the following fields:
        # 
        # *   **start**: the start time of a backup task
        # *   **interval**: the interval of backup tasks
        # *   **type**: the unit of the interval
        # *   **days**: the days of a week on which a backup task is performed
        self.retention = retention
        # The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:
        # 
        # *   **start**: the start time of a backup task
        # *   **interval**: the interval of backup tasks
        # *   **type**: the unit of the interval
        # *   **days**: the days of a week on which a backup task is performed
        self.speed_limiter = speed_limiter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.full_plan_shrink is not None:
            result['FullPlan'] = self.full_plan_shrink
        if self.inc_plan_shrink is not None:
            result['IncPlan'] = self.inc_plan_shrink
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('FullPlan') is not None:
            self.full_plan_shrink = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan_shrink = m.get('IncPlan')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class ModifyUniBackupPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUniBackupPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyUniBackupPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVpcHoneyPotRequest(TeaModel):
    def __init__(
        self,
        honey_pot_action: str = None,
        vpc_id: str = None,
    ):
        self.honey_pot_action = honey_pot_action
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honey_pot_action is not None:
            result['HoneyPotAction'] = self.honey_pot_action
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneyPotAction') is not None:
            self.honey_pot_action = m.get('HoneyPotAction')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ModifyVpcHoneyPotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVpcHoneyPotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVpcHoneyPotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        type: str = None,
    ):
        self.config = config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyVulConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVulConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulTargetRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        target: str = None,
    ):
        self.config = config
        self.target = target

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        return self


class ModifyVulTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVulTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulTargetConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        source_ip: str = None,
        type: str = None,
        uuid: str = None,
    ):
        self.config = config
        # 1.2.XX.XX
        self.source_ip = source_ip
        # Configures vulnerability detection for a server.
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyVulTargetConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulTargetConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVulTargetConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulWhitelistTargetRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        reason: str = None,
        source_ip: str = None,
        target_info: str = None,
    ):
        self.id = id
        self.reason = reason
        self.source_ip = source_ip
        self.target_info = target_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class ModifyVulWhitelistTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulWhitelistTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVulWhitelistTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulWhitelistTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockCreateConfigRequest(TeaModel):
    def __init__(
        self,
        defence_mode: str = None,
        dir: str = None,
        exclusive_dir: str = None,
        exclusive_file: str = None,
        exclusive_file_type: str = None,
        inclusive_file: str = None,
        inclusive_file_type: str = None,
        lang: str = None,
        local_backup_dir: str = None,
        mode: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        # The prevention mode. Valid values:
        # 
        # *   **block**: Interception Mode
        # *   **audit**: Alert Mode
        self.defence_mode = defence_mode
        # The directory that you want to protect.
        self.dir = dir
        # The directory for which you want to disable web tamper proofing.
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_dir = exclusive_dir
        # The file for which you want to disable web tamper proofing.
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_file = exclusive_file
        # The type of file for which you want to disable web tamper proofing. Separate multiple types with semicolons (;). Valid values:
        # 
        # *   php
        # *   jsp
        # *   asp
        # *   aspx
        # *   js
        # *   cgi
        # *   html
        # *   htm
        # *   xml
        # *   shtml
        # *   shtm
        # *   jpg
        # *   gif
        # *   png
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_file_type = exclusive_file_type
        # The file for which you want to enable web tamper proofing.
        # 
        # > If you set **Mode** to **whitelist**, you must specify this parameter.
        self.inclusive_file = inclusive_file
        # The type of file for which you want to enable web tamper proofing. Separate multiple types with semicolons (;). Valid values:
        # 
        # *   php
        # *   jsp
        # *   asp
        # *   aspx
        # *   js
        # *   cgi
        # *   html
        # *   htm
        # *   xml
        # *   shtml
        # *   shtm
        # *   jpg
        # *   gif
        # *   png
        # 
        # > If you set **Mode** to **whitelist**, you must specify this parameter.
        self.inclusive_file_type = inclusive_file_type
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The local path to the backup files of the protected directory.
        self.local_backup_dir = local_backup_dir
        # The protection mode of web tamper proofing. Valid values:
        # 
        # *   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
        # *   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified sub-directories, file types, and files in the protected directories.
        self.mode = mode
        # The source IP address of the request.
        self.source_ip = source_ip
        # The UUID of the server for which you want to add a directory to protect.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockCreateConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockCreateConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockCreateConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockCreateConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockDeleteConfigRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        lang: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        # The ID of the protected directory that you want to delete.
        # 
        # > You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the IDs of protected directories.
        self.id = id
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # The UUID of the server for which you want to delete the protected directory.
        # 
        # > You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockDeleteConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockDeleteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockDeleteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockDeleteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockProcessStatusRequest(TeaModel):
    def __init__(
        self,
        deal_all: int = None,
        operate_info: str = None,
        process_path: List[str] = None,
        status: int = None,
        uuid: str = None,
    ):
        self.deal_all = deal_all
        self.operate_info = operate_info
        self.process_path = process_path
        self.status = status
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deal_all is not None:
            result['DealAll'] = self.deal_all
        if self.operate_info is not None:
            result['OperateInfo'] = self.operate_info
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DealAll') is not None:
            self.deal_all = m.get('DealAll')
        if m.get('OperateInfo') is not None:
            self.operate_info = m.get('OperateInfo')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockProcessStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockProcessStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockProcessStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockProcessStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockStartRequest(TeaModel):
    def __init__(
        self,
        defence_mode: str = None,
        dir: str = None,
        exclusive_dir: str = None,
        exclusive_file: str = None,
        exclusive_file_type: str = None,
        inclusive_file_type: str = None,
        local_backup_dir: str = None,
        mode: str = None,
        uuid: str = None,
    ):
        # The prevention mode. Valid values:
        # 
        # *   **block**: Interception Mode
        # *   **audit**: Alert Mode
        self.defence_mode = defence_mode
        # The directory for which you want to enable web tamper proofing. Separate multiple directories with commas (,).
        self.dir = dir
        # The directory for which you want to disable web tamper proofing.
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_dir = exclusive_dir
        # The file for which you want to disable web tamper proofing.
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_file = exclusive_file
        # The type of the file for which you want to disable web tamper proofing. Separate multiple types with semicolons (;). Valid values:
        # 
        # *   php
        # *   jsp
        # *   asp
        # *   aspx
        # *   js
        # *   cgi
        # *   html
        # *   htm
        # *   xml
        # *   shtml
        # *   shtm
        # *   jpg
        # *   gif
        # *   png
        # 
        # > If you set **Mode** to **blacklist**, you must specify this parameter.
        self.exclusive_file_type = exclusive_file_type
        # The type of the file for which you want to enable web tamper proofing. Separate multiple types with semicolons (;). Valid values:
        # 
        # *   php
        # *   jsp
        # *   asp
        # *   aspx
        # *   js
        # *   cgi
        # *   html
        # *   htm
        # *   xml
        # *   shtml
        # *   shtm
        # *   jpg
        # *   gif
        # *   png
        # 
        # > If you set **Mode** to **whitelist**, you must specify this parameter.
        self.inclusive_file_type = inclusive_file_type
        # The local path to the backup files of the protected directory.\
        # The directory format of a Linux server is different from that of a Windows server. You must enter the directory in the required format based on your operating system. Examples:
        # 
        # *   Linux server: /usr/local/aegis/bak
        # *   Windows server: C:\Program Files (x86)\Alibaba\Aegis\bak
        self.local_backup_dir = local_backup_dir
        # The protection mode of web tamper proofing. Valid values:
        # 
        # *   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
        # *   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified subdirectories, file types, and files in the protected directory.
        self.mode = mode
        # The UUID of the server for which you want to enable web tamper proofing.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockStartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockStartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockStartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockStartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        status: str = None,
        uuid: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # Specifies whether to enable or disable web tamper proofing for the specified server. Valid values:
        # 
        # *   **on**: enables web tamper proofing
        # *   **off**: disables web tamper proofing
        # 
        # > After you disable web tamper proofing for the specified server, one quota is released.
        self.status = status
        # The UUID of the server for which you want to enable or disable web tamper proofing. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockUnbindRequest(TeaModel):
    def __init__(
        self,
        uuid: str = None,
    ):
        # The UUID of the server for which you want to disable web tamper proofing.
        # 
        # > You can call the [DescribeWebLockBindList](~~DescribeWebLockBindList~~) operation to query the UUIDs of servers.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockUnbindResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockUnbindResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockUnbindResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockUnbindResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockUpdateConfigRequest(TeaModel):
    def __init__(
        self,
        defence_mode: str = None,
        dir: str = None,
        exclusive_dir: str = None,
        exclusive_file: str = None,
        exclusive_file_type: str = None,
        id: int = None,
        inclusive_file: str = None,
        inclusive_file_type: str = None,
        lang: str = None,
        local_backup_dir: str = None,
        mode: str = None,
        source_ip: str = None,
        uuid: str = None,
    ):
        self.defence_mode = defence_mode
        self.dir = dir
        self.exclusive_dir = exclusive_dir
        self.exclusive_file = exclusive_file
        self.exclusive_file_type = exclusive_file_type
        self.id = id
        self.inclusive_file = inclusive_file
        self.inclusive_file_type = inclusive_file_type
        self.lang = lang
        self.local_backup_dir = local_backup_dir
        self.mode = mode
        self.source_ip = source_ip
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockUpdateConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockUpdateConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebLockUpdateConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockUpdateConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebPathRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        target: str = None,
        type: str = None,
    ):
        self.config = config
        self.target = target
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyWebPathResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyWebPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyWebPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenSensitiveFileScanRequest(TeaModel):
    def __init__(
        self,
        switch_on: str = None,
    ):
        self.switch_on = switch_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.switch_on is not None:
            result['SwitchOn'] = self.switch_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SwitchOn') is not None:
            self.switch_on = m.get('SwitchOn')
        return self


class OpenSensitiveFileScanResponseBodyData(TeaModel):
    def __init__(
        self,
        switch_on: str = None,
    ):
        self.switch_on = switch_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.switch_on is not None:
            result['SwitchOn'] = self.switch_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SwitchOn') is not None:
            self.switch_on = m.get('SwitchOn')
        return self


class OpenSensitiveFileScanResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: OpenSensitiveFileScanResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = OpenSensitiveFileScanResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OpenSensitiveFileScanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenSensitiveFileScanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenSensitiveFileScanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateAgentClientInstallRequest(TeaModel):
    def __init__(
        self,
        instance_ids: str = None,
        lang: str = None,
        uuids: str = None,
    ):
        # The IDs of the servers on which you want to install the Security Center agent. Separate multiple IDs with commas (,).
        # 
        # > You must specify at least one of the **InstanceIds** and **Uuids** parameters before you can call this operation.
        self.instance_ids = instance_ids
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The UUIDs of the servers on which you want to install the Security Center agent. Separate multiple UUIDs with commas (,).
        # 
        # > You must specify at least one of the **InstanceIds** and **Uuids** parameters before you can call this operation.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        record_id: int = None,
        uuid: str = None,
    ):
        # The ID of the server.
        self.instance_id = instance_id
        # The ID of the installation task.
        self.record_id = record_id
        # The UUID of the server.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class OperateAgentClientInstallResponseBody(TeaModel):
    def __init__(
        self,
        aegis_celint_install_respose_list: List[OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList] = None,
        request_id: str = None,
    ):
        # An array that consists of the returned results.
        self.aegis_celint_install_respose_list = aegis_celint_install_respose_list
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.aegis_celint_install_respose_list:
            for k in self.aegis_celint_install_respose_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisCelintInstallResposeList'] = []
        if self.aegis_celint_install_respose_list is not None:
            for k in self.aegis_celint_install_respose_list:
                result['AegisCelintInstallResposeList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aegis_celint_install_respose_list = []
        if m.get('AegisCelintInstallResposeList') is not None:
            for k in m.get('AegisCelintInstallResposeList'):
                temp_model = OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList()
                self.aegis_celint_install_respose_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateAgentClientInstallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateAgentClientInstallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateAgentClientInstallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateCommonOverallConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        source_ip: str = None,
        type: str = None,
    ):
        self.config = config
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateCommonOverallConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateCommonOverallConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateCommonOverallConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateCommonTargetConfigRequest(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_value: str = None,
        source_ip: str = None,
        target_operations: str = None,
        target_type: str = None,
        type: str = None,
    ):
        # The name of the image repository or the namespace of the image repository.
        self.field_name = field_name
        # The data returned.
        self.field_value = field_value
        # The type of the feature. Valid values:
        # 
        # *   **alidetect-scan-enable**: local file detection
        # *   **ACTION-TRIAL-PERMISSION**: data delivery of ActionTrail
        # *   **alidetect**: local file detection engine
        # *   **container\_prevent\_escape**: container escape prevention
        # *   **image\_repo**: repository image scan
        # *   **proc\_filter\_switch**: log filtering
        # *   **agentless**: agentless detection
        # *   **rasp**: application protection
        # *   **sensitiveFile**: sensitive file detection
        # *   **aliscriptengine**: in-depth detection engine
        # *   **containerNetwork**: container network visualization
        self.source_ip = source_ip
        # The type of the image. Valid values:
        # 
        # *   **repoName**: the name of the image repository
        # *   **repoNamespace**: the namespace of the image repository
        self.target_operations = target_operations
        # The configuration of proactive defense for your server. The value includes the following fields:
        # 
        # *   **targetType**: specifies the dimension from which you manage proactive defense. UUIDs are supported. Set the value to **uuid**.
        # *   **target**: specifies the UUID of the server for which you want to configure proactive defense.
        # *   **flag**: specifies whether to enable or disable proactive defense for your server. Valid values are **add** and **del**. The value add indicates that proactive defense will be enabled for your server. The value del indicates that proactive defense will be disabled for your server.
        self.target_type = target_type
        # The dimension based on which you want to configure the feature. Valid values:
        # 
        # *   **uuid**: the UUID of the server
        # *   **Cluster**: the ID of the cluster
        # *   **image_repo**: the name of the image repository
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_operations is not None:
            result['TargetOperations'] = self.target_operations
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetOperations') is not None:
            self.target_operations = m.get('TargetOperations')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateCommonTargetConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateCommonTargetConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateCommonTargetConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateCommonTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateImageBaselineWhitelistRequest(TeaModel):
    def __init__(
        self,
        baseline_item_key_list: str = None,
        image_uuid: str = None,
        lang: str = None,
        operation: str = None,
        scan_range: List[str] = None,
    ):
        self.baseline_item_key_list = baseline_item_key_list
        self.image_uuid = image_uuid
        self.lang = lang
        self.operation = operation
        self.scan_range = scan_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_key_list is not None:
            result['BaselineItemKeyList'] = self.baseline_item_key_list
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineItemKeyList') is not None:
            self.baseline_item_key_list = m.get('BaselineItemKeyList')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class OperateImageBaselineWhitelistResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateImageBaselineWhitelistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateImageBaselineWhitelistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateImageBaselineWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateImageVulRequest(TeaModel):
    def __init__(
        self,
        info: str = None,
        operate_type: str = None,
        type: str = None,
    ):
        self.info = info
        self.operate_type = operate_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateImageVulResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateImageVulResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateImageVulResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateImageVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateSuspiciousOverallConfigRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        lang: str = None,
        no_target_as_on: bool = None,
        source_ip: str = None,
        type: str = None,
    ):
        self.config = config
        self.lang = lang
        self.no_target_as_on = no_target_as_on
        # OperateSuspiciousOverallConfig
        self.source_ip = source_ip
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.no_target_as_on is not None:
            result['NoTargetAsOn'] = self.no_target_as_on
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NoTargetAsOn') is not None:
            self.no_target_as_on = m.get('NoTargetAsOn')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateSuspiciousOverallConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateSuspiciousOverallConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateSuspiciousOverallConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateSuspiciousOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateSuspiciousTargetConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        target_operations: str = None,
        target_type: str = None,
        type: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The source IP address of the request.
        self.source_ip = source_ip
        # The configuration of proactive defense for your server. The value includes the following fields:
        # 
        # *   **targetType**: specifies the dimension from which you manage proactive defense. UUIDs are supported. Set the value to **uuid**.
        # *   **target**: specifies the UUID of the server for which you want to configure proactive defense.
        # *   **flag**: specifies whether to enable or disable proactive defense for your server. Valid values are **add** and **del**. The value add indicates that proactive defense will be enabled for your server. The value del indicates that proactive defense will be disabled for your server.
        self.target_operations = target_operations
        # The dimension from which you manage proactive defense. Only the server UUID dimension is supported.
        # 
        # Set the value to **uuid**.
        self.target_type = target_type
        # The type of proactive defense. Valid Values:
        # 
        # *   **auto_breaking**: automatic blocking
        # *   **webshell_cloud_breaking**: webshell defense
        # *   **alinet**: malicious behavior defense
        # *   **ransomware_breaking**: ransomware capture
        # *   **alisecguard**: client protection
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_operations is not None:
            result['TargetOperations'] = self.target_operations
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetOperations') is not None:
            self.target_operations = m.get('TargetOperations')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateSuspiciousTargetConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateSuspiciousTargetConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateSuspiciousTargetConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateSuspiciousTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateVirusEventsRequest(TeaModel):
    def __init__(
        self,
        operation_all: int = None,
        operation_code: str = None,
        operation_range: str = None,
    ):
        # Specifies whether to handle all alert events. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.operation_all = operation_all
        # The operation that you want to perform on the alert events. Valid values:
        # 
        # *   **default**: performs in-depth detection and removal
        # *   **ignore**: ignores the alert event
        # *   **advance_mark_mis_info**: adds the alert events to the whitelist
        # *   **manual_handled**: marks the alert events as manually handled
        self.operation_code = operation_code
        # The handling scope.
        self.operation_range = operation_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_all is not None:
            result['OperationAll'] = self.operation_all
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_range is not None:
            result['OperationRange'] = self.operation_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationAll') is not None:
            self.operation_all = m.get('OperationAll')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationRange') is not None:
            self.operation_range = m.get('OperationRange')
        return self


class OperateVirusEventsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the task to handle multiple alert events at a time.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class OperateVirusEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateVirusEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateVirusEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateVulsRequest(TeaModel):
    def __init__(
        self,
        operate_type: str = None,
        type: str = None,
        uuids: List[str] = None,
        vul_names: List[str] = None,
    ):
        self.operate_type = operate_type
        self.type = type
        self.uuids = uuids
        self.vul_names = vul_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vul_names is not None:
            result['VulNames'] = self.vul_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VulNames') is not None:
            self.vul_names = m.get('VulNames')
        return self


class OperateVulsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateVulsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateVulsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateVulsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateWebLockFileEventsRequest(TeaModel):
    def __init__(
        self,
        deal_all: int = None,
        event_ids: List[int] = None,
        operation_code: str = None,
    ):
        self.deal_all = deal_all
        self.event_ids = event_ids
        self.operation_code = operation_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deal_all is not None:
            result['DealAll'] = self.deal_all
        if self.event_ids is not None:
            result['EventIds'] = self.event_ids
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DealAll') is not None:
            self.deal_all = m.get('DealAll')
        if m.get('EventIds') is not None:
            self.event_ids = m.get('EventIds')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        return self


class OperateWebLockFileEventsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateWebLockFileEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateWebLockFileEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateWebLockFileEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperationCancelIgnoreSuspEventRequest(TeaModel):
    def __init__(
        self,
        security_event_ids: List[int] = None,
    ):
        # OperationCancelIgnoreSuspEvent
        self.security_event_ids = security_event_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        return self


class OperationCancelIgnoreSuspEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        time_cost: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class OperationCancelIgnoreSuspEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperationCancelIgnoreSuspEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperationCancelIgnoreSuspEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperationSuspEventsRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        operation: str = None,
        source_ip: str = None,
        sub_operation: str = None,
        suspicious_event_ids: str = None,
        warn_type: str = None,
    ):
        self.from_ = from_
        # WB01014029
        self.operation = operation
        # Handles multiple exceptions at a time.
        self.source_ip = source_ip
        self.sub_operation = sub_operation
        # OperationSuspEvents
        self.suspicious_event_ids = suspicious_event_ids
        self.warn_type = warn_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.sub_operation is not None:
            result['SubOperation'] = self.sub_operation
        if self.suspicious_event_ids is not None:
            result['SuspiciousEventIds'] = self.suspicious_event_ids
        if self.warn_type is not None:
            result['WarnType'] = self.warn_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SubOperation') is not None:
            self.sub_operation = m.get('SubOperation')
        if m.get('SuspiciousEventIds') is not None:
            self.suspicious_event_ids = m.get('SuspiciousEventIds')
        if m.get('WarnType') is not None:
            self.warn_type = m.get('WarnType')
        return self


class OperationSuspEventsResponseBody(TeaModel):
    def __init__(
        self,
        access_code: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.access_code = access_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_code is not None:
            result['AccessCode'] = self.access_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessCode') is not None:
            self.access_code = m.get('AccessCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OperationSuspEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperationSuspEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperationSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PageImageRegistryRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        registry_name_like: str = None,
        registry_type_in_list: List[str] = None,
        registry_type_not_in_list: List[str] = None,
        source_ip: str = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.registry_name_like = registry_name_like
        self.registry_type_in_list = registry_type_in_list
        self.registry_type_not_in_list = registry_type_not_in_list
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.registry_name_like is not None:
            result['RegistryNameLike'] = self.registry_name_like
        if self.registry_type_in_list is not None:
            result['RegistryTypeInList'] = self.registry_type_in_list
        if self.registry_type_not_in_list is not None:
            result['RegistryTypeNotInList'] = self.registry_type_not_in_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegistryNameLike') is not None:
            self.registry_name_like = m.get('RegistryNameLike')
        if m.get('RegistryTypeInList') is not None:
            self.registry_type_in_list = m.get('RegistryTypeInList')
        if m.get('RegistryTypeNotInList') is not None:
            self.registry_type_not_in_list = m.get('RegistryTypeNotInList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class PageImageRegistryResponseBodyList(TeaModel):
    def __init__(
        self,
        black_list: str = None,
        domain_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        image_count: int = None,
        jenkins_env: str = None,
        net_type: int = None,
        password: str = None,
        persistence_day: int = None,
        protocol_type: int = None,
        region_id: str = None,
        registry_host_ip: str = None,
        registry_name: str = None,
        registry_type: str = None,
        token: str = None,
        trans_per_hour: int = None,
        user_name: str = None,
        vpc_id: str = None,
        white_list: str = None,
    ):
        self.black_list = black_list
        self.domain_name = domain_name
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.image_count = image_count
        self.jenkins_env = jenkins_env
        self.net_type = net_type
        self.password = password
        self.persistence_day = persistence_day
        self.protocol_type = protocol_type
        self.region_id = region_id
        self.registry_host_ip = registry_host_ip
        self.registry_name = registry_name
        self.registry_type = registry_type
        self.token = token
        self.trans_per_hour = trans_per_hour
        self.user_name = user_name
        self.vpc_id = vpc_id
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_list is not None:
            result['BlackList'] = self.black_list
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.jenkins_env is not None:
            result['JenkinsEnv'] = self.jenkins_env
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlackList') is not None:
            self.black_list = m.get('BlackList')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('JenkinsEnv') is not None:
            self.jenkins_env = m.get('JenkinsEnv')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class PageImageRegistryResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        self.current_page = current_page
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PageImageRegistryResponseBody(TeaModel):
    def __init__(
        self,
        list: List[PageImageRegistryResponseBodyList] = None,
        page_info: PageImageRegistryResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        self.list = list
        self.page_info = page_info
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = PageImageRegistryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = PageImageRegistryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PageImageRegistryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PageImageRegistryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PageImageRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseClientRequest(TeaModel):
    def __init__(
        self,
        uuids: str = None,
        value: str = None,
    ):
        # The UUIDs of servers for which you want to enable or disable the Security Center agent.
        self.uuids = uuids
        # The status of the Security Center agent. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PauseClientResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PauseClientResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PauseClientResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicCreateImageScanTaskRequest(TeaModel):
    def __init__(
        self,
        digests: str = None,
        instance_ids: str = None,
        region_ids: str = None,
        registry_types: str = None,
        repo_ids: str = None,
        repo_names: str = None,
        repo_namespaces: str = None,
        source_ip: str = None,
        tags: str = None,
    ):
        self.digests = digests
        self.instance_ids = instance_ids
        self.region_ids = region_ids
        self.registry_types = registry_types
        self.repo_ids = repo_ids
        self.repo_names = repo_names
        self.repo_namespaces = repo_namespaces
        self.source_ip = source_ip
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digests is not None:
            result['Digests'] = self.digests
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.registry_types is not None:
            result['RegistryTypes'] = self.registry_types
        if self.repo_ids is not None:
            result['RepoIds'] = self.repo_ids
        if self.repo_names is not None:
            result['RepoNames'] = self.repo_names
        if self.repo_namespaces is not None:
            result['RepoNamespaces'] = self.repo_namespaces
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digests') is not None:
            self.digests = m.get('Digests')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('RegistryTypes') is not None:
            self.registry_types = m.get('RegistryTypes')
        if m.get('RepoIds') is not None:
            self.repo_ids = m.get('RepoIds')
        if m.get('RepoNames') is not None:
            self.repo_names = m.get('RepoNames')
        if m.get('RepoNamespaces') is not None:
            self.repo_namespaces = m.get('RepoNamespaces')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class PublicCreateImageScanTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        can_create: bool = None,
        collect_time: int = None,
        exec_time: int = None,
        finish_count: int = None,
        progress: int = None,
        result: str = None,
        status: str = None,
        task_id: str = None,
        total_count: int = None,
    ):
        self.can_create = can_create
        self.collect_time = collect_time
        self.exec_time = exec_time
        self.finish_count = finish_count
        self.progress = progress
        self.result = result
        self.status = status
        self.task_id = task_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PublicCreateImageScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        data: PublicCreateImageScanTaskResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicCreateImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicCreateImageScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublicCreateImageScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicCreateImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicPreCheckImageScanTaskRequest(TeaModel):
    def __init__(
        self,
        digests: str = None,
        instance_ids: str = None,
        region_ids: str = None,
        registry_types: str = None,
        repo_ids: str = None,
        repo_names: str = None,
        repo_namespaces: str = None,
        source_ip: str = None,
        tags: str = None,
    ):
        self.digests = digests
        self.instance_ids = instance_ids
        self.region_ids = region_ids
        self.registry_types = registry_types
        self.repo_ids = repo_ids
        self.repo_names = repo_names
        self.repo_namespaces = repo_namespaces
        self.source_ip = source_ip
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digests is not None:
            result['Digests'] = self.digests
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.registry_types is not None:
            result['RegistryTypes'] = self.registry_types
        if self.repo_ids is not None:
            result['RepoIds'] = self.repo_ids
        if self.repo_names is not None:
            result['RepoNames'] = self.repo_names
        if self.repo_namespaces is not None:
            result['RepoNamespaces'] = self.repo_namespaces
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Digests') is not None:
            self.digests = m.get('Digests')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('RegistryTypes') is not None:
            self.registry_types = m.get('RegistryTypes')
        if m.get('RepoIds') is not None:
            self.repo_ids = m.get('RepoIds')
        if m.get('RepoNames') is not None:
            self.repo_names = m.get('RepoNames')
        if m.get('RepoNamespaces') is not None:
            self.repo_namespaces = m.get('RepoNamespaces')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class PublicPreCheckImageScanTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        need_auth_count: int = None,
        scan_image_count: int = None,
    ):
        self.need_auth_count = need_auth_count
        self.scan_image_count = scan_image_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.need_auth_count is not None:
            result['NeedAuthCount'] = self.need_auth_count
        if self.scan_image_count is not None:
            result['ScanImageCount'] = self.scan_image_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NeedAuthCount') is not None:
            self.need_auth_count = m.get('NeedAuthCount')
        if m.get('ScanImageCount') is not None:
            self.scan_image_count = m.get('ScanImageCount')
        return self


class PublicPreCheckImageScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        data: PublicPreCheckImageScanTaskResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicPreCheckImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicPreCheckImageScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublicPreCheckImageScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicPreCheckImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicSyncAndCreateImageScanTaskRequest(TeaModel):
    def __init__(
        self,
        images: str = None,
        source_ip: str = None,
    ):
        # The status of the image scan task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **PRE_ANALYZER**: The task is being pre-processed.
        # *   **SUCCESS**: The task is successful.
        # *   **FAIL**: The task failed.
        self.images = images
        # The ID of the image scan task.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Images') is not None:
            self.images = m.get('Images')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class PublicSyncAndCreateImageScanTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        can_create: bool = None,
        collect_time: int = None,
        exec_time: int = None,
        finish_count: int = None,
        progress: int = None,
        result: str = None,
        status: str = None,
        task_id: str = None,
        total_count: int = None,
    ):
        self.can_create = can_create
        self.collect_time = collect_time
        self.exec_time = exec_time
        # PublicSyncAndCreateImageScanTask
        self.finish_count = finish_count
        self.progress = progress
        self.result = result
        self.status = status
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.task_id = task_id
        # Adds images to Security Center and creates an image scan task to scan the images.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PublicSyncAndCreateImageScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        data: PublicSyncAndCreateImageScanTaskResponseBodyData = None,
        request_id: str = None,
    ):
        # The total number of images to scan.
        self.data = data
        # The data returned if the call is successful.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicSyncAndCreateImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicSyncAndCreateImageScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublicSyncAndCreateImageScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicSyncAndCreateImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDiscoverDatabaseRequest(TeaModel):
    def __init__(
        self,
        create_mark: str = None,
    ):
        # The ID of the scan task.
        # 
        # > You can call the [StartDiscoverDatabaseTask](~~StartDiscoverDatabaseTask~~) operation to query the ID of the task.
        self.create_mark = create_mark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        return self


class QueryDiscoverDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_progress: int = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # The progress of the database scan task in percentage.
        self.task_progress = task_progress

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_progress is not None:
            result['TaskProgress'] = self.task_progress
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskProgress') is not None:
            self.task_progress = m.get('TaskProgress')
        return self


class QueryDiscoverDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDiscoverDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDiscoverDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryGroupIdByGroupNameRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        source_ip: str = None,
    ):
        self.group_name = group_name
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryGroupIdByGroupNameResponseBody(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        request_id: str = None,
    ):
        self.group_id = group_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryGroupIdByGroupNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryGroupIdByGroupNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryGroupIdByGroupNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryGroupedSecurityEventMarkMissListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        disposal_way: str = None,
        event_name: str = None,
        from_: str = None,
        lang: str = None,
        page_size: int = None,
        remark: str = None,
        source_ip: str = None,
    ):
        # The number of entries to return on each page. Default value: **20**.
        self.current_page = current_page
        # The name of the alert event. The value indicates a subtype.
        self.disposal_way = disposal_way
        # The operator. Valid values:
        # 
        # *   **contains**: contains
        # *   **notContains**: does not contain
        # *   **strEqual**: equals
        # *   **strNotEqual**: does not equal
        # *   **regex**: regular expression
        self.event_name = event_name
        # The ID of the request source. Set the value to sas.
        self.from_ = from_
        # The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.
        self.lang = lang
        # The error message returned.
        self.page_size = page_size
        # The ID of the user.
        self.remark = remark
        # The field that is used in the whitelist rule.
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.disposal_way is not None:
            result['DisposalWay'] = self.disposal_way
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DisposalWay') is not None:
            self.disposal_way = m.get('DisposalWay')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBodyList(TeaModel):
    def __init__(
        self,
        ali_uid: int = None,
        disposal_way: str = None,
        event_name: str = None,
        event_name_original: str = None,
        event_type: str = None,
        event_type_original: str = None,
        field: str = None,
        field_value: str = None,
        filed_alias_name: str = None,
        operate: str = None,
        uuids: str = None,
    ):
        # The handling method. Valid values:
        # 
        # *   **1**: Automatically Added to Whitelist
        # *   **2**: Defense Without Notification
        self.ali_uid = ali_uid
        # The alias of the field.
        self.disposal_way = disposal_way
        # The number of entries returned on the current page.
        self.event_name = event_name
        # The handling method. Valid values:
        # 
        # *   **auto_add_white**: Automatically Added to Whitelist
        # *   **defense_not_notification**: Defense Without Notification
        self.event_name_original = event_name_original
        # The condition that is used to query alert events by asset. You can specify a value of the following types:
        # 
        # *   The IP address of the asset.
        # *   The public IP address of the asset.
        # *   The private IP address of the asset.
        # *   The name of the asset.
        self.event_type = event_type
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.event_type_original = event_type_original
        # Unusual logon
        self.field = field
        # The name of the alert event. The value indicates a subtype.
        self.field_value = field_value
        # The number of the page to return. Default value: **1**.
        self.filed_alias_name = filed_alias_name
        # The number of entries returned per page. Default value: **20**.
        self.operate = operate
        # The pagination information.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.disposal_way is not None:
            result['DisposalWay'] = self.disposal_way
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_name_original is not None:
            result['EventNameOriginal'] = self.event_name_original
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.event_type_original is not None:
            result['EventTypeOriginal'] = self.event_type_original
        if self.field is not None:
            result['Field'] = self.field
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.operate is not None:
            result['Operate'] = self.operate
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('DisposalWay') is not None:
            self.disposal_way = m.get('DisposalWay')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventNameOriginal') is not None:
            self.event_name_original = m.get('EventNameOriginal')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('EventTypeOriginal') is not None:
            self.event_type_original = m.get('EventTypeOriginal')
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('Operate') is not None:
            self.operate = m.get('Operate')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.count = count
        # Queries whitelist rules.
        self.current_page = current_page
        # QueryGroupedSecurityEventMarkMissList
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        list: List[QueryGroupedSecurityEventMarkMissListResponseBodyList] = None,
        message: str = None,
        page_info: QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        # The subtype of the alert event.
        self.list = list
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.page_info = page_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = QueryGroupedSecurityEventMarkMissListResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryGroupedSecurityEventMarkMissListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryGroupedSecurityEventMarkMissListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryGroupedSecurityEventMarkMissListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJenkinsImageRegistryPersistenceDayRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
    ):
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryJenkinsImageRegistryPersistenceDayResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        http_status_code: int = None,
        request_id: str = None,
        time_cost: int = None,
    ):
        self.data = data
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class QueryJenkinsImageRegistryPersistenceDayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryJenkinsImageRegistryPersistenceDayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJenkinsImageRegistryPersistenceDayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPreCheckDatabaseRequest(TeaModel):
    def __init__(
        self,
        instance_uuid: str = None,
        task_id: str = None,
        uni_region_id: str = None,
    ):
        self.instance_uuid = instance_uuid
        self.task_id = task_id
        self.uni_region_id = uni_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class QueryPreCheckDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        completed_time: int = None,
        created_time: int = None,
        description: str = None,
        progress: int = None,
        request_id: str = None,
        result: str = None,
        updated_time: int = None,
    ):
        self.completed_time = completed_time
        self.created_time = created_time
        self.description = description
        self.progress = progress
        self.request_id = request_id
        self.result = result
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed_time is not None:
            result['CompletedTime'] = self.completed_time
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompletedTime') is not None:
            self.completed_time = m.get('CompletedTime')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class QueryPreCheckDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryPreCheckDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPreCheckDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootMachineRequest(TeaModel):
    def __init__(
        self,
        uuid: str = None,
    ):
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class RebootMachineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RebootMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshAssetsRequest(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
        cloud_asset_sub_type: int = None,
        cloud_asset_type: int = None,
    ):
        self.asset_type = asset_type
        self.cloud_asset_sub_type = cloud_asset_sub_type
        self.cloud_asset_type = cloud_asset_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.cloud_asset_sub_type is not None:
            result['CloudAssetSubType'] = self.cloud_asset_sub_type
        if self.cloud_asset_type is not None:
            result['CloudAssetType'] = self.cloud_asset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('CloudAssetSubType') is not None:
            self.cloud_asset_sub_type = m.get('CloudAssetSubType')
        if m.get('CloudAssetType') is not None:
            self.cloud_asset_type = m.get('CloudAssetType')
        return self


class RefreshAssetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RefreshAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefreshAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshContainerAssetsRequest(TeaModel):
    def __init__(
        self,
        asset_type: str = None,
    ):
        self.asset_type = asset_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        return self


class RefreshContainerAssetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RefreshContainerAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefreshContainerAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshContainerAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveCheckInstanceResultWhiteListRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        instance_ids: List[str] = None,
    ):
        self.check_id = check_id
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RemoveCheckInstanceResultWhiteListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveCheckInstanceResultWhiteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveCheckInstanceResultWhiteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveCheckInstanceResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveCheckResultWhiteListRequest(TeaModel):
    def __init__(
        self,
        check_group_id: str = None,
        check_ids: List[int] = None,
        type: str = None,
    ):
        # This parameter is deprecated.
        self.check_group_id = check_group_id
        # The IDs of check items.
        self.check_ids = check_ids
        # This parameter is deprecated.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_group_id is not None:
            result['CheckGroupId'] = self.check_group_id
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckGroupId') is not None:
            self.check_group_id = m.get('CheckGroupId')
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RemoveCheckResultWhiteListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveCheckResultWhiteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveCheckResultWhiteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveCheckResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackSuspEventQuaraFileRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        quara_file_id: int = None,
        source_ip: str = None,
    ):
        self.from_ = from_
        self.quara_file_id = quara_file_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class RollbackSuspEventQuaraFileResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackSuspEventQuaraFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackSuspEventQuaraFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackSuspEventQuaraFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SasInstallCodeRequest(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
    ):
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class SasInstallCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: str = None,
    ):
        self.request_id = request_id
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class SasInstallCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SasInstallCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SasInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveImageBaselineStrategyRequest(TeaModel):
    def __init__(
        self,
        baseline_item_list: str = None,
        lang: str = None,
        strategy_id: int = None,
        strategy_name: str = None,
    ):
        # The baseline check items.
        # 
        # > You can call the [DescribeImageBaselineStrategy](~~DescribeImageBaselineStrategy~~) operation to query baseline check items.
        self.baseline_item_list = baseline_item_list
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the baseline check policy.
        # 
        # > You can call the [DescribeImageBaselineStrategy](~~DescribeImageBaselineStrategy~~) operation to query the IDs of baseline check policies.
        self.strategy_id = strategy_id
        # The name of the baseline check policy.
        self.strategy_name = strategy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_list is not None:
            result['BaselineItemList'] = self.baseline_item_list
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineItemList') is not None:
            self.baseline_item_list = m.get('BaselineItemList')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class SaveImageBaselineStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SaveImageBaselineStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveImageBaselineStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveImageBaselineStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveSuspEventUserSettingRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        levels_on: str = None,
    ):
        # The data source of the exception. Set the value to sas.
        self.from_ = from_
        # The severities of alert notifications. Valid values:
        # 
        # *   **remind**\
        # *   **suspicious**\
        # *   **serious**\
        self.levels_on = levels_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        return self


class SaveSuspEventUserSettingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code
        # The message returned.
        self.message = message
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveSuspEventUserSettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveSuspEventUserSettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveSuspEventUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetClusterInterceptionConfigRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: str = None,
        switch_on: int = None,
        switch_type: int = None,
    ):
        self.cluster_ids = cluster_ids
        self.switch_on = switch_on
        self.switch_type = switch_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.switch_on is not None:
            result['SwitchOn'] = self.switch_on
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('SwitchOn') is not None:
            self.switch_on = m.get('SwitchOn')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class SetClusterInterceptionConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class SetClusterInterceptionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetClusterInterceptionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetClusterInterceptionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetRegistryScanDayNumRequest(TeaModel):
    def __init__(
        self,
        scan_day_num: int = None,
    ):
        # The cycle at which you want to scan your images. Unit: days.
        self.scan_day_num = scan_day_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scan_day_num is not None:
            result['ScanDayNum'] = self.scan_day_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScanDayNum') is not None:
            self.scan_day_num = m.get('ScanDayNum')
        return self


class SetRegistryScanDayNumResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetRegistryScanDayNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetRegistryScanDayNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetRegistryScanDayNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartBaselineSecurityCheckRequest(TeaModel):
    def __init__(
        self,
        item_ids: List[int] = None,
        lang: str = None,
        resource_owner_id: int = None,
        source_ip: str = None,
        type: str = None,
    ):
        # The IDs of the check items.
        # 
        # > To perform a check task on cloud service configurations, you must specify the ID of the check item. You can call the [DescribeRiskItemType](~~DescribeRiskItemType~~) operation to query the IDs of check items.
        self.item_ids = item_ids
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.resource_owner_id = resource_owner_id
        # The source IP address of the request.
        self.source_ip = source_ip
        # The type of the check task. Valid values:
        # 
        # *   **check**\
        # *   **verify**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemIds') is not None:
            self.item_ids = m.get('ItemIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartBaselineSecurityCheckResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartBaselineSecurityCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartBaselineSecurityCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartBaselineSecurityCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartDiscoverDatabaseTaskResponseBody(TeaModel):
    def __init__(
        self,
        create_mark: str = None,
        request_id: str = None,
    ):
        # The ID of the scan task.
        self.create_mark = create_mark
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartDiscoverDatabaseTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartDiscoverDatabaseTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartDiscoverDatabaseTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPreCheckDatabaseRequest(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        instance_uuid: str = None,
        uni_region_id: str = None,
    ):
        self.database_type = database_type
        self.instance_uuid = instance_uuid
        self.uni_region_id = uni_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class StartPreCheckDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        create_mark: str = None,
        request_id: str = None,
    ):
        self.create_mark = create_mark
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartPreCheckDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPreCheckDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPreCheckDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartVirusScanTaskRequest(TeaModel):
    def __init__(
        self,
        target_info: str = None,
    ):
        self.target_info = target_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class StartVirusScanTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scan_task_id: int = None,
    ):
        self.request_id = request_id
        self.scan_task_id = scan_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scan_task_id is not None:
            result['ScanTaskId'] = self.scan_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScanTaskId') is not None:
            self.scan_task_id = m.get('ScanTaskId')
        return self


class StartVirusScanTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartVirusScanTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartVirusScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCheckResponseBodyData(TeaModel):
    def __init__(
        self,
        operate_code: str = None,
    ):
        self.operate_code = operate_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class SubmitCheckResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCheckResponseBodyData = None,
        request_id: str = None,
        task_id: str = None,
    ):
        self.data = data
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCheckResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindAegisRequest(TeaModel):
    def __init__(
        self,
        uuids: str = None,
    ):
        # The UUID of the server that you want to unbind. Separate multiple UUIDs with commas (,).
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class UnbindAegisResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindAegisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindAegisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindAegisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallBackupClientRequest(TeaModel):
    def __init__(
        self,
        policy_version: str = None,
        uuid: str = None,
        uuid_list: List[str] = None,
    ):
        self.policy_version = policy_version
        self.uuid = uuid
        self.uuid_list = uuid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class UninstallBackupClientResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UninstallBackupClientResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UninstallBackupClientResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallBackupClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallUniBackupAgentRequest(TeaModel):
    def __init__(
        self,
        policy_id: int = None,
    ):
        # The ID of the anti-ransomware policy.
        # 
        # > You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.policy_id = policy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class UninstallUniBackupAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UninstallUniBackupAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UninstallUniBackupAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallUniBackupAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotRequest(TeaModel):
    def __init__(
        self,
        honeypot_id: str = None,
        honeypot_name: str = None,
        lang: str = None,
        meta: str = None,
    ):
        self.honeypot_id = honeypot_id
        self.honeypot_name = honeypot_name
        self.lang = lang
        self.meta = meta

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.meta is not None:
            result['Meta'] = self.meta
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        return self


class UpdateHoneypotResponseBodyData(TeaModel):
    def __init__(
        self,
        honeypot_id: str = None,
        honeypot_image_display_name: str = None,
        honeypot_image_name: str = None,
        honeypot_name: str = None,
        node_id: str = None,
        preset_id: str = None,
        state: List[str] = None,
    ):
        self.honeypot_id = honeypot_id
        self.honeypot_image_display_name = honeypot_image_display_name
        self.honeypot_image_name = honeypot_image_name
        self.honeypot_name = honeypot_name
        self.node_id = node_id
        self.preset_id = preset_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdateHoneypotResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateHoneypotResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateHoneypotResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHoneypotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotNodeRequest(TeaModel):
    def __init__(
        self,
        available_probe_num: int = None,
        node_id: str = None,
        node_name: str = None,
        security_group_probe_ip_list: List[str] = None,
    ):
        self.available_probe_num = available_probe_num
        # The HTTP status code returned.
        self.node_id = node_id
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.node_name = node_name
        self.security_group_probe_ip_list = security_group_probe_ip_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_probe_num is not None:
            result['AvailableProbeNum'] = self.available_probe_num
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableProbeNum') is not None:
            self.available_probe_num = m.get('AvailableProbeNum')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        return self


class UpdateHoneypotNodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHoneypotNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotPresetRequest(TeaModel):
    def __init__(
        self,
        honeypot_image_name: str = None,
        honeypot_preset_id: str = None,
        lang: str = None,
        meta: str = None,
        preset_name: str = None,
    ):
        self.honeypot_image_name = honeypot_image_name
        self.honeypot_preset_id = honeypot_preset_id
        self.lang = lang
        self.meta = meta
        self.preset_name = preset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class UpdateHoneypotPresetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotPresetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHoneypotPresetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotProbeRequest(TeaModel):
    def __init__(
        self,
        arp: bool = None,
        display_name: str = None,
        lang: str = None,
        ping: bool = None,
        probe_id: str = None,
        service_ip_list: List[str] = None,
    ):
        self.arp = arp
        self.display_name = display_name
        self.lang = lang
        self.ping = ping
        self.probe_id = probe_id
        self.service_ip_list = service_ip_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        return self


class UpdateHoneypotProbeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotProbeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHoneypotProbeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJenkinsImageRegistryNameRequest(TeaModel):
    def __init__(
        self,
        registry_id: int = None,
        registry_name: str = None,
        source_ip: str = None,
    ):
        self.registry_id = registry_id
        self.registry_name = registry_name
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_id is not None:
            result['RegistryId'] = self.registry_id
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegistryId') is not None:
            self.registry_id = m.get('RegistryId')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class UpdateJenkinsImageRegistryNameResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        http_status_code: int = None,
        request_id: str = None,
        time_cost: int = None,
    ):
        self.data = data
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class UpdateJenkinsImageRegistryNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJenkinsImageRegistryNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJenkinsImageRegistryNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJenkinsImageRegistryPersistenceDayRequest(TeaModel):
    def __init__(
        self,
        persistence_day: int = None,
        registry_id: int = None,
        source_ip: str = None,
    ):
        self.persistence_day = persistence_day
        self.registry_id = registry_id
        self.source_ip = source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.registry_id is not None:
            result['RegistryId'] = self.registry_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('RegistryId') is not None:
            self.registry_id = m.get('RegistryId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class UpdateJenkinsImageRegistryPersistenceDayResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        http_status_code: int = None,
        request_id: str = None,
        time_cost: int = None,
    ):
        self.data = data
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class UpdateJenkinsImageRegistryPersistenceDayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJenkinsImageRegistryPersistenceDayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJenkinsImageRegistryPersistenceDayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeBackupPolicyVersionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the anti-ransomware policy.
        # 
        # > You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpgradeBackupPolicyVersionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpgradeBackupPolicyVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeBackupPolicyVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeBackupPolicyVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ValidateHcWarningsRequest(TeaModel):
    def __init__(
        self,
        check_ids: str = None,
        risk_ids: str = None,
        uuids: str = None,
    ):
        self.check_ids = check_ids
        # The UUIDs of servers on which you want to verify risk items.
        self.risk_ids = risk_ids
        # The ID of the request.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.risk_ids is not None:
            result['RiskIds'] = self.risk_ids
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('RiskIds') is not None:
            self.risk_ids = m.get('RiskIds')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ValidateHcWarningsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ValidateHcWarningsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ValidateHcWarningsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ValidateHcWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCheckInstanceResultRequest(TeaModel):
    def __init__(
        self,
        check_id: int = None,
        instance_ids: List[str] = None,
    ):
        self.check_id = check_id
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class VerifyCheckInstanceResultResponseBodyData(TeaModel):
    def __init__(
        self,
        fail_instances: List[str] = None,
        operate_code: str = None,
    ):
        self.fail_instances = fail_instances
        self.operate_code = operate_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_instances is not None:
            result['FailInstances'] = self.fail_instances
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailInstances') is not None:
            self.fail_instances = m.get('FailInstances')
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class VerifyCheckInstanceResultResponseBody(TeaModel):
    def __init__(
        self,
        data: VerifyCheckInstanceResultResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = VerifyCheckInstanceResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class VerifyCheckInstanceResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: VerifyCheckInstanceResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyCheckInstanceResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCheckResultRequest(TeaModel):
    def __init__(
        self,
        check_ids: List[int] = None,
    ):
        # An array that consists of the IDs of risk items.
        self.check_ids = check_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        return self


class VerifyCheckResultResponseBodyData(TeaModel):
    def __init__(
        self,
        operate_code: str = None,
    ):
        # The operation code of the cloud service configuration task. Valid values:
        # 
        # *   **Throttling**: frequency limit
        # *   **ActionTrialUnauthorized**: an error that is related to unauthorized operations
        self.operate_code = operate_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class VerifyCheckResultResponseBody(TeaModel):
    def __init__(
        self,
        data: VerifyCheckResultResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data.
        self.data = data
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = VerifyCheckResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class VerifyCheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: VerifyCheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


